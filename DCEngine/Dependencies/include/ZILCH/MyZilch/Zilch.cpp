#include "Zilch.hpp"
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes


#if defined(UNICODE)
  #undef UNICODE
  #define TEMP_DISABLE_UNICODE
#endif


namespace Zilch
{
  //***************************************************************************
  Any::Any() :
    StoredType(nullptr)
  {
    ZilchErrorIfNotStarted(Any);

    // Memset the area to empty, so any handles or primitives we store won't get messed up by exceptions
    memset(this->Data, 0, sizeof(this->Data));
  }

  //***************************************************************************
  Any::Any(Type* type)
  {
    ZilchErrorIfNotStarted(Any);

    // Get how big the copyable size of the object is (size of a handle, or the entire value size)
    size_t copyableSize = type->GetCopyableSize();

    // Allocate room to store this type (may store locally and not actually allocate)
    byte* destination = this->AllocateData(copyableSize);

    // Store the type and default construct the data into us
    this->StoredType = type;
    type->GenericDefaultConstruct(destination);
  }

  //***************************************************************************
  Any::Any(const byte* data, Type* type)
  {
    ZilchErrorIfNotStarted(Any);
    
    // Get how big the copyable size of the object is (size of a handle, or the entire value size)
    size_t copyableSize = type->GetCopyableSize();

    // Allocate room to store this type (may store locally and not actually allocate)
    byte* destination = this->AllocateData(copyableSize);

    // Store the type and copy construct the data into us
    this->StoredType = type;
    type->GenericCopyConstruct(destination, data);
  }

  //***************************************************************************
  Any::Any(const Any& other)
  {
    // Change the stored type to their same type
    this->StoredType = other.StoredType;

    // If we're copying from an any that actually contains data...
    if (this->StoredType != nullptr)
    {
      // Get how big the copyable size of the object is (size of a handle, or the entire value size)
      size_t copyableSize = this->StoredType->GetCopyableSize();

      // Allocate room to store this type (may store locally and not actually allocate)
      byte* destination = this->AllocateData(copyableSize);

      // Copy the right hand data into our data
      this->StoredType->GenericCopyConstruct(destination, other.GetData());
    }
    else
    {
      // Memset the area to empty, so any handles or primitives we store won't get messed up by exceptions
      memset(this->Data, 0, sizeof(this->Data));
    }
  }

  //***************************************************************************
  Any::~Any()
  {
    // Clear the any, even though it's a bit redundant (could be optimized)
    this->Clear();
  }

  //***************************************************************************
  byte* Any::AllocateData(size_t size)
  {
    // We assume that the size of the object will fit within our data section
    byte* result = this->Data;

    // If the type is bigger then we can store... (note than storing an 'any' inside an 'any' will always hit this case!)
    if (size > sizeof(this->Data))
    {
      // Allocate memory to store the data
      result = new byte[size];

      // Store a pointer to our allocation inside the data field
      *((byte**)this->Data) = result;
    }

    // Return data that will be large enough to store the object
    return result;
  }

  //***************************************************************************
  const byte* Any::GetData() const
  {
    // Get the size of the handle, delegate, or entire value type (copyable size)
    size_t copyableSize = this->StoredType->GetCopyableSize();

    // If the type is bigger then we can store... (note than storing an 'any' inside an 'any' will always hit this case!)
    if (copyableSize > sizeof(this->Data))
    {
      // The size of the object was large, which meant we must be storing it by pointer instead
      return *((byte**)this->Data);
    }

    // Otherwise, it was small enough so we just stored it in our fixed data field
    return this->Data;
  }

  //***************************************************************************
  void Any::Clear()
  {
    // If we're storing anything...
    if (this->StoredType != nullptr)
    {
      // Get the size of the handle, delegate, or entire value type (copyable size)
      size_t copyableSize = this->StoredType->GetCopyableSize();

      // Memory that we need to free
      byte* toBeDeleted = nullptr;

      // Where we store the memory that needs to be destructed (via GenericDestruct)
      byte* data = this->Data;

      // If the type is bigger then we can store... (note than storing an 'any' inside an 'any' will always hit this case!)
      if (copyableSize > sizeof(this->Data))
      {
        // The size of the object was large, which meant we must be storing it by pointer instead
        data = *((byte**)this->Data);

        // Since we're clearing, we also want to free the data
        toBeDeleted = data;
      }

      // Generically destruct the data we store first
      this->StoredType->GenericDestruct(data);

      // Delete the memory (could be null!)
      delete[] toBeDeleted;

      // Memset the area to empty, so any handles or primitives we store won't get messed up by exceptions
      memset(this->Data, 0, sizeof(this->Data));

      // Clear the stored type
      this->StoredType = nullptr;
    }
  }
    
  //***************************************************************************
  Any& Any::operator=(const Any& other)
  {
    // Avoid self assignment
    if (this == &other)
      return *this;

    // Clear ourself out, which destructs any data we were storing
    this->Clear();

    // Change the stored type to their same type
    this->StoredType = other.StoredType;

    // If we're copying from an any that actually contains data...
    if (this->StoredType != nullptr)
    {
      // Get how big the copyable size of the object is (size of a handle, or the entire value size)
      size_t copyableSize = this->StoredType->GetCopyableSize();

      // Allocate room to store this type (may store locally and not actually allocate)
      byte* destination = this->AllocateData(copyableSize);

      // Copy the right hand data into our data
      this->StoredType->GenericCopyConstruct(destination, other.GetData());
    }

    // Return ourself for chaining... which I don't like ;)
    return *this;
  }

  //***************************************************************************
  bool Any::operator==(const Any& rhs) const
  {
    // The types must compare the same for the values to be the same
    // Remember that the types stored are the MOST derived type in terms of inheritance
    // Example:
    // var derviedClass = new Cat();
    // var baseClass : Animal = derviedClass;
    // var any : Any = baseClass;
    // The 'StoredType' in Any will be 'Cat', not 'Animal' (most derived)
    if (this->StoredType != rhs.StoredType)
      return false;

    // If the types are both null, return true (we already know they are the same based on the above check)
    if (this->StoredType == nullptr)
      return true;

    // Generically compare the type with each other (we know they are the same type!)
    return this->StoredType->GenericEquals(this->GetData(), rhs.GetData());
  }
  
  //***************************************************************************
  bool Any::operator!=(const Any& rhs) const
  {
    // Just invert the comparison
    return !((*this) == rhs);
  }

  //***************************************************************************
  int Any::Hash() const
  {
    // The hash of an empty any is always 0
    if (this->StoredType == nullptr)
      return 0;

    // Generically hash our stored value
    return this->StoredType->GenericHash(this->GetData());
  }

  //***************************************************************************
  String Any::ToString() const
  {
    // Return an empty string if we store nothing
    static String EmptyString("<empty>");
    if (this->StoredType == nullptr)
      return EmptyString;

    // Generically stringify our stored value
    return this->StoredType->GenericToString(this->GetData());
  }

  //***************************************************************************
  void Any::AssignFrom(const byte* data, Type* type)
  {
    ErrorIf(type == nullptr, "Cannot assign the 'Any' to a null type, use Clear instead");

    // Avoid self assignment
    if (this->GetData() == data)
      return;

    // Clear ourself out, which destructs any data we were storing
    this->Clear();

    // Get the copyable size (size of the handle, deleget, or value type, etc)
    size_t copyableSize = type->GetCopyableSize();

    // Allocate room to store this type (may store locally and not actually allocate)
    byte* destination = this->AllocateData(copyableSize);

    // Copy the right hand data into our data
    type->GenericCopyConstruct(destination, data);

    // Change the stored type to their same type
    this->StoredType = type;
  }

  //***************************************************************************
  void Any::DefaultConstruct(Type* type)
  {
    ErrorIf(type == nullptr, "Cannot assign the 'Any' to a null type, use Clear instead");

    // Destruct any memory we are currently holding
    this->Clear();

    // Change the stored type to their same type
    this->StoredType = type;

    // Get the copyable size (size of the handle, deleget, or value type, etc)
    size_t copyableSize = type->GetCopyableSize();

    // Allocate room to store this type (may store locally and not actually allocate)
    byte* destination = this->AllocateData(copyableSize);

    // Default construct the value into our data
    // Typically makes handles null, delegates null, and value types cleared to 0
    this->StoredType->GenericDefaultConstruct(destination);
  }

  //***************************************************************************
  void Any::CopyStoredValueTo(byte* to) const
  {
    ErrorIf(this->StoredType == nullptr, "The any does not contain a type!");

    // Get the size of the handle, delegate, or entire value type (copyable size)
    size_t copyableSize = this->StoredType->GetCopyableSize();

    // Where we store the memory that needs to be copied from
    const byte* data = this->GetData();

    // Generically copy the stored value
    this->StoredType->GenericCopyConstruct(to, data);
  }

  //***************************************************************************
  template <>
  Any CopyToAnyOrActualType<Any>(byte* data, Type* dataType)
  {
    // If no data was provided, then default construct the type into the any
    if (data == nullptr)
      return Any(dataType);

    // Construct the any from the given data
    return Any(data, dataType);
  }

  //***************************************************************************
  template <>
  void CopyFromAnyOrActualType<Any>(const Any& any, byte* to)
  {
    // Generically copy the contained type to the destination
    any.CopyStoredValueTo(to);
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes





namespace Zilch
{
  //***************************************************************************
  ZilchDefineExternalGiven(ArrayClass<Handle       >, "Array[Handle]"       , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Handle       )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Delegate     >, "Array[Delegate]"     , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Delegate     )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Boolean      >, "Array[Boolean]"      , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Boolean      )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Boolean2     >, "Array[Boolean2]"     , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Boolean2     )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Boolean3     >, "Array[Boolean3]"     , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Boolean3     )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Boolean4     >, "Array[Boolean4]"     , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Boolean4     )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Byte         >, "Array[Byte]"         , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Byte         )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Integer      >, "Array[Integer]"      , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Integer      )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Integer2     >, "Array[Integer2]"     , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Integer2     )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Integer3     >, "Array[Integer3]"     , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Integer3     )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Integer4     >, "Array[Integer4]"     , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Integer4     )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Real         >, "Array[Real]"         , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Real         )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Real2        >, "Array[Real2]"        , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Real2        )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Real3        >, "Array[Real3]"        , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Real3        )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Real4        >, "Array[Real4]"        , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Real4        )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Quaternion   >, "Array[Quaternion]"   , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Quaternion   )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<DoubleInteger>, "Array[DoubleInteger]", builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(DoubleInteger)), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<DoubleReal   >, "Array[DoubleReal]"   , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(DoubleReal   )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}
  ZilchDefineExternalGiven(ArrayClass<Any          >, "Array[Any]"          , builder.InstantiateTemplate("Array", Array<Type*>(ZeroInit, ZilchTypeId(Any          )), LibraryArray(ZeroInit, Core::GetInstance().GetBuilder()->BuiltLibrary)).Type, Core, builder, type) {}

  //***************************************************************************
  // Unfortunately because there's some sort of bug in the MSVC linker, we have to make a bunch of non-inlined comparison functions
  ZilchNoInline bool LinkerEquals(Boolean         a, Boolean          b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Boolean2Param   a, Boolean2Param    b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Boolean3Param   a, Boolean3Param    b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Boolean4Param   a, Boolean4Param    b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Integer         a, Integer          b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Integer2Param   a, Integer2Param    b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Integer3Param   a, Integer3Param    b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Integer4Param   a, Integer4Param    b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Real            a, Real             b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Real2Param      a, Real2Param       b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Real3Param      a, Real3Param       b) { return a == b; }
  ZilchNoInline bool LinkerEquals(Real4Param      a, Real4Param       b) { return a == b; }
  ZilchNoInline bool LinkerEquals(QuaternionParam a, QuaternionParam  b) { return a == b; }
  ZilchNoInline bool LinkerEquals(DoubleInteger   a, DoubleInteger    b) { return a == b; }
  ZilchNoInline bool LinkerEquals(DoubleReal      a, DoubleReal       b) { return a == b; }
  ZilchNoInline bool LinkerEquals(const Handle&   a, const Handle&    b) { return a == b; }
  ZilchNoInline bool LinkerEquals(const Delegate& a, const Delegate&  b) { return a == b; }
  ZilchNoInline bool LinkerEquals(const Any&      a, const Any&       b) { return a == b; }
  
  //***************************************************************************
  ArrayUserData::ArrayUserData() :
    ContainedType(nullptr),
    RangeType(nullptr),
    SelfType(nullptr)
  {
  }
  
  //***************************************************************************
  // Enum comparison mode for array sorting
  DeclareEnum2(ComparisonMode, BoolMode, CompareMode);

  //***************************************************************************
  // Forward declaration of the range template
  template <typename T>
  class ArrayRangeTemplate;
  
  //***************************************************************************
  // The template layout we use for arrays
  // As an optimization, the array can be instantiated for some known data types
  // For all other unknown types (such as structs created in Zilch) we use the 'Any' type
  template <typename T>
  class ArrayTemplate : public ArrayClass<T>
  {
  public:
    // Get the number of elements in the array
    Integer GetCount()
    {
      return (Integer)this->NativeArray.size();
    }

    //***************************************************************************
    static String ArrayToString(const BoundType* type, const byte* data)
    {
      // Read the element size from the current function's user-data
      ArrayUserData& userData = type->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Create a string builder to generate the array entries
      StringBuilder builder;
      builder.Append(Grammar::GetKeywordOrSymbol(Grammar::BeginInitializer));

      // Grab the generic data as our own self template
      ArrayTemplate* self = (ArrayTemplate*)data;
    
      // Loop through all entries in the array
      for (size_t i = 0; i < self->NativeArray.size(); ++i)
      {
        // Get a pointer to to the value at the given index (as a byte*)
        byte* valuePointer = (byte*)&self->NativeArray[i];

        // Convert that value to a string generically
        String valueString = userData.ContainedType->GenericToString(valuePointer);

        // Append the stringified value to the builder
        builder.Append(valueString);

        // If we're not the last element, add a comma (argument separator) and a space
        bool isNotLastItem = (self->NativeArray.size() - 1 != i);
        if (isNotLastItem)
        {
          builder.Append(Grammar::GetKeywordOrSymbol(Grammar::ArgumentSeparator));
          builder.Append(" ");
        }
      }

      builder.Append(Grammar::GetKeywordOrSymbol(Grammar::EndInitializer));

      String result = builder.ToString();
      return result;
    }

    //***************************************************************************
    // Store 'Any' value as return value
    static void ArrayCopyReturnValue(Call& call, const T& value)
    {
      // Get a pointer to the return value data (on the stack)
      byte* returnValue = call.GetReturnUnchecked();
      call.DisableReturnChecks();

      // Generically copy the contained type to the return value
      CopyFromAnyOrActualType<T>(value, returnValue);
    }

    //***************************************************************************
    static T ArrayReadValue(Call& call, ArrayTemplate* self, Integer parameter)
    {
      // Read the element size from the current function's user-data
      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Get the value
      byte* valueData = call.GetParameterUnchecked(parameter);

      // Grab the data out generically (if this is an Any type, we handle that properly)
      return CopyToAnyOrActualType<T>(valueData, userData.ContainedType);
    }

    //***************************************************************************
    static void ArrayGet(Call& call, ExceptionReport& report)
    {
      // Read the element size from the current function's user-data
      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Read the array index
      Integer index = call.Get<Integer>(0);

      // Check the array index
      if (index < 0 || index >= self->GetCount())
      {
        call.GetState()->ThrowException(report, "Array index was out of bounds");
        return;
      }

      // Return the value
      ArrayCopyReturnValue(call, self->NativeArray[index]);
    }

    //***************************************************************************
    static void ArraySet(Call& call, ExceptionReport& report)
    {
      // Read the element size from the current function's user-data
      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Read the array index
      Integer index = call.Get<Integer>(0);
    
      // Check the array index
      if (index < 0 || index >= self->GetCount())
      {
        call.GetState()->ThrowException(report, "Array index was out of bounds");
        return;
      }

      // Place in array
      self->NativeArray[index] = ArrayReadValue(call, self, 1);
      self->Modified();
    }

    //***************************************************************************
    static void ArrayPush(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Place in array
      self->NativeArray.push_back(ArrayReadValue(call, self, 0));
      self->Modified();
    }

    //***************************************************************************
    static void ArrayInsert(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Read the array index
      Integer index = call.Get<Integer>(0);

      // Check the array index
      if (index < 0 || index >= self->GetCount())
      {
        call.GetState()->ThrowException(report, "Array index was out of bounds");
        return;
      }

      // Place in array
      self->NativeArray.insertAt(index, ArrayReadValue(call, self, 1));
      self->Modified();
    }

    //***************************************************************************
    static void ArrayPop(Call& call, ExceptionReport& report)
    {
      // Read the element size from the current function's user-data
      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Check that the array has elements
      if (self->GetCount() == 0)
      {
        call.GetState()->ThrowException(report, "Cannot pop from an empty array");
        return;
      }

      // This function returns the popped value so copy it to return value before removal
      ArrayCopyReturnValue(call, self->NativeArray.back());

      //  Remove the element
      self->NativeArray.pop_back();
      self->Modified();
    }

    //***************************************************************************
    static void ArrayRemoveAt(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Get the index we're trying to remove at
      Integer index = call.Get<Integer>(0);

      // Check the array index
      if (index < 0 || index >= self->GetCount())
      {
        call.GetState()->ThrowException(report, "Array index was out of bounds");
        return;
      }

      // Erase the value
      self->NativeArray.eraseAt(index);
      self->Modified();
    }

    //***************************************************************************
    static void ArrayRemoveSwap(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Get the index we're trying to remove at
      Integer index = call.Get<Integer>(0);

      // Check the array index
      if (index < 0 || index >= self->GetCount())
      {
        call.GetState()->ThrowException(report, "Array index was out of bounds");
        return;
      }

      RemoveSwap(self->NativeArray, index);
      self->Modified();
    }

    //***************************************************************************
    static void ArrayClear(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      self->NativeArray.clear();
      self->Modified();
    }

    //***************************************************************************
    static void ArrayCopy(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Create the new array
      Handle arrayHandle = call.GetState()->AllocateDefaultConstructedHeapObject(userData.SelfType, report, HeapFlags::ReferenceCounted);

      // If we threw an exception, we need to early out and let the stack unroll
      if (report.HasThrownExceptions())
        return;

      // Get pointer to the new array
      ArrayTemplate* newArray = (ArrayTemplate*)arrayHandle.Dereference();

      // Copy array data
      newArray->NativeArray = self->NativeArray;

      // Write out the count
      call.SetHandle(Call::Return, arrayHandle);
    }

    //***************************************************************************
    static void ArrayCount(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Write out the count
      call.Set(Call::Return, self->GetCount());
    }

    //***************************************************************************
    static void ArrayCapacity(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Write out the capacity
      call.Set(Call::Return, (Integer)self->NativeArray.capacity());
    }

    //***************************************************************************
    static void ArrayReserve(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Get the first argument, capacity
      Integer capacity = call.Get<Integer>(0);

      // Reserve space on the array (setting to anything smaller than the current capacity is ignored)
      self->NativeArray.reserve(capacity);
    }

    //***************************************************************************
    static void ArrayResizeHelper(Call& call, ExceptionReport& report, byte* defaultValue)
    {
      // Get the user data, because we need to know the template types
      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Get the new size of the array (first argument)
      Integer newSize = call.Get<Integer>(0);

      // If the user attempted to pass in a negative value...
      if (newSize < 0)
      {
        call.GetState()->ThrowException(report, "Cannot resize the array to a negative size");
        return;
      }

      // Reserve space on the array (setting to anything smaller than the current capacity is ignored)
      // Normally we'd like to just invoke 'resize', however because this is an array of any types,
      // each element needs to be default constructed to the contained value type
      if (newSize > self->GetCount())
      {
        // First start by reserving space
        self->NativeArray.reserve((size_t)newSize);

        // Loop until we've filled the array
        while (self->GetCount() < newSize)
        {
          // Add each element one by one and construct it to be the element type
          T& element = self->NativeArray.push_back();

          // If no default value was provided, use default construction (otherwise use the given default value)
          element = CopyToAnyOrActualType<T>(defaultValue, userData.ContainedType);
        }
      }
      else
      {
        // Just resize the array, this will auto destruct elements
        self->NativeArray.resize((size_t)newSize);
      }
    }

    //***************************************************************************
    static void ArrayResizeConstructorHelper(Call& call, ExceptionReport& report, byte* defaultValue)
    {
      // Read the element size from the current function's user-data
      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Get ourselves (the array)
      byte* memory = call.GetHandle(Call::This).Dereference();

      // Construct the array
      ArrayTemplate* self = new (memory) ArrayTemplate();
    
      // Resize with no default value
      ArrayResizeHelper(call, report, defaultValue);
    }

    //***************************************************************************
    static void ArrayConstructorResize(Call& call, ExceptionReport& report)
    {
      // Construct the array and resize the number of elements, with no default value
      ArrayResizeConstructorHelper(call, report, nullptr);
    }

    //***************************************************************************
    static void ArrayConstructorResizeDefault(Call& call, ExceptionReport& report)
    {
      // The second argument should be the default value we'd like to initialize elements with
      byte* defaultValue = call.GetParameterUnchecked(1);

      // Construct the array and resize the number of elements, with no default value
      ArrayResizeConstructorHelper(call, report, defaultValue);
    }

    //***************************************************************************
    static void ArrayResize(Call& call, ExceptionReport& report)
    {
      // Resize with no default value
      ArrayResizeHelper(call, report, nullptr);
    }

    //***************************************************************************
    static void ArrayResizeDefault(Call& call, ExceptionReport& report)
    {
      // The second argument should be the default value we'd like to initialize elements with
      byte* defaultValue = call.GetParameterUnchecked(1);
    
      // Resize with the given default value
      ArrayResizeHelper(call, report, defaultValue);
    }

    //***************************************************************************
    static void ArrayLastIndex(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Write out the count
      call.Set(Call::Return, self->GetCount() - 1);
    }

    //***************************************************************************
    static void ArrayFindFirstIndex(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Read value to find
      T value = ArrayReadValue(call, self, 0);

      // Loop through the entire array to find the value
      for (size_t i = 0; i < self->NativeArray.size(); ++i)
      {
        // If we found the value....
        const T& temp = self->NativeArray[i];
        if (LinkerEquals(value, temp))
        {
          // Return the index at which we found the value
          return call.Set(Call::Return, (Integer)i);
        }
      }

      // We didn't find the first index, just return -1 to indicate it was not found
      call.Set(Call::Return, -1);
    }

    //***************************************************************************
    static void ArrayRemoveFirst(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Read the value to find
      T value = ArrayReadValue(call, self, 0);

      // Loop through all the values in the native array
      for (size_t i = 0; i < self->NativeArray.size(); ++i)
      {
        // If we found the value...
        const T& temp = self->NativeArray[i];
        if (LinkerEquals(value, temp))
        {
          // Erase the value at that index and mark the container as modified
          self->NativeArray.eraseAt(i);
          self->Modified();

          // Return that we removed a value
          return call.Set<Boolean>(Call::Return, true);
        }
      }

      // Return that we did not remove a value
      call.Set<Boolean>(Call::Return, false);
    }

    //***************************************************************************
    static void ArrayRemoveAll(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Read the value that we want to remove
      T testValue = ArrayReadValue(call, self, 0);

      // Remove all the elements if they are equal, and get how many were removed
      size_t removeCount = RemoveAll(self->NativeArray, Zero::EqualTo<T>(testValue));

      // Return the amount we removed
      call.Set<Integer>(Call::Return, (Integer)removeCount);
    }

    //***************************************************************************
    static void SetParameter(Call& call, size_t index, T& value)
    {
      byte* dest = call.GetParameterUnchecked(index);
      CopyFromAnyOrActualType(value, dest);
    }

    //***************************************************************************
    template <ComparisonMode::Enum comparisonMode>
    class DelegateCompare
    {
    public:
      DelegateCompare(ExecutableState* state, ExceptionReport& report, Delegate& comparer) :
        State(state),
        Report(&report),
        Comparer(&comparer)
      {
      }

      ExecutableState* State;
      ExceptionReport* Report;
      Delegate* Comparer;

      bool operator()(T& left, T& right)
      {
        // Ideally we would have exited out of the algorithm, but sort has no mechanism for that
        // Just check if an exception was set upon coming in here, if so ignore it
        if (this->Report->HasThrownExceptions())
          return false;

        // Call the delegate with the left and right values
        Zilch::Call call(*this->Comparer, this->State);
        SetParameter(call, 0, left);
        SetParameter(call, 1, right);
        call.DisableParameterChecks();
        call.Invoke(*this->Report);

        // If the recent invocation threw an exception, then it means no return value was placed on the stack
        if (this->Report->HasThrownExceptions())
          return false;

        //do a different compare depending on if this is a boolean compare function or a int compare function
        if(comparisonMode == ComparisonMode::BoolMode)
          return call.Get<bool>(Call::Return);
        else if(comparisonMode == ComparisonMode::CompareMode)
          return call.Get<int>(Call::Return) < 0;
        return false;
      }
    };

    //***************************************************************************
    static void ArraySortDelegate(Call& call, ExceptionReport& report)
    {
      Delegate& comparer = call.GetDelegate(0);
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();
      sort(self->NativeArray.all(), DelegateCompare<ComparisonMode::BoolMode>(call.GetState(), report, comparer) );
    }

    //***************************************************************************
    static void ArraySortCompareToDelegate(Call& call, ExceptionReport& report)
    {
      Delegate& comparer = call.GetDelegate(0);
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();
      sort(self->NativeArray.all(), DelegateCompare<ComparisonMode::CompareMode>(call.GetState(), report, comparer) );
    }

    //***************************************************************************
    static void ArrayReturnIndexedRange(Call& call, ExceptionReport& report, ArrayTemplate* self, Integer start, Integer count)
    {
      // Read the element size from the current function's user-data
      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Create the range type that we will return
      Handle rangeHandle = call.GetState()->AllocateDefaultConstructedHeapObject(userData.RangeType, report, HeapFlags::ReferenceCounted);

      // If we threw an exception, we need to early out and let the stack unroll
      if (report.HasThrownExceptions())
        return;

      // Get the range's data (should have been constructed!)
      ArrayRangeTemplate<T>* range = (ArrayRangeTemplate<T>*)rangeHandle.Dereference();

      // Setup the range to be returned
      range->Array = call.GetHandle(Call::This);
      range->Count = count;
      range->Start = start;
      range->Current = start;
      range->ModifyId = self->ModifyId;

      // Return the handle to the array range
      call.SetHandle(Call::Return, rangeHandle);
    }


    //***************************************************************************
    static void ArrayAll(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Range of all elements
      ArrayReturnIndexedRange(call, report, self, 0, self->GetCount());
    }

    //***************************************************************************
    static void ArrayRange(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the array)
      ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

      // Get the index we're trying to remove at
      Integer begin = call.Get<Integer>(0);
      Integer count = call.Get<Integer>(1);

      if (begin < 0 || begin >= self->GetCount())
      {
        call.GetState()->ThrowException(report, "Array range was out of bounds");
        return;
      }

      Integer end = begin + count;
      if (count < 0 || end > self->GetCount())
      {
        call.GetState()->ThrowException(report, "Array range was out of bounds");
        return;
      }

      // Range of all elements
      ArrayReturnIndexedRange(call, report, self, begin, count);
    }

  };

  // To iterate through arrays using 'foreach', we use the range type
  // Ranges are also much safer than iterators
  template <typename T>
  class ArrayRangeTemplate
  {
  public:

    // Constructor
    ArrayRangeTemplate() :
      Current(0),
      Start(0),
      Count(0),
      ModifyId(0)
    {
    }

    // Check if the range is empty
    Boolean IsEmpty()
    {
      return (this->Current - this->Start) == this->Count;
    }

    // Check if the range is not empty
    Boolean IsNotEmpty()
    {
      return this->IsEmpty() == false;
    }

    // A handle back to the source container that our data belongs to
    Handle Array;

    // The current index that we're iterating through
    Integer Current;

    // Where we started (so we can reset the range)
    Integer Start;

    // How many elements are in the range (so we know the end)
    Integer Count;

    // The id that the container had when we were created from it
    Integer ModifyId;

    //***************************************************************************
    static void ArrayRangeConstructor(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the range)
      Handle& selfHandle = call.GetHandle(Call::This);
      byte* selfData = selfHandle.Dereference();

      // Call our default constructor on the memory
      new (selfData) ArrayRangeTemplate();
    }

    //***************************************************************************
    static void ArrayRangeDestructor(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the range)
      ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Directly invoke the destructor
      self->~ArrayRangeTemplate();
    }

    //***************************************************************************
    static void ArrayRangeReset(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the range)
      ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Move the range back to the start
      self->Current = self->Start;
    }

    //***************************************************************************
    static void ArrayRangeMoveNext(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the range)
      ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Check if the difference (how much we've gone forward) is past the count
      if (self->IsEmpty())
      {
        // Throw an exception since the range was empty and we called MoveNext
        call.GetState()->ThrowException(report, "The range reached the end, but then an attempt was made to make it iterate forward more");
        return;
      }
      else
      {
        // Move the range forward
        ++self->Current;
      }
    }

    //***************************************************************************
    static void ArrayRangeIsEmpty(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the range)
      ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();

      // Compute and return whether or not he range is empty
      Boolean isEmpty = self->IsEmpty();
      call.Set(Call::Return, isEmpty);
    }

    //***************************************************************************
    static void ArrayRangeIsNotEmpty(Call& call, ExceptionReport& report)
    {
      // Get ourselves (the range)
      ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();

      // Compute and return whether or not he range is empty
      Boolean isNotEmpty = self->IsNotEmpty();
      call.Set(Call::Return, isNotEmpty);
    }
  
    //***************************************************************************
    static void ArrayRangeAll(Call& call, ExceptionReport& report)
    {
      // Grab our self handle and return it (we just return ourselves)
      Handle& selfHandle = call.GetHandle(Call::This);
      call.SetHandle(Call::Return, selfHandle);
    }

    //***************************************************************************
    static void ArrayRangeCurrent(Call& call, ExceptionReport& report)
    {
      // Read the element size from the current function's user-data
      ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

      // Get this object
      ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();
    
      // Get the array that we look at
      ArrayTemplate<T>* array = (ArrayTemplate<T>*)self->Array.Dereference();

      // Check if the array was modified
      if (self->ModifyId != array->ModifyId)
      {
        // It was modified, so throw an exception and early out
        call.GetState()->ThrowException(report,
          "The collection was modified and therefore the range cannot be used");
        return;
      }

      // If we've already reached the end...
      if (self->IsEmpty())
      {
        // Throw an exception since the range was empty and we called Current
        call.GetState()->ThrowException(report, "The range reached the end and an attempt was made to get the current value");
        return;
      }
      else
      {
        // Get a pointer to the return value data (on the stack)
        byte* returnValue = call.GetReturnUnchecked();
        call.DisableReturnChecks();

        // Copy the value at the array to the return type (this properly deals with the Any type)
        CopyFromAnyOrActualType(array->NativeArray[self->Current], returnValue);
      }
    }
  };

  //***************************************************************************
  template <typename T>
  BoundType* InstantiateArray
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  )
  {
    // Error checking
    ErrorIf(templateTypes.size() != 1,
      "The Array template should only take one template argument");

    // Get the type we're instantiating
    Type* containedType = templateTypes.front();

    // We could have put core in our userdata, but no real need
    Core& core = Core::GetInstance();

    StringBuilder rangeName;
    rangeName.Append("ArrayRange[");
    rangeName.Append(containedType->ToString());
    rangeName.Append("]");

    String fullyQualifiedRangeName = rangeName.ToString();
    
    ZilchTodo("The range type must have a valid destructor the decrements the reference count on the 'array' handle");
    BoundType* rangeType = builder.AddBoundType(fullyQualifiedRangeName, TypeCopyMode::ReferenceType, sizeof(ArrayRangeTemplate<T>));

    // Create the array type instance (arrays and any other containers should be reference types!)
    BoundType* arrayType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(ArrayTemplate<T>));

    arrayType->ToStringFunction = ArrayTemplate<T>::ArrayToString;

    Function* f = nullptr;
    Property* p = nullptr;

    ArrayUserData arrayUserData;
    arrayUserData.ContainedType = containedType;
    arrayUserData.RangeType = rangeType;
    arrayUserData.SelfType = arrayType;
    arrayType->ComplexUserData.WriteObject(arrayUserData);

    ZilchBindConstructor(builder, arrayType, ArrayTemplate<T>, ZilchNoNames);
    ZilchBindDestructor(builder, arrayType, ArrayTemplate<T>);

    f = builder.AddBoundConstructor(arrayType, ArrayTemplate<T>::ArrayConstructorResize, OneParameter(core.IntegerType, "size"));
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundConstructor(arrayType, ArrayTemplate<T>::ArrayConstructorResizeDefault, TwoParameters(core.IntegerType, "size", containedType, "defaultValue"));
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, OperatorGet, ArrayTemplate<T>::ArrayGet, OneParameter(core.IntegerType, "index"), containedType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, OperatorSet, ArrayTemplate<T>::ArraySet, TwoParameters(core.IntegerType, "index", containedType, "value"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, OperatorInsert, ArrayTemplate<T>::ArrayPush, OneParameter(containedType), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Reserve", ArrayTemplate<T>::ArrayReserve, OneParameter(core.IntegerType, "capacity"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Resize", ArrayTemplate<T>::ArrayResize, OneParameter(core.IntegerType, "size"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Resize", ArrayTemplate<T>::ArrayResizeDefault, TwoParameters(core.IntegerType, "size", containedType, "defaultValue"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Push", ArrayTemplate<T>::ArrayPush, OneParameter(containedType), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Pop", ArrayTemplate<T>::ArrayPop, ParameterArray(), containedType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Insert", ArrayTemplate<T>::ArrayInsert, TwoParameters(core.IntegerType, "index", containedType, "value"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "RemoveAt", ArrayTemplate<T>::ArrayRemoveAt, OneParameter(core.IntegerType, "index"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "RemoveFirst", ArrayTemplate<T>::ArrayRemoveFirst, OneParameter(containedType, "value"), core.BooleanType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "RemoveAll", ArrayTemplate<T>::ArrayRemoveAll, OneParameter(containedType, "value"), core.IntegerType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "RemoveSwap", ArrayTemplate<T>::ArrayRemoveSwap, OneParameter(core.IntegerType, "index"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Range", ArrayTemplate<T>::ArrayRange, TwoParameters(core.IntegerType, "start", core.IntegerType, "count"), rangeType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Copy", ArrayTemplate<T>::ArrayCopy, ParameterArray(), arrayType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "Clear", ArrayTemplate<T>::ArrayClear, ParameterArray(), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    f = builder.AddBoundFunction(arrayType, "FindFirstIndex", ArrayTemplate<T>::ArrayFindFirstIndex, OneParameter(containedType, "value"), core.IntegerType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    DelegateType* binaryCompare = builder.GetDelegateType(TwoParameters(containedType, "left", containedType, "right"), core.BooleanType);
    f = builder.AddBoundFunction(arrayType, "Sort", ArrayTemplate<T>::ArraySortDelegate, OneParameter(binaryCompare, "compare"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    DelegateType* binaryCompareTo = builder.GetDelegateType(TwoParameters(containedType, "left", containedType, "right"), core.IntegerType);
    f = builder.AddBoundFunction(arrayType, "Sort", ArrayTemplate<T>::ArraySortCompareToDelegate, OneParameter(binaryCompareTo, "compare"), core.VoidType, FunctionOptions::None);
    f->ComplexUserData.WriteObject(arrayUserData);

    builder.AddBoundProperty(arrayType, "Count", core.IntegerType, nullptr, ArrayTemplate<T>::ArrayCount, MemberOptions::None);
    builder.AddBoundProperty(arrayType, "Capacity", core.IntegerType, nullptr, ArrayTemplate<T>::ArrayCapacity, MemberOptions::None);
    builder.AddBoundProperty(arrayType, "LastIndex", core.IntegerType, nullptr, ArrayTemplate<T>::ArrayLastIndex, MemberOptions::None);

    p = builder.AddBoundProperty(arrayType, "All", rangeType, nullptr, ArrayTemplate<T>::ArrayAll, MemberOptions::None);
    p->Get->ComplexUserData.WriteObject(arrayUserData);

    builder.AddBoundConstructor(rangeType, ArrayRangeTemplate<T>::ArrayRangeConstructor, ParameterArray());
    builder.AddBoundDestructor(rangeType, ArrayRangeTemplate<T>::ArrayRangeDestructor);

    builder.AddBoundFunction(rangeType, "MoveNext", ArrayRangeTemplate<T>::ArrayRangeMoveNext, ParameterArray(), core.VoidType, FunctionOptions::None);
    builder.AddBoundFunction(rangeType, "Reset", ArrayRangeTemplate<T>::ArrayRangeReset, ParameterArray(), core.VoidType, FunctionOptions::None);

    p = builder.AddBoundProperty(rangeType, "Current", containedType, nullptr, ArrayRangeTemplate<T>::ArrayRangeCurrent, MemberOptions::None);
    p->Get->ComplexUserData.WriteObject(arrayUserData);

    builder.AddBoundProperty(rangeType, "IsEmpty", core.BooleanType, nullptr, ArrayRangeTemplate<T>::ArrayRangeIsEmpty, MemberOptions::None);
    builder.AddBoundProperty(rangeType, "IsNotEmpty", core.BooleanType, nullptr, ArrayRangeTemplate<T>::ArrayRangeIsNotEmpty, MemberOptions::None);
    builder.AddBoundProperty(rangeType, "All", rangeType, nullptr, ArrayRangeTemplate<T>::ArrayRangeAll, MemberOptions::None);
    
    // Return the array type we instantiated
    return arrayType;
  }

  //***************************************************************************
  BoundType* InstantiateArray
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  )
  {
    // Get the type our array is containing
    Type* containedType = templateTypes.front();

    if (Type::IsHandleType(containedType))
    {
      return InstantiateArray<Handle>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsDelegateType(containedType))
    {
      return InstantiateArray<Delegate>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Boolean)))
    {
      return InstantiateArray<Boolean>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Boolean2)))
    {
      return InstantiateArray<Boolean2>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Boolean3)))
    {
      return InstantiateArray<Boolean3>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Boolean4)))
    {
      return InstantiateArray<Boolean4>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Byte)))
    {
      return InstantiateArray<Byte>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Integer)) || Type::IsEnumOrFlagsType(containedType))
    {
      return InstantiateArray<Integer>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Integer2)))
    {
      return InstantiateArray<Integer2>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Integer3)))
    {
      return InstantiateArray<Integer3>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Integer4)))
    {
      return InstantiateArray<Integer4>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Real)))
    {
      return InstantiateArray<Real>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Real2)))
    {
      return InstantiateArray<Real2>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Real3)))
    {
      return InstantiateArray<Real3>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Real4)))
    {
      return InstantiateArray<Real4>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(Quaternion)))
    {
      return InstantiateArray<Quaternion>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(DoubleInteger)))
    {
      return InstantiateArray<DoubleInteger>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else if (Type::IsSame(containedType, ZilchTypeId(DoubleReal)))
    {
      return InstantiateArray<DoubleReal>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
    else
    {
      return InstantiateArray<Any>(builder, baseName, fullyQualifiedName, templateTypes, userData);
    }
  }

  // Make sure the size of ArrayClass is the same as ArrayTemplate
  ZilchStaticAssert(sizeof(ArrayClass<Byte>) == sizeof(ArrayTemplate<Byte>),
    "The array base 'ArrayClass' and 'ArrayTemplate' should be binary compatable with each other",
    ArrayClassAndArrayTemplateShouldBeBinaryCompatable1);
  ZilchStaticAssert(sizeof(ArrayClass<Any>) == sizeof(ArrayTemplate<Any>),
    "The array base 'ArrayClass' and 'ArrayTemplate' should be binary compatable with each other",
    ArrayClassAndArrayTemplateShouldBeBinaryCompatable2);
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes





namespace Zilch
{
  //***************************************************************************
  DebugSize::DebugSize() :
    Text("This member only exists to ensure that the proper base and derived types were passed into the ZilchDeclareType macros")
  {
  }

  //***************************************************************************
  bool TypeBinding::VirtualTableCounter::StaticDebugIsVirtual = false;
  
  //***************************************************************************
  TypeBinding::VirtualTableCounter::VirtualTableCounter()
  {
    // Make sure both flags are set to false so that we don't trip the assert
    StaticDebugIsVirtual = false;
    this->InstanceDebugIsVirtual = false;
  }
  
  //***************************************************************************
  void TypeBinding::VirtualTableCounter::AssertIfNotVirtual()
  {
    // Perform the error checking
    ErrorIf(StaticDebugIsVirtual == false || this->InstanceDebugIsVirtual == false,
      "Method being tested was not virtual!");

    // Reset our state back, just incase we use this again
    StaticDebugIsVirtual = false;
    this->InstanceDebugIsVirtual = false;
  }

  //***************************************************************************
  bool TypeBinding::IsA(BoundType* type, BoundType* base)
  {
    // Loop until the type chain becomes empty
    while (type != nullptr)
    {
      // If the base type is the same as the current type...
      ZilchTodo("Using the names of the BoundType to compare isn't technically correct");
      if (base == type || base->Name == type->Name)
        return true;

      // Iterate to the next parent
      type = type->BaseType;
    }

    // Otherwise, the given type does not inherit from base
    return false;
  }
  
  //***************************************************************************
  bool TypeBinding::IndirectionIsA(IndirectionType* type, IndirectionType* base)
  {
    // The is-a relationship stands for indirect types (the types they point at)
    return IsA
    (
      type->ReferencedType,
      base->ReferencedType
    );
  }
  
  //***************************************************************************
  bool TypeBinding::GenericIsA(Type* type, Type* base)
  {
    // Get the first type as a bound type
    BoundType* boundType = DynamicCast<BoundType*>(type);

    // If the first type is a bound type...
    if (boundType != nullptr)
    {
      // Then hopefully the base is a bound type also
      BoundType* boundBase = DynamicCast<BoundType*>(base);

      // If it's not, then these types do not match
      if (boundBase == nullptr)
        return false;

      // Otherwise, check for the IsA relationship on two bound types
      return IsA(boundType, boundBase);
    }

    // The first type wasn't a bound type, but is it an indirect type?
    IndirectionType* indirectType = DynamicCast<IndirectionType*>(type);

    // If the first type is an indirect type...
    if (indirectType != nullptr)
    {
      // Then hopefully the base is an indirect type also
      IndirectionType* indirectBase = DynamicCast<IndirectionType*>(base);

      // If it's not, then these types do not match
      if (indirectBase == nullptr)
        return false;

      // Otherwise, check for the IsA relationship on two bound types
      return IndirectionIsA(indirectType, indirectBase);
    }

    // If we got here, then we don't know what type these are
    return Type::IsSame(type, base);
  }

  //***************************************************************************
  BoundType* TypeBinding::StaticTypeId<void>::Get()
  {
    return Core::GetInstance().VoidType;
  }

  //***************************************************************************
  BoundType* TypeBinding::StaticTypeId<NullPointerType>::Get()
  {
    return Core::GetInstance().NullType;
  }

  //***************************************************************************
  AnyType* TypeBinding::StaticTypeId<Any>::Get()
  {
    return Core::GetInstance().AnythingType;
  }

  //***************************************************************************
  DelegateType* TypeBinding::StaticTypeId<Delegate>::Get()
  {
    return Core::GetInstance().AnyDelegateType;
  }

  //***************************************************************************
  BoundType* TypeBinding::StaticTypeId<Handle>::Get()
  {
    return Core::GetInstance().AnyHandleType;
  }

  //***************************************************************************
  ZilchDefineExternalType(Boolean,        "Boolean",        Core, builder, type) {}
  ZilchDefineExternalType(Boolean2,       "Boolean2",       Core, builder, type) {}
  ZilchDefineExternalType(Boolean3,       "Boolean3",       Core, builder, type) {}
  ZilchDefineExternalType(Boolean4,       "Boolean4",       Core, builder, type) {}
  ZilchDefineExternalType(Byte,           "Byte",           Core, builder, type) {}
  ZilchDefineExternalType(Integer,        "Integer",        Core, builder, type) {}
  ZilchDefineExternalType(Integer2,       "Integer2",       Core, builder, type) {}
  ZilchDefineExternalType(Integer3,       "Integer3",       Core, builder, type) {}
  ZilchDefineExternalType(Integer4,       "Integer4",       Core, builder, type) {}
  ZilchDefineExternalType(Real,           "Real",           Core, builder, type) {}
  ZilchDefineExternalType(Real2,          "Real2",          Core, builder, type) {}
  ZilchDefineExternalType(Real3,          "Real3",          Core, builder, type) {}
  ZilchDefineExternalType(Real4,          "Real4",          Core, builder, type) {}
  ZilchDefineExternalType(Quaternion,     "Quaternion",     Core, builder, type) {}
  ZilchDefineExternalType(String,         "String",         Core, builder, type) {}
  ZilchDefineExternalType(DoubleReal,     "DoubleReal",     Core, builder, type) {}
  ZilchDefineExternalType(DoubleInteger,  "DoubleInteger",  Core, builder, type) {}

  // All the redirection types
  ZilchDefineImplicitRedirectType(         char     );
  ZilchDefineImplicitRedirectType(signed   char     );
  ZilchDefineImplicitRedirectType(signed   short    );
  ZilchDefineImplicitRedirectType(unsigned short    );
  ZilchDefineImplicitRedirectType(unsigned int      );
  ZilchDefineImplicitRedirectType(signed   long     );
  ZilchDefineImplicitRedirectType(unsigned long     );
  ZilchDefineImplicitRedirectType(unsigned long long);
}
/*
cdecoder.c - c source to a base64 decoding algorithm implementation

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/




int base64_decode_value(char value_in)
{
	static const char decoding[] = {62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-2,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51};
	static const char decoding_size = sizeof(decoding);
	value_in -= 43;
	if (value_in < 0 || value_in >= decoding_size) return -1;
	return decoding[(int)value_in];
}

void base64_init_decodestate(base64_decodestate* state_in)
{
	state_in->step = step_a;
	state_in->plainchar = 0;
}

size_t base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in)
{
	const char* codechar = code_in;
	char* plainchar = plaintext_out;
	char fragment;
	
	*plainchar = state_in->plainchar;
	
	switch (state_in->step)
	{
		while (1)
		{
	case step_a:
			do {
				if (codechar == code_in+length_in)
				{
					state_in->step = step_a;
					state_in->plainchar = *plainchar;
					return plainchar - plaintext_out;
				}
				fragment = (char)base64_decode_value(*codechar++);
			} while (fragment < 0);
			*plainchar    = (fragment & 0x03f) << 2;
	case step_b:
			do {
				if (codechar == code_in+length_in)
				{
					state_in->step = step_b;
					state_in->plainchar = *plainchar;
					return plainchar - plaintext_out;
				}
				fragment = (char)base64_decode_value(*codechar++);
			} while (fragment < 0);
			*plainchar++ |= (fragment & 0x030) >> 4;
			*plainchar    = (fragment & 0x00f) << 4;
	case step_c:
			do {
				if (codechar == code_in+length_in)
				{
					state_in->step = step_c;
					state_in->plainchar = *plainchar;
					return plainchar - plaintext_out;
				}
				fragment = (char)base64_decode_value(*codechar++);
			} while (fragment < 0);
			*plainchar++ |= (fragment & 0x03c) >> 2;
			*plainchar    = (fragment & 0x003) << 6;
	case step_d:
			do {
				if (codechar == code_in+length_in)
				{
					state_in->step = step_d;
					state_in->plainchar = *plainchar;
					return plainchar - plaintext_out;
				}
				fragment = (char)base64_decode_value(*codechar++);
			} while (fragment < 0);
			*plainchar++   |= (fragment & 0x03f);
		}
	}
	/* control should not reach here */
	return plainchar - plaintext_out;
}

/*
cencoder.c - c source to a base64 encoding algorithm implementation

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/


/*
cencode.h - c header for a base64 encoding algorithm

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/

#ifndef BASE64_CENCODE_H
#define BASE64_CENCODE_H

typedef enum
{
	step_A, step_B, step_C
} base64_encodestep;

typedef struct
{
	base64_encodestep step;
	char result;
	int stepcount;
} base64_encodestate;

int compute_base64_size(int length);

void base64_init_encodestate(base64_encodestate* state_in);

char base64_encode_value(char value_in);

size_t base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in);

size_t base64_encode_blockend(char* code_out, base64_encodestate* state_in);

#endif /* BASE64_CENCODE_H */



const int CHARS_PER_LINE = 72;


int compute_base64_size(int length)
{
  return (int)(ceil(length / 3.0f)) * 4;
}

void base64_init_encodestate(base64_encodestate* state_in)
{
	state_in->step = step_A;
	state_in->result = 0;
	state_in->stepcount = 0;
}

char base64_encode_value(char value_in)
{
	static const char* encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	if (value_in > 63) return '=';
	return encoding[(int)value_in];
}

size_t base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in)
{
	const char* plainchar = plaintext_in;
	const char* const plaintextend = plaintext_in + length_in;
	char* codechar = code_out;
	char result;
	char fragment;
	
	result = state_in->result;
	
	switch (state_in->step)
	{
		while (1)
		{
	case step_A:
			if (plainchar == plaintextend)
			{
				state_in->result = result;
				state_in->step = step_A;
				return codechar - code_out;
			}
			fragment = *plainchar++;
			result = (fragment & 0x0fc) >> 2;
			*codechar++ = base64_encode_value(result);
			result = (fragment & 0x003) << 4;
	case step_B:
			if (plainchar == plaintextend)
			{
				state_in->result = result;
				state_in->step = step_B;
				return codechar - code_out;
			}
			fragment = *plainchar++;
			result |= (fragment & 0x0f0) >> 4;
			*codechar++ = base64_encode_value(result);
			result = (fragment & 0x00f) << 2;
	case step_C:
			if (plainchar == plaintextend)
			{
				state_in->result = result;
				state_in->step = step_C;
				return codechar - code_out;
			}
			fragment = *plainchar++;
			result |= (fragment & 0x0c0) >> 6;
			*codechar++ = base64_encode_value(result);
			result  = (fragment & 0x03f) >> 0;
			*codechar++ = base64_encode_value(result);
			
			++(state_in->stepcount);
			if (state_in->stepcount == CHARS_PER_LINE/4)
			{
				*codechar++ = '\n';
				state_in->stepcount = 0;
			}
		}
	}
	/* control should not reach here */
	return codechar - code_out;
}

size_t base64_encode_blockend(char* code_out, base64_encodestate* state_in)
{
	char* codechar = code_out;
	
	switch (state_in->step)
	{
	case step_B:
		*codechar++ = base64_encode_value(state_in->result);
		*codechar++ = '=';
		*codechar++ = '=';
		break;
	case step_C:
		*codechar++ = base64_encode_value(state_in->result);
		*codechar++ = '=';
		break;
	case step_A:
		break;
	}
	
	return codechar - code_out;
}

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes














namespace Zilch
{
  //***************************************************************************
  CodeGenerator::CodeGenerator() :
    Builder(nullptr)
  {
    ZilchErrorIfNotStarted(CodeGenerator);

    // Walk all any type of expression (often, expressions are nested within each other)
    this->GeneratorWalker.Register(&CodeGenerator::GenerateEnumValueProperties);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateEventNameProperties);
    this->GeneratorWalker.Register(&CodeGenerator::ClassAndPreconstructorContext);
    this->GeneratorWalker.RegisterDerived<FunctionNode>(&CodeGenerator::FunctionContext);
    this->GeneratorWalker.RegisterDerived<ConstructorNode>(&CodeGenerator::FunctionContext);
    this->GeneratorWalker.RegisterDerived<DestructorNode>(&CodeGenerator::FunctionContext);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateInitializer);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateParameter);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateLocalVariable);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateDebugBreak);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateMemberVariable);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateTimeout);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateIfRoot);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateWhile);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateDoWhile);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateFor);
    this->GeneratorWalker.RegisterDerived<ForEachNode>(&CodeGenerator::GenerateFor);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateLoop);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateScope);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateBinaryOperation);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateUnaryOperation);
    this->GeneratorWalker.Register(&CodeGenerator::GeneratePropertyDelegateOperation);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateMemberAccess);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateTypeCast);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateTypeId);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateLocalVariableReference);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateReturnValue);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateFunctionCall);
    this->GeneratorWalker.Register(&CodeGenerator::CollectValue);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateStringInterpolants);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateDelete);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateThrow);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateStaticTypeOrCreationCall);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateExpressionInitializer);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateMultiExpression);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateBreak);
    this->GeneratorWalker.Register(&CodeGenerator::GenerateContinue);
    
    this->PropertySetWalker.Register(&CodeGenerator::GeneratePropertySetMemberAccess);
  }

  //***************************************************************************
  void CodeGenerator::ComputeSize(BoundType* type, const CodeLocation& location)
  {
    // If we already computed a size for this type then don't bother recomputing
    if (type->Size != UndeterminedSize)
      return;

    // Start the size off at zero
    type->Size = 0;

    // If we have a base class type...
    if (type->BaseType != nullptr)
    {
      // Compute the size if we haven't already
      this->ComputeSize(type->BaseType, type->BaseType->Location);
  
      // Add the base type's size to the size of our object
      type->Size += AlignToBusWidth(type->BaseType->GetAllocatedSize());
    }

    // Loop through all the members
    FieldMapRange allFields = type->InstanceFields.all();
    while (allFields.empty() == false)
    {
      // Get the member
      Field& field = *allFields.front().second;
      allFields.popFront();
  
      // Set the position of the member as the current size
      field.Offset = type->Size;
  
      // We only care about computing the size of the type if it's a value type
      if (Type::IsValueType(field.PropertyType))
      {
        // If the class type exists without our hash set
        BoundType* propertyType = TypeBinding::DynamicCast<BoundType*>(field.PropertyType);

        // Compute the size if we haven't already (it may not be one of our types,
        // but compute will early out if it has its size already computed)
        if (propertyType != nullptr)
          this->ComputeSize(propertyType, field.Location);
      }
      // If this type is a handle type...
      else if (Type::IsHandleType(field.PropertyType))
      {
        type->Handles.push_back(type->Size);
      }
      // Otherwise, if it's a delegate type
      else if (TypeBinding::DynamicCast<DelegateType*>(field.PropertyType) != nullptr)
      {
        type->Delegates.push_back(type->Size);
      }
  
      // Add to the size of the object
      type->Size += AlignToBusWidth(field.PropertyType->GetCopyableSize());
    }
  }

  //***************************************************************************
  LibraryRef CodeGenerator::Generate(SyntaxTree& syntaxTree, LibraryBuilder& builder)
  {
    // Create the context
    GeneratorContext generatorContext;
    
    // Store the builder
    this->Builder = &builder;

    // Before we do anything else, we want to compute the sizes of any class whose size has yet to be determined
    BoundTypeValueRange boundTypes = builder.BoundTypes.values();

    // We've collected all the classes we're compiling, as well as the members
    // Loop through all the classes and compute their sizes
    while (boundTypes.empty() == false)
    {
      // Grab the current type and iterate to the next
      BoundType* type = boundTypes.front();
      boundTypes.popFront();

      // Compute the size for the class type
      this->ComputeSize(type, type->Location);
    }

    // Make sure all delegates know thier sizes (may be computed more than once due to code-gen needing the sizes)
    builder.ComputeDelegateAndFunctionSizesOnce();

    // Now generate all the code
    this->GeneratorWalker.Walk(this, syntaxTree.Root, &generatorContext);

    // Create the library
    return this->Builder->CreateLibrary();
  }

  //***************************************************************************
  void CodeGenerator::ClassContext(ClassNode*& node, GeneratorContext* context)
  {
    // Push the class onto the stack so that children can access it
    // (the top of the stack will be the most relevant class to them)
    context->ClassTypeStack.push_back(node->Type);
    
    // Walk all children of the class generically
    context->Walker->GenericWalkChildren(this, node, context);

    // We are exiting this class, so pop it off
    context->ClassTypeStack.pop_back();
  }

  //***************************************************************************
  void CodeGenerator::GenerateEventNameProperties(SendsEventNode*& node, GeneratorContext* context)
  {
    // If we have an event property...
    // It is possible to not have once since we could have a duplicate declaration, which is allowed
    if (node->EventProperty != nullptr)
    {
      // Grab the getter function
      Function* get = node->EventProperty->Get;

      // Change the getter/setter to include the integral value
      get->BoundFunction = VirtualMachine::EventsProperty;

      // Store the event name in the complex user data (the 'EventsProperty' will pull it out when it needs it)
      get->ComplexUserData.WriteObject(node->Name->Token);
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateEnumValueProperties(EnumValueNode*& node, GeneratorContext* context)
  {
    // Grab the getter function
    Function* get = node->IntegralProperty->Get;

    // Change the getter/setter to include the integral value
    get->BoundFunction = VirtualMachine::EnumerationProperty;

    // Store the integral value as the user data (our enum property function will grab that value on the other side)
    get->UserData = (void*)node->IntegralValue;
  }

  //***************************************************************************
  void CodeGenerator::ClassAndPreconstructorContext(ClassNode*& node, GeneratorContext* context)
  {
    // Store the pre-constructor for convenience
    Function* preCtor = node->PreConstructor;

    // We're about to generate code for the pre-constructor, push it onto the stack
    context->FunctionStack.push_back(preCtor);

    // NOTE:
    // This was here, but if you look above in 'GeneratePreConstructorAndPushClassContext'
    // it is already doing this (doing it again would not break anything, just use extra memory)
    // Allocate space for the implicit 'this' pointer
    //preCtor->AllocateRegister(preCtor->This->ResultType->GetCopyableSize());

    // Invoke the class context, which walks the rest of the tree and pushes the class type
    this->ClassContext(node, context);

    // Generate the return opcode, which simply just stops execution of a function
    preCtor->AllocateArgumentFreeOpcode(Instruction::Return, DebugOrigin::ReturnValue, node->Location);

    // Pop the pre constructor
    context->FunctionStack.pop_back();
  }

  // Store the function in the code context
  void CodeGenerator::FunctionContext(GenericFunctionNode*& node, GeneratorContext* context)
  {
    // Push the function onto the stack so that children can access it
    // (the top of the stack will be the most relevant function to them)
    Function* function = node->DefinedFunction;
    context->FunctionStack.push_back(function);

    // Loop through all the parameters
    // The parameters are supposed to occur before checking if the function is static
    // That way, the 'this' pointer always ends up at the end of the stack
    // Yet the instruction ends up at the beginning
    // See CodeGenerator.cpp, approximately line 695, in the function GenerateFunctionCall there is an explanation
    for (size_t i = 0; i < node->Parameters.size(); ++i)
    {
      // Walk the statements
      context->Walker->Walk(this, node->Parameters[i], context);
    }

    // Loop through all the statements
    for (size_t i = 0; i < node->Statements.size(); ++i)
    {
      // Walk the statements
      context->Walker->Walk(this, node->Statements[i], context);
    }

    // Get a reference to the core library
    Core& core = Core::GetInstance();

    // If the function has no return type and not all code paths return...
    if (Type::IsSame(function->FunctionType->Return, core.VoidType) && node->AllPathsReturn == false)
    {
      // Generate an implicit return opcode at the end of the function
      function->AllocateArgumentFreeOpcode(Instruction::Return, DebugOrigin::FunctionContext, node->Location.GetEndOnlyLocation());
    }

    // We are exiting this function, so pop it off
    context->FunctionStack.pop_back();
  }

  //***************************************************************************
  void CodeGenerator::GenerateOutOfScope(ScopeNode*& node, GeneratorContext* context)
  {
    VariableValueRange variables = node->ScopedVariables.values();
    ZilchTodo("Todo: Generate out of scope destructors")

    //// Loop through all the variables in this scope
    //while (variables.empty() == false)
    //{
    //  // Get the current variable and iterate to the next
    //  Variable* variable = variables.front();
    //  variables.popFront();
    //  // 
    //  //variable->ResultType
    //}
  }

  //***************************************************************************
  void CodeGenerator::GenerateParameter(ParameterNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();
    ZilchTodo("Default parameter values (expressions)");

    // We already allocated space for this parameter inside the delegate's parameter computing
    // Just set our variable's local position to the delegate's same parameter stack position
    node->CreatedVariable->Local = function->FunctionType->Parameters[node->ParameterIndex].StackOffset;
  }

  //***************************************************************************
  void CodeGenerator::GenerateLocalVariable(LocalVariableNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Make sure we generate code for the initial value of the variable
    context->Walker->Walk(this, node->InitialValue, context);

    // If the flag is set, this local variable will forward access directly
    // to another stack local (without allocating storage of its own)
    if (node->ForwardLocalAccessIfPossible && node->InitialValue->Access.Type == OperandType::Local)
    {
      // Copy of the access to the initial value, and set the local variable definition to point at the same local
      node->Access = node->InitialValue->Access;
      node->CreatedVariable->Local = node->Access.HandleConstantLocal;
    }
    else
    {
      // This expression's result will be stored in the last created register
      this->CreateLocal(function, node->ResultType->GetCopyableSize(), node->Access);

      // The variable is always on the stack (hence local) so we only need to look at the local part of the access
      node->CreatedVariable->Local = node->Access.HandleConstantLocal;

      // Generate a copy to copy the initial value to the local register
      // The register is not yet initialized, so this must be an init copy
      this->GenerateCopyInitialize
      (
        function,
        node->CreatedVariable->ResultType,
        node->InitialValue->Access,
        Operand(node->CreatedVariable->Local),
        DebugOrigin::LocalVariable,
        node->Location
      );
    }
  }
  
  //***************************************************************************
  void CodeGenerator::GenerateDebugBreak(DebugBreakNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Generate the simple debug breakpoint opcode
    function->AllocateOpcode<Opcode>(Instruction::InternalDebugBreakpoint, DebugOrigin::DebugBreak, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateMemberVariable(MemberVariableNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // The function should always be the pre-constructor
    // Note: If we're generating initialization code for a static field, then we end up pushing another function onto the stack below
    ErrorIf(function != context->ClassTypeStack.back()->PreConstructor,
      "The function on the top of the stack should be the pre-constructor");

    // Error checking
    ErrorIf(node->IsProperty && node->InitialValue != nullptr,
      "Properties should not have initial values");

    // If this is a data member with an initial value...
    if (node->InitialValue != nullptr)
    {
      // Get a reference directly to the field
      Field* field = node->CreatedField;
      
      // Function options for the field initializer we generate below
      FunctionOptions::Enum functionOptions = FunctionOptions::None;

      // If the member is static, then the getter and setter are static too
      if (field->IsStatic)
      {
        functionOptions = FunctionOptions::Static;
      }
      // Generate pre-constructor initialization of a member variable (only for instance fields)
      else
      {
        // Make sure we generate code for the initial value of the member variable
        // This code will be generated in the pre-constructor function
        context->Walker->Walk(this, node->InitialValue, context);

        // Get the 'this' parameter (which will be the only parameter, since this is the Pre-Constructor)
        Variable* thisVariable = function->This;

        // Establish where we're going to be writing to
        Operand destination(thisVariable->Local, field->Offset, OperandType::Field);

        // Generate a copy to copy the initial value to the member
        // Since this is copying over un-initialized memory, then this is a init copy
        this->GenerateCopyInitialize
        (
          function,
          node->ResultType,
          node->InitialValue->Access,
          destination,
          DebugOrigin::MemberVariable,
          node->Location
        );
      }

      // For both static and instance fields, we want to generate an initializer (a function that can be ran on its own)
      // Technically the CreateRawFunction should be generated during the Syntaxer, just in case we ever expose the ability to access it
      // However, initializers are a pretty internal detail (only used by patching and static variable initialization)
      Function* initializer = this->Builder->CreateRawFunction
      (
        field->Owner,
        FieldInitializerName,
        VirtualMachine::ExecuteNext,
        ParameterArray(),
        ZilchTypeId(void),
        functionOptions
      );

      // Push the function onto the stack so that children can access it
      // (the top of the stack will be the most relevant function to them)
      field->Initializer = initializer;
      context->FunctionStack.push_back(initializer);
      
      // Generate code to compute the initial value
      context->Walker->Walk(this, node->InitialValue, context);

      // Establish where we're going to be writing to (a member of an instance of an object, eg field, or a static location)
      Operand destination;

      // If the field is a static field
      if (field->IsStatic)
      {
        // Copy the value computed by walking the intial value into a static variable location
        destination.StaticField = field;
        destination.FieldOffset = 0;
        destination.Type = OperandType::StaticField;
      }
      else
      {
        // Get the 'this' parameter since this is an instance version of a field initializer
        Variable* thisVariable = function->This;

        // We'll write to a field on the this handle using the given offset
        destination.HandleConstantLocal = thisVariable->Local;
        destination.FieldOffset = field->Offset;
        destination.Type = OperandType::Field;
      }

      // Generate a copy to copy the initial value to the member
      // Since this is copying over un-initialized memory, then this is a init copy
      this->GenerateCopyInitialize
      (
        initializer,
        node->ResultType,
        node->InitialValue->Access,
        destination,
        DebugOrigin::MemberVariable,
        node->Location
      );

      // Generate the return opcode, which simply just stops execution of a function
      initializer->AllocateArgumentFreeOpcode(Instruction::Return, DebugOrigin::MemberVariable, node->Location);

      // Pop the function from the stack
      context->FunctionStack.pop_back();
    }

    // Generate the get function if we have one
    if (node->Get != nullptr)
    {
      context->Walker->Walk(this, node->Get, context);
    }

    // Generate the set function if we have one
    if (node->Set != nullptr)
    {
      context->Walker->Walk(this, node->Set, context);
    }
  }

  //***************************************************************************
  // All the if statements (except for the last one) need to jump to the end of the entire if statement
  struct IfEndJump
  {
    RelativeJumpOpcode* Opcode;
    size_t JumpInstructionIndex;
  };
  
  //***************************************************************************
  void CodeGenerator::GenerateIfRoot(IfRootNode*& node, GeneratorContext* context)
  {
    // At the end of each if statement (except for the last one) we need a jump
    // that jumps to the very end of the entire if, store pointers to all those opcode here
    Array<IfEndJump> jumpsAfterEveryElse;

    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Walk through all the parts of the if statement
    for (size_t i = 0; i < node->IfParts.size(); ++i)
    {
      // Grab the current if part node
      IfNode* ifPart = node->IfParts[i];

      // If we have no condition... (that means we're an else statement)
      if (ifPart->Condition == nullptr)
      {
        // Loop through all the statements and generate opcode for each
        this->GenerateStatements(context, ifPart);
        break;
      }

      // Generate code for the condition of the if statement
      context->Walker->Walk(this, ifPart->Condition, context);

      // Store the index that we generated the opcode
      size_t ifFalseInstructionIndex = function->GetCurrentOpcodeIndex();

      // Generate an opcode that will jump if the given conditional-expression is false
      // For now, we'll leave out the "jump to" address as we don't yet know where to go
      // The jump-to address will be filled in upon the post pass
      IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(Instruction::IfFalseRelativeGoTo, DebugOrigin::If, ifPart->Condition->Location);
      ifOpcode.Condition = ifPart->Condition->Access;

      // Loop through all the statements and generate opcode for each
      this->GenerateStatements(context, ifPart);

      // If this if part has another else statement to follow (literally whether we're the last node)
      bool hasElseStatement = (i != node->IfParts.size() - 1);

      // The index of the jump instruction
      RelativeJumpOpcode* jumpOpcode = nullptr;
      size_t jumpInstructionIndex = 0;

      // If we have an else statement, we need one more opcode
      // This has to be here (and not below) because the if-false needs to skip this instruction
      if (hasElseStatement)
      {
        // Create a jump opcode and store it so we can fill in the parameters after we've 
        IfEndJump& endJump = jumpsAfterEveryElse.push_back();
        endJump.JumpInstructionIndex = function->GetCurrentOpcodeIndex();
        endJump.Opcode = &function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::If, ifPart->Location);
      }

      // Jump to wherever the statements inside the if-statement end
      size_t opcodeIndexAfterStatements = function->GetCurrentOpcodeIndex();
      ifOpcode.JumpOffset = (ByteCodeOffset)(opcodeIndexAfterStatements - ifFalseInstructionIndex);
    }

    // Get the opcode index after all the else statements have been processed
    size_t opcodeIndexAfterAllElses = function->GetCurrentOpcodeIndex();

    // Loop through all the jumps
    for (size_t i = 0; i < jumpsAfterEveryElse.size(); ++i)
    {
      // Grab the current jump
      IfEndJump& endJump = jumpsAfterEveryElse[i];

      // Retreive that jump opcode we made earlier, and set its jump offset
      endJump.Opcode->JumpOffset = (ByteCodeOffset)(opcodeIndexAfterAllElses - endJump.JumpInstructionIndex);
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateStatements(GeneratorContext* context, ScopeNode* node)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Loop through all the statements
    for (size_t i = 0; i < node->Statements.size(); ++i)
    {
      // Walk the statements and generate all their code
      context->Walker->Walk(this, node->Statements[i], context);
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateLoopStatementsAndContinues(GeneratorContext* context, LoopScopeNode* node)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Generate all statements for the loop node
    this->GenerateStatements(context, node);

    // By here, we should have collected any continue statements
    // (for break to work properly, this has to come after that backwards jump opcode)
    for (size_t i = 0; i < node->Continues.size(); ++i)
    {
      // Get the current continue node
      ContinueNode* continueNode = node->Continues[i];

      // Get the instruction index for the continue's jump
      size_t continueInstructionIndex = continueNode->InstructionIndex;

      // Get the continue opcode
      RelativeJumpOpcode& continueOpcode = *continueNode->JumpOpcode;

      // We want to jump forward
      continueOpcode.JumpOffset = (ByteCodeOffset)(function->GetCurrentOpcodeIndex() - continueInstructionIndex);
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateBackwardsLoopJump(GeneratorContext* context, size_t backwardsJumpInstructionIndex, const CodeLocation& debugLocation)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Determine the jump offset that we'd like to jump
    ByteCodeOffset jumpOffset = (ByteCodeOffset)(backwardsJumpInstructionIndex - function->GetCurrentOpcodeIndex());

    // Generate one more opcode that will jump back up the beginning (before the condition is checked)
    RelativeJumpOpcode& jumpOpcode = function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::While, debugLocation);
    jumpOpcode.JumpOffset = jumpOffset;
  }

  //***************************************************************************
  void CodeGenerator::GenerateLoopBreaks(GeneratorContext* context, LoopScopeNode* node)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // By here, we should have collected any break statements
    // and finished the opcode that returns to the beginning of the loop
    // (for break to work properly, this has to come after that backwards jump opcode)
    for (size_t i = 0; i < node->Breaks.size(); ++i)
    {
      // Get the current break node
      BreakNode* breakNode = node->Breaks[i];

      // Get the instruction index for the break's jump
      size_t breakInstructionIndex = breakNode->InstructionIndex;

      // Get the break opcode
      RelativeJumpOpcode& breakOpcode = *breakNode->JumpOpcode;

      // We want to jump forward
      breakOpcode.JumpOffset = (ByteCodeOffset)(function->GetCurrentOpcodeIndex() - breakInstructionIndex);
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateTimeout(TimeoutNode*& node, GeneratorContext* context)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Generate the beginning of the scope
    function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::Timeout, node->Location);

    // Generate the beginning of the timeout with seconds
    TimeoutOpcode& timeout = function->AllocateOpcode<TimeoutOpcode>(Instruction::BeginTimeout, DebugOrigin::Timeout, node->Location);
    timeout.LengthSeconds = node->Seconds;

    // Generate all the statements code and continues
    this->GenerateStatements(context, node);

    // Generate the ending of the timeout scope
    function->AllocateOpcode<Opcode>(Instruction::EndTimeout, DebugOrigin::Timeout, node->Location);

    // Generate the final ending of the scope
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::Timeout, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateWhile(WhileNode*& node, GeneratorContext* context)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Store the index that we'd like to jump back to at the end of the loop
    size_t backwardsJumpInstructionIndex = function->GetCurrentOpcodeIndex();
    
    // Generate the beginning of the scope
    function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::While, node->Location);

    // Generate code for the condition of the while statement
    context->Walker->Walk(this, node->Condition, context);

    // Store the index that we generated the opcode
    size_t ifFalseInstructionIndex = function->GetCurrentOpcodeIndex();

    // Generate an opcode that will jump if the given conditional-expression is false
    // For now, we'll leave out the "jump to" address as we don't yet know where to go
    // The jump-to address will be filled in upon the post pass
    IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(Instruction::IfFalseRelativeGoTo, DebugOrigin::While, node->Condition->Location);
    ifOpcode.Condition = node->Condition->Access;

    // Generate all the statements code and continues
    GenerateLoopStatementsAndContinues(context, node);

    // Generate the ending of the scope
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::While, node->Location);

    // Generate the backwards jump, and the breaks
    GenerateBackwardsLoopJump(context, backwardsJumpInstructionIndex, node->Location);
    GenerateLoopBreaks(context, node);

    // Jump to wherever the statements inside the if-statement end
    ifOpcode.JumpOffset = (ByteCodeOffset)(function->GetCurrentOpcodeIndex() - ifFalseInstructionIndex);

    // Generate the final ending of the scope, called when we break or fail the loop conditional
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::While, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateDoWhile(DoWhileNode*& node, GeneratorContext* context)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Store the index that we'd like to jump back to at the end of the loop
    size_t backwardsJumpInstructionIndex = function->GetCurrentOpcodeIndex();

    // Generate the beginning of the scope
    function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::DoWhile, node->Location);

    // Generate all the statements code and continues
    // (we don't actually have a typical backwards jump, that's on the condition)
    GenerateLoopStatementsAndContinues(context, node);

    // Generate code for the condition of the while statement
    context->Walker->Walk(this, node->Condition, context);

    // Generate the ending of the scope
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::DoWhile, node->Location);

    // We have to compute the jump offset before creating the if-opcode, since we don't typically include the
    // size of any opcode when jumping backwards
    ByteCodeOffset jumpOffset = (ByteCodeOffset)(backwardsJumpInstructionIndex - function->GetCurrentOpcodeIndex());

    // Generate an opcode that will jump if the given conditional-expression is false
    // For now, we'll leave out the "jump to" address as we don't yet know where to go
    // The jump-to address will be filled in upon the post pass
    IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(Instruction::IfTrueRelativeGoTo, DebugOrigin::DoWhile, node->Condition->Location);
    ifOpcode.Condition = node->Condition->Access;
    ifOpcode.JumpOffset = jumpOffset;

    // Store the index that we'd like to jump back to at the end of the loop
    size_t jumpInstructionIndex = function->GetCurrentOpcodeIndex();

    // Typically in other loops we end up having one 'EndScope' at the end because the last iteration always terminates inside a BeginScope (while, for, etc)
    // Since the if-condition in a do-while comes outside the BeginScope/EndScope, then we need to take special care because we do NOT need another EndScope opcode
    // The EndScope NEEDS to be run in the case of a break statement, however, because breaks are within the BeginScope/EndScope
    RelativeJumpOpcode& jumpPastEndScopeWhenConditionMet = function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::DoWhile, node->Condition->Location);
    
    // Generate the break (note that we have to have an EndScope after this, but not after the condition fails)
    GenerateLoopBreaks(context, node);
    
    // Generate the final ending of the scope, called when we break or fail the loop conditional
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::While, node->Location);
    
    // Get the opcode index after the 'EndScope' instruction
    size_t opcodeIndexAfterEndScope = function->GetCurrentOpcodeIndex();

    // Retreive that jump opcode we made earlier, and set its jump offset
    jumpPastEndScopeWhenConditionMet.JumpOffset = (ByteCodeOffset)(opcodeIndexAfterEndScope - jumpInstructionIndex);
  }

  //***************************************************************************
  void CodeGenerator::GenerateFor(ForNode*& node, GeneratorContext* context)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // If we have a range variable, generate it first
    if (node->RangeVariable != nullptr)
    {
      // Generate code for the variable
      context->Walker->Walk(this, node->RangeVariable, context);
    }

    // If we have a variable
    if (node->ValueVariable != nullptr)
    {
      // Generate code for the variable
      context->Walker->Walk(this, node->ValueVariable, context);
    }
    else if (node->Initialization != nullptr)
    {
      // Generate code for the initialization expression
      context->Walker->Walk(this, node->Initialization, context);
    }

    // Store the index that we'd like to jump back to at the end of the loop
    size_t backwardsJumpInstructionIndex = function->GetCurrentOpcodeIndex();

    // Generate the beginning of the scope
    function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::For, node->Location);

    // Generate code for the condition of the while statement
    context->Walker->Walk(this, node->Condition, context);

    // Store the index that we generated the opcode
    size_t ifFalseInstructionIndex = function->GetCurrentOpcodeIndex();

    // Generate an opcode that will jump if the given conditional-expression is false
    // For now, we'll leave out the "jump to" address as we don't yet know where to go
    // The jump-to address will be filled in upon the post pass
    IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(Instruction::IfFalseRelativeGoTo, DebugOrigin::For, node->Condition->Location);
    ifOpcode.Condition = node->Condition->Access;

    // Generate all the statements code, the continues
    GenerateLoopStatementsAndContinues(context, node);

    // Walk the iterator since that will still come after a continue
    context->Walker->Walk(this, node->Iterator, context);

    // Generate the ending of the scope
    // All continues and proper loops will hit here, however, the loop conditional failing
    // or a break statement being hit will cause this opcode to not be reached, hense the one below
    // The break / loop conditional should be the only ways to exit the loop
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::For, node->Location);

    // After the iterator, do the backwards jump, and then any breaks
    GenerateBackwardsLoopJump(context, backwardsJumpInstructionIndex, node->Location);
    GenerateLoopBreaks(context, node);

    // Jump to wherever the statements inside the if-statement end
    ifOpcode.JumpOffset = (ByteCodeOffset)(function->GetCurrentOpcodeIndex() - ifFalseInstructionIndex);

    // Generate the final ending of the scope, called when we break or fail the loop conditional
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::For, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateScope(ScopeNode*& node, GeneratorContext* context)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Generate the beginning of the scope
    function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::Scope, node->Location);

    // Loop through all the statements and generate opcode for each
    this->GenerateStatements(context, node);

    // Generate the ending of the scope
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::Scope, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateLoop(LoopNode*& node, GeneratorContext* context)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Store the index that we'd like to jump back to at the end of the loop
    size_t backwardsJumpInstructionIndex = function->GetCurrentOpcodeIndex();

    // Generate the beginning of the scope
    function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::Loop, node->Location);

    // Generate all the statements code, the continues, the backwards jump, and the breaks
    GenerateLoopStatementsAndContinues(context, node);

    // Generate the ending of the scope
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::Loop, node->Location);

    // Do the backwards jump, and then any breaks
    GenerateBackwardsLoopJump(context, backwardsJumpInstructionIndex, node->Location);
    GenerateLoopBreaks(context, node);

    // Generate the final ending of the scope, called when we break on the last iteration
    function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::Loop, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateBreak(BreakNode*& node, GeneratorContext* context)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Make an opcode that will jump to the end of the loop
    node->InstructionIndex = function->GetCurrentOpcodeIndex();
    node->JumpOpcode = &function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::Break, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateContinue(ContinueNode*& node, GeneratorContext* context)
  {
    // Get a pointer to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Make an opcode that will jump to the end of the loop
    node->InstructionIndex = function->GetCurrentOpcodeIndex();
    node->JumpOpcode = &function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::Continue, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateBinaryOperation(BinaryOperatorNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Create the opcode so that we can fill it in
    size_t opcodeStart = function->GetCurrentOpcodeIndex();

    // Grab the token we used for this operator
    Grammar::Enum opToken = node->Operator->TokenId;

    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // Store the binary operator info for convenience (shared definition)
    BinaryOperator& info = node->OperatorInfo;

    // If we need to flip the arguments (only matters for the opcode, but in these cases the result should be the same
    if (info.FlipArguments)
    {
      // Swap the left and right operands
      ExpressionNode* oldLeft = node->LeftOperand;
      node->LeftOperand = node->RightOperand;
      node->RightOperand = oldLeft;
    }

    // For debugging...
    DebugOrigin::Enum debug = DebugOrigin::BinaryOperation;

    // We always handle assignment specially since it's actually just the same as a copy opcode
    if (opToken == Grammar::Assignment)
    {
      // Generate code for the left and right operands
      context->Walker->Walk(this, node->LeftOperand, context);
      context->Walker->Walk(this, node->RightOperand, context);

      // Pull out things we need
      Type* type = node->RightOperand->ResultType;
      Operand& source = node->RightOperand->Access;
      Operand& destination = node->LeftOperand->Access;

      // If this is a strict property set...
      if (node->LeftOperand->IoUsage & IoMode::StrictPropertySet)
      {
        // We actually need to perform initialization, despite it being an assignment
        // because a strict property set just generates a temporary space to initialize
        CreateCopyOpcode(function, CopyMode::Initialize, type, source, destination, debug, node->Location);
      }
      else
      {
        // This is just a straight assignment copy
        CreateCopyOpcode(function, CopyMode::Assignment, type, source, destination, debug, node->Location);
      }
    }
    // If the operator results in an l-value...
    else if (info.Io & IoMode::WriteLValue)
    {
      // Generate code for the left and right operands
      context->Walker->Walk(this, node->LeftOperand, context);
      context->Walker->Walk(this, node->RightOperand, context);

      // Create the opcode
      BinaryLValueOpcode& opcode = function->AllocateOpcode<BinaryLValueOpcode>(info.Instruction, debug, node->Location);

      // All l-value binary operations result in a chained left hand value,
      // therefore we use the same primary and secondary index as the left operand
      // (no register allocation should ever be needed)
      node->Access = node->LeftOperand->Access;

      // We output to the left operand, and our right operand is the right expression
      opcode.Output = node->LeftOperand->Access;
      opcode.Right = node->RightOperand->Access;
    }
    // Otherwise, the operator results in an r-value...
    else
    {
      // All r-value binary operations result in a value (temporary) on the stack
      // Therefore we need to allocate a register to store our result in
      CreateLocal(function, node->ResultType->GetCopyableSize(), node->Access);

      // Handle the short-circuit operators specially
      if (opToken == Grammar::LogicalAnd || opToken == Grammar::LogicalOr)
      {
        // The first thing we do is always walk the left, because we could end up not running the right's opcode
        context->Walker->Walk(this, node->LeftOperand, context);

        // In both short circuit cases, we generate an if-jump that jumps after the right opcode
        Instruction::Enum ifInstruction = Instruction::InvalidInstruction;

        // For a logical 'and', we need to evaluate the first argument and if it returns false we early out
        if (opToken == Grammar::LogicalAnd)
        {
          ifInstruction = Instruction::IfFalseRelativeGoTo;
        }
        // For a logical 'or', we need to evaluate the first argument and if it returns true we early out
        else
        {
          ifInstruction = Instruction::IfTrueRelativeGoTo;
        }

        // OPTIMIZATION:
        // This could be removed if we just had the left operand directly output to our own local, instead of its own
        // Copy the resulting value from the left to the output, even though it may not be the final result
        GenerateCopyInitialize
        (
          function,
          node->ResultType,
          node->LeftOperand->Access,
          node->Access,
          DebugOrigin::BinaryOperation,
          node->Location
        );
        
        // Store the index that we generated the if opcode (so we know how far to relative jump)
        size_t ifFalseInstructionIndex = function->GetCurrentOpcodeIndex();

        // The condition (regardless of whether testing false or true) is always based on the left argument
        IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(ifInstruction, DebugOrigin::BinaryOperation, node->Location);
        ifOpcode.Condition = node->LeftOperand->Access;
        
        // Now generate opcode to evaluate the right argument
        context->Walker->Walk(this, node->RightOperand, context);

        // OPTIMIZATION: (see above)
        // This could be removed if we just had the right operand directly output to our own local, instead of its own
        // Copy the resulting value from the right to the output, if this occurs it will always be the final result (may be skipped by above if)
        // Not that it really matters for value types, but this copy is an 'Assignment', because technically the local will always be initialized above
        CreateCopyOpcode
        (
          function,
          CopyMode::Assignment,
          node->ResultType,
          node->RightOperand->Access,
          node->Access,
          DebugOrigin::BinaryOperation,
          node->Location
        );

        // The jump we generated before will skip directly to here, after the right argument gets evaluated
        size_t opcodeIndexAfterStatements = function->GetCurrentOpcodeIndex();
        ifOpcode.JumpOffset = (ByteCodeOffset)(opcodeIndexAfterStatements - ifFalseInstructionIndex);
      }
      else
      {
        // Note: The walkers MUST come before allocating the opcode (makes sense) otherwise the parent
        // opcode will run before the children's opcode get evaluated
        // Generate code for the left and right operands
        context->Walker->Walk(this, node->LeftOperand, context);
        context->Walker->Walk(this, node->RightOperand, context);

        // Create the opcode
        BinaryRValueOpcode& opcode = function->AllocateOpcode<BinaryRValueOpcode>(info.Instruction, debug, node->Location);

        // We always output to the stack
        opcode.Output = node->Access.HandleConstantLocal;

        // Initialize both operands
        opcode.Left = node->LeftOperand->Access;
        opcode.Right = node->RightOperand->Access;

        // The size is needed for some operations, such as value comparison
        opcode.Size = node->LeftOperand->ResultType->GetCopyableSize();
      }
    }

    // Error checking
    ErrorIf(opcodeStart == function->GetCurrentOpcodeIndex(), "No instructions were written!");

    // We have to generate set functions for any properties that need it
    GeneratorContext propContext;
    propContext.FunctionStack.push_back(function);
    this->PropertySetWalker.Walk(this, node->LeftOperand, &propContext);
    propContext.FunctionStack.pop_back();
  }

  //***************************************************************************
  void CodeGenerator::GeneratePropertyDelegateOperation(PropertyDelegateOperatorNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Attempt to get the operand as a member access node...
    // This operator only works on properties and members
    MemberAccessNode* member = TypeBinding::DynamicCast<MemberAccessNode*>(node->Operand);

    // We already verified that this was a member access in 
    ErrorIf(member == nullptr,
      "Somehow our operand was not a MemberAccessNode, even though we verified that in the Syntaxer");

    // Normally we would walk the operand, but we need to only
    // walk the operand's left since we're ignoring the property
    context->Walker->Walk(this, member->LeftOperand, context);

    // The 'this' of the property is going to be the left operand (who we're accessing the property on)
    Type* thisType = member->LeftOperand->ResultType;
    Operand& thisSource = member->LeftOperand->Access;

    // Create a location on the stack to store the 'this' handle
    OperandLocal thisHandle = function->AllocateRegister(sizeof(Handle));

    // Make sure that we make a handle out of the left argument (will be used as our this handle)
    // We'll save this new handle on the stack in the location that we allocated above
    GenerateHandleInitialize
    (
      function,
      thisType,
      thisSource,
      Operand(thisHandle),
      DebugOrigin::FunctionMemberAccess,
      node->Location
    );

    // Make an opcode that will jump to the end of the loop
    CreatePropertyDelegateOpcode& opcode = function->AllocateOpcode<CreatePropertyDelegateOpcode>(Instruction::PropertyDelegate, DebugOrigin::PropertyDelegate, node->Location);

    // Tell the opcode the type it will be creating (this cast should always be safe, because property delegates are always bound types)
    opcode.CreatedType = (BoundType*)node->ResultType;
    
    // Setup the 'this' handle from where we get the properties
    opcode.ThisHandleLocal = thisHandle;

    // Setup the save handle where the property delegate goes
    // This expression's result will be stored in the last created register
    CreateLocal(function, sizeof(Handle), node->Access);
    opcode.SaveHandleLocal = node->Access.HandleConstantLocal;

    // Tell the opcode the getter and setter functions it will be using from the accessed property
    opcode.Get = node->AccessedProperty->Get;
    opcode.Set = node->AccessedProperty->Set;
  }

  //***************************************************************************
  void CodeGenerator::GenerateUnaryOperation(UnaryOperatorNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Generate code for the only operand
    context->Walker->Walk(this, node->Operand, context);

    // Generate the binary operator instructions, and also make sure to set our register/secondary index and access modes
    GenerateUnaryOp(function, *node, DebugOrigin::UnaryOperation);

    // We have to generate set functions for any properties that need it
    GeneratorContext propContext;
    propContext.FunctionStack.push_back(function);
    this->PropertySetWalker.Walk(this, node->Operand, &propContext);
    propContext.FunctionStack.pop_back();
  }

  //***************************************************************************
  void CodeGenerator::GenerateMemberAccess(MemberAccessNode*& node, GeneratorContext* context)
  {
    if (node->MemberType == MemberAccessType::Field)
    {
      if (node->AccessedField->IsStatic)
        GenerateStaticFieldAccess(node, context);
      else
        GenerateFieldAccess(node, context);
    }
    else if (node->MemberType == MemberAccessType::Function)
    {
      GenerateFunctionDelegateMemberAccess(node, context);
    }
    else if (node->MemberType == MemberAccessType::Property)
    {
      GeneratePropertyGetMemberAccess(node, context);
    }
    else if (node->MemberType == MemberAccessType::Dynamic)
    {
      //GenerateDynamicGetMemberAccess(node, context);
    }
    else
    {
      Error("A member access type was used that we didn't know about, or memory got corrupted");
    }
  }
  
  //***************************************************************************
  void CodeGenerator::GenerateStaticFieldAccess(MemberAccessNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();
    
    // Normally an Operand can actually point at a handle through another handle (class A containing a reference to another class B)
    // and this will work properly with GetOperand<Handle> where OperandType is Field
    // In this case, we only need to copy the handle for A to the stack, but not B (because again, Operand access solves this)
    // We do not need to copy any handles to the stack because the first one will be resolved by an OperandType of Static
    // Any subsequent member accesses will not be just a regular Field/Propery accesses
    // which will automatically copy the handle to the stack when needed
    
    // Our current implementation is a bit silly, but we just shove a direct pointer to the Field*
    // into the operand's Field size_t value, (it will always fit, because size_t should be as big as a pointer)
    node->Access.StaticField = node->AccessedField;
    node->Access.FieldOffset = 0;

    // Just treat this as if it's just any other local on the stack
    node->Access.Type = OperandType::StaticField;
  }

  //***************************************************************************
  void CodeGenerator::GenerateFieldAccess(MemberAccessNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();
    
    // For the awkward reason that type refernces are post expressions, we need to check
    if (node->LeftOperand != nullptr)
    {
      // Generate the code for the left operand
      context->Walker->Walk(this, node->LeftOperand, context);
    }
    
    // Get the type that we're performing the access on (not the resulting type, but basically leftType.SomeMember)
    Type* leftType = node->LeftOperand->ResultType;

    // Delegates will need a special
    ErrorIf(TypeBinding::DynamicCast<DelegateType*>(leftType) != nullptr,
      "I haven't properly handled accessing members on delegates yet, see below");

    // If the left-hand type is a handle (indirection type or a reference type)...
    if (Type::IsHandleType(leftType))
    {
      // Set the handle index to be the left's primary index
      OperandIndex handleIndex = node->LeftOperand->Access.HandleConstantLocal;

      // If the left type is accessed as a data member... (we need to copy it onto the stack!)
      // Even when we access a static field (and then we access a member on that field, eg TypeMemberAccess -> MemberAccess)
      // we still need to copy the handle to a stack local before we use it further
      if (node->LeftOperand->Access.Type == OperandType::Field || node->LeftOperand->Access.Type == OperandType::StaticField)
      {
        // Allocate a register to store the handle
        handleIndex = function->AllocateRegister(leftType->GetCopyableSize());

        // Generate a copy to bring the handle to the local register
        // Since we are not assigning (we're copying this to the stack) then
        // this is a copy over uninitialized memory
        GenerateCopyInitialize
        (
          function,
          leftType,
          node->LeftOperand->Access,
          Operand(handleIndex),
          DebugOrigin::DataMemberAccess,
          node->Location
        );
      }

      // Set our primary index to be the handle index
      node->Access.HandleConstantLocal = handleIndex;

      // Use the member index into the class
      node->Access.FieldOffset = node->AccessedField->Offset;

      // We are accessed as a field...
      node->Access.Type = OperandType::Field;
    }
    // If the left-hand type is a data-type / value...
    else
    {
      // If the left hand side is entirely on the stack
      if (node->LeftOperand->Access.Type == OperandType::Local)
      {
        // Simply just offset the primary index so that it points at the member on the stack
        node->Access.HandleConstantLocal = (OperandIndex)(node->LeftOperand->Access.HandleConstantLocal + node->AccessedField->Offset);

        // Our secondary index is zero since we don't use it
        node->Access.FieldOffset = 0;

        // Just treat this as if it's just any other local on the stack
        node->Access.Type = OperandType::Local;
      }
      // If the left hand side is still being accessed as a field
      else if (node->LeftOperand->Access.Type == OperandType::Field)
      {
        // Our access is just the same access as the field itself (this logic is recursive for as many struct accesses beyond this)
        node->Access = node->LeftOperand->Access;

        // Our offset is just the previous structs offset plus the offset to that newly accessed field
        node->Access.FieldOffset += node->AccessedField->Offset;
      }
      // If the left hand side is accessed as a static field
      // Note: We never need to worry about the left hand side being a type, and us being a static
      // because that would make our node a TypeMemberAccess, which is handeld in GenerateStaticFieldAccess
      // This is the case where we are accessing a member, and our left operand should be a TypeMemberAccess (not us)
      else if (node->LeftOperand->Access.Type == OperandType::StaticField)
      {
        // Our access is just the same access as the field itself (this logic is recursive for as many struct accesses beyond this)
        node->Access = node->LeftOperand->Access;
        
        // Our offset is just the previous structs offset plus the offset to that newly accessed field
        node->Access.FieldOffset += node->AccessedField->Offset;
      }
      else
      {
        // We should never be able to get here
        Error("Unhandled case");
      }
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateFunctionDelegateMemberAccess(MemberAccessNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // For the awkward reason that type refernces are post expressions, we need to check
    if (node->LeftOperand != nullptr)
    {
      // Generate the code for the left operand
      context->Walker->Walk(this, node->LeftOperand, context);
    }

    // A temporary barrier whilst we don't have a way to resolve overloads with anything other than function calls
    if (node->AccessedFunction == nullptr)
      return;
    
    // Note: In the case where we're accessing a static from a type reference the
    // 'node->LeftOperand' will always be null, but note we do not need it (no this handle)!
    
    // If the function we're calling is a member function (not a static function)
    if (node->AccessedFunction->This != nullptr)
    {
      this->CreateInstanceDelegateAndThisHandle
      (
        function,
        node->AccessedFunction,
        node->LeftOperand->ResultType, // Note that the left operand in a member access is the object ('this')
        node->LeftOperand->Access,
        node->Access,
        (node->Operator != Grammar::NonVirtualAccess),
        node->Location,
        DebugOrigin::FunctionMemberAccess
      );
    }
    else
    {
      this->CreateStaticDelegate
      (
        function,
        node->AccessedFunction,
        node->Access,
        node->Location,
        DebugOrigin::FunctionMemberAccess
      );
    }
  }

  //***************************************************************************
  void CodeGenerator::GeneratePropertyGetMemberAccess(MemberAccessNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();
    
    // For the awkward reason that type references are post expressions, we need to check
    if (node->LeftOperand != nullptr)
    {
      // Generate the code for the left operand
      context->Walker->Walk(this, node->LeftOperand, context);
    }

    // Note: In the case where we're accessing a static from a type reference the
    // 'node->LeftOperand' will always be null, but note we do not need it (no this handle)!
    
    // Get the property for ease of use
    Property* property = node->AccessedProperty;
    
    // Check if we're even being read
    if ((node->IoUsage & IoMode::ReadRValue) != 0)
    {
      // Get the 'get' for ease of use
      Function* get = property->Get;

      // We generate a delegate before calling the function
      Operand delegateLocal;

      // If the get function we're calling is a member function (not a static function)
      if (get->This != nullptr)
      {
        this->CreateInstanceDelegateAndThisHandle
        (
          function,
          get,
          node->LeftOperand->ResultType, // Note that the left operand in a member access is the object ('this')
          node->LeftOperand->Access,
          delegateLocal,
          (node->Operator != Grammar::NonVirtualAccess),
          node->Location,
          DebugOrigin::PropertyGetMemberAccess
        );
      }
      else
      {
        this->CreateStaticDelegate
        (
          function,
          get,
          delegateLocal,
          node->Location,
          DebugOrigin::PropertyGetMemberAccess
        );
      }

      // Generate opcode for calling the function (we still need to copy arguments ourselves)
      GenerateCallOpcodePreArgs(function, get->FunctionType, delegateLocal, node->Location, DebugOrigin::PropertyGetMemberAccess);

      // Generate opcode for finishing up the call to the function
      GenerateCallOpcodePostArgs(function, get->FunctionType, &node->Access, node->Location, DebugOrigin::PropertyGetMemberAccess);
    }
    // Check if we're ONLY being written to
    else if ((node->IoUsage & IoMode::WriteLValue) != 0)
    {
      // We need to let any assignments know that this is NOT an initialized
      // value, and therefore the copy must also perform initialization!
      // Note: Assignment should be the only thing possible with a set-only property
      node->IoUsage = (IoMode::Enum)(node->IoUsage | IoMode::StrictPropertySet);

      // Make space that any operator will write to
      CreateLocal(function, property->PropertyType->GetCopyableSize(), node->Access);
    }
    else
    {
      // Otherwise, we're not being used by anything
      ErrorIf(node->IoUsage != IoMode::Ignore, "Unexpected case");
    }
  }


  //***************************************************************************
  void CodeGenerator::GeneratePropertySetMemberAccess(MemberAccessNode*& node, GeneratorContext* context)
  {
    // If this node is a property, we don't care about it
    if (node->MemberType != MemberAccessType::Property)
      return;

    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();
    
    // Note: We never need to walk the left operand (it was already done)

    // Check if we're even being written to
    if ((node->IoUsage & IoMode::WriteLValue) != 0)
    {
      // Get the property for ease of use
      Property* property = node->AccessedProperty;
      Function* set = property->Set;

      // We generate a delegate before calling the function
      Operand delegateLocal;

      // If the set function we're calling is a member function (not a static function)
      if (set->This != nullptr)
      {
        this->CreateInstanceDelegateAndThisHandle
        (
          function,
          set,
          node->LeftOperand->ResultType, // Note that the left operand in a member access is the object ('this')
          node->LeftOperand->Access,
          delegateLocal,
          (node->Operator != Grammar::NonVirtualAccess),
          node->Location,
          DebugOrigin::PropertySetMemberAccess
        );
      }
      else
      {
        this->CreateStaticDelegate
        (
          function,
          set,
          delegateLocal,
          node->Location,
          DebugOrigin::PropertySetMemberAccess
        );
      }

      // Generate opcode for calling the function (we still need to copy arguments ourselves)
      GenerateCallOpcodePreArgs(function, set->FunctionType, delegateLocal, node->Location, DebugOrigin::PropertySetMemberAccess);

      // Check if we were read, then we assume that 'get' was
      // already called, and our modified value is on the stack
      if ((node->IoUsage & IoMode::ReadRValue) != 0)
      {
        // Note: In the case where 'get'  was called, we know our ResultType is the property type
        ErrorIf(node->ResultType != property->PropertyType,
          "The resulting type when a property has 'get' called on it should be the property type");

        // Generate the opcode for copying a parameter in a function call
        GenerateCopyToParameter
        (
          function,
          node->ResultType,
          node->Access,
          set->FunctionType->Parameters.front().StackOffset,
          DebugOrigin::PropertySetMemberAccess,
          node->Location
        );
      }
      else
      {
        // Generate the opcode for copying a parameter in a function call
        GenerateCopyToParameter
        (
          function,
          property->PropertyType,
          node->Access,
          set->FunctionType->Parameters.front().StackOffset,
          DebugOrigin::PropertySetMemberAccess,
          node->Location
        );
      }

      // Generate opcode for finishing up the call to the function
      GenerateCallOpcodePostArgs(function, set->FunctionType, nullptr, node->Location, DebugOrigin::PropertySetMemberAccess);
    }
  }


  //***************************************************************************
  void CodeGenerator::GenerateInitializer(InitializerNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // If the function we're calling is a member function (not a static function)
    if (node->InitializerFunction->This != nullptr)
    {
      this->CreateInstanceDelegateAndThisHandle
      (
        function,
        node->InitializerFunction,
        function->This->ResultType,     // The this type is the type we're compiling
        Operand(function->This->Local), // Get the 'this' handle from the local variable
        node->Access,
        false,
        node->Location,
        DebugOrigin::FunctionMemberAccess
      );
    }
    else
    {
      this->CreateStaticDelegate
      (
        function,
        node->InitializerFunction,
        node->Access,
        node->Location,
        DebugOrigin::FunctionMemberAccess
      );
    }
  }

  //***************************************************************************
  template <typename T>
  T& CodeGenerator::DelegateOpcode
  (
    Function*           caller,
    Function*           toCall,
    OperandIndex        delegateDest,
    const CodeLocation& location,
    Instruction::Enum   instruction,
    DebugOrigin::Enum   debug
  )
  {
    // Create an opcode that will create a delegate
    T& opcode = caller->AllocateOpcode<T>(instruction, debug, location);
    opcode.BoundFunction = toCall;

    // We'll save the delegate at the location indicated by this node
    opcode.SaveLocal = delegateDest;

    // Return the allocated opcode
    return opcode;
  }

  //***************************************************************************
  void CodeGenerator::CreateInstanceDelegateAndThisHandle
  (
    Function*           caller,
    Function*           toCall,
    Type*               thisType,
    const Operand&      thisSource,
    Operand&            delegateDestOut,
    bool                canBeVirtual,
    const CodeLocation& location,
    DebugOrigin::Enum   debug
  )
  {
    // Note: 'thisSource' is NOT necessarily a handle
    // as it is possible to invoke a function on value types (we need to generate a handle for those cases)
    // By default we just assume the source is a handle
    Operand thisHandle = thisSource;

    // If the type is not already a handle, we need to make a handle for it on the stack
    if (Type::IsHandleType(thisType) == false)
    {
      // Create a location on the stack to store the 'this' handle
      OperandLocal thisHandleLocal = caller->AllocateRegister(sizeof(Handle));
      thisHandle = Operand(thisHandleLocal);

      // Make sure that we make a handle out of the left argument (will be used as our this handle)
      // We'll save this new handle on the stack in the location that we allocated above
      GenerateHandleInitialize
      (
        caller,
        thisType,
        thisSource,
        Operand(thisHandleLocal),
        DebugOrigin::FunctionMemberAccess,
        location
      );
    }

    // Now create the delegate (the 'this' handle could be copied, or not)
    this->CreateInstanceDelegateWithThisHandle
    (
      caller,
      toCall,
      thisHandle,
      delegateDestOut,
      canBeVirtual,
      location,
      debug
    );
  }

  //***************************************************************************
  void CodeGenerator::CreateInstanceDelegateWithThisHandle
  (
    Function*           caller,
    Function*           toCall,
    const Operand&      thisHandle,
    Operand&            delegateDestOut,
    bool                canBeVirtual,
    const CodeLocation& location,
    DebugOrigin::Enum   debug
  )
  {
    // This expression's result will be stored in the last created register
    CreateLocal(caller, toCall->FunctionType->GetCopyableSize(), delegateDestOut);

    // Create an instance delegate opcode
    CreateInstanceDelegateOpcode& delegateOpcode = DelegateOpcode<CreateInstanceDelegateOpcode>
    (
      caller,
      toCall,
      delegateDestOut.HandleConstantLocal,
      location,
      Instruction::CreateInstanceDelegate,
      debug
    );

    // Mark whether or not this member can be virtual
    delegateOpcode.CanBeVirtual = canBeVirtual;

    // Let the delegate know where to get it's 'this' handle from
    delegateOpcode.ThisHandle = thisHandle;
  }

  //***************************************************************************
  void CodeGenerator::CreateStaticDelegate
  (
    Function*           caller,
    Function*           toCall,
    Operand&            delegateDest,
    const CodeLocation& location,
    DebugOrigin::Enum   debug
  )
  {
    // This expression's result will be stored in the last created register
    CreateLocal(caller, toCall->FunctionType->GetCopyableSize(), delegateDest);

    // Create a static delegate opcode
    DelegateOpcode<CreateStaticDelegateOpcode>
    (
      caller,
      toCall,
      delegateDest.HandleConstantLocal,
      location,
      Instruction::CreateStaticDelegate,
      debug
    );
  }

  //***************************************************************************
  void CodeGenerator::GenerateTypeCast(TypeCastNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Generate the code for the operand of the type cast
    context->Walker->Walk(this, node->Operand, context);

    // Generate a copy opcode for the return type to the return value
    // (also puts the result in a register and sets this node's register index)
    GenerateConversion(function, *node, DebugOrigin::TypeCast);
  }
  
  //***************************************************************************
  void CodeGenerator::GenerateTypeId(TypeIdNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // If we have a value...
    if (node->Value != nullptr)
    {
      // Technically the expression inside a type-id does not need
      // to be run, but just for the principle of least surprise
      context->Walker->Walk(this, node->Value, context);
    }

    // If this is a compile time type that was given, then this is always just a constant
    if (node->CompileTimeSyntaxType != nullptr)
    {
      // We treat the type as a constant
      node->Access.Type = OperandType::Constant;
      node->Access.FieldOffset = 0;

      // Create a handle in constant space for the type pointer
      Handle& handle = function->AllocateConstant<Handle>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal);

      // Set the handle manager and type of the handle
      // We know explicitly that the string handle manager is a shared manager
      HandleManagers& managers = HandleManagers::GetInstance();
      handle.Manager = managers.GetSharedManager(ZilchManagerId(PointerManager));
      handle.Type = TypeBinding::DynamicCast<BoundType*>(node->ResultType);

      // Store the pointer to the compile time type into the handle
      handle.Manager->ObjectToHandle((byte*)node->CompileTimeType, handle);
    }
    else
    {
      // This expression's result will be stored in the last created register
      this->CreateLocal(function, sizeof(Handle), node->Access);

      // Set the register indices for the operands, and set the location that the result should be stored into
      TypeIdOpcode& opcode = function->AllocateOpcode<TypeIdOpcode>(Instruction::TypeId, DebugOrigin::TypeId, node->Location);
      opcode.Expression = node->Value->Access;
      opcode.SaveTypeHandleLocal = node->Access.HandleConstantLocal;
      opcode.CompileTimeType = node->CompileTimeType;
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateLocalVariableReference(LocalVariableReferenceNode*& node, GeneratorContext* /*context*/)
  {
    // Point to the exact same register as the local variable
    node->Access.HandleConstantLocal = node->AccessedVariable->Local;

    // We have no secondary index
    node->Access.FieldOffset = 0;

    // We are accessing a local variable on the stack
    node->Access.Type = OperandType::Local;
  }

  //***************************************************************************
  void CodeGenerator::GenerateReturnValue(ReturnNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Loop through all the return values
    if (node->ReturnValue != nullptr)
    {
      // Store the return value for convenience
      ExpressionNode* returnValue = node->ReturnValue;

      // Generate the code for the current return expression
      context->Walker->Walk(this, returnValue, context);

      // Generate a copy opcode for the return type to the return value
      // The return value should be uninitialized memory before this point
      // so this must be an initialized copy
      GenerateCopyToReturn
      (
        function,
        returnValue->ResultType,
        returnValue->Access,
        Operand(0),
        DebugOrigin::ReturnValue,
        returnValue->Location
      );
    }

    // Generate the return opcode, which simply just stops execution of a function
    function->AllocateArgumentFreeOpcode(Instruction::Return, DebugOrigin::ReturnValue, node->Location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateFunctionCall(FunctionCallNode*& node, GeneratorContext* context)
  {
    // If we have no left operand, don't bother walking it (such is the case with attribute calls)
    if (node->LeftOperand == nullptr)
      return;

    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Generate the code for the left operand first
    context->Walker->Walk(this, node->LeftOperand, context);

    // Note: We generate code for the passed in arguments below, but we needed to do the left
    //       expression right here since we immediately grab its delegate type and start using it
    Operand delegateLocal;

    // Store the delegate type that we'll be calling
    DelegateType* delegateType = nullptr;

    // For debugging purposes
    DebugOrigin::Enum debugOrigin = DebugOrigin::FunctionCall;

    // We need to generate access for a return value (except in some cases, like creation calls!)
    Operand* returnValueAccess = &node->Access;

    // If the left hand node is a creation call node (basicall is this a constructor?)...
    StaticTypeNode* creationNode = node->FindCreationCall();
    if (creationNode != nullptr)
    {
      // A creation call does not return a handle to the created value, primarily because
      // we do not know whether it is being allocated as a handle or as a local!
      // Therefore, it always returns void (however, we definately do not want to generate anything for returns)
      returnValueAccess = nullptr;

      // Update the debug origin to be a little more clear (we're in a constructor)
      debugOrigin = DebugOrigin::FunctionCallConstructor;

      // Technically this constructor call comes above the actual new/local in the syntax tree
      // which means that whoever is referencing the new/local will actually be getting our FunctionCallNode result
      // Because this is specifically a constructor, we need to return exactly what the left operand returns
      // Our result type should have already been set in the syntaxer phase
      node->Access = creationNode->Access;

      // If we have no constructor function (eg the default constructor, or just pre-constructor)
      if (creationNode->ConstructorFunction == nullptr)
      {
        // Return early, since there is no function call to be made
        return;
      }

      // Create an instance delegate for the constructor
      this->CreateInstanceDelegateWithThisHandle
      (
        function,
        creationNode->ConstructorFunction,
        Operand(creationNode->ThisHandleLocal),
        delegateLocal,
        false,
        node->Location,
        debugOrigin
      );

      // The delegate type should be grabbed from the contstructor
      delegateType = creationNode->ConstructorFunction->FunctionType;
    }
    else
    {
      // The delegate local is the left expression
      delegateLocal = node->LeftOperand->Access;

      // The delegate type should be grabbed from the left operand
      delegateType = TypeBinding::DynamicCast<DelegateType*>(node->LeftOperand->ResultType);
    }

    // Generate opcode for calling the function (we still need to copy arguments ourselves)
    GenerateCallOpcodePreArgs(function, delegateType, delegateLocal, node->Location, debugOrigin);

    ZilchTodo("Parameters are currently not re-ordered");

    // Loop through all the function's parameters
    for (size_t i = 0; i < node->Arguments.size(); ++i)
    {
      // Get the expression node that will be placed into the parameter
      ExpressionNode* currentArgument = node->Arguments[i];

      // Generate the code for the current expression
      context->Walker->Walk(this, currentArgument, context);

      // Generate the opcode for copying a parameter in a function call
      GenerateCopyToParameter
      (
        function,
        currentArgument->ResultType,
        currentArgument->Access,
        delegateType->Parameters[i].StackOffset,
        DebugOrigin::FunctionCall,
        currentArgument->Location
      );
    }

    // Generate opcode for finishing up the call to the function
    GenerateCallOpcodePostArgs(function, delegateType, returnValueAccess, node->Location, debugOrigin);
  }


  //***************************************************************************
  void CodeGenerator::GenerateCallOpcodePreArgs
  (
    Function* caller,
    DelegateType* delegateTypeToCall,
    const Operand& delegateOperand,
    const CodeLocation& location,
    DebugOrigin::Enum debugOrigin
  )
  {
    // Record the current offset in instructions (this is not where we will jump to)
    size_t opcodePosBeforeThisCopy = caller->GetCurrentOpcodeIndex();
    
    // Allocate the prep-for-function instruction, and give it the index that the 
    // function lives as well as the register that we'd like to store the return value
    PrepForFunctionCallOpcode& prepOpcode = caller->AllocateOpcode<PrepForFunctionCallOpcode>(Instruction::PrepForFunctionCall, debugOrigin, location);
    prepOpcode.Delegate = delegateOperand;

    // We basically always generate the copy opcode for copying a 'this' parameter, even when its a static function
    // That being said, this opcode will be skipped if the PrepForFunctionCall opcode determines that the calling function is not static
    // Note that the calling convention is currently that the 'this' object goes last, but that it's the first opcode to be run
    // Being last in memory allows it to be easily omitted for static function calls
    // Being the first opcode to run allows the opcode to easily be skipped after the PrepForFunctionCall
    // See CodeGenerator.cpp, approximately line 292, in the function FunctionContext is the counterpart to this explanation
    {
      // Determine the position of the handle (it resides inside the delegate)
      Operand handleOperand = delegateOperand;

      if (handleOperand.Type == OperandType::Field)
      {
        handleOperand.FieldOffset += offsetof(Delegate, ThisHandle);
      }
      else
      {
        handleOperand.HandleConstantLocal += offsetof(Delegate, ThisHandle);
      }

      // Get the instance of the type database
      Core& core = Core::GetInstance();

      // Copy the handle from the delegate local into the first argument
      GenerateCopyToParameter
      (
        caller,
        core.NullType,
        handleOperand,
        delegateTypeToCall->ThisHandleStackOffset,
        debugOrigin,
        location
      );
    }

    // We want to jump to the next opcode if the function is static
    prepOpcode.JumpOffsetIfStatic = (OperandIndex)(caller->GetCurrentOpcodeIndex() - opcodePosBeforeThisCopy);
  }


  //***************************************************************************
  void CodeGenerator::GenerateCallOpcodePostArgs
  (
    Function* caller,
    DelegateType* delegateTypeToCall,
    Operand* returnAccessOut,
    const CodeLocation& location,
    DebugOrigin::Enum debugOrigin
  )
  {
    // Generate an opcode for a function call (the last parameter is where the return value will be stored)
    caller->AllocateArgumentFreeOpcode(Instruction::FunctionCall, debugOrigin, location);

    // Grab the core
    Core& core = Core::GetInstance();

    // In certain cases it is possible that we're not even able to get the return value (even if it is void!)
    // For example, the case of a setter (technically returns void, which is storable, but cannot every be accessed)
    // In these cases, the 'returnAccessOut' will be null since there's nothing to return
    if (returnAccessOut != nullptr)
    {
      // Note: We used to have an exception here for Void types (we wouldn't generate a return because they could not be stored)
      // Now void types can actually be stored, so therefore we must create a local for the void type
      // Having said that, a Void type has a size of 0 (creating a 0 sized local does nothing)
      // Moreover, we should also not copy the void type to the return, as there is nothing to copy (optimization and sanity!)

      // Note: There was a previous bug where we relied upon the node->ResultType as our return, which is true
      // for all function calls, however this is not the case in terms of constructor calls
      // A constructor call's delegateType will always be null (and for a function, it should be the same as node->ResultType)

      // This function call's result will be stored in the last created register
      CreateLocal(caller, delegateTypeToCall->Return->GetCopyableSize(), *returnAccessOut);

      // Generate the opcode for copying a return in a function call
      GenerateCopyFromReturn
      (
        caller,
        delegateTypeToCall->Return,
        0,
        returnAccessOut->HandleConstantLocal,
        debugOrigin,
        location
      );
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateStringInterpolants(StringInterpolantNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // We need to create a temporary string builder that we use to efficiently concatenate strings together
    function->AllocateOpcode<BeginStringBuilderOpcode>(Instruction::BeginStringBuilder, DebugOrigin::StringInterpolant, node->Location);

    // Walk through all the children we want to stringify
    for (size_t i = 0; i < node->Elements.size(); ++i)
    {
      // Get the current element (it may be a string itself...)
      ExpressionNode* elementNode = node->Elements[i];

      // Make sure we generate code for the element expression
      context->Walker->Walk(this, elementNode, context);

      // Set the register indices for the operands, and set the location that the result should be stored into
      AddToStringBuilderOpcode& opcode = function->AllocateOpcode<AddToStringBuilderOpcode>(Instruction::AddToStringBuilder, DebugOrigin::StringInterpolant, node->Location);
      opcode.Value = elementNode->Access;
      opcode.TypeToConvert = elementNode->ResultType;
    }

    // Make space for the string local (the string should be the result type)
    CreateLocal(function, node->ResultType->GetCopyableSize(), node->Access);

    // Finish off the string builder (with all our additions to it) and store the resulting string on the stack
    EndStringBuilderOpcode& endOpcode = function->AllocateOpcode<EndStringBuilderOpcode>(Instruction::EndStringBuilder, DebugOrigin::StringInterpolant, node->Location);
    endOpcode.SaveStringHandleLocal = node->Access.HandleConstantLocal;
  }

  //***************************************************************************
  void CodeGenerator::CollectValue(ValueNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // A value is always a constant
    node->Access.Type = OperandType::Constant;

    // We have no secondary index
    node->Access.FieldOffset = 0;

    // Based off the type of token...
    switch (node->Value.TokenId)
    {
      // The value is an integer
      case Grammar::IntegerLiteral:
      {
        // Read the value as an Integer (and allocate a constant for it)
        function->AllocateConstant<Integer>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = atoi(node->Value.Token.c_str());
        break;
      }

      // The value is an double integer
      case Grammar::DoubleIntegerLiteral:
      {
        // Read the value as an Integer (and allocate a constant for it)
        function->AllocateConstant<DoubleInteger>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = ZilchStrToDoubleInteger(node->Value.Token.c_str(), 10);
        break;
      }
      
      // The value is a real
      case Grammar::RealLiteral:
      {
        // Read the value as a Real (and allocate a constant for it)
        function->AllocateConstant<Real>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = (Real)atof(node->Value.Token.c_str());
        break;
      }
      
      // The value is a double real
      case Grammar::DoubleRealLiteral:
      {
        // Read the value as a DoubleReal (and allocate a constant for it)
        function->AllocateConstant<DoubleReal>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = (DoubleReal)atof(node->Value.Token.c_str());
        break;
      }
      
      // The value is a string
      case Grammar::StringLiteral:
      {
        // Get a reference to the core library
        Core& core = Core::GetInstance();

        // Create a new handle that will point at a string node
        Handle& handle = function->AllocateConstant<Handle>(core.StringType->GetCopyableSize(), node->Access.HandleConstantLocal);

        // Set the handle manager and type of the handle
        // We know explicitly that the string handle manager is a shared manager
        HandleManagers& managers = HandleManagers::GetInstance();
        handle.Manager = managers.GetSharedManager(ZilchManagerId(StringManager));
        handle.Type = core.StringType;

        // The token is always stored in it's original vanilla form
        // We need to get rid of any quotes and perform escape replacements
        String& token = node->Value.Token;
        String unescapedString = ReplaceStringEscapesAndStripQuotes(token);
        
        // Create the string literal in the library builder
        const String& stringLiteral = this->Builder->AddStringLiteral(unescapedString);

        // Copy a string into the handle
        // This method will actually increase the reference count
        // which means we would need to store an array of destructors for constant memory (which we do)
        handle.Manager->ObjectToHandle((byte*)&stringLiteral, handle);
        break;
      }
      
      // The value is a bool
      case Grammar::True:
      {
        // Read the value as a "real" (and allocate a constant for it)
        function->AllocateConstant<Boolean>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = true;
        break;
      }
      
      // The value is a bool
      case Grammar::False:
      {
        // Read the value as a "real" (and allocate a constant for it)
        function->AllocateConstant<Boolean>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = false;
        break;
      }
      
      // The value is a null
      case Grammar::Null:
      {
        ZilchTodo("We probably want to eventually share null constants, also examine the behavior of using sizeof(Delegate)!");

        // At the moment, since we use null for handles, delegates, etc, we just allocate wiped space (with 0s) that
        // is big enough to support all nullable things (all primtives support being set to all 0)
        size_t largeIndex;
        byte* data = function->Constants.Allocate(sizeof(Delegate), nullptr, nullptr, &largeIndex);
        memset(data, 0, sizeof(Delegate));
        node->Access.HandleConstantLocal = (OperandIndex)largeIndex;
        break;
      }

      default:
      {
        // We don't know what type it is???
        // This especially should not be an identifier, since identifiers are caught as VariableReferences
        Error("The node was marked as being a value node, but had a token that was not recognizable as a value type");
      }
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateDelete(DeleteNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Make sure we generate code for the deleted object expression (its most likely a variable reference)
    context->Walker->Walk(this, node->DeletedObject, context);

    // Set the register indices for the operands, and set the location that the result should be stored into
    DeleteObjectOpcode& opcode = function->AllocateOpcode<DeleteObjectOpcode>(Instruction::DeleteObject, DebugOrigin::DeleteObject, node->Location);
    opcode.Object = node->DeletedObject->Access;
  }
  
  //***************************************************************************
  void CodeGenerator::GenerateThrow(ThrowNode*& node, GeneratorContext* context)
  {
    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // Make sure we generate code for the exception expression
    context->Walker->Walk(this, node->Exception, context);

    // Set the register indices for the operands, and set the location that the result should be stored into
    ThrowExceptionOpcode& opcode = function->AllocateOpcode<ThrowExceptionOpcode>(Instruction::ThrowException, DebugOrigin::ThrowException, node->Location);
    opcode.Exception = node->Exception->Access;
  }

  //***************************************************************************
  void CodeGenerator::GenerateExpressionInitializer(ExpressionInitializerNode*& node, GeneratorContext* context)
  {
    // Walk the left operand first (allocate and pre-construct an object, then invoke a constructor on it)
    context->Walker->Walk(this, node->LeftOperand, context);

    // Now walk the rest of the statements to invoke 'Add's and initialize members
    context->Walker->Walk(this, node->InitializerStatements, context);

    // Our output is just the output of the construction call
    node->Access = node->LeftOperand->Access;
  }
  
  //***************************************************************************
  void CodeGenerator::GenerateMultiExpression(MultiExpressionNode*& node, GeneratorContext* context)
  {
    // Generate code for all the expressions
    context->Walker->Walk(this, node->Expressions, context);

    // Forward the access from the yielded expression to ourself
    ExpressionNode* yieldedExpression = node->Expressions[node->YieldChildExpressionIndex];
    node->Access = yieldedExpression->Access;
  }

  //***************************************************************************
  void CodeGenerator::GenerateStaticTypeOrCreationCall(StaticTypeNode*& node, GeneratorContext* context)
  {
    // If this is being used as a creation...
    if (node->Mode == CreationMode::Invalid)
      return;

    // Note: The NewObject/LocalObject opcodes only invoke the pre-constructor (via InvokePreConstructorOrRelease)
    // This pre-constructs all classes up to the base class
    // The function call that has the CreationCallNode as its Operand is what is responsible for invoking the real constructor
    // Constructors walk up and invoke their base constructors, via the InitializerNode

    // Get a reference to the current function that we're building
    Function* function = context->FunctionStack.back();

    // This expression's result will be stored in the last created register
    this->CreateLocal(function, node->ResultType->GetCopyableSize(), node->Access);

    // If we're creating a heap object with 'new'
    if (node->Mode == CreationMode::New)
    {
      // Set the register indices for the operands, and set the location that the result should be stored into
      CreateTypeOpcode& opcode = function->AllocateOpcode<CreateTypeOpcode>(Instruction::NewObject, DebugOrigin::NewObject, node->Location);
      opcode.SaveHandleLocal = node->Access.HandleConstantLocal;
      opcode.CreatedType = node->ReferencedType;

      // We want an object handle for other calls (such as the constructor)
      node->ThisHandleLocal = node->Access.HandleConstantLocal;
    }
    // Otherwise we're creating a local or member object with 'local'
    else
    {
      // Set the register indices for the operands, and set the location that the result should be stored into
      CreateLocalTypeOpcode& opcode = function->AllocateOpcode<CreateLocalTypeOpcode>(Instruction::LocalObject, DebugOrigin::LocalObject, node->Location);
      opcode.CreatedType = node->ReferencedType;

      // Error checking
      ErrorIf(node->ReferencedType != node->ResultType,
        "The created type should always be the expression type");

      // Allocate space for a handle created to the local object
      // The local creation opcode will generate a handle for us at the specified location
      // This handle gets used in calling the preconstructor (inside the 'LocalObject' instruction)
      // and in calling the actual constructor (inside of 'FunctionCall')
      OperandIndex handleIndex = function->AllocateRegister(this->Builder->ReferenceOf(node->ReferencedType)->GetCopyableSize());
      opcode.SaveHandleLocal = handleIndex;
    
      // The object should be allocated here on the stack
      opcode.StackLocal = node->Access.HandleConstantLocal;

      // We want an object handle for other calls (such as the constructor)
      node->ThisHandleLocal = handleIndex;
    }
  }

  //***************************************************************************
  void CodeGenerator::GenerateHandleInitialize(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
  {
    // If the type is a handle...
    if (Type::IsHandleType(type))
    {
      // Since the type of the expression is already a handle, just copy it to the location that the user wants it at
      // This handle is always initializing uninitialized memory on the stack
      GenerateCopyInitialize(function, type, source, destination, debugOrigin, location);
    }
    // If the type is a named-type / value...
    else if (BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type))
    {
      // Allocate an opcode for creating a handle from a local
      ToHandleOpcode& opcode = function->AllocateOpcode<ToHandleOpcode>(Instruction::ToHandle, debugOrigin, location);

      // Get the handle type
      Type* handleType = this->Builder->ReferenceOf(boundType);
      
      // If we're attempting to generate a handle to a constant, then we want to copy it locally to the stack first
      if (source.Type == OperandType::Constant)
      {
        // Generate a stack local to store the constant
        Operand stackLocal(function->AllocateRegister(type->GetCopyableSize()));

        // Copy the constant to the stack
        this->GenerateCopyInitialize(function, type, source, stackLocal, debugOrigin, location);

        // Create a handle to the stack local
        opcode.ToHandle = stackLocal;
      }
      else
      {
        // Set the value that we want to make a handle of
        opcode.ToHandle = source;
      }

      // Save the handle in a newly allocated register
      opcode.SaveLocal = function->AllocateRegister(handleType->GetCopyableSize());

      // We also need to know the type of this handle
      opcode.Type = boundType;

      // Since the type of the expression is already a handle, just copy it to the location that the user wants it at
      // This handle is always initializing uninitialized memory on the stack
      GenerateCopyInitialize(function, handleType, Operand(opcode.SaveLocal), destination, debugOrigin, location);
    }
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes




namespace Zilch
{
  //***************************************************************************
  CodeLocation::CodeLocation() :
    StartLine(1),
    PrimaryLine(1),
    EndLine(1),
    StartCharacter(1),
    PrimaryCharacter(1),
    EndCharacter(1),
    StartPosition(0),
    PrimaryPosition(0),
    EndPosition(0),
    Origin(UnknownOrigin),
    CodeUserData(nullptr),
    IsNative(true)
  {
  }

  //***************************************************************************
  CodeLocation CodeLocation::GetStartOnlyLocation()
  {
    // First copy the current code location, then just change the end and primary to point at the start
    CodeLocation result;
    result = *this;
    result.EndCharacter     = result.StartCharacter;
    result.EndLine          = result.StartLine;
    result.PrimaryCharacter = result.StartCharacter;
    result.PrimaryLine      = result.StartLine;
    return result;
  }
  
  //***************************************************************************
  CodeLocation CodeLocation::GetEndOnlyLocation()
  {
    // First copy the current code location, then just change the start and primary to point at the end
    CodeLocation result;
    result = *this;
    result.StartCharacter   = result.EndCharacter;
    result.StartLine        = result.EndLine;
    result.PrimaryCharacter = result.EndCharacter;
    result.PrimaryLine      = result.EndLine;
    return result;
  }
  
  //***************************************************************************
  size_t CodeLocation::GetHash()
  {
    return this->Code.hash() ^ this->Origin.hash() * 5689;
  }

  //***************************************************************************
  bool CodeLocation::IsValid()
  {
    // As long as we have code, we consider this valid
    return this->Code.empty() == false;
  }

  //***************************************************************************
  String CodeLocation::GetFormattedString(MessageFormat::Enum format) const
  {
    // Based on the format (typically we support many different language formats)
    switch (format)
    {
      case MessageFormat::Zilch:
      {
        // If we have no function name...
        if (this->Function.empty())
        {
          return String::Format("  In %s at line %d, character %d",
            this->Origin.c_str(),
            this->PrimaryLine,
            this->PrimaryCharacter);
        }
        // Otherwise, a function name was provided
        else
        {
          return String::Format("  In %s at line %d, character %d (within function %s)",
            this->Origin.c_str(),
            this->PrimaryLine,
            this->PrimaryCharacter,
            this->Function.c_str());
        }
      }

      case MessageFormat::Python:
      {
        // If we have no function name...
        if (this->Function.empty())
        {
          return String::Format("  File \"%s\", line %d",
            this->Origin.c_str(),
            this->PrimaryLine);
        }
        // Otherwise, a function name was provided
        else
        {
          return String::Format("  File \"%s\", line %d, in %s",
            this->Origin.c_str(),
            this->PrimaryLine,
            this->Function.c_str());
        }
      }

      case MessageFormat::MsvcCpp:
      {
        // If we have no function name...
        if (this->Function.empty())
        {
          return String::Format("  %s(%d)",
            this->Origin.c_str(),
            this->PrimaryLine);
        }
        // Otherwise, a function name was provided
        else
        {
          return String::Format("  %s(%d) in %s",
            this->Origin.c_str(),
            this->PrimaryLine,
            this->Function.c_str());
        }
      }
    }

    // We should never end up here!
    Error("Unhandled format type or the user passed in a garbage value");
    return String();
  }

  //***************************************************************************
  //bool CodeLocation::IsValid()
  //{
  //  return this->CodeEntryId != 0;
  //}

  //***************************************************************************
  String CodeLocation::GetFormattedStringWithMessage(MessageFormat::Enum format, StringParam message) const
  {
    // First, just get the formatted code location
    String formattedLocation = this->GetFormattedString(format);

    // This will be used as the format string
    cstr strFormat = nullptr;
    size_t tabbing = 0;
    bool tabFirstLine = true;

    // Based on the format (typically we support many different language formats)
    switch (format)
    {
      case MessageFormat::Zilch:
      {
        strFormat = "%s:\n%s\n";
        tabbing = 4;
        break;
      }

      case MessageFormat::Python:
      {
        strFormat = "%s\n%s\n";
        tabbing = 4;
        break;
      }

      case MessageFormat::MsvcCpp:
      {
        strFormat = "%s: %s\n";
        tabbing = 2;
        tabFirstLine = false;
        break;
      }
    }

    // Tab in every line in the message, if requested
    StringBuilder builder;
    for (Zero::StringSplitRange range = message.Split("\n"); range.empty() == false;)
    {
      // Grab the current line and immediately pop (this lets us know if we're at the end so we don't append an extra "\n")
      StringRange line = range.front();
      range.popFront();

      // If this isn't the first line, or we specify that we want to tab the first line...
      if (builder.GetSize() > 0 || tabFirstLine)
        builder.Repeat(tabbing, " ");

      builder.Append(line);
      if (range.empty() == false)
        builder.Append("\n");
    }
    String tabbedMessage = builder.ToString();

    // Make sure we got a string format from above
    ErrorIf(strFormat == nullptr, "Unhandled format type or the user passed in a garbage value");

    // Return the formatted location with the message attached
    return String::Format(strFormat,
            formattedLocation.c_str(),
            tabbedMessage.c_str());
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes




#ifdef __clang__
  // At the moment, these are missing from the clang libc (no idea what they are!)
  void* __gxx_personality_v0 = NULL;
  void* _Unwind_Resume = NULL;
#endif

namespace Zilch
{
  //***************************************************************************
  String GetDocumentationStringOrEmpty(StringParam string)
  {
    ZilchErrorIfNotStarted(Documentation);

    if (ZilchSetup::Instance->Flags & StartupFlags::NoDocumentationStrings)
      return String();

    return string;
  }
  
  //***************************************************************************
  String GetDocumentationCStringOrEmpty(cstr string)
  {
    ZilchErrorIfNotStarted(Documentation);

    if (ZilchSetup::Instance->Flags & StartupFlags::NoDocumentationStrings)
      return String();

    return string;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes



namespace Zilch
{
  //***************************************************************************
  namespace Events
  {
    ZilchDefineEvent(CompilationError);
  }

  //***************************************************************************
  void DefaultErrorCallback(ErrorEvent* e)
  {
    // Print out the standard formatted error message to the console
    printf("%s", e->GetFormattedMessage(MessageFormat::Zilch).c_str());
  }

  //***************************************************************************
  void OutputErrorStringCallback(ErrorEvent* e, void* stringPointer)
  {
    String& outputString = *(String*)stringPointer;
    outputString = e->GetFormattedMessage(MessageFormat::Zilch);
  }

  //***************************************************************************
  CompilationErrors::CompilationErrors() :
    WasError(false),
    IgnoreMultipleErrors(true),
    UserData(nullptr),
    TolerantMode(false)
  {
  }

  //***************************************************************************
  void CompilationErrors::RaiseArgs(const CodeLocation& location, ErrorCode::Enum errorCode, va_list args)
  {
    return RaiseArgs(location, String(), LocationArray(), errorCode, args);
  }

  //***************************************************************************
  void CompilationErrors::RaiseArgs(const CodeLocation& location, StringParam extra, const CodeLocation& associatedLocation, ErrorCode::Enum errorCode, va_list args)
  {
    LocationArray associatedLocations;
    associatedLocations.push_back(&associatedLocation);
    return RaiseArgs(location, String(), associatedLocations, errorCode, args);
  }

  //***************************************************************************
  void CompilationErrors::RaiseArgs(const CodeLocation& location, StringParam extra, const LocationArray& associatedLocations, ErrorCode::Enum errorCode, va_list args)
  {
    // If there already was an error and we're set to ignore multiple errors, exit out early
    if (this->WasError && this->IgnoreMultipleErrors)
      return;

    // If we're in tolerant mode, skip raising any errors
    if (this->TolerantMode)
      return;

    // An error occurred, set the flag
    this->WasError = true;

    // Get the error information from the database
    const ErrorInfo& errorInfo = ErrorDatabase::GetInstance().GetErrorInfo(errorCode);

    // Create an error details object that encompasses the error (including the context of the error)
    ErrorEvent errorDetails(errorInfo, location, errorCode, args);

    // Copy over any associated locations
    // For example, duplicate class definitions, where is the duplicate class?
    ZilchForEach(const CodeLocation* location, associatedLocations.all())
      errorDetails.AssociatedOtherLocations.push_back(*location);

    // Append any extra context to the error
    // Eg. when the parser expects something, it will say what it got and what it expected
    errorDetails.ExactError = BuildString(errorDetails.ExactError, extra);

    // Send the event and let everyone recieve it
    EventSend(this, Events::CompilationError, &errorDetails);

    // If the error was an internal error, then break here
    if (errorCode == ErrorCode::InternalError)
    {
      // We have to break and solve this issue
      Error("Internal error: %s", errorDetails.ExactError.c_str());
    }
  }
  
  //***************************************************************************
  void CompilationErrors::Raise(const CodeLocation& location, ErrorCode::Enum errorCode, ...)
  {
    // Create a variable argument list
    va_list argList;
    va_start(argList, errorCode);

    // Raise the error with the argument list
    RaiseArgs(location, String(), LocationArray(), errorCode, argList);

    // Finish reading variable argments
    va_end(argList);
  }

  //***************************************************************************
  void CompilationErrors::Raise(const CodeLocation& location, StringParam extra, const CodeLocation& associatedLocation, ErrorCode::Enum errorCode, ...)
  {
    // Create a variable argument list
    va_list argList;
    va_start(argList, errorCode);

    // Raise the error with the argument list
    LocationArray associatedLocations;
    associatedLocations.push_back(&associatedLocation);
    RaiseArgs(location, String(), associatedLocations, errorCode, argList);

    // Finish reading variable argments
    va_end(argList);
  }

  //***************************************************************************
  void CompilationErrors::Raise(const CodeLocation& location, StringParam extra, const LocationArray& associatedLocations, ErrorCode::Enum errorCode, ...)
  {
    // Create a variable argument list
    va_list argList;
    va_start(argList, errorCode);

    // Raise the error with the argument list
    RaiseArgs(location, errorCode, argList);

    // Finish reading variable argments
    va_end(argList);
  }
}/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes






namespace Zilch
{
  //***************************************************************************
  namespace Events
  {
    ZilchDefineEvent(ConsoleWrite);
    ZilchDefineEvent(ConsoleRead);
  }

  //***************************************************************************
  // Initialize static variables
  EventHandler Console::Events;
  static String ConsoleSeparator(", ");
  static String NewLine("\n");

  //***************************************************************************
  void DefaultWriteText(ConsoleEvent* event)
  {
    // Print the text to the console
    printf("%s", event->Text.c_str());
  }

  //***************************************************************************
  void DefaultReadText(ConsoleEvent* event)
  {
    // Attempt to read a string from the console
    const size_t BufferSize = 1024;
    char buffer[BufferSize + 1] = {0};

    // Read data into the buffer
    fgets(buffer, BufferSize, stdin);

    // Loop through all characters in the buffer
    for (size_t i = 0; i < BufferSize; ++i)
    {
      // If we hit a newline...
      if (buffer[i] == '\r' || buffer[i] == '\n')
      {
        // Terminate the string at the newline
        buffer[i] = '\0';
      }
    }
    
    // Return the read in data
    event->Text = String(buffer);
  }

  //***************************************************************************
  ZilchDefineType(Console, "Console", Core, builder, type)
  {
    ZilchBindMethod(builder, type, &Console::Write, (void (*)(AnyParam)),                                         "Write", nullptr);
    ZilchBindMethod(builder, type, &Console::Write, (void (*)(AnyParam, AnyParam)),                               "Write", nullptr);
    ZilchBindMethod(builder, type, &Console::Write, (void (*)(AnyParam, AnyParam, AnyParam)),                     "Write", nullptr);
    ZilchBindMethod(builder, type, &Console::Write, (void (*)(AnyParam, AnyParam, AnyParam, AnyParam)),           "Write", nullptr);
    ZilchBindMethod(builder, type, &Console::Write, (void (*)(AnyParam, AnyParam, AnyParam, AnyParam, AnyParam)), "Write", nullptr);
    
    ZilchBindMethod(builder, type, &Console::WriteLine, (void (*)()),                                                 "WriteLine", nullptr);
    ZilchBindMethod(builder, type, &Console::WriteLine, (void (*)(AnyParam)),                                         "WriteLine", nullptr);
    ZilchBindMethod(builder, type, &Console::WriteLine, (void (*)(AnyParam, AnyParam)),                               "WriteLine", nullptr);
    ZilchBindMethod(builder, type, &Console::WriteLine, (void (*)(AnyParam, AnyParam, AnyParam)),                     "WriteLine", nullptr);
    ZilchBindMethod(builder, type, &Console::WriteLine, (void (*)(AnyParam, AnyParam, AnyParam, AnyParam)),           "WriteLine", nullptr);
    ZilchBindMethod(builder, type, &Console::WriteLine, (void (*)(AnyParam, AnyParam, AnyParam, AnyParam, AnyParam)), "WriteLine", nullptr);

    ZilchBindMethod(builder, type, &Console::DumpValue, (void (*)(AnyParam)),          "DumpValue", nullptr);
    ZilchBindMethod(builder, type, &Console::DumpValue, (void (*)(AnyParam, Integer)), "DumpValue", nullptr);

    ZilchBindMethod(builder, type, &Console::ReadString,  ZilchNoOverload, "ReadString",   nullptr);
    ZilchBindMethod(builder, type, &Console::ReadInteger, ZilchNoOverload, "ReadInteger",  nullptr);
    ZilchBindMethod(builder, type, &Console::ReadBoolean, ZilchNoOverload, "ReadBoolean",  nullptr);
    ZilchBindMethod(builder, type, &Console::ReadReal,    ZilchNoOverload, "ReadReal",     nullptr);
  }
  
  //***************************************************************************
  void Console::WriteData(StringParam text)
  {
    // Send out the event with the given text data
    ConsoleEvent toSend;
    toSend.State = ExecutableState::CallingState;
    toSend.Text = text;
    EventSend(&Events, Events::ConsoleWrite, &toSend);
  }
  
  //***************************************************************************
  String Console::ReadData()
  {
    // Send out the event (the user must fill out the text field)
    ConsoleEvent toSend;
    toSend.State = ExecutableState::CallingState;
    EventSend(&Events, Events::ConsoleRead, &toSend);
    return toSend.Text;
  }

  //***************************************************************************
  void Console::Write(AnyParam value0)
  {
    WriteData(value0.ToString());
  }

  //***************************************************************************
  void Console::Write(AnyParam value0, AnyParam value1)
  {
    WriteData(BuildString(value0.ToString(), ConsoleSeparator, value1.ToString()));
  }

  //***************************************************************************
  void Console::Write(AnyParam value0, AnyParam value1, AnyParam value2)
  {
    WriteData(BuildString(value0.ToString(), ConsoleSeparator, value1.ToString(), ConsoleSeparator, value2.ToString()));
  }

  //***************************************************************************
  void Console::Write(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3)
  {
    StringBuilder builder;
    builder.Append(value0.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value1.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value2.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value3.ToString());
    WriteData(builder.ToString());
  }

  //***************************************************************************
  void Console::Write(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3, AnyParam value4)
  {
    StringBuilder builder;
    builder.Append(value0.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value1.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value2.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value3.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value4.ToString());
    WriteData(builder.ToString());
  }

  //***************************************************************************
  void Console::Write(StringParam value)
  {
    WriteData(value);
  }
  
  //***************************************************************************
  void Console::Write(StringRange value)
  {
    WriteData(value);
  }

  //***************************************************************************
  void Console::Write(cstr value)
  {
    WriteData(String(value));
  }

  //***************************************************************************
  void Console::Write(char value)
  {
    WriteData(String(value));
  }

  //***************************************************************************
  void Console::Write(Integer value)
  {
    WriteData(IntegerToString(value));
  }

  //***************************************************************************
  void Console::Write(Integer2Param value)
  {
    WriteData(Integer2ToString(value));
  }

  //***************************************************************************
  void Console::Write(Integer3Param value)
  {
    WriteData(Integer3ToString(value));
  }

  //***************************************************************************
  void Console::Write(Integer4Param value)
  {
    WriteData(Integer4ToString(value));
  }

  //***************************************************************************
  void Console::Write(DoubleInteger value)
  {
    WriteData(DoubleIntegerToString(value));
  }

  //***************************************************************************
  void Console::Write(Boolean value)
  {
    WriteData(BooleanToString(value));
  }

  //***************************************************************************
  void Console::Write(Boolean2Param value)
  {
    WriteData(Boolean2ToString(value));
  }

  //***************************************************************************
  void Console::Write(Boolean3Param value)
  {
    WriteData(Boolean3ToString(value));
  }

  //***************************************************************************
  void Console::Write(Boolean4Param value)
  {
    WriteData(Boolean4ToString(value));
  }

  //***************************************************************************
  void Console::Write(Real value)
  {
    WriteData(RealToString(value));
  }

  //***************************************************************************
  void Console::Write(DoubleReal value)
  {
    WriteData(DoubleRealToString(value));
  }

  //***************************************************************************
  void Console::Write(Real2Param value)
  {
    WriteData(Real2ToString(value));
  }

  //***************************************************************************
  void Console::Write(Real3Param value)
  {
    WriteData(Real3ToString(value));
  }

  //***************************************************************************
  void Console::Write(Real4Param value)
  {
    WriteData(Real4ToString(value));
  }

  //***************************************************************************
  void Console::Write(QuaternionParam value)
  {
    WriteData(QuaternionToString(value));
  }

  //***************************************************************************
  void Console::WriteLine()
  {
    WriteData(NewLine);
  }

  //***************************************************************************
  void Console::WriteLine(AnyParam value0)
  {
    WriteData(BuildString(value0.ToString(), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(AnyParam value0, AnyParam value1)
  {
    WriteData(BuildString(value0.ToString(), ConsoleSeparator, value1.ToString(), NewLine));
  }
  
  //***************************************************************************
  void Console::WriteLine(AnyParam value0, AnyParam value1, AnyParam value2)
  {
    StringBuilder builder;
    builder.Append(value0.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value1.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value2.ToString());
    builder.Append(NewLine);
    WriteData(builder.ToString());
  }
  
  //***************************************************************************
  void Console::WriteLine(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3)
  {
    StringBuilder builder;
    builder.Append(value0.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value1.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value2.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value3.ToString());
    builder.Append(NewLine);
    WriteData(builder.ToString());
  }
  
  //***************************************************************************
  void Console::WriteLine(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3, AnyParam value4)
  {
    StringBuilder builder;
    builder.Append(value0.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value1.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value2.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value3.ToString());
    builder.Append(ConsoleSeparator);
    builder.Append(value4.ToString());
    builder.Append(NewLine);
    WriteData(builder.ToString());
  }
  
  //***************************************************************************
  void Console::WriteLine(StringParam value)
  {
    WriteData(BuildString(value, NewLine));
  }
  
  //***************************************************************************
  void Console::WriteLine(StringRange value)
  {
    WriteData(BuildString(value, NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(cstr value)
  {
    WriteData(BuildString(String(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(char value)
  {
    WriteData(BuildString(String(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Integer value)
  {
    WriteData(BuildString(IntegerToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Integer2Param value)
  {
    WriteData(BuildString(Integer2ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Integer3Param value)
  {
    WriteData(BuildString(Integer3ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Integer4Param value)
  {
    WriteData(BuildString(Integer4ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(DoubleInteger value)
  {
    WriteData(BuildString(DoubleIntegerToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Boolean value)
  {
    WriteData(BuildString(BooleanToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Boolean2Param value)
  {
    WriteData(BuildString(Boolean2ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Boolean3Param value)
  {
    WriteData(BuildString(Boolean3ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Boolean4Param value)
  {
    WriteData(BuildString(Boolean4ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Real value)
  {
    WriteData(BuildString(RealToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(DoubleReal value)
  {
    WriteData(BuildString(DoubleRealToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Real2Param value)
  {
    WriteData(BuildString(Real2ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Real3Param value)
  {
    WriteData(BuildString(Real3ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(Real4Param value)
  {
    WriteData(BuildString(Real4ToString(value), NewLine));
  }

  //***************************************************************************
  void Console::WriteLine(QuaternionParam value)
  {
    WriteData(BuildString(QuaternionToString(value), NewLine));
  }

  //***************************************************************************
  void Console::DumpValue(StringBuilderExtended& builder, Type* type, const byte* value, Integer howDeep, Integer currentDepth)
  {
    // First write the generic value of the type...
    String baseValueString = type->GenericToString(value);
    builder.WriteLine(baseValueString);

    // If this is the level of depth we wanted to traverse, exit out
    if (currentDepth == howDeep)
      return;

    // If this is a bound type, lets print out its property/member values
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);
    if (boundType != nullptr)
    {
      byte* instanceData = boundType->GenericGetMemory(value);
      if (instanceData)
      {
        // Loop through all the instance properties
        PropertyArray& properties = boundType->AllProperties;
        for (size_t i = 0; i < properties.size(); ++i)
        {
          // Grab the current property
          Property* property = properties[i];

          // If it's a static or hidden property, skip it
          if (property->IsStatic || property->IsHidden)
            continue;

          // TEMPORARY - Because we do not have the ExecutableState in bound C++ functions, we can only
          // print out fields (because we know their type and know where they exist in memory
          if (Field* field = TypeBinding::DynamicCast<Field*>(property))
          {
            // Write tabs up to the current depth
            for (Integer i = 0; i <= currentDepth; ++i)
              builder.Write("  ");

            // Write out the property name
            builder.Write(field->Name);
            builder.Write(": ");

            byte* fieldData = instanceData + field->Offset;
          
            // Recursively dumping will imediately print out the property value
            DumpValue(builder, field->PropertyType, fieldData, howDeep, currentDepth + 1);
          }
        }
      }
    }
  }

  //***************************************************************************
  void Console::DumpValue(AnyParam value)
  {
    DumpValue(value, 1);
  }

  //***************************************************************************
  void Console::DumpValue(AnyParam value, Integer howDeep)
  {
    // Create the string builder we'll use to fully build the object
    StringBuilderExtended builder;

    // Call the helper (recursive)
    DumpValue(builder, value.StoredType, value.Data, howDeep, 0);

    // Write out the debug text for the object
    String finalText = builder.ToString();
    Write(finalText);
  }
  
  //***************************************************************************
  String Console::ReadString()
  {
    // Just read the string directly (no interpreting, may be empty)
    return ReadData();
  }
  
  //***************************************************************************
  Integer Console::ReadInteger()
  {
    // Just read the string directly (may be empty)
    String readText = ReadData();

    // Convert the text to the value type
    Integer returnValue = 0;
    ToValue(readText, returnValue);

    // Return the resulting read value, or a default if we had no callback
    return returnValue;
  }

  //***************************************************************************
  Boolean Console::ReadBoolean()
  {
    // Just read the string directly (may be empty)
    String readText = ReadData();

    // Convert the text to the value type
    Boolean returnValue = false;
    ToValue(readText, returnValue);

    // Return the resulting read value, or a default if we had no callback
    return returnValue;
  }
  
  //***************************************************************************
  Real Console::ReadReal()
  {
    // Just read the string directly (may be empty)
    String readText = ReadData();

    // Convert the text to the value type
    Real returnValue = 0.0f;
    ToValue(readText, returnValue);

    // Return the resulting read value, or a default if we had no callback
    return returnValue;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes















namespace Zilch
{
  //***************************************************************************
  Core& Core::GetInstance()
  {
    static Core instance;
    return instance;
  }

  //***************************************************************************
  Core::Core() :
    StaticLibrary("Core"),
    IntegerType(nullptr),
    DoubleIntegerType(nullptr),
    RealType(nullptr),
    DoubleRealType(nullptr),
    BooleanType(nullptr),
    Real2Type(nullptr),
    Real3Type(nullptr),
    Real4Type(nullptr),
    Integer2Type(nullptr),
    Integer3Type(nullptr),
    Integer4Type(nullptr),
    Boolean2Type(nullptr),
    Boolean3Type(nullptr),
    Boolean4Type(nullptr),
    QuaternionType(nullptr),
    StringType(nullptr),
    ExceptionType(nullptr),
    MathType(nullptr),
    VoidType(nullptr),
    NullType(nullptr),
    ErrorType(nullptr),
    AnyDelegateType(nullptr),
    AnyHandleType(nullptr),
    AnythingType(nullptr)
  {
    // Clear out all the vector types
    memset(this->RealTypes,     0, sizeof(this->RealTypes));
    memset(this->IntegerTypes,  0, sizeof(this->IntegerTypes));
    memset(this->BooleanTypes,  0, sizeof(this->BooleanTypes));
  }
  
  //***************************************************************************
  Core::~Core()
  {
  }

  ////***************************************************************************
  //template <typename T>
  //void Sign(ExecutableState* state)
  //{
  //  // Get a pointer to the stack data
  //  byte* stack = state->GetCurrentStackFrame();

  //  // The return value is the first value (then comes the input)
  //  Integer& returnValue = ReadValue<Integer>(stack);
  //  T& input = ReadValue<T>(stack);

  //  // If the input is greater than zero
  //  if (input > T(+0))
  //  {
  //    returnValue = +1;
  //  }
  //  // If the input is less than zero
  //  else if (input < T(-0))
  //  {
  //    returnValue = -1;
  //  }
  //  // Otherwise, the input is zero
  //  else
  //  {
  //    returnValue = 0;
  //  }
  //}
  //
  ////***************************************************************************
  //template <typename T>
  //void Max(ExecutableState* state)
  //{
  //  // Get a pointer to the stack data
  //  byte* stack = state->GetCurrentStackFrame();

  //  // The return value is the first value (then comes the input)
  //  T& returnValue = ReadValue<T>(stack);
  //  T& input1 = ReadValue<T>(stack);
  //  T& input2 = ReadValue<T>(stack);

  //  // If the first input is greater than the second
  //  if (input1 > input2)
  //  {
  //    returnValue = input1;
  //  }
  //  // Otherwise, the second was greater than the first
  //  // or they were equal, and it won't matter
  //  else
  //  {
  //    returnValue = input2;
  //  }
  //}
  //
  ////***************************************************************************
  //template <typename T>
  //void Min(ExecutableState* state)
  //{
  //  // Get a pointer to the stack data
  //  byte* stack = state->GetCurrentStackFrame();

  //  // The return value is the first value (then comes the input)
  //  T& returnValue = ReadValue<T>(stack);
  //  T& input1 = ReadValue<T>(stack);
  //  T& input2 = ReadValue<T>(stack);

  //  // If the first input is less than the second
  //  if (input1 < input2)
  //  {
  //    returnValue = input1;
  //  }
  //  // Otherwise, the second was less than the first
  //  // or they were equal, and it won't matter
  //  else
  //  {
  //    returnValue = input2;
  //  }
  //}

  //***************************************************************************
  void IntegerAbs(Call& call, ExceptionReport& report)
  {
    // Get the input value
    Integer input = call.Get<Integer>(0);

    // Apply the absolute value function
    if (input < 0)
    {
      input = -input;
    }

    call.Set(Call::Return, input);
  }

  ////***************************************************************************
  //template <typename T>
  //void Lerp(Call& call, ExceptionReport& report)
  //{
  //  // The return value is the first value (then comes the input)
  //  T& returnValue = ReadValue<T>(stack);
  //  
  //  T& input0 = call.Get<T>(0);
  //  T& input1 = call.Get<T>(1);

  //  Real interpolant = call.Get<Real>(2);

  //  // Apply the lerp function
  //  T result = input1 * interpolant + input2 * (1.0f - interpolant);
  //  call.Set(Call::Return, result);
  //}

  //***************************************************************************
  template <typename T>
  T Lerp(T start, T end, Real t)
  {
     return (Real(1.0) - t) * start + t * end;
  }

  ////***************************************************************************
  //template <typename T>
  //void Clamp(ExecutableState* state)
  //{
  //  // Get a pointer to the stack data
  //  byte* stack = state->GetCurrentStackFrame();

  //  // The return value is the first value (then comes the input)
  //  T& returnValue = ReadValue<T>(stack);
  //  T& input = ReadValue<T>(stack);

  //  // If the input is less than our lower bound (0)
  //  if (input < T(0))
  //  {
  //    returnValue = T(0);
  //  }
  //  // If the input is greater than our upper bound (1)
  //  else if (input > T(1))
  //  {
  //    returnValue = T(1);
  //  }
  //  // Otherwise, the input is within range
  //  else
  //  {
  //    returnValue = input;
  //  }
  //}
  //
  ////***************************************************************************
  //template <typename T>
  //void ClampBounds(ExecutableState* state)
  //{
  //  // Get a pointer to the stack data
  //  byte* stack = state->GetCurrentStackFrame();
  //  
  //  // The return value is the first value (then comes the input)
  //  T& returnValue = ReadValue<T>(stack);
  //  T& input = ReadValue<T>(stack);
  //  T& lower = ReadValue<T>(stack);
  //  T& upper = ReadValue<T>(stack);

  //  // If the input is less than our lower bound
  //  if (input < lower)
  //  {
  //    returnValue = lower;
  //  }
  //  // If the input is greater than our upper bound
  //  else if (input > upper)
  //  {
  //    returnValue = upper;
  //  }
  //  // Otherwise, the input is within range
  //  else
  //  {
  //    returnValue = input;
  //  }
  //}

  //***************************************************************************
  void Pi(Call& call, ExceptionReport& report)
  {
    call.Set(Call::Return, 3.1415926535897932384626433832795f);
  }
  
  //***************************************************************************
  void E(Call& call, ExceptionReport& report)
  {
    call.Set(Call::Return, 2.7182818284590452353602874713526f);
  }

  //***************************************************************************
  template <size_t Components, typename ComponentType>
  void VectorDefaultConstructor(Call& call, ExceptionReport& report)
  {
    // Get the handle to ourselves
    Handle& selfHandle = call.GetHandle(Call::This);
    byte* self = selfHandle.Dereference();

    // Clear out the object's data (for all vector types)
    memset(self, 0, Components * sizeof(ComponentType));
  }

  //***************************************************************************
  template <size_t Components, typename ComponentType>
  void VectorScalarConstructor(Call& call, ExceptionReport& report)
  {
    // Get the handle to ourselves
    Handle& selfHandle = call.GetHandle(Call::This);
    ComponentType* self = (ComponentType*)selfHandle.Dereference();

    // The first thing on the stack will be the single value (scalar)
    ComponentType scalar = call.Get<ComponentType>(0);

    // Loop through all the components
    for (size_t i = 0; i < Components; ++i)
    {
      self[i] = scalar;
    }
  }

  //***************************************************************************
  template <size_t Components, typename ComponentType>
  void GenerateVectorScalarConstructor(LibraryBuilder& builder, BoundType* type, BoundType* scalarType)
  {
    // We only have one parameter
    ParameterArray parameters;
    DelegateParameter& scalarParam = parameters.push_back();
    scalarParam.ParameterType = scalarType;
    scalarParam.Name = "scalar";

    // Bind constructors to the vector types
    builder.AddBoundConstructor(type,  VectorScalarConstructor<Components, ComponentType>, parameters);
  }

  //***************************************************************************
  template <size_t Components, typename ComponentType>
  void VectorComponentConstructor(Call& call, ExceptionReport& report)
  {
    // Get the handle to ourselves
    Handle& selfHandle = call.GetHandle(Call::This);
    ComponentType* self = (ComponentType*)selfHandle.Dereference();

    // Get the stack memory where all the values live
    byte* stackValues = call.GetParametersUnchecked();

    // We want to get the alignment of the stack values
    size_t alignedComponentSize = AlignToBusWidth(sizeof(ComponentType));

    // This is very subltle but because of padding we can't assume the values on the stakc
    // directly align with the values inside our structure. For example, sizeof(bool) is typically 1,
    // however on the stack each bool is aligned by 4 bytes so therefore 3 bools in the stack is 3 * 4 = 12,
    // rather than a Boolean3 which is actually sizeof(bool) * 3 = 3 + padding = 4
    for (size_t i = 0; i < Components; ++i)
    {
      // Grab the current value fo the stack
      ComponentType value = *(ComponentType*)(stackValues + i * alignedComponentSize);

      // Treat ourself like a contiguous array and directly set our members
      self[i] = value;
    }
  }

  //***************************************************************************
  void ScalarTypeRealOne(byte* outData)
  {
    *(Real*)outData = 1.0f;
  }

  //***************************************************************************
  void ScalarTypeIntegerOne(byte* outData)
  {
    *(Integer*)outData = 1;
  }

  //***************************************************************************
  void ScalarTypeBooleanOne(byte* outData)
  {
    *(Boolean*)outData = true;
  }

  //***************************************************************************
  template <size_t Components>
  void VectorCount(Call& call, ExceptionReport& report)
  {
    // Return the number of components in the vector
    call.Set(Call::Return, (Integer)Components);
  }

  //***************************************************************************
  template <size_t Components, typename ComponentType>
  void VectorGet(Call& call, ExceptionReport& report)
  {
    // Get the handle to ourselves
    Handle& selfHandle = call.GetHandle(Call::This);
    ComponentType* self = (ComponentType*)selfHandle.Dereference();

    // Read the index off the stack
    Integer index = call.Get<Integer>(0);
    
    // Make sure the index is within range
    if (index < 0 || index >= Components)
    {
      call.GetState()->ThrowException(report, String::Format("The index used to access a component of a vector was out of range [0-%d]", Components - 1));
      return;
    }

    // Return the vector's value at that index
    ComponentType result = self[index];
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  template <size_t Components, typename ComponentType>
  void VectorSet(Call& call, ExceptionReport& report)
  {
    // Get the handle to ourselves
    Handle& selfHandle = call.GetHandle(Call::This);
    ComponentType* self = (ComponentType*)selfHandle.Dereference();

    // Read the index off the stack
    Integer index = call.Get<Integer>(0);

    // Read the value we want to set
    ComponentType value = call.Get<ComponentType>(1);
    
    // Make sure the index is within range
    if (index < 0 || index >= Components)
    {
      call.GetState()->ThrowException(report, String::Format("The index used to access a component of a vector was out of range [0-%d]", Components - 1));
      return;
    }

    // Set the value on the vector
    self[index] = value;
  }

  //***************************************************************************
  void Vector3CrossProduct(Call& call, ExceptionReport& report)
  {
    // Read in the two vectors
    Real3& vector0 = call.Get<Real3&>(0);
    Real3& vector1 = call.Get<Real3&>(1);

    // Perform the cross product
    Real3 result = Math::Cross(vector0, vector1);

    // Output the result
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void Vector2PerpDotProduct(Call& call, ExceptionReport& report)
  {
    // Get a pointer to the two 2 dimensional input vector
    Real2& vector1 = call.Get<Real2&>(0);
    Real2& vector2 = call.Get<Real2&>(1);

    // Compute the perpendicular dot product
    Real result = vector1.x * vector2.y - vector2.x * vector1.y;
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void Vector2Perpendicular(Call& call, ExceptionReport& report)
  {
    Real2& input = call.Get<Real2&>(0);

    // Compute the perpendicular
    Real2 result(+input.y, -input.x);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  template <size_t Components>
  Real VectorDotProduct(Real* vector0, Real* vector1)
  {
    // Initialize the result to zero
    Real returnValue = 0.0f;

    // Loop through all the components to apply the dot product
    for (size_t i = 0; i < Components; ++i)
    {
      // Perform the dot product operation
      returnValue += vector0[i] * vector1[i];
    }

    // Return the computed dot product
    return returnValue;
  }

  //***************************************************************************
  template <size_t Components>
  void VectorDotProduct(Call& call, ExceptionReport& report)
  {
    // Get pointers to the two vectors
    Real* vector0 = (Real*)call.GetParameterUnchecked(0);
    Real* vector1 = (Real*)call.GetParameterUnchecked(1);

    // Compute the dot product
    Real result = VectorDotProduct<Components>(vector0, vector1);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  //template <size_t Components>
  //void VectorDistance(ExecutableState* state)
  //{
  //}

  //// Gets a vector whose components are the
  //// minimum of the components from the two vectors
  //template <size_t Components>
  //static void MinReal(ExecutableState* state);
  //template <size_t Components>
  //static void MinComponent(ExecutableState* state);

  //// Gets a vector whose components are the
  //// maximum of the components from the two vectors
  //template <size_t Components>
  //static void MaxReal(ExecutableState* state);
  //template <size_t Components>
  //static void MaxComponent(ExecutableState* state);

  //***************************************************************************
  template <size_t Components>
  void VectorLengthSq(Call& call, ExceptionReport& report)
  {
    // Get a pointer to the vector
    Real* vector = (Real*)call.GetParameterUnchecked(0);

    // Dot the vector with itself (it's the equivalent of length squared)
    Real lengthSq = VectorDotProduct<Components>(vector, vector);
    call.Set(Call::Return, lengthSq);
  }

  //***************************************************************************
  template <size_t Components>
  void VectorLength(Call& call, ExceptionReport& report)
  {
    // Get a pointer to the vector
    Real* vector = (Real*)call.GetParameterUnchecked(0);

    // Dot the vector with itself (it's the equivalent of length squared)
    Real lengthSq = VectorDotProduct<Components>(vector, vector);
    Real length = sqrt(lengthSq);
    call.Set(Call::Return, length);
  }

  //***************************************************************************
  template <size_t Components>
  void VectorDistance(Call& call, ExceptionReport& report)
  {
    // Get a pointer to the vectors
    Real* vector1 = (Real*)call.GetParameterUnchecked(0);
    Real* vector2 = (Real*)call.GetParameterUnchecked(1);

    Real diff[Components];
    for (size_t i = 0; i < Components; ++i)
    {
      diff[i] = vector1[i] - vector2[i];
    }

    // Dot the vector with itself (it's the equivalent of length squared)
    Real distanceSq = VectorDotProduct<Components>(diff, diff);
    Real distance = sqrt(distanceSq);
    call.Set(Call::Return, distance);
  }

  //***************************************************************************
  template <size_t Components>
  void VectorDistanceSq(Call& call, ExceptionReport& report)
  {
    // Get a pointer to the vectors
    Real* vector1 = (Real*)call.GetParameterUnchecked(0);
    Real* vector2 = (Real*)call.GetParameterUnchecked(1);

    Real diff[Components];
    for(size_t i = 0; i < Components; ++i)
    {
      diff[i] = vector1[i] - vector2[i];
    }

    // Dot the vector with itself (it's the equivalent of length squared)
    Real distanceSq = VectorDotProduct<Components>(diff, diff);
    call.Set(Call::Return, distanceSq);
  }

  //***************************************************************************
  template <size_t Components>
  void VectorNormalize(Call& call, ExceptionReport& report)
  {
    // Get a pointer to the vector
    Real* vector = (Real*)call.GetParameterUnchecked(0);

    // Dot the vector with itself (it's the equivalent of length squared)
    Real lengthSq = VectorDotProduct<Components>(vector, vector);
    Real length = sqrt(lengthSq);

    Real* result = (Real*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // If the length is non zero (don't want undefined divisions)
    if (length > 1e-20f)
    {
      // Loop through all the components and divide out the length
      for (size_t i = 0; i < Components; ++i)
      {
        result[i] = vector[i]  / length;
      }
    }
    else
    {
      // Zero out all elements of the returned vector
      for (size_t i = 0; i < Components; ++i)
      {
        result[i] = 0.0f;
      }
    }
  }
  
  //***************************************************************************
  void QuaternionDefaultConstructor(Call& call, ExceptionReport& report)
  {
    // Get our own object
    //Quaternion& self = call.Get<Quaternion&>(Call::This);

    // Set the quaternion to the identity quaternion (0, 0, 0, 1)
    //self = Quaternion::cIdentity;

    Handle& selfHandle = call.GetHandle(Call::This);
    byte* self = selfHandle.Dereference();

    *(Quaternion*)self = Quaternion::cIdentity;
  }

  //***************************************************************************
  void QuaternionIdentity(Call& call, ExceptionReport& report)
  {
    call.Set(Call::Return, Quaternion::cIdentity);
  }

  //***************************************************************************
  void QuaternionAdd(Call& call, ExceptionReport& report)
  {
    Quaternion& input0 = call.Get<Quaternion&>(0);
    Quaternion& input1 = call.Get<Quaternion&>(1);

    Quaternion result = input0 + input1;
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void QuaternionSubtract(Call& call, ExceptionReport& report)
  {
    Quaternion& input0 = call.Get<Quaternion&>(0);
    Quaternion& input1 = call.Get<Quaternion&>(1);

    Quaternion result = input0 - input1;
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void QuaternionInvert(Call& call, ExceptionReport& report)
  {
    Quaternion& input = call.Get<Quaternion&>(0);
    Real lengthSq = input.LengthSq();

    // We can't invert a zero length quaternion
    if (lengthSq == 0.0f)
    {
      call.GetState()->ThrowException(report, "Attempting to invert a zero length quaternion which would result in a 0 division");
      return;
    }
    Real inverseLengthSq = 1.0f / lengthSq;

    Quaternion result;
    result.x = -input.x * inverseLengthSq;
    result.y = -input.y * inverseLengthSq;
    result.z = -input.z * inverseLengthSq;
    result.w = +input.w * inverseLengthSq;

    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void QuaternionSlerp(Call& call, ExceptionReport& report)
  {
    // Get pointers to the two vectors
    Quaternion& start = call.Get<Quaternion&>(0);
    Quaternion& end = call.Get<Quaternion&>(1);

    // Get the interpolant value
    Real interpolant = call.Get<Real>(2);

    Quaternion result = Math::Slerp(start, end, interpolant);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void QuaternionAxisAngleConstructor(Call& call, ExceptionReport& report)
  {
    Real3& axis = call.Get<Real3&>(0);
    Real radian = call.Get<Real>(1);

    Quaternion result = ToQuaternion(axis, radian);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void QuaternionTransformQuaternion(Call& call, ExceptionReport& report)
  {
    Quaternion& value = call.Get<Quaternion&>(0);
    Quaternion& by = call.Get<Quaternion&>(1);

    Quaternion result = by * value;
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void QuaternionTransformVector3(Call& call, ExceptionReport& report)
  {
    Real3& value = call.Get<Real3&>(0);
    Quaternion& by = call.Get<Quaternion&>(1);

    Real3 result = by.RotatedVector(value);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void QuaternionMultiplyQuaternion(Call& call, ExceptionReport& report)
  {
    Quaternion& by = call.Get<Quaternion&>(0);
    Quaternion& the = call.Get<Quaternion&>(1);

    Quaternion result = by * the;
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void QuaternionMultiplyVector3(Call& call, ExceptionReport& report)
  {
    Quaternion& by = call.Get<Quaternion&>(0);
    Real3& the = call.Get<Real3&>(1);

    Real3 result = by.RotatedVector(the);
    call.Set(Call::Return, result);
  }
  
  //***************************************************************************
  bool EvolvePermutation(size_t indices[], size_t count, size_t upperBound)
  {
    // Increment the first index
    ++indices[0];

    // Now we need to check if we need to overflow into the next slot
    size_t innerIndex = 0;

    // Loop while we're overflowing and our index hasn't gone outside the 
    while (indices[innerIndex] == upperBound)
    {
      // If we hit the last index, and it's at the upper bound (confirmed above)
      if (innerIndex == (count - 1))
        return false;

      // Reset the current counter
      indices[innerIndex] = 0;

      // Increment the index so we can increment the next value (overflow)
      ++innerIndex;
      ++indices[innerIndex];
    }
    
    // We need to continue the permutation!
    return true;
  }
  
  //***************************************************************************
  template <typename ComponentType>
  void VectorSwizzleSet(Call& call, ExceptionReport& report)
  {
    // Get the function that's executing us
    Function* function = call.GetFunction();

    // Get the order of the swizzle from the user data (directly!)
    unsigned order = *(unsigned*)&function->UserData;

    // Get how many components the swizzle uses
    unsigned swizzleCount = (order & 7);  // 00 00 00 00 111

    // Read the userdata to figure out which components are being swizzled
    const size_t MaxComponents = 4;
    size_t componentIndex[MaxComponents] =
    {
      (order >> 3) & 3, // 00 00 00 11 000
      (order >> 5) & 3, // 00 00 11 00 000
      (order >> 7) & 3, // 00 11 00 00 000
      (order >> 9) & 3, // 11 00 00 00 000
    };

    // Get a pointer to the vector that we're being set to
    ComponentType* vector = (ComponentType*)call.GetParameterUnchecked(0);

    // Get a pointer to our handle
    Handle& selfHandle = call.GetHandle(Call::This);
    ComponentType* self = (ComponentType*)selfHandle.Dereference();

    // Loop through all the components and read the index that we're supposed to swizzle
    for (size_t i = 0; i < swizzleCount; ++i)
    {
      // Get the index for the current component swizzle
      size_t index = (size_t)componentIndex[i];
      
      // Perform the component wise set
      self[index] = vector[i];
    }
  }
  
  //***************************************************************************
  template <typename ComponentType>
  void VectorSwizzleGet(Call& call, ExceptionReport& report)
  {
    // Get the function that's executing us
    Function* function = call.GetFunction();

    // Get the order of the swizzle from the user data (directly!)
    unsigned order = *(unsigned*)&function->UserData;

    // Get how many components the swizzle uses
    unsigned swizzleCount = (order & 7);  // 00 00 00 00 111

    // Read the userdata to figure out which components are being swizzled
    const size_t MaxComponents = 4;
    size_t componentIndex[MaxComponents] =
    {
      (order >> 3) & 3, // 00 00 00 11 000
      (order >> 5) & 3, // 00 00 11 00 000
      (order >> 7) & 3, // 00 11 00 00 000
      (order >> 9) & 3, // 11 00 00 00 000
    };

    // Get a pointer to the the resulting vector
    ComponentType* result = (ComponentType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // Get a pointer to our handle
    Handle& selfHandle = call.GetHandle(Call::This);
    ComponentType* self = (ComponentType*)selfHandle.Dereference();

    // Loop through all the components and read the index that we're supposed to swizzle
    for (size_t i = 0; i < swizzleCount; ++i)
    {
      // Get the index for the current component swizzle
      size_t index = (size_t)componentIndex[i];
      
      // Perform the component wise get
      result[i] = self[index];
    }
  }

  //***************************************************************************
  template <size_t Components, typename ComponentType>
  void GenerateVectorSwizzles(LibraryBuilder& builder, BoundType* type, BoundType* componentTypes[Core::MaxComponents])
  {
    // Get a reference to the core so we can access all the vector/real types
    Core& core = Core::GetInstance();

    char componentNamesSet[2][4] = {{'X', 'Y', 'Z', 'W'}, {'R', 'G', 'B', 'A'}};

    // For now only bind the XYZW components (until code completion is better)
    for (size_t namesIndex = 0; namesIndex < 1; ++namesIndex)
    {
      // Loop through the number of components, down to one
      for (size_t count = Core::MaxComponents; count > 0; --count)
      {
        // Indices into a specific component (x, y, z, w)
        char *componentNames = componentNamesSet[namesIndex];
        size_t componentIndex[Core::MaxComponents] = {0};

        Type* sizeType = componentTypes[count - 1];

        // Loop through all the permutations
        do
        {
          StringBuilder nameBuilder;

          bool inOrder = true;
          bool noDuplicateComponents = true;
          bool usedComponent[Core::MaxComponents] = {0};

          for (size_t i = 0; i < count; ++i)
          {
            size_t index = componentIndex[i];

            // Check if the components are in order
            if (i > 0 && componentIndex[i - 1] != index - 1)
            {
              inOrder = false;
            }

            bool& used = usedComponent[index];

            if (used)
            {
              noDuplicateComponents = false;
            }

            used = true;

            nameBuilder.Append(componentNames[index]);
          }

          String name = nameBuilder.ToString();

          // Store whatever property we make in here so we can set whether it's hidden afterwards
          Property* property = nullptr;

          // If the swizzle is a completely in order swizzle
          // That means that we can directly access the memory of the structure (no properties needed)
          if (inOrder)
          {
            // Compute the offset into the vector
            // X is at the front, and therefore is 0, y should be 1 real in, etc
            size_t offset = componentIndex[0] * sizeof(ComponentType);

            // Add the swizzle field
            property = builder.AddBoundField(type, name, sizeType, offset, MemberOptions::None);
          }
          // It must be a property then
          else
          {
            // Create a single integer to be used as userdata to describe the order of the swizzle
            void* orderUserData = nullptr;

            // Put the order into a series of bytes that we store directly as the user data pointer
            size_t& order = *(size_t*)&orderUserData;

            order = count |
              (componentIndex[0] << 3)  |
              (componentIndex[1] << 5)  |
              (componentIndex[2] << 7)  |
              (componentIndex[3] << 9);

            // As long as we have no duplicate components, we
            // can at least make it a read/write property (with a get/set)
            if (noDuplicateComponents)
            {
              // Add the get/set property
              property = builder.AddBoundProperty
                (
                type,
                name,
                sizeType,
                VectorSwizzleSet<ComponentType>,
                VectorSwizzleGet<ComponentType>,
                MemberOptions::None
                );

              // Store the userdata on the property get/set functions
              property->Get->UserData = orderUserData;
              property->Set->UserData = orderUserData;
            }
            else
            {
              // Add the get (read only) property
              property = builder.AddBoundProperty
                (
                type,
                name,
                sizeType,
                nullptr,
                VectorSwizzleGet<ComponentType>,
                MemberOptions::None
                );

              // Store the userdata on the property get function
              property->Get->UserData = orderUserData;
            }
          }

          // Hide all properties that aren't just .X, .Y, .Z, .W
          // Also hide .X on single values
          if (count != 1 || type == componentTypes[0])
            property->IsHidden = true;
        }
        while (EvolvePermutation(componentIndex, count, Components));
      }
    }
  }

  //***************************************************************************
  template <size_t Components, typename ComponentType>
  void GenerateVectorComponentConstructors(LibraryBuilder& builder, BoundType* type, BoundType* componentTypes[Core::MaxComponents])
  {
    // Get a reference to the core so we can access all the vector/real types
    Core& core = Core::GetInstance();

    // We're generating constructors for a fixed number of components (a specific vector type)
    for (size_t count = Components; count > 0; --count)
    {
      // Only ever index up to 'count' in size
      // This array is an array of indices into the component types above
      // This array will be incremented much like an N counter
      size_t typeIndex[Core::MaxComponents] = {0};

      // Loop through all the 
      do
      {
        // Create an array to hold all the parameters
        ParameterArray parameters;
        
        // With this permutation of constructor, what does the size end up being?
        size_t size = 0;

        // Walk through all the types, make sure the sum of the sizes of types we could take matches our size
        for (size_t i = 0; i < count; ++i)
        {
          // The type index corresponds to its size (component type) + 1
          size += (typeIndex[i] + 1);
        }

        // If the size of all the arguments matched our vector size...
        if (size == Components)
        {
          // Then walk through the arguments and generate a constructor signature for it
          for (size_t i = 0; i < count; ++i)
          {
            // Each parameter contributes to the signature (set it's type to the permuted vector types)
            DelegateParameter& param = parameters.push_back();
            param.ParameterType = componentTypes[typeIndex[i]];
          }

          // Finally, add the constructor to both our type and the library itself
          builder.AddBoundConstructor(type, VectorComponentConstructor<Components, ComponentType>, parameters);
        }
      }
      // Walk through all possible constructor permutations
      while (EvolvePermutation(typeIndex, count, count + 1));
    }
  }

  //***************************************************************************
  template <typename ComponentType>
  BoundType* CreateVectorType(String name, size_t components)
  {
    return new BoundType(name, TypeCopyMode::ValueType, components * sizeof(ComponentType), 0);
  }
  
  //***************************************************************************
  BoundType* Core::InstantiatePropertyDelegate
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  )
  {
    // Get the type that we're getting / setting
    Type* innerType = templateTypes.front();

    // We could have put core in our userdata, but no real need
    Core& core = Core::GetInstance();

    ParameterArray setParameters;
    DelegateParameter& setParameter = setParameters.push_back();
    setParameter.Name = "value";
    setParameter.ParameterType = innerType;

    DelegateType* setDelegateType = builder.GetDelegateType(setParameters, core.VoidType);
    DelegateType* getDelegateType = builder.GetDelegateType(ParameterArray(), innerType);

    BoundType* type = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(PropertyDelegateTemplate));
    builder.AddBoundField(type, "Set", setDelegateType, offsetof(PropertyDelegateTemplate, Set), MemberOptions::None);
    builder.AddBoundField(type, "Get", getDelegateType, offsetof(PropertyDelegateTemplate, Get), MemberOptions::None);
    
    // Bind the constructor
    ZilchBindConstructor(builder, type, PropertyDelegateTemplate, nullptr);
    ZilchBindDestructor(builder, type, PropertyDelegateTemplate);

    return type;
  }

  void SubString(Call& call, ExceptionReport& report)
  {
    // Get this string object
    String& self = call.Get<String&>(Call::This);

    Integer start = call.Get<Integer>(0);
    Integer length = call.Get<Integer>(1);
    
    Integer stringCount = (Integer)self.size();
    Integer end = start + length;
    if(start < 0 || end > stringCount)
    {
      call.GetState()->ThrowException(report, "String index was out of bounds");
      return;
    }
    if(length < 0)
    {
      call.GetState()->ThrowException(report, "A negative substring length is not supported");
      return;
    }

    String result = self.sub_string_unsafe(start, length);
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void SubStringBytes(Call& call, ExceptionReport& report)
  {
    // Get this string object
    String& self = call.Get<String&>(Call::This);

    Integer start = call.Get<Integer>(0);
    Integer length = call.Get<Integer>(1);

    Integer stringCount = (Integer)self.size();
    Integer end = start + length;

    // Check the character index (note that 'end' being equal to the string count is valid)
    if (start < 0 || end > stringCount)
    {
      call.GetState()->ThrowException(report, "String index was out of bounds");
      return;
    }
    if (length < 0)
    {
      call.GetState()->ThrowException(report, "A negative substring length is not supported");
      return;
    }

    StringRange result = self.sub_string(start, length);
    StringRangeExtended::SetResultStringRange(call, report, self, result);
  }

  //***************************************************************************
  void StringGetChar(Call& call, ExceptionReport& report)
  {
    // Get this string object
    String& self = call.Get<String&>(Call::This);
    Integer index = call.Get<Integer>(0);
    
    Integer stringCount = (Integer)self.size();
  
    // Check the character index (here, index CANNOT be the string count)
    if (index < 0 || index >= stringCount)
    {
      call.GetState()->ThrowException(report, "String index was out of bounds");
      return;
    }
  
    char result = self[index];
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void StringRuneIteratorFromByteIndex(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    int byteIndex = call.Get<int>(0);

    StringRangeExtended::RuneIteratorFromByteIndexInternal(call, report, self, self.all(), byteIndex);
  }

  //***************************************************************************
  void StringRuneIteratorFromRuneIndex(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    int runeIndex = call.Get<int>(0);

    StringRangeExtended::RuneIteratorFromRuneIndexInternal(call, report, self, self.all(), runeIndex);
  }

  //***************************************************************************
  void StringAll(Call& call, ExceptionReport& report)
  {
    // Get this string object
    String& self = call.Get<String&>(Call::This);

    StringRangeExtended::SetResultStringRange(call, report, self, self.all());
  }

  //***************************************************************************
  void StringByteCount(Call& call, ExceptionReport& report)
  {
    // Get this string object
    String& self = call.Get<String&>(Call::This);

    Integer count = (Integer)self.size();
    call.Set(Call::Return, count);
  }

  //***************************************************************************
  void StringConcatenate(Call& call, ExceptionReport& report)
  {
    String* first = call.Get<String*>(0);
    String* second = call.Get<String*>(1);

    if (first == nullptr || second == nullptr)
    {
      call.GetState()->ThrowNullReferenceException(report);
      return;
    }

    String result = BuildString(*first, *second);
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void StringRangeConcatenate(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* second = call.Get<StringRangeExtended*>(1);

    if (first == nullptr || second == nullptr)
    {
      call.GetState()->ThrowNullReferenceException(report);
      return;
    }

    String result = BuildString(first->mRange, second->mRange);
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void StringFromChar(Call& call, ExceptionReport& report)
  {
    char character = (char)call.Get<Integer>(0);
    String result(&character, 1);
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void StringContains(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);

    bool result = self.Contains(first->mRange);
    call.Set(Call::Return, result);
  }
  
  //***************************************************************************
  void StringCompare(Call& call, ExceptionReport& report)
  {
    String* first = call.Get<String*>(0);
    String* second = call.Get<String*>(1);

    int result = first->CompareTo(*second);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void StringRangeCompare(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* second = call.Get<StringRangeExtended*>(1);

    int result = first->mRange.CompareTo(second->mRange);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void StringCompareTo(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);

    int result = self.CompareTo(first->mRange);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void StringStartsWith(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);

    bool result = self.StartsWith(first->mRange);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void StringEndsWith(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);

    bool result = self.EndsWith(first->mRange);
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void StringTrimStart(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);

    StringRangeExtended::SetResultStringRange(call, report, self, self.TrimStart());
  }

  //***************************************************************************
  void StringTrimEnd(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);

    StringRangeExtended::SetResultStringRange(call, report, self, self.TrimEnd());
  }

  //***************************************************************************
  void StringTrim(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);

    StringRangeExtended::SetResultStringRange(call, report, self, self.Trim());
  }

  //***************************************************************************
  void StringToLower(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);

    String result = self.ToLower();
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void StringToUpper(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);

    String result = self.ToUpper();
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void StringReplace(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* second = call.Get<StringRangeExtended*>(1);

    String result = self.Replace(first->mRange, second->mRange);
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void StringFindRangeInclusive(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* second = call.Get<StringRangeExtended*>(1);

    StringRange result = self.FindRangeInclusive(first->mRange, second->mRange);
    StringRangeExtended::SetResultStringRange(call, report, self, result);
  }

  //***************************************************************************
  void StringFindRangeExclusive(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* second = call.Get<StringRangeExtended*>(1);

    StringRange result = self.FindRangeExclusive(first->mRange, second->mRange);
    StringRangeExtended::SetResultStringRange(call, report, self, result);
  }

  //***************************************************************************
  void StringFindFirstOf(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);

    StringRange result = self.FindFirstRangeOf(first->mRange);
    StringRangeExtended::SetResultStringRange(call, report, self, result);
  }

  //***************************************************************************
  void StringFindLastOf(Call& call, ExceptionReport& report)
  {
    String& self = call.Get<String&>(Call::This);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(0);

    StringRange result = self.FindLastRangeOf(first->mRange);
    StringRangeExtended::SetResultStringRange(call, report, self, result);
  }

  //***************************************************************************
  void JoinTwoStrings(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* separator = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(1);
    StringRangeExtended* second = call.Get<StringRangeExtended*>(2);
    if(separator == NULL || first == NULL || second == NULL)
    {
      call.GetState()->ThrowNullReferenceException(report);
      return;
    }

    String result = Zero::String::Join(separator->mRange, first->mRange, second->mRange);
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void JoinThreeStrings(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* separator = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(1);
    StringRangeExtended* second = call.Get<StringRangeExtended*>(2);
    StringRangeExtended* third = call.Get<StringRangeExtended*>(3);
    if(separator == nullptr || first == nullptr || second == nullptr || third == nullptr)
    {
      call.GetState()->ThrowNullReferenceException(report);
      return;
    }

    String result = Zero::String::Join(separator->mRange, first->mRange, second->mRange, third->mRange);
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void JoinFourStrings(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* separator = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* first = call.Get<StringRangeExtended*>(1);
    StringRangeExtended* second = call.Get<StringRangeExtended*>(2);
    StringRangeExtended* third = call.Get<StringRangeExtended*>(3);
    StringRangeExtended* fourth = call.Get<StringRangeExtended*>(4);
    if(separator == nullptr || first == nullptr || second == nullptr || third == nullptr || fourth == nullptr)
    {
      call.GetState()->ThrowNullReferenceException(report);
      return;
    }

    String result = Zero::String::Join(separator->mRange, first->mRange, second->mRange, third->mRange, fourth->mRange);
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  void StringRangeIsNullOrEmpty(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* separator = call.Get<StringRangeExtended*>(0);
    bool result = true;
    if(separator != nullptr)
      result = separator->mRange.empty();
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void StringRangeIsNullOrWhitespace(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* separator = call.Get<StringRangeExtended*>(0);
    bool result = true;
    if(separator != nullptr)
      result = separator->mRange.IsAllWhitespace();
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  class FormatCState;
  class FormatCEdge
  {
  public:

    // The characters we test against
    HashSet<int> Characters;

    // The name of this state, just for debugging
    cstr Name;

    // The state we want to transition to
    FormatCState* TransitionTo;

    // Create an edge that looks for any of the given characters
    FormatCEdge(cstr name, size_t charcterCount, ...) :
      Name(name),
      TransitionTo(nullptr)
    {
      va_list args;
      va_start(args, charcterCount);

      for (size_t i = 0; i < charcterCount; ++i)
      {
        int character = va_arg(args, int);
        this->Characters.insertOrError(character, "Two characters mapped to the same edge");
      }

      va_end(args);
    }
      
    // Check an edge for a transition on a character
    bool CheckEdge(char c)
    {
      return this->Characters.contains(c);
    }
  };

  //***************************************************************************
  class FormatCState
  {
  public:

    // All the edges to be evaluated, in order
    Array<FormatCEdge*> Edges;

    // The name of this state, just for debugging
    cstr Name;

    // Create a state with a given number of edges
    FormatCState(cstr name) :
      Name(name)
    {
    }
  };

  //***************************************************************************
  static FormatCState FormatCStateRoot                      ("Root");
  //---------------------------------------------------------------------------
  static FormatCState FormatCStateParsedFlags               ("ParsedFlags");
  //---------------------------------------------------------------------------
  static FormatCState FormatCStateParsedWidthStar           ("ParsedWidthStar");
  static FormatCState FormatCStateParsedWidthNumber         ("ParsedWidthNumber");
  //---------------------------------------------------------------------------
  static FormatCState FormatCStateParsedPrecisionDot        ("ParsedPrecisionDot");
  static FormatCState FormatCStateParsedPrecisionStar       ("ParsedPrecisionStar");
  static FormatCState FormatCStateParsedPrecisionNumber     ("ParsedPrecisionNumber");
  //---------------------------------------------------------------------------
  static FormatCState FormatCStateParsedSpecifier           ("ParsedSpecifier");
  
  //***************************************************************************
  static FormatCEdge  FormatCEdgeFlags                      ("Flags",               5, '-', '+', ' ', '#', '0');
  static FormatCEdge  FormatCEdgeFlagsLoop                  ("FlagsLoop",           5, '-', '+', ' ', '#', '0');
  //---------------------------------------------------------------------------
  static FormatCEdge  FormatCEdgeWidthStar                  ("WidthStar",           1, '*');
  static FormatCEdge  FormatCEdgeWidthNumber                ("WidthNumber",         10, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
  static FormatCEdge  FormatCEdgeWidthNumberLoop            ("WidthNumberLoop",     10, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
  //---------------------------------------------------------------------------
  static FormatCEdge  FormatCEdgePrecisionDot               ("PrecisionDot",        1, '.');
  static FormatCEdge  FormatCEdgePrecisionStar              ("PrecisionStar",       1, '*');
  static FormatCEdge  FormatCEdgePrecisionNumber            ("PrecisionNumber",     10, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
  static FormatCEdge  FormatCEdgePrecisionNumberLoop        ("PrecisionNumberLoop", 10, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
  //---------------------------------------------------------------------------
  static FormatCEdge  FormatCEdgeSpecifiers                 ("Specifiers",          18, 'd', 'i', 'u', 'o', 'x', 'X', 'f', 'F', 'e', 'E', 'g', 'G', 'a', 'A', 'c', 's', 'p', '%');

  //***************************************************************************
  static void InitializeFormatCStates()
  {
    // If we never initialized the state machine...
    static bool initialized = false;
    if (initialized == false)
    {
      // One time initialization
      initialized = true;

      /**** States ****/
      // From the root, we can basically go down any of the edges (except the loops and precision star/number, because that requires a .)
      FormatCStateRoot.Edges.push_back(&FormatCEdgeFlags);
      FormatCStateRoot.Edges.push_back(&FormatCEdgeWidthStar);
      FormatCStateRoot.Edges.push_back(&FormatCEdgeWidthNumber);
      FormatCStateRoot.Edges.push_back(&FormatCEdgePrecisionDot);
      FormatCStateRoot.Edges.push_back(&FormatCEdgeSpecifiers);

      // Once we've parsed flags, we can parse width, precision, or a specifier
      FormatCStateParsedFlags.Edges.push_back(&FormatCEdgeWidthStar);
      FormatCStateParsedFlags.Edges.push_back(&FormatCEdgeWidthNumber);
      FormatCStateParsedFlags.Edges.push_back(&FormatCEdgePrecisionDot);
      FormatCStateParsedFlags.Edges.push_back(&FormatCEdgeSpecifiers);

      // The user can technically specify as many flags as they want
      FormatCStateParsedFlags.Edges.push_back(&FormatCEdgeFlagsLoop);

      // Once we've parsed width, we can parse precision or a specifier (note we have to handle both width states here)
      FormatCStateParsedWidthStar.Edges.push_back(&FormatCEdgePrecisionDot);
      FormatCStateParsedWidthStar.Edges.push_back(&FormatCEdgeSpecifiers);
      FormatCStateParsedWidthNumber.Edges.push_back(&FormatCEdgePrecisionDot);
      FormatCStateParsedWidthNumber.Edges.push_back(&FormatCEdgeSpecifiers);

      // Make sure the width number edge loops back to itself
      FormatCStateParsedWidthNumber.Edges.push_back(&FormatCEdgeWidthNumberLoop);

      // The dot state we have to handle specially, because it's not legal to transition to anything except the precision star/number
      FormatCStateParsedPrecisionDot.Edges.push_back(&FormatCEdgePrecisionStar);
      FormatCStateParsedPrecisionDot.Edges.push_back(&FormatCEdgePrecisionNumber);

      // Once we've parsed precision, we can only parse a specifier (note we have to handle both precision states here, but not dot!)
      FormatCStateParsedPrecisionStar.Edges.push_back(&FormatCEdgeSpecifiers);
      FormatCStateParsedPrecisionNumber.Edges.push_back(&FormatCEdgeSpecifiers);

      // Make sure the precision number edge loops back to itself
      FormatCStateParsedPrecisionNumber.Edges.push_back(&FormatCEdgePrecisionNumberLoop);

      /**** Edges ****/
      FormatCEdgeFlags.TransitionTo               = &FormatCStateParsedFlags;
      FormatCEdgeFlagsLoop.TransitionTo           = &FormatCStateParsedFlags;
      FormatCEdgeWidthStar.TransitionTo           = &FormatCStateParsedWidthStar;
      FormatCEdgeWidthNumber.TransitionTo         = &FormatCStateParsedWidthNumber;
      FormatCEdgeWidthNumberLoop.TransitionTo     = &FormatCStateParsedWidthNumber;
      FormatCEdgePrecisionDot.TransitionTo        = &FormatCStateParsedPrecisionDot;
      FormatCEdgePrecisionStar.TransitionTo       = &FormatCStateParsedPrecisionStar;
      FormatCEdgePrecisionNumber.TransitionTo     = &FormatCStateParsedPrecisionNumber;
      FormatCEdgePrecisionNumberLoop.TransitionTo = &FormatCStateParsedPrecisionNumber;
      FormatCEdgeSpecifiers.TransitionTo          = &FormatCStateParsedSpecifier;
    }
  }

  //***************************************************************************
  namespace FormatCInputType
  {
    enum Enum
    {
      DoubleInteger,
      DoubleReal,
      String,
      Pointer
    };
  }

  //***************************************************************************
  template <typename T>
  int FormatCSprintf(char* buffer, cstr format, int widthStar, int precisionStar, T value)
  {
    // If no buffer was provided, it means we're just counting the length
    if (buffer == nullptr)
    {
      // We have to determine the correct arguments to pass in based on whether the * was used for with or precision
      if (widthStar >= 0 && precisionStar >= 0)
        return ZeroSPrintfCount(format, widthStar, precisionStar, value);
      else if (widthStar >= 0)
        return ZeroSPrintfCount(format, widthStar, value);
      else if (precisionStar >= 0)
        return ZeroSPrintfCount(format, widthStar, value);
      else
        return ZeroSPrintfCount(format, value);
    }
    else
    {
      // We have to determine the correct arguments to pass in based on whether the * was used for with or precision
      if (widthStar >= 0 && precisionStar >= 0)
        return sprintf(buffer, format, widthStar, precisionStar, value);
      else if (widthStar >= 0)
        return sprintf(buffer, format, widthStar, value);
      else if (precisionStar >= 0)
        return sprintf(buffer, format, precisionStar, value);
      else
        return sprintf(buffer, format, value);
    }
  }
  
  //***************************************************************************
  template <typename T>
  void FormatCPrint(ExecutableState* state, ExceptionReport& report, StringBuilder& builder, StringParam format, Array<char>& temporaryBuffer, int widthStar, int precisionStar, const Any& argument, T value)
  {
    // Grab the stored type of the argument, for error printing
    Type* argumentType = argument.StoredType;

    // First, get the length that the printf would output
    int sprintfLength = FormatCSprintf(nullptr, format.c_str(), widthStar, precisionStar, value);

    // If the print failed, let the user know
    if (sprintfLength < 0)
    {
      state->ThrowException(report, String::Format("The format specifier '%s' was invalid. The argument was '%s' of type '%s'", format.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));
      return;
    }

    // This must be less than or equal to, because we need extra space for the null
    if (temporaryBuffer.size() <= (size_t)sprintfLength)
    {
      // Expand it just a bit to prevent a lot of re-allocating (and +1 just for the null)
      temporaryBuffer.resize(sprintfLength * 2 + 1);

      // Clear the memory just in case for some reason sprintf fails
      memset(temporaryBuffer.data(), 0, temporaryBuffer.size());
    }

    // Now that we've sized our buffer to fit the text, actually print out to the buffer
    sprintfLength = FormatCSprintf(temporaryBuffer.data(), format.c_str(), widthStar, precisionStar, value);

    // This should basically never happen... but just in case it does!
    if (sprintfLength < 0)
    {
      state->ThrowException(report, String::Format("The format specifier '%s' was invalid. The argument was '%s' of type '%s'", format.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));
      return;
    }

    // Finally, append the formatted text to the builder
    builder.Append(temporaryBuffer.data());
  }

  //***************************************************************************
  void StringFormatC(Call& call, ExceptionReport& report)
  {
    // Make sure all the edges and states are setup for our DFA
    InitializeFormatCStates();

    // How many arguments this overload is going to read off the stack (from 1 to 10)
    size_t argumentCount = (size_t)call.GetFunction()->UserData;

    // The format string (as used with sprintf)
    StringParam format = call.Get<StringParam>(0);

    // Create a stack array to hold all the arguments we read off the Zilch stack
    // The 'Any' type can hold any value from Zilch, including primitives and classes
    const Any** arguments = (const Any**)alloca(sizeof(const Any*) * argumentCount);

    // Read each argument off the stack
    for (size_t i = 0; i < argumentCount; ++i)
    {
      // Put each argument into the static array we created
      // The +1 is for the format argument at the beginning
      const Any* argument = call.Get<const Any*>(i + 1);
      arguments[i] = argument;
    }

    // Get the current state (for throwing exceptions)
    ExecutableState* state = call.GetState();

    // What we'll use to concatenate all the strings together
    StringBuilder builder;

    // The index we use when reading in format specifiers
    size_t argumentIndex = 0;

    // A temporary buffer where we print out each argumnent / format specifier to
    Array<char> temporaryBuffer;

    // Loop through all characters in the format string
    for (size_t i = 0; i < format.size(); ++i)
    {
      // Grab the current character
      char c = format[i];

      // If this is a format specifier...
      if (c == '%')
      {
        // Format specifier syntax: (we do not support length)
        // %[flags][width][.precision]specifier

        // We use a state machine / DFA to parse the format specifiers
        FormatCState* currentState = &FormatCStateRoot;

        // Save where this format specifier started, right at the % sign
        size_t formatSpecifierStart = i;

        // Because we already read the '%', we want to advance to the first character of the specifier
        ++i;

        // Loop until we read the rest of the specifier, or the end of the string (null terminates the DFA!)
        for (; i <= format.size(); ++i)
        {
          // Read the current character
          c = format[i];

          // This will tell us if, after testing all the edges, we transitioned to a new state
          // Note: Not transitioning is considered an error
          bool transitioned = false;

          // Loop through all the current state's outgoing edges
          for (size_t e = 0; e < currentState->Edges.size(); ++e)
          {
            // Grab the current edge
            FormatCEdge* edge = currentState->Edges[e];

            // Check to see if this edge would transition on the character
            if (edge->CheckEdge(c))
            {
              // We transitioned, move to the next state
              currentState = edge->TransitionTo;
              transitioned = true;
              break;
            }
          }

          // Create a range that represents the format specifier up to this point (the +1 is because i is actually at the current character)
          StringRange formatSpecifierRange(format.c_str() + formatSpecifierStart, i - formatSpecifierStart + 1);

          // If we didn't transition, that means we found an invalid format specifier
          if (transitioned == false)
          {
            state->ThrowException(report, BuildString("Invalid or unsupported format specifier: '", formatSpecifierRange, "'"));
            return;
          }
          // If we reached the end (parsed the format specifier)
          else if (currentState == &FormatCStateParsedSpecifier)
          {
            // We finished parsing the format specifier, time to try it out!
            String formatSpecifierString = formatSpecifierRange;
            
            // Get the format specifier character
            char formatSpecifier = formatSpecifierString.back();

            // Sting is the safest fallback, just in case something happens
            FormatCInputType::Enum inputType = FormatCInputType::String;

            // Check for the integral, float, and pointer types
            switch (formatSpecifier)
            {
              // Printf integer format specifiers
              case 'd':
              case 'i':
              case 'o':
              case 'u':
              case 'x':
              case 'X':
                inputType = FormatCInputType::DoubleInteger;
                break;
                
              // Printf float format specifiers
              case 'f':
              case 'F':
              case 'e':
              case 'E':
              case 'g':
              case 'G':
              case 'a':
              case 'A':
                inputType = FormatCInputType::DoubleReal;
                break;
                
              // Printf pointer format specifier
              case 'p':
                inputType = FormatCInputType::Pointer;
                break;
            }

            // Usign a * in printf can add extra integer arguments to the va-list
            Integer widthStar = -1;
            Integer precisionStar = -1;
            
            // Count the number of extra integral arguments we need
            for (size_t j = 0; j < formatSpecifierString.size(); ++j)
            {
              // If we hit the * operator...
              if (formatSpecifierString[j] == '*')
              {
                // So long as we haven't run out of arguments...
                if (argumentIndex >= argumentCount)
                {
                  state->ThrowException(report, "There are more '%' format specifiers or '*' operators then there are arguments");
                  return;
                }

                // This is always valid to check the previous character because we know format specifiers must start with %
                // If the previous character was a '.', then we know this is a 'precision' star
                bool isPrecision = (formatSpecifierString[j - 1] == '.');

                // Grab the current integer argument (for either width or precision)
                const Any& argument = *arguments[argumentIndex];
                Type* argumentType = argument.StoredType;
                const byte* argumentData = argument.GetData();
                ++argumentIndex;

                // Make sure the type was an integer
                if (Type::IsSame(argumentType, ZilchTypeId(Integer)) == false)
                {
                  // It wasn't an integer, inform the user of which * was wrong
                  cstr starType = "width";
                  if (isPrecision)
                    starType = "precision";
                  
                  // Let the user know about the * requiring an integer argument, including as much info as possible
                  state->ThrowException
                  (
                    report,
                    String::Format("When using * for %s an Integer must be provided before the argument, instead we found '%s' of type '%s' for the '%s' format specifier",
                    starType,
                    argument.ToString().c_str(),
                    argumentType->ToString().c_str(),
                    formatSpecifierString.c_str())
                  );
                  return;
                }

                // Finally, if this is a precision or width star get the actual integral value...
                if (isPrecision)
                  precisionStar = *(Integer*)argumentData;
                else
                  widthStar = *(Integer*)argumentData;
              }
            }
            
            // After we may have read any * arguments, we need to check if the current format specifier actually has a valid argument (too few?)
            if (argumentIndex >= argumentCount)
            {
              state->ThrowException(report, "There are more '%' format specifiers or '*' operators then there are arguments");
              return;
            }

            // Grab the current argument for the format specifier
            const Any& argument = *arguments[argumentIndex];
            Type* argumentType = argument.StoredType;
            const byte* argumentData = argument.GetData();

            // We're using a format specifier that accepts a DoubleInteger
            if (inputType == FormatCInputType::DoubleInteger)
            {
              // If it's an integer, we always just print out long longs
              // We basically add the 'll' format specifier before the last character, which is the format specifier that told us it was an integer
              String integralFormatSpecifierString = BuildString
              (
                StringRange(formatSpecifierRange.begin, formatSpecifierRange.end - 1),
                "ll",
                StringRange(formatSpecifierRange.end -1, formatSpecifierRange.end)
              );

              // Convert as many types as we can to the DoubleInteger value
              DoubleInteger value = 0;

              // Look for Integer, DoubleInteger, Real, and DoubleReal
              if (Type::IsSame(argumentType, ZilchTypeId(Byte)))
                value = (DoubleInteger)*(Byte*)argumentData;
              else if (Type::IsSame(argumentType, ZilchTypeId(Integer)))
                value = (DoubleInteger)*(Integer*)argumentData;
              else if (Type::IsSame(argumentType, ZilchTypeId(DoubleInteger)))
                value = (DoubleInteger)*(DoubleInteger*)argumentData;
              else if (Type::IsSame(argumentType, ZilchTypeId(Real)))
                value = (DoubleInteger)*(Real*)argumentData;
              else if (Type::IsSame(argumentType, ZilchTypeId(DoubleReal)))
                value = (DoubleInteger)*(DoubleReal*)argumentData;
              else
                // Anything else must be an error since we don't know what it is
                return state->ThrowException(report, String::Format("The format specifier '%s' requires an integral or real type, instead we got '%s' of type '%s'", formatSpecifierString.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));

              // Print the value out and store it in the builder (this can throw an exception)
              FormatCPrint(state, report, builder, integralFormatSpecifierString, temporaryBuffer, widthStar, precisionStar, argument, value);
              if (report.HasThrownExceptions())
                return;
            }
            // We're using a format specifier that accepts a DoubleReal
            else if (inputType == FormatCInputType::DoubleReal)
            {
              // Convert as many types as we can to the DoubleReal value
              DoubleReal value = 0.0;

              // Look for Integer, DoubleInteger, Real, and DoubleReal
              if (Type::IsSame(argumentType, ZilchTypeId(Byte)))
                value = (DoubleReal)*(Byte*)argumentData;
              else if (Type::IsSame(argumentType, ZilchTypeId(Integer)))
                value = (DoubleReal)*(Integer*)argumentData;
              else if (Type::IsSame(argumentType, ZilchTypeId(DoubleInteger)))
                value = (DoubleReal)*(DoubleInteger*)argumentData;
              else if (Type::IsSame(argumentType, ZilchTypeId(Real)))
                value = (DoubleReal)*(Real*)argumentData;
              else if (Type::IsSame(argumentType, ZilchTypeId(DoubleReal)))
                value = (DoubleReal)*(DoubleReal*)argumentData;
              else
                // Anything else must be an error since we don't know what it is
                return state->ThrowException(report, String::Format("The format specifier '%s' requires an integral or real type, instead we got '%s' of type '%s'", formatSpecifierString.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));
              
              // Print the value out and store it in the builder (this can throw an exception)
              FormatCPrint(state, report, builder, formatSpecifierString, temporaryBuffer, widthStar, precisionStar, argument, value);
              if (report.HasThrownExceptions())
                return;
            }
            // When expecting a string, we actually just allow the user to print anything (%s is our one size fits all)
            // String's 'ToString' just results in itself
            else if (inputType == FormatCInputType::String)
            {
              // Print the value out and store it in the builder (this can throw an exception)
              FormatCPrint(state, report, builder, formatSpecifierString, temporaryBuffer, widthStar, precisionStar, argument, argument.ToString().c_str());
              if (report.HasThrownExceptions())
                return;
            }
            // The pointer format specifier just prints out special pointer values
            else if (inputType == FormatCInputType::Pointer)
            {
              // The meaning of the pointer is not entirely relevant, but can be used for debugging
              void* pointerValue = nullptr;
              bool isValidValue = false;

              // If the argument is a handle type (bound type as a class/reference type, or an indirect / ref struct)
              if (Type::IsHandleType(argumentType))
              {
                // Dereference the handle to get the actual value we point at
                pointerValue = ((Handle*)argumentData)->Dereference();
                isValidValue = true;
              }
              // If the argument is a delegate, we can at least give the 'Function' pointer
              else if (Type::IsDelegateType(argumentType))
              {
                // Just tell the user the location of the function
                pointerValue = ((Delegate*)argumentData)->BoundFunction;
                isValidValue = true;
              }

              // If we didn't detect the type of value, throw an exception
              if (isValidValue == false)
              {
                state->ThrowException(report, String::Format("The format specifier '%s' requires a class, ref struct, or delegate type. Instead we got '%s' of type '%s'", formatSpecifierString.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));
                return;
              }
              
              // Print the value out and store it in the builder (this can throw an exception)
              FormatCPrint(state, report, builder, formatSpecifierString, temporaryBuffer, widthStar, precisionStar, argument, pointerValue);
              if (report.HasThrownExceptions())
                return;
            }

            // We read and processed the format specifier, no need to continue
            // This will break to the outer loop where we keep reading the format string
            break;
          }
        }

        // We parsed a format specifier, so move to the next argument
        ++argumentIndex;
      }
      else
      {
        // Nothing special, just append the character directly from the format
        builder.Append(c);
      }
    }

    // If we didn't consume all the arguments...
    if (argumentIndex != argumentCount)
    {
      state->ThrowException(report, "There are more arguments then there are '%' format specifiers or '*' operators");
      return;
    }

    // Return the string we built to the Zilch stack
    String result = builder.ToString();
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  String BooleanToString(Boolean value)
  {
    // Basically because we only have two outcomes, just pre-create the strings
    static const String True("true");
    static const String False("false");

    if (value)
    {
      return True;
    }
    else
    {
      return False;
    }
  }

  //***************************************************************************
  cstr TrueFalseCstr(Boolean value)
  {
    return value ? "true" : "false";
  }

  //***************************************************************************
  String Boolean2ToString(Boolean2Param value)
  {
    return String::Format("(%s, %s)", TrueFalseCstr(value.x), TrueFalseCstr(value.y));
  }

  //***************************************************************************
  String Boolean3ToString(Boolean3Param value)
  {
    return String::Format("(%s, %s, %s)", TrueFalseCstr(value.x), TrueFalseCstr(value.y), TrueFalseCstr(value.z));
  }

  //***************************************************************************
  String Boolean4ToString(Boolean4Param value)
  {
    return String::Format("(%s, %s, %s, %s)", TrueFalseCstr(value.x), TrueFalseCstr(value.y), TrueFalseCstr(value.z), TrueFalseCstr(value.w));
  }

  //***************************************************************************
  String ByteToString(Byte value)
  {
    return String::Format("%d", value);
  }

  //***************************************************************************
  String IntegerToString(Integer value)
  {
    return String::Format("%d", value);
  }

  //***************************************************************************
  String Integer2ToString(Integer2Param value)
  {
    return String::Format("(%d, %d)", value.x, value.y);
  }

  //***************************************************************************
  String Integer3ToString(Integer3Param value)
  {
    return String::Format("(%d, %d, %d)", value.x, value.y, value.z);
  }

  //***************************************************************************
  String Integer4ToString(Integer4Param value)
  {
    return String::Format("(%d, %d, %d, %d)", value.x, value.y, value.z, value.w);
  }

  //***************************************************************************
  String RealToString(Real value)
  {
    return String::Format("%g", value);
  }

  //***************************************************************************
  String Real2ToString(Real2Param value)
  {
    return String::Format("(%g, %g)", value.x, value.y);
  }

  //***************************************************************************
  String Real3ToString(Real3Param value)
  {
    return String::Format("(%g, %g, %g)", value.x, value.y, value.z);
  }

  //***************************************************************************
  String Real4ToString(Real4Param value)
  {
    return String::Format("(%g, %g, %g, %g)", value.x, value.y, value.z, value.w);
  }

  //***************************************************************************
  String QuaternionToString(QuaternionParam value)
  {
    // First, convert the quaternion to Euler Angles (simple to read/understand)
    EulerAngles angles(Math::EulerOrders::XYZs);
    ToEulerAngles(value, &angles);

    // Also convert the quaternion to Axis/Angle form, as it may be more intuitive
    Real3 axis;
    Real angle;
    ToAxisAngle(value, &axis, &angle);

    // Print out the quaternion, then the Euler Angles form, then the Axis/Angle form
    return String::Format
    (
      "(%g, %g, %g, %g), Euler: (%g, %g, %g), Axis: (%g, %g, %g), Angle: %g",
      value.x, value.y, value.z, value.w,
      angles.Angles.x, angles.Angles.y, angles.Angles.z,
      axis.x, axis.y, axis.z,
      angle
    );
  }

  //***************************************************************************
  String DoubleIntegerToString(DoubleInteger value)
  {
    return String::Format("%lld", value);
  }

  //***************************************************************************
  String DoubleRealToString(DoubleReal value)
  {
    return String::Format("%g", value);
  }

  //***************************************************************************
  String StringToString(const BoundType* type, const byte* data)
  {
    return *(String*)data;
  }

  //***************************************************************************
  String ByteToString(const BoundType* type, const byte* data)
  {
    return ByteToString(*(Byte*)data);
  }

  //***************************************************************************
  String BooleanToString(const BoundType* type, const byte* data)
  {
    return BooleanToString(*(Boolean*)data);
  }

  //***************************************************************************
  String Boolean2ToString(const BoundType* type, const byte* data)
  {
    return Boolean2ToString(*(Boolean2*)data);
  }

  //***************************************************************************
  String Boolean3ToString(const BoundType* type, const byte* data)
  {
    return Boolean3ToString(*(Boolean3*)data);
  }

  //***************************************************************************
  String Boolean4ToString(const BoundType* type, const byte* data)
  {
    return Boolean4ToString(*(Boolean4*)data);
  }

  //***************************************************************************
  String IntegerToString(const BoundType* type, const byte* data)
  {
    return IntegerToString(*(Integer*)data);
  }

  //***************************************************************************
  String Integer2ToString(const BoundType* type, const byte* data)
  {
    return Integer2ToString(*(Integer2*)data);
  }

  //***************************************************************************
  String Integer3ToString(const BoundType* type, const byte* data)
  {
    return Integer3ToString(*(Integer3*)data);
  }

  //***************************************************************************
  String Integer4ToString(const BoundType* type, const byte* data)
  {
    return Integer4ToString(*(Integer4*)data);
  }

  //***************************************************************************
  String RealToString(const BoundType* type, const byte* data)
  {
    return RealToString(*(Real*)data);
  }

  //***************************************************************************
  String Real2ToString(const BoundType* type, const byte* data)
  {
    return Real2ToString(*(Real2*)data);
  }

  //***************************************************************************
  String Real3ToString(const BoundType* type, const byte* data)
  {
    return Real3ToString(*(Real3*)data);
  }

  //***************************************************************************
  String Real4ToString(const BoundType* type, const byte* data)
  {
    return Real4ToString(*(Real4*)data);
  }

  //***************************************************************************
  String QuaternionToString(const BoundType* type, const byte* data)
  {
    return QuaternionToString(*(Quaternion*)data);
  }

  //***************************************************************************
  String DoubleIntegerToString(const BoundType* type, const byte* data)
  {
    return DoubleIntegerToString(*(DoubleInteger*)data);
  }

  //***************************************************************************
  String DoubleRealToString(const BoundType* type, const byte* data)
  {
    return DoubleRealToString(*(DoubleReal*)data);
  }

  //***************************************************************************
  String VectorToString(Real* vector, size_t vectorSize)
  {
    if (vectorSize == 1)
      return RealToString(*(Real*)vector);
    else if (vectorSize == 2)
      return Real2ToString(*(Real2*)vector);
    else if (vectorSize == 3)
      return Real3ToString(*(Real3*)vector);
    else if (vectorSize == 4)
      return Real4ToString(*(Real4*)vector);

    Error("Somehow we tried to turn a vector into a string that has a size greater than 4");
    return String();
  }

  //***************************************************************************
  void RealApproximatelyEqual(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();
    size_t count = (size_t)call.GetFunction()->UserData;

    Real* lhs = (Real*)call.GetParameterUnchecked(0);
    Real* rhs = (Real*)call.GetParameterUnchecked(1);
    Real epsilon = call.Get<Real>(2);
    Boolean* result = (Boolean*)call.GetReturnUnchecked();

    // Check each element
    for(size_t i = 0; i < count; ++i)
      result[i] = Math::Abs(lhs[i] - rhs[i]) <= epsilon;
  }

  //***************************************************************************
  Integer ZilchParseInteger(StringRangeExtended range)
  {
    Integer value;
    Zero::ToValue(range.mRange, value);
    return value;
  }

  //***************************************************************************
  Real ZilchParseReal(StringRangeExtended range)
  {
    Real value;
    ToValue(range.mRange, value);
    return value;
  }

  //***************************************************************************
  Real ZilchRealPositiveMax()
  {
    return Math::PositiveMax();
  }

  //***************************************************************************
  Real ZilchRealPositiveValueClosestToZero()
  {
    return Math::PositiveMin();
  }

  //***************************************************************************
  Real ZilchRealNegativeValueClosestToZero()
  {
    return -Math::PositiveMin();
  }

  //***************************************************************************
  Real ZilchRealNegativeMin()
  {
    return -Math::PositiveMax();
  }

  //***************************************************************************
  Integer ZilchIntegerPositiveMax()
  {
    return Math::IntegerPositiveMax();
  }

  //***************************************************************************
  Integer ZilchIntegerPositiveValueClosestToZero()
  {
    return 1;
  }

  //***************************************************************************
  Integer ZilchIntegerNegativeValueClosestToZero()
  {
    return -1;
  }

  //***************************************************************************
  Integer ZilchIntegerNegativeMin()
  {
    return Math::IntegerNegativeMin();
  }

  //***************************************************************************
  // User data for vector (Real2, Integer2, etc...) types to implement generic functionality.
  class VectorUserData
  {
  public:
    VectorUserData(size_t count, size_t elementTypeIndex)
    {
      Count = count;
      ElementTypeIndex = elementTypeIndex;
    }

    size_t Count;
    size_t ElementTypeIndex;
  };

  //***************************************************************************
  void VectorCount(Call& call, ExceptionReport& report)
  {
    // The dimension of the vector was stored as the user data
    size_t dimension = *(size_t*)&(call.GetFunction()->UserData);
    call.Set(Call::Return, dimension);
  }

  //***************************************************************************
  void SetVectorAxis(byte* returnData, VectorUserData& userData, size_t axis, size_t typeIndex)
  {
    // Get the element type of the vector (Real, Integer, etc...)
    Core& core = Core::GetInstance();
    BoundType* elementType = core.VectorScalarBoundTypes[userData.ElementTypeIndex];

    size_t elementSize = elementType->Size;
    for(size_t i = 0; i < userData.Count; ++i)
    {
      byte* data = returnData + i * elementSize;

      // If this is the specified axis then call the appropriate function to set the value to
      // 1 for the current element type (1.0f for floats, 1 for ints, etc...)
      if(i == axis)
        core.ScalarTypeOneFunctions[userData.ElementTypeIndex](data);
      //otherwise just memset to zero
      else
        memset(data, 0, elementSize);
    }
  }

  //***************************************************************************
  void VectorGetAxis(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();

    // Get the user data for the vector and what axis to operate on
    VectorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<VectorUserData>(0);
    Integer axis = call.Get<Integer>(0);

    // Set the return data to be a vector of all zero except for the specified axis
    byte* returnData = call.GetReturnUnchecked();
    SetVectorAxis(returnData, userData, axis, userData.ElementTypeIndex);
  }

  //***************************************************************************
  void VectorAxisFunction(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();

    // Get the user data for the vector and what axis to operate on (from the regular user data)
    VectorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<VectorUserData>(0);
    size_t axis = (size_t)(call.GetFunction()->UserData);

    // Set the return data to be a vector of all zero except for the specified axis
    byte* returnData = call.GetReturnUnchecked();
    SetVectorAxis(returnData, userData, axis, userData.ElementTypeIndex);
  }

  //***************************************************************************
  void VectorZeroFunction(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();

    // Get the user data for the function
    VectorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<VectorUserData>(0);

    // Get the element type of the vector (Real, Integer, etc...)
    Core& core = Core::GetInstance();
    BoundType* elementType = core.VectorScalarBoundTypes[userData.ElementTypeIndex];

    // Set the entire array to zero (based upon the size of the element type and the number of elements)
    byte* returnData = call.GetReturnUnchecked();
    memset(returnData, 0, elementType->Size * userData.Count);
  }

  //***************************************************************************
  // Splats a function of the type Scalar Fn(Scalar) to
  // Vec(n) Fn(Vec(n)) (vector could be of whatever scalar type is)
  template <size_t Components, typename ScalarType, ScalarType (*Function)(ScalarType)>
  void SplatVecToVec(Call& call, ExceptionReport& report)
  {
    // Get a pointer to our input vector
    ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

    // Get a pointer to our return/output vector
    ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < Components; ++i)
    {
      // Call the function on the single input (splat)
      result[i] = Function(input[i]);
    }
  }

  //***************************************************************************
  // Splats a function of the type Scalar Fn(Scalar) to
  // Vec(n) Fn(Vec(n), a) (vector could be of whatever scalar type is)
  template <size_t Components, typename ScalarType, typename ExtraA, ScalarType (*Function)(ScalarType, ExtraA)>
  void SplatVecToVecOneExtra(Call& call, ExceptionReport& report)
  {
    // Get a pointer to our input vector
    ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

    // Grab the extra parameter
    ExtraA a = call.Get<ExtraA>(1);

    // Get a pointer to our return/output vector
    ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < Components; ++i)
    {
      // Call the function on the single input (splat)
      result[i] = Function(input[i], a);
    }
  }

  //***************************************************************************
  // Splats a function of the type Scalar Fn(Scalar) to
  // Vec(n) Fn(Vec(n), a, b) (vector could be of whatever scalar type is)
  template <size_t Components, typename ScalarType, typename ExtraA, typename ExtraB, ScalarType (*Function)(ScalarType, ExtraA, ExtraB)>
  void SplatVecToVecTwoExtra(Call& call, ExceptionReport& report)
  {
    // Get a pointer to our input vector
    ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

    // Grab the extra two parameters
    ExtraA a = call.Get<ExtraA>(1);
    ExtraB b = call.Get<ExtraB>(2);

    // Get a pointer to our return/output vector
    ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < Components; ++i)
    {
      // Call the function on the single input (splat)
      result[i] = Function(input[i], a, b);
    }
  }

  //***************************************************************************
  // Splats a function of the type Boolean Fn(Scalar, Scalar&) to
  // Vec(n) Fn(Vec(n)). The function being splatted is a Scalar Fn(Scalar)
  // function that has been altered to return if it failed so an exception
  // can be thrown.
  template <size_t Components, typename ScalarType, bool (*Function)(ScalarType, ScalarType&)>
  void SplatVecToVecWithError(Call& call, ExceptionReport& report)
  {
    // Get a pointer to our input vector
    ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

    // Get a pointer to our return/output vector
    ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    bool success = true;
    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < Components; ++i)
    {
      // Call the function on the single input (splat)
      success = Function(input[i], result[i]);

      // If the function failed for whatever reason then throw an exception
      if (success == false)
      {
        // The user data of this function should contain a format string with
        // one %s in it to display the input value that failed.
        cstr errFormat = (cstr)call.GetFunction()->UserData;
        String vectorValue = VectorToString(input, Components);
        String msg = String::Format(errFormat, vectorValue.c_str());
        call.GetState()->ThrowException(report, msg);
        return;
      }
    }
  }

  //***************************************************************************
  // Splats a function of the type Scalar Fn(Scalar, Scalar) to
  // Vec(n) Fn(Vec(n), Vec(n)) (vector could be of whatever scalar type is)
  template <size_t Components, typename ScalarType, ScalarType (*Function)(ScalarType, ScalarType)>
  void SplatTwoVecToVec(Call& call, ExceptionReport& report)
  {
    // Get a pointer to our input vector
    ScalarType* input0 = (ScalarType*)call.GetParameterUnchecked(0);
    ScalarType* input1 = (ScalarType*)call.GetParameterUnchecked(1);

    // Get a pointer to our return/output vector
    ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
    call.DisableReturnChecks();
    
    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < Components; ++i)
    {
      // Call the function on the single inputs (splat)
      result[i] = Function(input0[i], input1[i]);
    }
  }

  //***************************************************************************
  //Splats a function of the type Scalar Fn(Scalar, Scalar, Scalar) to
  //Vec(n) Fn(Vec(n), Vec(n), Vec(n)) (vector could be of whatever scalar type is)
  template <size_t Components, typename ScalarType, ScalarType (*Function)(ScalarType, ScalarType, ScalarType)>
  void SplatThreeVecToVec(Call& call, ExceptionReport& report)
  {
    // Get a pointer to our input vector
    ScalarType* input0 = (ScalarType*)call.GetParameterUnchecked(0);
    ScalarType* input1 = (ScalarType*)call.GetParameterUnchecked(1);
    ScalarType* input2 = (ScalarType*)call.GetParameterUnchecked(2);

    // Get a pointer to our return/output vector
    ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
    call.DisableReturnChecks();
    
    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < Components; ++i)
    {
      // Call the function on the single inputs (splat)
      result[i] = Function(input0[i], input1[i], input2[i]);
    }
  }

  //***************************************************************************
  //Splats a function of the type Scalar Fn(Scalar, Scalar, Real) to
  //Vec(n) Fn(Vec(n), Vec(n), Real) (vector could be of whatever scalar type is)
  template <size_t Components, typename ScalarType, ScalarType (*Function)(ScalarType, ScalarType, Real)>
  void SplatTwoVecAndRealToVec(Call& call, ExceptionReport& report)
  {
    // Get pointers to the two vectors
    ScalarType* input0 = (ScalarType*)call.GetParameterUnchecked(0);
    ScalarType* input1 = (ScalarType*)call.GetParameterUnchecked(1);
    Real inputReal = call.Get<Real>(2);

    // Get a pointer to our return/output vector
    ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();
    
    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < Components; ++i)
    {
      // Call the function on the single inputs (splat)
      result[i] = Function(input0[i], input1[i], inputReal);
    }
  }

#define ZilchSplatAllVectorOperationsAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, Name, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVec<1, type, NamespaceAndClass::Method>, OneParameter(this->type##Type ), this->type##Type , FunctionOptions::Static)->Description = ZilchDocumentString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVec<2, type, NamespaceAndClass::Method>, OneParameter(this->type##2Type), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVec<3, type, NamespaceAndClass::Method>, OneParameter(this->type##3Type), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVec<4, type, NamespaceAndClass::Method>, OneParameter(this->type##4Type), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); 

#define ZilchSplatNamedAllVectorOperationsTwoExtraAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, typeA, typeB, Method, Name, p1, p2, p3, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecTwoExtra<1, type, typeA, typeB, NamespaceAndClass::Method>, ThreeParameters(this->type##Type , p1, ZilchTypeId(typeA), p2, ZilchTypeId(typeB), p3), this->type##Type , FunctionOptions::Static)->Description = ZilchDocumentString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecTwoExtra<2, type, typeA, typeB, NamespaceAndClass::Method>, ThreeParameters(this->type##2Type, p1, ZilchTypeId(typeA), p2, ZilchTypeId(typeB), p3), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecTwoExtra<3, type, typeA, typeB, NamespaceAndClass::Method>, ThreeParameters(this->type##3Type, p1, ZilchTypeId(typeA), p2, ZilchTypeId(typeB), p3), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecTwoExtra<4, type, typeA, typeB, NamespaceAndClass::Method>, ThreeParameters(this->type##4Type, p1, ZilchTypeId(typeA), p2, ZilchTypeId(typeB), p3), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); 
  
#define ZilchSplatNamedAllVectorOperationsOneExtraAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, typeA, Method, Name, p1, p2, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecOneExtra<1, type, typeA, NamespaceAndClass::Method>, TwoParameters(this->type##Type , p1, ZilchTypeId(typeA), p2), this->type##Type , FunctionOptions::Static)->Description = ZilchDocumentString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecOneExtra<2, type, typeA, NamespaceAndClass::Method>, TwoParameters(this->type##2Type, p1, ZilchTypeId(typeA), p2), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecOneExtra<3, type, typeA, NamespaceAndClass::Method>, TwoParameters(this->type##3Type, p1, ZilchTypeId(typeA), p2), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecOneExtra<4, type, typeA, NamespaceAndClass::Method>, TwoParameters(this->type##4Type, p1, ZilchTypeId(typeA), p2), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); 

#define ZilchSplatNamedAllVectorOperationsAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, FunctionName, ParamName, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVec<1, type, NamespaceAndClass::Method>, OneParameter(this->type##Type , ParamName), this->type##Type,  FunctionOptions::Static)->Description = ZilchDocumentString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVec<2, type, NamespaceAndClass::Method>, OneParameter(this->type##2Type, ParamName), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVec<3, type, NamespaceAndClass::Method>, OneParameter(this->type##3Type, ParamName), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVec<4, type, NamespaceAndClass::Method>, OneParameter(this->type##4Type, ParamName), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise."));

#define ZilchSplatAllVectorOperationsWithErrorAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, FunctionName, ErrorFormatString) \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<1, type, NamespaceAndClass::Method>, OneParameter(this->type##Type ),  this->type##Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<2, type, NamespaceAndClass::Method>, OneParameter(this->type##2Type), this->type##2Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<3, type, NamespaceAndClass::Method>, OneParameter(this->type##3Type), this->type##3Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<4, type, NamespaceAndClass::Method>, OneParameter(this->type##4Type), this->type##4Type, FunctionOptions::Static)->UserData = ErrorFormatString;

#define ZilchSplatNamedAllVectorOperationsWithErrorAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, FunctionName, ParamName, ErrorFormatString) \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<1, type, NamespaceAndClass::Method>, OneParameter(this->type##Type , ParamName),  this->type##Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<2, type, NamespaceAndClass::Method>, OneParameter(this->type##2Type, ParamName), this->type##2Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<3, type, NamespaceAndClass::Method>, OneParameter(this->type##3Type, ParamName), this->type##3Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<4, type, NamespaceAndClass::Method>, OneParameter(this->type##4Type, ParamName), this->type##4Type, FunctionOptions::Static)->UserData = ErrorFormatString;

#define ZilchSplatAllTwoVecToVecAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, Name, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecToVec<1, type, NamespaceAndClass::Method>, TwoParameters(this->type##Type),  this->type##Type,  FunctionOptions::Static)->Description = ZilchDocumentString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecToVec<2, type, NamespaceAndClass::Method>, TwoParameters(this->type##2Type), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecToVec<3, type, NamespaceAndClass::Method>, TwoParameters(this->type##3Type), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecToVec<4, type, NamespaceAndClass::Method>, TwoParameters(this->type##4Type), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise."));

#define ZilchSplatNamedAllTwoVecToVecAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, FunctionName, Param1Name, Param2Name, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatTwoVecToVec<1, type, NamespaceAndClass::Method>, TwoParameters( this->type##Type, Param1Name,  this->type##Type, Param2Name), this->type##Type,  FunctionOptions::Static)->Description = ZilchDocumentString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatTwoVecToVec<2, type, NamespaceAndClass::Method>, TwoParameters(this->type##2Type, Param1Name, this->type##2Type, Param2Name), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatTwoVecToVec<3, type, NamespaceAndClass::Method>, TwoParameters(this->type##3Type, Param1Name, this->type##3Type, Param2Name), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatTwoVecToVec<4, type, NamespaceAndClass::Method>, TwoParameters(this->type##4Type, Param1Name, this->type##4Type, Param2Name), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise."));

#define ZilchSplatAllThreeVecToVecAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, Name, p1, p2, p3, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatThreeVecToVec<1, type, NamespaceAndClass::Method>, ThreeParameters(this->type##Type,   p1, this->type##Type,   p2,  this->type##Type, p3),  this->type##Type, FunctionOptions::Static)->Description = ZilchDocumentString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatThreeVecToVec<2, type, NamespaceAndClass::Method>, ThreeParameters(this->type##2Type,  p1, this->type##2Type,  p2, this->type##2Type, p3), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatThreeVecToVec<3, type, NamespaceAndClass::Method>, ThreeParameters(this->type##3Type,  p1, this->type##3Type,  p2, this->type##3Type, p3), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatThreeVecToVec<4, type, NamespaceAndClass::Method>, ThreeParameters(this->type##4Type,  p1, this->type##4Type,  p2, this->type##4Type, p3), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise."));

#define ZilchSplatAllTwoVecAndRealToVecAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, Name, p1, p2, p3, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecAndRealToVec<1, type, NamespaceAndClass::Method>, ThreeParameters(this->type##Type,  p1, this->type##Type,  p2, this->type##Type, p3),  this->type##Type, FunctionOptions::Static)->Description = ZilchDocumentString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecAndRealToVec<2, type, NamespaceAndClass::Method>, ThreeParameters(this->type##2Type, p1, this->type##2Type, p2, this->type##Type, p3), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecAndRealToVec<3, type, NamespaceAndClass::Method>, ThreeParameters(this->type##3Type, p1, this->type##3Type, p2, this->type##Type, p3), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecAndRealToVec<4, type, NamespaceAndClass::Method>, ThreeParameters(this->type##4Type, p1, this->type##4Type, p2, this->type##Type, p3), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocumentString(BuildString(UserDescription, " Performed component-wise."));

  //***************************************************************************
  // Splat a zero parameter function across a vector/matrix.
  template <typename ResultType,
    typename FunctionPointer, FunctionPointer Fn>
    void FullNoParameterSplat(Call& call, ExceptionReport& report)
  {
    size_t size = (size_t)call.GetFunction()->UserData;

    // Get a pointer to our return/output vector
    ResultType* result = (ResultType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < size; ++i)
      result[i] = Fn();
  }

  //***************************************************************************
  // This version of no parameter splatting allows the user to specify an overloaded function (by providing the types manually)
  template <typename ResultType,
    ResultType (*Function)()>
    void FullNoParameterSplatAs(Call& call, ExceptionReport& report)
  {
    FullNoParameterSplat<ResultType,
      TypeOfFunctionPointer(Function), Function>(call, report);
  }

  //***************************************************************************
  // Splat a one parameter function across a vector/matrix.
  template <typename ScalarType0, typename ResultType,
    size_t ScalarType0Offset,
    typename FunctionPointer, FunctionPointer Fn>
    void FullOneParameterSplat(Call& call, ExceptionReport& report)
  {
    size_t size = (size_t)call.GetFunction()->UserData;

    // Get pointers to our input data
    ScalarType0* input0 = (ScalarType0*)call.GetParameterUnchecked(0);

    // Get a pointer to our return/output vector
    ResultType* result = (ResultType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < size; ++i)
    {
      // Call the function bound function
      // (the offset is used to generically control if an input should be only one scalar or another vector type)
      result[i] = Fn(input0[i * ScalarType0Offset]);
    }
  }

  //***************************************************************************
  // This version of one parameter splatting allows the user to specify an overloaded function (by providing the types manually)
  template <typename ScalarType0, typename ResultType,
    typename FnScalarType0,
    size_t ScalarType0Offset,
    ResultType (*Function)(FnScalarType0)>
    void FullOneParameterSplatAs(Call& call, ExceptionReport& report)
  {
    FullOneParameterSplat<ScalarType0, ResultType,
      ScalarType0Offset,
      TypeOfFunctionPointer(Function), Function>(call, report);
  }

  //***************************************************************************
  // Splats a function of the type Result Fn(Scalar0, Scalar1).
  // The offset numbers are used to generically control if an input is a scalar or a vector.
  // ie. scalarOffsets of <1, 1> are used to splat Real3 Max(Real3, Real3) while
  // scalarOffset of <1, 0> are used to splat Real3 Ceil(Real3, Real).

  template <typename ScalarType0, typename ScalarType1, typename ResultType,
    size_t ScalarType0Offset, size_t ScalarType1Offset,
    typename FunctionPointer, FunctionPointer Fn>
    void FullTwoParameterSplat(Call& call, ExceptionReport& report)
  {
    size_t size = (size_t)call.GetFunction()->UserData;

    // Get pointers to our input data
    ScalarType0* input0 = (ScalarType0*)call.GetParameterUnchecked(0);
    ScalarType1* input1 = (ScalarType1*)call.GetParameterUnchecked(1);

    // Get a pointer to our return/output vector
    ResultType* result = (ResultType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < size; ++i)
    {
      // Call the function bound function
      // (the offset is used to generically control if an input should be only one scalar or another vector type)
      result[i] = Fn(input0[i * ScalarType0Offset], input1[i * ScalarType1Offset]);
    }
  }

  //***************************************************************************
  // This version of two parameter splatting allows the user to specify an overloaded function (by providing the types manually)
  template <typename ScalarType0, typename ScalarType1, typename ResultType,
    typename FnScalarType0, typename FnScalarType1,
    size_t ScalarType0Offset, size_t ScalarType1Offset,
    ResultType (*Function)(ScalarType0, ScalarType1)>
    void FullTwoParameterSplatAs(Call& call, ExceptionReport& report)
  {
    FullTwoParameterSplat<ScalarType0, ScalarType1, ResultType,
      ScalarType0Offset, ScalarType1Offset,
      TypeOfFunctionPointer(Function), Function>(call, report);
  }

  //***************************************************************************
  // Splats a function of the type Result Fn(Scalar0, Scalar1, Scalar2).
  // The offset numbers are used to generically control if an input is a scalar or a vector.
  // ie. scalarOffsets of <1, 1, 1> are used to splat Real3 Clamp(Real3, Real3, Real3) while
  // scalarOffset of <1, 1, 0> are used to splat Real3 Lerp(Real3, Real3, Real).
  // This is the most general case splat so that the function parameters can be specified separately
  // (mainly so the the ScalarType can be Real while the function can take const Real&)
  template <typename ScalarType0, typename ScalarType1, typename ScalarType2, typename ResultType,
    size_t ScalarType0Offset, size_t ScalarType1Offset, size_t ScalarType2Offset,
    typename FunctionPointer, FunctionPointer Fn>
    void FullThreeParameterSplat(Call& call, ExceptionReport& report)
  {
    size_t size = (size_t)call.GetFunction()->UserData;

    // Get pointers to our input data
    ScalarType0* input0 = (ScalarType0*)call.GetParameterUnchecked(0);
    ScalarType1* input1 = (ScalarType1*)call.GetParameterUnchecked(1);
    ScalarType2* input2 = (ScalarType2*)call.GetParameterUnchecked(2);

    // Get a pointer to our return/output vector
    ResultType* result = (ResultType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < size; ++i)
    {
      // Call the function bound function
      // (the offset is used to generically control if an input should be only one scalar or another vector type)
      result[i] = Fn(input0[i * ScalarType0Offset], input1[i * ScalarType1Offset], input2[i * ScalarType2Offset]);
    }
  }

  //***************************************************************************
  // This version of two parameter splatting allows the user to specify an overloaded function (by providing the types manually)
  template <typename ScalarType0, typename ScalarType1, typename ScalarType2, typename ResultType,
    typename FnScalarType0, typename FnScalarType1, typename FnScalarType2,
    size_t ScalarType0Offset, size_t ScalarType1Offset, size_t ScalarType2Offset,
    ResultType (*Function)(FnScalarType0, FnScalarType1, FnScalarType2)>
    void FullThreeParameterSplatAs(Call& call, ExceptionReport& report)
  {
    FullThreeParameterSplat<ScalarType0, ScalarType1, ScalarType2, ResultType,
      ScalarType0Offset, ScalarType1Offset, ScalarType2Offset,
      TypeOfFunctionPointer(Function), Function>(call, report);

  }

  //***************************************************************************
  // User data for splatting a function with a custom error message. 
  // Used by Sqrt to deal with negative numbers and a few other functions.
  class SplatWithErrorUserData
  {
  public:

    SplatWithErrorUserData(size_t size, cstr errorFormat, BoundType* boundType) :
      Size(size),
      ErrorFormat(errorFormat),
      Type(boundType)
    {

    }

    size_t Size;
    cstr ErrorFormat;
    BoundType* Type;
  };

  //***************************************************************************
  void AllNonZero(Call& call, ExceptionReport& report)
  {
    SplatWithErrorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<SplatWithErrorUserData>(0);

    size_t elementSize = userData.Type->Size / userData.Size;
    
    // This should always be a small allocation so just allocate it on the stack
    byte* data = (byte*)alloca(elementSize);
    memset(data, 0, elementSize);

    byte* input = call.GetParameterUnchecked(0);

    bool allTrue = true;
    for (size_t i = 0; i < userData.Size; ++i)
    {
      if (memcmp(input + i * elementSize, data, elementSize) == 0)
        allTrue = false;
    }

    call.Set(Call::Return, allTrue);
  }
  
  //***************************************************************************
  void AnyNonZero(Call& call, ExceptionReport& report)
  {
    SplatWithErrorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<SplatWithErrorUserData>(0);

    size_t elementSize = userData.Type->Size / userData.Size;
    
    // This should always be a small allocation so just allocate it on the stack
    byte* data = (byte*)alloca(elementSize);
    memset(data, 0, elementSize);

    byte* input = call.GetParameterUnchecked(0);

    bool anyTrue = false;
    for (size_t i = 0; i < userData.Size; ++i)
    {
      if (memcmp(input + i * elementSize, data, elementSize) != 0)
      {
        anyTrue = true;
        break;
      }
    }

    call.Set(Call::Return, anyTrue);
  }

  //***************************************************************************
  // Splats a function of the type Boolean Fn(Scalar, Scalar&) to
  // Vec(n) Fn(Vec(n)). The function being splatted is a Scalar Fn(Scalar)
  // function that has been altered to return if it failed so an exception
  // can be thrown.
  template <typename ScalarType, bool (*Function)(ScalarType, ScalarType&)>
  void SimpleSplatWithError(Call& call, ExceptionReport& report)
  {
    SplatWithErrorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<SplatWithErrorUserData>(0);
    
    // Get a pointer to our input vector
    ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

    // Get a pointer to our return/output vector
    ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    bool success = true;
    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < userData.Size; ++i)
    {
      // Call the function on the single input (splat)
      success = Function(input[i], result[i]);

      // If the function failed for whatever reason then throw an exception
      if (success == false)
      {
        // The user data of this function should contain a format string with
        // one %s in it to display the input value that failed.
        cstr errFormat = userData.ErrorFormat;
        String inputAsString = userData.Type->GenericToString((byte*)input);
        String msg = String::Format(errFormat, inputAsString.c_str());
        call.GetState()->ThrowException(report, msg);
        return;
      }
    }
  }

  //***************************************************************************
  // Splats a function of the type Boolean Fn(Scalar, Scalar&) to
  // Vec(n) Fn(Vec(n)). The function being splatted is a Scalar Fn(Scalar)
  // function that has been altered to return if it failed so an exception
  // can be thrown.
  template <typename ScalarType0, typename ScalarType1, typename ResultType,
    size_t ScalarType0Offset, size_t ScalarType1Offset,
    bool (*Function)(ScalarType0, ScalarType1, ResultType&)>
  void FullTwoParameterSplatWithError(Call& call, ExceptionReport& report)
  {
    SplatWithErrorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<SplatWithErrorUserData>(0);
    
    // Get a pointer to our input vector
    ScalarType0* input0 = (ScalarType0*)call.GetParameterUnchecked(0);
    ScalarType1* input1 = (ScalarType1*)call.GetParameterUnchecked(1);

    // Get a pointer to our return/output vector
    ResultType* result = (ResultType*)call.GetReturnUnchecked();
    call.MarkReturnAsSet();

    bool success = true;
    // Loop through all the components to apply the given function (splat)
    for (size_t i = 0; i < userData.Size; ++i)
    {
      // Call the function on the single input (splat)
      success = Function(input0[i * ScalarType0Offset], input1[i * ScalarType0Offset], result[i]);

      // If the function failed for whatever reason then throw an exception
      if (success == false)
      {
        // The user data of this function should contain a format string with
        // two %s in it to display the input value that failed.
        cstr errFormat = userData.ErrorFormat;
        String input0AsString = userData.Type->GenericToString((byte*)input0);
        String input1AsString = userData.Type->GenericToString((byte*)input1);
        String msg = String::Format(errFormat, input0AsString.c_str(), input1AsString.c_str());
        call.GetState()->ThrowException(report, msg);
        return;
      }
    }
  }

#define ZilchSetUserDataAndDescription(function, boundType, scalarBoundType, docString)    \
  f->UserData = (void*)(boundType->Size / scalarBoundType->Size);                          \
  if (boundType == scalarBoundType)                                                        \
    f->Description = ZilchDocumentString(docString);                                            \
  else                                                                                     \
    f->Description = ZilchDocumentString(BuildString(docString, " Performed component-wise.")); 

#define ZilchComplexOneParameterSplatBinder(scalarType0, returnType, offset0, function) \
  FullOneParameterSplatAs<scalarType0, returnType, scalarType0, offset0, function>

#define ZilchBindBasicSplat(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString) \
  {                                                                                                                                \
    Zilch::BoundFn boundFn = ZilchComplexOneParameterSplatBinder(scalarType, scalarType, 1, function);                             \
    Function* f = builder.AddBoundFunction(owner, functionName, boundFn, parameters, boundType, FunctionOptions::Static);          \
    ZilchSetUserDataAndDescription(f, boundType, scalarBoundType, docString);                                                      \
  }

#define ZilchBindBasicSplatWithError(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString, errorFormat)     \
  {                                                                                                                                                          \
    Function* f = builder.AddBoundFunction(owner, functionName, SimpleSplatWithError<scalarType, function>, parameters, boundType, FunctionOptions::Static); \
    SplatWithErrorUserData userData(boundType->Size / scalarBoundType->Size, errorFormat, boundType);                                                        \
    f->ComplexUserData.WriteObject(userData);                                                                                                                \
    if (boundType == scalarBoundType)                                                                                                                        \
      f->Description = ZilchDocumentString(docString);                                                                                                            \
    else                                                                                                                                                     \
      f->Description = ZilchDocumentString(BuildString(docString, " Performed component-wise."));                                                                 \
  }

#define ZilchComplexTwoParameterSplatBinder(scalarType0, scalarType1, returnType, offset0, offset1, function) \
  FullTwoParameterSplatAs<scalarType0, scalarType1, returnType, scalarType0, scalarType1, offset0, offset1, function>

#define ZilchBindBasicTwoParamSplat(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString) \
  {                                                                                                                                        \
    Zilch::BoundFn boundFn = ZilchComplexTwoParameterSplatBinder(scalarType, scalarType, scalarType, 1, 1, function);                      \
    Function* f = builder.AddBoundFunction(owner, functionName, boundFn, parameters, boundType, FunctionOptions::Static);                  \
    ZilchSetUserDataAndDescription(f, boundType, scalarBoundType, docString);                                                              \
  }

#define ZilchBindBasicTwoParamSplatWithError(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString, errorFormat) \
  {                                                                                                                                                              \
    Zilch::BoundFn boundFn = FullTwoParameterSplatWithError<scalarType, scalarType, scalarType, 1, 1, function>;                                                 \
    Function* f = builder.AddBoundFunction(owner, functionName, boundFn, parameters, boundType, FunctionOptions::Static);                                        \
    SplatWithErrorUserData userData(boundType->Size / scalarBoundType->Size, errorFormat, boundType);                                                            \
    f->ComplexUserData.WriteObject(userData);                                                                                                                    \
    if (boundType == scalarBoundType)                                                                                                                            \
      f->Description = ZilchDocumentString(docString);                                                                                                                \
    else                                                                                                                                                         \
      f->Description = ZilchDocumentString(BuildString(docString, " Performed component-wise."));                                                                     \
  }

#define ZilchFullThreeParameterSplatBinder(Type0, Type1, Type2, ReturnType, Offset0, Offset1, Offset2, BoundFunction) \
  FullThreeParameterSplat<Type0, Type1, Type2, ReturnType, Offset0, Offset1, Offset2, ZilchTypeOfFunctionPointer(BoundFunction) , BoundFunction>

#define ZilchComplexThreeParameterSplatBinder(scalarType0, scalarType1, scalarType2, returnType, offset0, offset1, offset2, function) \
  FullThreeParameterSplatAs<scalarType0, scalarType1, scalarType2, returnType, scalarType0, scalarType1, scalarType2, offset0, offset1, offset2, function>

#define ZilchBindBasicThreeParamSplat(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString) \
  {                                                                                                                                          \
    Zilch::BoundFn boundFn = ZilchComplexThreeParameterSplatBinder(scalarType, scalarType, scalarType, scalarType, 1, 1, 1, function);       \
    Function* f = builder.AddBoundFunction(owner, functionName, boundFn, parameters, boundType, FunctionOptions::Static);                    \
    ZilchSetUserDataAndDescription(f, boundType, scalarBoundType, docString);                                                                \
  }

  //***************************************************************************
  void Core::SetupBinding(LibraryBuilder& builder)
  {
    // Setup all the primitive types
    BoundType* doubleIntegerType      = ZilchTypeId(DoubleInteger);
    BoundType* doubleRealType         = ZilchTypeId(DoubleReal);
    BoundType* byteType               = ZilchTypeId(Byte);
    BoundType* booleanType            = ZilchTypeId(Boolean);
    BoundType* boolean2Type           = ZilchTypeId(Boolean2);
    BoundType* boolean3Type           = ZilchTypeId(Boolean3);
    BoundType* boolean4Type           = ZilchTypeId(Boolean4);
    BoundType* integerType            = ZilchTypeId(Integer);
    BoundType* integer2Type           = ZilchTypeId(Integer2);
    BoundType* integer3Type           = ZilchTypeId(Integer3);
    BoundType* integer4Type           = ZilchTypeId(Integer4);
    BoundType* realType               = ZilchTypeId(Real);
    BoundType* real2Type              = ZilchTypeId(Real2);
    BoundType* real3Type              = ZilchTypeId(Real3);
    BoundType* real4Type              = ZilchTypeId(Real4);
    BoundType* quaternionType         = ZilchTypeId(Quaternion);
    BoundType* anyHandleType          = new BoundType("AnyHandle", TypeCopyMode::ReferenceType, 0, 0);
    BoundType* nullType               = new BoundType("Null", TypeCopyMode::ReferenceType, 0, 0);
    BoundType* voidType               = new BoundType("Void", TypeCopyMode::ValueType, 0, 0);
    BoundType* errorType              = new BoundType("[ErrorType]", TypeCopyMode::ValueType, 0, 0);
    BoundType* overloadedMethodsType  = new BoundType("[MultipleMethodsOfTheSameName]", TypeCopyMode::ValueType, 0, 0);
    DelegateType* anyDelegateType     = builder.GetDelegateType(ParameterArray(), voidType);

    // Add ourselves to the library
    builder.AddRawBoundType(anyHandleType);
    builder.AddRawBoundType(nullType);
    builder.AddRawBoundType(voidType);
    builder.AddRawBoundType(errorType);
    builder.AddRawBoundType(overloadedMethodsType);

    // Store the primitive types as global constants
    this->ByteType              = byteType;
    this->BooleanType           = booleanType;
    this->Boolean2Type          = boolean2Type;
    this->Boolean3Type          = boolean3Type;
    this->Boolean4Type          = boolean4Type;
    this->IntegerType           = integerType;
    this->Integer2Type          = integer2Type;
    this->Integer3Type          = integer3Type;
    this->Integer4Type          = integer4Type;
    this->RealType              = realType;
    this->Real2Type             = real2Type;
    this->Real3Type             = real3Type;
    this->Real4Type             = real4Type;
    this->QuaternionType        = quaternionType;
    this->DoubleIntegerType     = doubleIntegerType;
    this->DoubleRealType        = doubleRealType;
    this->VoidType              = voidType;
    this->NullType              = nullType;
    this->ErrorType             = errorType;
    this->OverloadedMethodsType = overloadedMethodsType;
    this->AnyDelegateType       = anyDelegateType;
    this->AnyHandleType         = anyHandleType;

    // Fill out the real array
    this->BooleanTypes[0] = booleanType;
    this->BooleanTypes[1] = boolean2Type;
    this->BooleanTypes[2] = boolean3Type;
    this->BooleanTypes[3] = boolean4Type;
    this->AllBooleanTypes.push_back(booleanType);
    this->AllBooleanTypes.push_back(boolean2Type);
    this->AllBooleanTypes.push_back(boolean3Type);
    this->AllBooleanTypes.push_back(boolean4Type);
    this->IntegerTypes[0] = integerType;
    this->IntegerTypes[1] = integer2Type;
    this->IntegerTypes[2] = integer3Type;
    this->IntegerTypes[3] = integer4Type;
    this->AllIntegerTypes.push_back(integerType);
    this->AllIntegerTypes.push_back(integer2Type);
    this->AllIntegerTypes.push_back(integer3Type);
    this->AllIntegerTypes.push_back(integer4Type);
    this->RealTypes[0] = realType;
    this->RealTypes[1] = real2Type;
    this->RealTypes[2] = real3Type;
    this->RealTypes[3] = real4Type;
    this->AllRealTypes.push_back(realType);
    this->AllRealTypes.push_back(real2Type);
    this->AllRealTypes.push_back(real3Type);
    this->AllRealTypes.push_back(real4Type);
    this->VectorScalarBoundTypes[VectorScalarTypes::Real] = realType;
    this->VectorScalarBoundTypes[VectorScalarTypes::Integer] = integerType;
    this->VectorScalarBoundTypes[VectorScalarTypes::Boolean] = booleanType;
    this->VectorTypes[VectorScalarTypes::Real] = this->RealTypes;
    this->VectorTypes[VectorScalarTypes::Integer] = this->IntegerTypes;
    this->VectorTypes[VectorScalarTypes::Boolean] = this->BooleanTypes;
    this->MatrixElementTypes[0] = realType;
    this->MatrixElementTypes[1] = integerType;
    this->MatrixElementTypes[2] = booleanType;

    // Setup the functions to set a value to 1 for the each primary scalar type
    ScalarTypeOneFunctions[VectorScalarTypes::Real] = ScalarTypeRealOne;
    ScalarTypeOneFunctions[VectorScalarTypes::Integer] = ScalarTypeIntegerOne;
    ScalarTypeOneFunctions[VectorScalarTypes::Boolean] = ScalarTypeBooleanOne;

    // Create the one special any type (there should only ever be one instantiation of this!)
    this->AnythingType = new AnyType();
    builder.BuiltLibrary->OwnedTypes.push_back(this->AnythingType);

    // Add the array template instantiator
    StringArray arrayArguments;
    arrayArguments.push_back("Type");
    builder.AddTemplateInstantiator("Property", InstantiatePropertyDelegate, arrayArguments, nullptr);
    builder.AddTemplateInstantiator("Array", InstantiateArray, arrayArguments, nullptr);

    StringArray keyValueArguments;
    keyValueArguments.push_back("Key");
    keyValueArguments.push_back("Value");

    // Add the hash-map template instantiator
    builder.AddTemplateInstantiator("HashMap", InstantiateHashMap, keyValueArguments, nullptr);
    builder.AddTemplateInstantiator("HashMapRange", InstantiateHashMapRange, keyValueArguments, (void*)(size_t)HashMapRangeMode::Pair);
    builder.AddTemplateInstantiator("HashMapKeyRange", InstantiateHashMapRange, StringArray(ZeroInit, "Key"), (void*)(size_t)HashMapRangeMode::Key);
    builder.AddTemplateInstantiator("HashMapValueRange", InstantiateHashMapRange, StringArray(ZeroInit, "Value"), (void*)(size_t)HashMapRangeMode::Value);
    builder.AddTemplateInstantiator("KeyValue", InstantiateKeyValue, keyValueArguments, nullptr);

    // Create the string type as a reference type
    BoundType* stringRangeType = ZilchTypeId(StringRangeExtended);
    BoundType* stringType = ZilchTypeId(String);
    BoundType* runeIteratorType = ZilchTypeId(RuneIterator);

    stringType->HandleManager = ZilchManagerId(StringManager);
    // Old functions that should eventually be removed
    builder.AddBoundFunction(stringType, "SubString", SubString, TwoParameters(integerType, "start", "length"), stringType, FunctionOptions::None);
    builder.AddBoundFunction(stringType, Zilch::OperatorGet, StringGetChar, OneParameter(integerType, "index"), integerType, FunctionOptions::None);

    builder.AddBoundFunction(stringType, "SubStringBytes", SubStringBytes, TwoParameters(integerType, "startByteIndex", "lengthInBytes"), stringRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Constructs a substring based upon a number of bytes. WARNING: strings are UTF8 so indexing by bytes could produce unexpected results on non-ascii strings.");
    builder.AddBoundFunction(stringType, "RuneIteratorFromByteIndex", StringRuneIteratorFromByteIndex, OneParameter(integerType, "byteIndex"), runeIteratorType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Finds the iterator from a byte index. WARNING: Strings are UTF8 and constructing an iterator from bytes indices can make an iterator in the middle of a rune.");
    builder.AddBoundFunction(stringType, "RuneIteratorFromRuneIndex", StringRuneIteratorFromRuneIndex, OneParameter(integerType, "runeIndex"), runeIteratorType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Finds the iterator from a rune index (the 'character' index). WARNING: this may be slow as finding an iterator from rune index requires a linear search.");
    builder.AddBoundProperty(stringType, "All", stringRangeType, nullptr, StringAll, FunctionOptions::None)
      ->Description = ZilchDocumentString("Converts the string into a string range.");
    builder.AddBoundProperty(stringType, "ByteCount", integerType, nullptr, StringByteCount, MemberOptions::None)
      ->Description = ZilchDocumentString("Returns the number of bytes in the string.");
    builder.AddBoundProperty(stringType, "Count", integerType, nullptr, StringByteCount, MemberOptions::None)
      ->Description = ZilchDocumentString("Returns the number of bytes in the string.");
    builder.AddBoundFunction(stringType, "Concatenate", StringConcatenate, TwoParameters(stringType), stringType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Combines the two strings into a new string.");
    builder.AddBoundFunction(stringType, "Concatenate", StringRangeConcatenate, TwoParameters(stringRangeType), stringType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Combines the two string ranges into a new string.");
    builder.AddBoundFunction(stringType, "FromChar", StringFromChar, OneParameter(integerType), stringType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Constructs a string from the ascii index of a character.");
    builder.AddBoundFunction(stringType, "Contains", StringContains, OneParameter(stringRangeType), booleanType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns if the string contains the specified substring.");
    builder.AddBoundFunction(stringType, "Compare", StringCompare, TwoParameters(stringType, "left", "right"), integerType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Compares the two strings and returns an integer to denote their relative sort order.");
    builder.AddBoundFunction(stringRangeType, "Compare", StringRangeCompare, TwoParameters(stringRangeType, "left", "right"), integerType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Compares the two string ranges and returns an integer to denote their relative sort order.");
    builder.AddBoundFunction(stringType, "CompareTo", StringCompareTo, OneParameter(stringRangeType), integerType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Compares this string to the given string and returns an integer to denote their relative sort order.");
    builder.AddBoundFunction(stringType, "StartsWith", StringStartsWith, OneParameter(stringRangeType), booleanType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns if the string starts with the specified substring.");
    builder.AddBoundFunction(stringType, "EndsWith", StringEndsWith, OneParameter(stringRangeType), booleanType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns if the string ends with the specified substring.");
    builder.AddBoundFunction(stringType, "TrimStart", StringTrimStart, ParameterArray(), stringRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Trims all leading whitespace.");
    builder.AddBoundFunction(stringType, "TrimEnd", StringTrimEnd, ParameterArray(), stringRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Trims all trailing whitespace.");
    builder.AddBoundFunction(stringType, "Trim", StringTrim, ParameterArray(), stringRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Trims all leading and trailing whitespace.");
    builder.AddBoundFunction(stringType, "ToLower", StringToLower, ParameterArray(), stringType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns a copy of the string that has been converted to lowercase.");
    builder.AddBoundFunction(stringType, "ToUpper", StringToUpper, ParameterArray(), stringType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns a copy of the string that has been converted to uppercase.");
    builder.AddBoundFunction(stringType, "Replace", StringReplace, TwoParameters(stringRangeType, "oldValue", "newValue"), stringType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns a new string with all occurances of a substrings replaced with another substring.");
    builder.AddBoundFunction(stringType, "FindRangeInclusive", StringFindRangeInclusive, TwoParameters(stringRangeType, "startRange", "endRange"), stringRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Finds the first StringRange that starts with 'startRange' and ends with 'endRange'. This substring includes 'startRange' and 'endRange'.");
    builder.AddBoundFunction(stringType, "FindRangeExclusive", StringFindRangeExclusive, TwoParameters(stringRangeType, "startRange", "endRange"), stringRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Finds the first StringRange that starts with 'startRange' and ends with 'endRange'. This substring excludes 'startRange' and 'endRange'.");
    builder.AddBoundFunction(stringType, "FindFirstOf", StringFindFirstOf, OneParameter(stringRangeType), stringRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns a StringRange that contains the first occurrence of given StringRange.");
    builder.AddBoundFunction(stringType, "FindLastOf", StringFindLastOf, OneParameter(stringRangeType), stringRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns a StringRange that contains the last occurrence of given StringRange.");
    builder.AddBoundFunction(stringType, "Join", JoinTwoStrings, ThreeParameters(stringRangeType, "separator", "value0", "value1"), stringType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Concatenates the given strings with the given separator string.");
    builder.AddBoundFunction(stringType, "Join", JoinThreeStrings, FourParameters(stringRangeType, "separator", "value0", "value1", "value2"), stringType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Concatenates the given strings with the given separator string.");
    builder.AddBoundFunction(stringType, "Join", JoinFourStrings, FiveParameters(stringRangeType, "separator", "value0", "value1", "value2", "value3"), stringType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Concatenates the given strings with the given separator string.");
    builder.AddBoundFunction(stringType, "IsNullOrEmpty", StringRangeIsNullOrEmpty, OneParameter(stringRangeType), booleanType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Returns if the given string is null or empty.");
    builder.AddBoundFunction(stringType, "IsNullOrWhitespace", StringRangeIsNullOrWhitespace, OneParameter(stringRangeType), booleanType, FunctionOptions::Static)
      ->Description = ZilchDocumentString("Returns if the given string is null, empty, or all whitespace.");

    // Bind the FormatC function which has "variadic arguments"
    ParameterArray parameters;
    DelegateParameter& formatParameter = parameters.push_back();
    formatParameter.Name = "format";
    formatParameter.ParameterType = stringType;
    for (size_t i = 0; i < 10; ++i)
    {
      DelegateParameter& parameter = parameters.push_back();
      parameter.ParameterType = ZilchTypeId(Any);
      Function* formatFunction = builder.AddBoundFunction(stringType, "FormatC", StringFormatC, parameters, stringType, FunctionOptions::Static);
      formatFunction->UserData = (void*)(i + 1);
    }
    
    this->StringType = stringType;
    this->StringRangeType = stringRangeType;
    ZilchBindMethod(builder, integerType, &ZilchParseInteger, ZilchNoOverload, "Parse", ZilchNoNames)->Description = ZilchDocumentString("Attempt to convert the given StringRange to an Integer. If parsing fails 0 is returned.");
    ZilchBindMethod(builder, realType, &ZilchParseReal, ZilchNoOverload, "Parse", ZilchNoNames)->Description = ZilchDocumentString("Attempt to convert the given StringRange to a Real. If parsing fails 0 is returned.");

    // Bind any stringify functions
    byteType          ->ToStringFunction = ByteToString;
    booleanType       ->ToStringFunction = BooleanToString;
    boolean2Type      ->ToStringFunction = Boolean2ToString;
    boolean3Type      ->ToStringFunction = Boolean3ToString;
    boolean4Type      ->ToStringFunction = Boolean4ToString;
    integerType       ->ToStringFunction = IntegerToString;
    integer2Type      ->ToStringFunction = Integer2ToString;
    integer3Type      ->ToStringFunction = Integer3ToString;
    integer4Type      ->ToStringFunction = Integer4ToString;
    realType          ->ToStringFunction = RealToString;
    real2Type         ->ToStringFunction = Real2ToString;
    real3Type         ->ToStringFunction = Real3ToString;
    real4Type         ->ToStringFunction = Real4ToString;
    quaternionType    ->ToStringFunction = QuaternionToString;
    doubleIntegerType ->ToStringFunction = DoubleIntegerToString;
    doubleRealType    ->ToStringFunction = DoubleRealToString;
    stringType        ->ToStringFunction = StringToString;
    
    // Add ourselves to the library
    BoundType* math = builder.AddBoundType("Math", TypeCopyMode::ReferenceType, 0);
    MathType = math;

    // Bind default constructors to the vector types
    builder.AddBoundDefaultConstructor(booleanType,     VectorDefaultConstructor<1, Boolean>);
    builder.AddBoundDefaultConstructor(boolean2Type,    VectorDefaultConstructor<2, Boolean>);
    builder.AddBoundDefaultConstructor(boolean3Type,    VectorDefaultConstructor<3, Boolean>);
    builder.AddBoundDefaultConstructor(boolean4Type,    VectorDefaultConstructor<4, Boolean>);
    builder.AddBoundDefaultConstructor(integerType,     VectorDefaultConstructor<1, Integer>);
    builder.AddBoundDefaultConstructor(integer2Type,    VectorDefaultConstructor<2, Integer>);
    builder.AddBoundDefaultConstructor(integer3Type,    VectorDefaultConstructor<3, Integer>);
    builder.AddBoundDefaultConstructor(integer4Type,    VectorDefaultConstructor<4, Integer>);
    builder.AddBoundDefaultConstructor(realType,        VectorDefaultConstructor<1, Real>);
    builder.AddBoundDefaultConstructor(real2Type,       VectorDefaultConstructor<2, Real>);
    builder.AddBoundDefaultConstructor(real3Type,       VectorDefaultConstructor<3, Real>);
    builder.AddBoundDefaultConstructor(real4Type,       VectorDefaultConstructor<4, Real>);
    builder.AddBoundDefaultConstructor(quaternionType,  QuaternionDefaultConstructor);

    // The scalar constructors
    {
      ParameterArray parameters;
      DelegateParameter& scalarParam = parameters.push_back();
      scalarParam.ParameterType = this->RealType;
      scalarParam.Name = "scalar";

      // Bind constructors to the vector types
      GenerateVectorScalarConstructor<1, Boolean>(builder, booleanType,   booleanType);
      GenerateVectorScalarConstructor<2, Boolean>(builder, boolean2Type,  booleanType);
      GenerateVectorScalarConstructor<3, Boolean>(builder, boolean3Type,  booleanType);
      GenerateVectorScalarConstructor<4, Boolean>(builder, boolean4Type,  booleanType);
      GenerateVectorScalarConstructor<1, Integer>(builder, integerType,   integerType);
      GenerateVectorScalarConstructor<2, Integer>(builder, integer2Type,  integerType);
      GenerateVectorScalarConstructor<3, Integer>(builder, integer3Type,  integerType);
      GenerateVectorScalarConstructor<4, Integer>(builder, integer4Type,  integerType);
      GenerateVectorScalarConstructor<1, Real   >(builder, realType,      realType);
      GenerateVectorScalarConstructor<2, Real   >(builder, real2Type,     realType);
      GenerateVectorScalarConstructor<3, Real   >(builder, real3Type,     realType);
      GenerateVectorScalarConstructor<4, Real   >(builder, real4Type,     realType);
    }

    // Generate the different permutations of constructors (no need to do the singles, they only have the scalar/default constructors)
    GenerateVectorComponentConstructors<2, Boolean>(builder, boolean2Type,    this->BooleanTypes);
    GenerateVectorComponentConstructors<3, Boolean>(builder, boolean3Type,    this->BooleanTypes);
    GenerateVectorComponentConstructors<4, Boolean>(builder, boolean4Type,    this->BooleanTypes);
    GenerateVectorComponentConstructors<2, Integer>(builder, integer2Type,    this->IntegerTypes);
    GenerateVectorComponentConstructors<3, Integer>(builder, integer3Type,    this->IntegerTypes);
    GenerateVectorComponentConstructors<4, Integer>(builder, integer4Type,    this->IntegerTypes);
    GenerateVectorComponentConstructors<2, Real   >(builder, real2Type,       this->RealTypes);
    GenerateVectorComponentConstructors<3, Real   >(builder, real3Type,       this->RealTypes);
    GenerateVectorComponentConstructors<4, Real   >(builder, real4Type,       this->RealTypes);
    GenerateVectorComponentConstructors<4, Real   >(builder, quaternionType,  this->RealTypes);
    
    // Generate swizzles for all of our vector types
    GenerateVectorSwizzles<1, Boolean >(builder, booleanType,     this->BooleanTypes);
    GenerateVectorSwizzles<2, Boolean >(builder, boolean2Type,    this->BooleanTypes);
    GenerateVectorSwizzles<3, Boolean >(builder, boolean3Type,    this->BooleanTypes);
    GenerateVectorSwizzles<4, Boolean >(builder, boolean4Type,    this->BooleanTypes);
    GenerateVectorSwizzles<1, Integer >(builder, integerType,     this->IntegerTypes);
    GenerateVectorSwizzles<2, Integer >(builder, integer2Type,    this->IntegerTypes);
    GenerateVectorSwizzles<3, Integer >(builder, integer3Type,    this->IntegerTypes);
    GenerateVectorSwizzles<4, Integer >(builder, integer4Type,    this->IntegerTypes);
    GenerateVectorSwizzles<1, Real    >(builder, realType,        this->RealTypes);
    GenerateVectorSwizzles<2, Real    >(builder, real2Type,       this->RealTypes);
    GenerateVectorSwizzles<3, Real    >(builder, real3Type,       this->RealTypes);
    GenerateVectorSwizzles<4, Real    >(builder, real4Type,       this->RealTypes);
    GenerateVectorSwizzles<4, Real    >(builder, quaternionType,  this->RealTypes);

    // Every vector gets a count which tells you how many elements there are, for generic programming
    builder.AddBoundProperty(booleanType,    "Count", this->IntegerType, nullptr, VectorCount<1>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(boolean2Type,   "Count", this->IntegerType, nullptr, VectorCount<2>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(boolean3Type,   "Count", this->IntegerType, nullptr, VectorCount<3>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(boolean4Type,   "Count", this->IntegerType, nullptr, VectorCount<4>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(integerType,    "Count", this->IntegerType, nullptr, VectorCount<1>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(integer2Type,   "Count", this->IntegerType, nullptr, VectorCount<2>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(integer3Type,   "Count", this->IntegerType, nullptr, VectorCount<3>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(integer4Type,   "Count", this->IntegerType, nullptr, VectorCount<4>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(realType,       "Count", this->IntegerType, nullptr, VectorCount<1>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(real2Type,      "Count", this->IntegerType, nullptr, VectorCount<2>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(real3Type,      "Count", this->IntegerType, nullptr, VectorCount<3>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(real4Type,      "Count", this->IntegerType, nullptr, VectorCount<4>, FunctionOptions::None)->IsHidden = true;
    builder.AddBoundProperty(quaternionType, "Count", this->IntegerType, nullptr, VectorCount<4>, FunctionOptions::None)->IsHidden = true;
    
    // Bind the get functions for vectors (indexing)
    builder.AddBoundFunction(booleanType,     OperatorGet, VectorGet<1, Boolean>, OneParameter(this->IntegerType), this->BooleanType, FunctionOptions::None);
    builder.AddBoundFunction(boolean2Type,    OperatorGet, VectorGet<2, Boolean>, OneParameter(this->IntegerType), this->BooleanType, FunctionOptions::None);
    builder.AddBoundFunction(boolean3Type,    OperatorGet, VectorGet<3, Boolean>, OneParameter(this->IntegerType), this->BooleanType, FunctionOptions::None);
    builder.AddBoundFunction(boolean4Type,    OperatorGet, VectorGet<4, Boolean>, OneParameter(this->IntegerType), this->BooleanType, FunctionOptions::None);
    builder.AddBoundFunction(integerType,     OperatorGet, VectorGet<1, Integer>, OneParameter(this->IntegerType), this->IntegerType, FunctionOptions::None);
    builder.AddBoundFunction(integer2Type,    OperatorGet, VectorGet<2, Integer>, OneParameter(this->IntegerType), this->IntegerType, FunctionOptions::None);
    builder.AddBoundFunction(integer3Type,    OperatorGet, VectorGet<3, Integer>, OneParameter(this->IntegerType), this->IntegerType, FunctionOptions::None);
    builder.AddBoundFunction(integer4Type,    OperatorGet, VectorGet<4, Integer>, OneParameter(this->IntegerType), this->IntegerType, FunctionOptions::None);
    builder.AddBoundFunction(realType,        OperatorGet, VectorGet<1, Real>,    OneParameter(this->IntegerType), this->RealType,    FunctionOptions::None);
    builder.AddBoundFunction(real2Type,       OperatorGet, VectorGet<2, Real>,    OneParameter(this->IntegerType), this->RealType,    FunctionOptions::None);
    builder.AddBoundFunction(real3Type,       OperatorGet, VectorGet<3, Real>,    OneParameter(this->IntegerType), this->RealType,    FunctionOptions::None);
    builder.AddBoundFunction(real4Type,       OperatorGet, VectorGet<4, Real>,    OneParameter(this->IntegerType), this->RealType,    FunctionOptions::None);
    builder.AddBoundFunction(quaternionType,  OperatorGet, VectorGet<4, Real>,    OneParameter(this->IntegerType), this->RealType,    FunctionOptions::None);
    
    // Bind the set functions for vectors (indexing)
    builder.AddBoundFunction(booleanType,     OperatorSet, VectorSet<1, Boolean>, TwoParameters(this->IntegerType, this->BooleanType),  this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(boolean2Type,    OperatorSet, VectorSet<2, Boolean>, TwoParameters(this->IntegerType, this->BooleanType),  this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(boolean3Type,    OperatorSet, VectorSet<3, Boolean>, TwoParameters(this->IntegerType, this->BooleanType),  this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(boolean4Type,    OperatorSet, VectorSet<4, Boolean>, TwoParameters(this->IntegerType, this->BooleanType),  this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(integerType,     OperatorSet, VectorSet<1, Integer>, TwoParameters(this->IntegerType, this->IntegerType),  this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(integer2Type,    OperatorSet, VectorSet<2, Integer>, TwoParameters(this->IntegerType, this->IntegerType),  this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(integer3Type,    OperatorSet, VectorSet<3, Integer>, TwoParameters(this->IntegerType, this->IntegerType),  this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(integer4Type,    OperatorSet, VectorSet<4, Integer>, TwoParameters(this->IntegerType, this->IntegerType),  this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(realType,        OperatorSet, VectorSet<1, Real>,    TwoParameters(this->IntegerType, this->RealType),     this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(real2Type,       OperatorSet, VectorSet<2, Real>,    TwoParameters(this->IntegerType, this->RealType),     this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(real3Type,       OperatorSet, VectorSet<3, Real>,    TwoParameters(this->IntegerType, this->RealType),     this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(real4Type,       OperatorSet, VectorSet<4, Real>,    TwoParameters(this->IntegerType, this->RealType),     this->VoidType, FunctionOptions::None);
    builder.AddBoundFunction(quaternionType,  OperatorSet, VectorSet<4, Real>,    TwoParameters(this->IntegerType, this->RealType),     this->VoidType, FunctionOptions::None);

    // The names of the axes for each index
    const char* axes[4] = {"XAxis", "YAxis", "ZAxis", "WAxis"};
    // Setup some generic functions for all vector types
    for(size_t typeIndex = 0; typeIndex < VectorScalarTypes::Size; ++typeIndex)
    {
      // The Vector1/2/3/4 types for the current scalar type
      BoundType** vectorTypes = this->VectorTypes[typeIndex];

      for(size_t dimension = 0; dimension < MaxComponents; ++dimension)
      {
        // Don't forget to +1 the dimension
        VectorUserData userData(dimension + 1, typeIndex);

        BoundType* vectorType = vectorTypes[dimension];
        Property* prop = nullptr;
        Function* fn = nullptr;

        // Add a get property for the number of elements in the vector
        prop = builder.AddBoundProperty(vectorType, "Count", integerType, nullptr, VectorCount, FunctionOptions::Static);
        *(size_t*)(&prop->Get->UserData) = userData.Count;
        prop->Description = ZilchDocumentString("The number of elements in the vector.");

        // Add a method to get an axis by index
        fn = builder.AddBoundFunction(vectorType, "GetAxis", VectorGetAxis, OneParameter(integerType), vectorType, FunctionOptions::Static);
        fn->ComplexUserData.WriteObject(userData);
        fn->Description = ZilchDocumentString("Returns an axis vector from the given index (ie. 0 is XAxis, 1 is YAxis, etc...");
       
        // Add a property for the zero vector
        prop = builder.AddBoundProperty(vectorType, "Zero", vectorType, nullptr, VectorZeroFunction, FunctionOptions::Static);
        prop->Get->ComplexUserData.WriteObject(userData);
        prop->Description = ZilchDocumentString("The zero vector (a vector containing all zeroes).");

        // Add a property for each axis (e.g. Real3.XAxis, Real3.YAxis, etc...)
        for(size_t axis = 0; axis <= dimension; ++axis)
        {
          prop = builder.AddBoundProperty(vectorType, axes[axis], vectorType, nullptr, VectorAxisFunction, FunctionOptions::Static);
          prop->Get->UserData = (void*)axis;
          prop->Get->ComplexUserData.WriteObject(userData); 
        }

        // Simple helper macro to make binding the below splats easier
      #define ZilchNoParameterSplat(builder, type, name, scalarType, fn, count, description)            \
        {                                                                                               \
          BoundFn boundFn = FullNoParameterSplatAs<scalarType, fn>;                                     \
          prop = builder.AddBoundProperty(type, name, type, nullptr, boundFn, FunctionOptions::Static); \
          prop->Get->UserData = (void*)count;                                                           \
          prop->Description = ZilchDocumentString(description);                                         \
        }

        // Add splats for the extremal values for types that matter (Real and Integer)
        if(typeIndex == VectorScalarTypes::Real)
        {
          ZilchNoParameterSplat(builder, vectorType, "PositiveMax", Real, ZilchRealPositiveMax, userData.Count, "The largest (most positive) value that can be represented by a Real.");
          ZilchNoParameterSplat(builder, vectorType, "PositiveValueClosestToZero", Real, ZilchRealPositiveValueClosestToZero, userData.Count, "The positive value closest to zero that can be represented by a Real.");
          ZilchNoParameterSplat(builder, vectorType, "NegativeValueClosestToZero", Real, ZilchRealNegativeValueClosestToZero, userData.Count, "The negative value closest to zero that can be represented by a Real.");
          ZilchNoParameterSplat(builder, vectorType, "NegativeMin", Real, ZilchRealNegativeMin, userData.Count, "The smallest (most negative) value that can be represented by a Real.");
        }
        else if(typeIndex == VectorScalarTypes::Integer)
        {
          ZilchNoParameterSplat(builder, vectorType, "PositiveMax", Integer, ZilchIntegerPositiveMax, userData.Count, "The largest (most positive) value that can be represented by an Integer.");
          ZilchNoParameterSplat(builder, vectorType, "PositiveValueClosestToZero", Integer, ZilchIntegerPositiveValueClosestToZero, userData.Count, "The positive value closest to zero that can be represented by an Integer.");
          ZilchNoParameterSplat(builder, vectorType, "NegativeValueClosestToZero", Integer, ZilchIntegerNegativeValueClosestToZero, userData.Count, "The negative value closest to zero that can be represented by an Integer.");
          ZilchNoParameterSplat(builder, vectorType, "NegativeMin", Integer, ZilchIntegerNegativeMin, userData.Count, "The smallest (most negative) value that can be represented by an Integer.");
        }
      #undef ZilchNoParameterSplat

      }
    }


    FunctionOptions::Enum options = FunctionOptions::Static;

    //ZilchBindMethod(builder, math, (Real3 (*)(Real3Param, Real3Param, Real)) &Math::RotateVector
    ZilchBindMethod(builder, math, &Math::RotateVector, ZilchNoOverload, "RotateVector", "vector, axis, radians")
      ->Description = ZilchDocumentString("Rotate a vector about an axis by the given radians.");

    ZilchBindMethod(builder, math, &Math::Angle, (Real (*)(Real2Param, Real2Param)), "AngleBetween", ZilchNoNames);

    ZilchBindMethod(builder, math, &Math::Angle, (Real (*)(Real3Param, Real3Param)), "AngleBetween", ZilchNoNames)
      ->Description = ZilchDocumentString("Returns the angle between two Real3s in radians.");

    ZilchBindMethod(builder, math, &Math::Angle, (Real (*)(QuaternionParam, QuaternionParam)), "AngleBetween", ZilchNoNames)
      ->Description = ZilchDocumentString("Returns the angle between two Quaternions in radians.");

    ZilchBindMethod(builder, math, &Math::SafeSlerp, (Real2       (*)(Real2Param,       Real2Param,       Real)), "Slerp", "start, end, t")
      ->Description = ZilchDocumentString("Spherical linear interpolation. Used to interpolate between two vectors by the parameter t.");
    ZilchBindMethod(builder, math, &Math::SafeSlerp, (Real3       (*)(Real3Param,       Real3Param,       Real)), "Slerp", "start, end, t")
      ->Description = ZilchDocumentString("Spherical linear interpolation. Used to interpolate between two vectors by the parameter t.");
    ZilchBindMethod(builder, math, &Math::Slerp,     (Quaternion  (*)(QuaternionParam,  QuaternionParam,  Real)), "Slerp", "start, end, t")
      ->Description = ZilchDocumentString("Spherical linear interpolation. Used to interpolate between two rotations by the parameter t.");

    ZilchBindMethod(builder, math, &Math::SafeRotateTowards, (Real2 (*)(Real2Param, Real2Param, Real)), "RotateTowards", "p0, p1, maxRadians")
      ->Description = ZilchDocumentString("Rotate a vector towards another vector changing at most maxRadians.");

    ZilchBindMethod(builder, math, &Math::SafeRotateTowards, (Real3 (*)(Real3Param, Real3Param, Real)), "RotateTowards", "p0, p1, maxRadians")
      ->Description = ZilchDocumentString("Rotate a vector towards another vector changing at most maxRadians.");

    ZilchBindMethod(builder, math, &Math::RotateTowards, (Quaternion (*)(QuaternionParam, QuaternionParam, Real)), "RotateTowards", "p0, p1, maxRadians")
      ->Description = ZilchDocumentString("Rotate a quaternion towards another quaternion changing at most maxRadians.");

    ZilchBindMethod(builder, math, &Math::SignedAngle, ZilchNoOverload, "SignedAngle", "p0, p1, up")
      ->Description = ZilchDocumentString("Get the rotation angle between two vectors in radians.");

    ZilchBindMethod(builder, math, &Math::Angle2D, ZilchNoOverload, "Angle2D", ZilchNoNames)
      ->Description = ZilchDocumentString("Computes the angle (in radians) about the z-axis between the vector and the x-axis.");

    ZilchBindMethod(builder, math, &Math::ProjectOnVector, (Real2(*)(Real2Param, Real2Param)), "ProjectOnVector", "toBeProjected, normalizedVector")
      ->Description = ZilchDocumentString("Projects the input vector onto the given normalized vector.");
    ZilchBindMethod(builder, math, &Math::ProjectOnVector, (Real3(*)(Real3Param, Real3Param)), "ProjectOnVector", "toBeProjected, normalizedVector")
      ->Description = ZilchDocumentString("Projects the input vector onto the given normalized vector.");
    ZilchBindMethod(builder, math, &Math::ProjectOnVector, (Real4(*)(Real4Param, Real4Param)), "ProjectOnVector", "toBeProjected, normalizedVector")
      ->Description = ZilchDocumentString("Projects the input vector onto the given normalized vector.");
    // Legacy project function (mostly to not break things like the swept controller)
    ZilchBindMethod(builder, math, &Math::ProjectOnVector, (Real3(*)(Real3Param, Real3Param)), "Project", "toBeProjected, normalizedVector")
      ->Description = ZilchDocumentString("Projects the input vector onto the given normalized vector. Note: This function is legacy. Instead call ProjectOnVector.");

    ZilchBindMethod(builder, math, &Math::ProjectOnPlane, (Real2(*)(Real2Param, Real2Param)), "ProjectOnPlane", "toBeProjected, planeNormal")
      ->Description = ZilchDocumentString("Projects the input vector onto plane defined by the given normal.");
    ZilchBindMethod(builder, math, &Math::ProjectOnPlane, (Real3(*)(Real3Param, Real3Param)), "ProjectOnPlane", "toBeProjected, planeNormal")
      ->Description = ZilchDocumentString("Projects the input vector onto plane defined by the given normal.");
    ZilchBindMethod(builder, math, &Math::ProjectOnPlane, (Real4(*)(Real4Param, Real4Param)), "ProjectOnPlane", "toBeProjected, planeNormal")
      ->Description = ZilchDocumentString("Projects the input vector onto plane defined by the given normal.");

    ZilchBindMethod(builder, math, &Math::ReflectAcrossPlane, (Real2(*)(Real2Param, Real2Param)), "ReflectAcrossPlane", "toBeReflected, planeNormal")
      ->Description = ZilchDocumentString("Reflects the input vector across the plane defined by the given normal.");
    ZilchBindMethod(builder, math, &Math::ReflectAcrossPlane, (Real3(*)(Real3Param, Real3Param)), "ReflectAcrossPlane", "toBeReflected, planeNormal")
      ->Description = ZilchDocumentString("Reflects the input vector across the plane defined by the given normal.");
    ZilchBindMethod(builder, math, &Math::ReflectAcrossPlane, (Real4(*)(Real4Param, Real4Param)), "ReflectAcrossPlane", "toBeReflected, planeNormal")
      ->Description = ZilchDocumentString("Reflects the input vector across the plane defined by the given normal.");

    ZilchBindMethod(builder, math, &Math::ReflectAcrossVector, (Real2(*)(Real2Param, Real2Param)), "ReflectAcrossVector", "toBeReflected, vector")
      ->Description = ZilchDocumentString("Reflects the input vector across the given vector.");
    ZilchBindMethod(builder, math, &Math::ReflectAcrossVector, (Real3(*)(Real3Param, Real3Param)), "ReflectAcrossVector", "toBeReflected, vector")
      ->Description = ZilchDocumentString("Reflects the input vector across the given vector.");
    ZilchBindMethod(builder, math, &Math::ReflectAcrossVector, (Real4(*)(Real4Param, Real4Param)), "ReflectAcrossVector", "toBeReflected, vector")
      ->Description = ZilchDocumentString("Reflects the input vector across the given vector.");

    ZilchBindMethod(builder, math, &Math::Refract, (Real2(*)(Real2Param, Real2Param, Real)), "Refract", "toBeRefracted, planeNormal, refractionIndex")
      ->Description = ZilchDocumentString("Calculates the refraction vector through a plane given a certain index of refraction.");
    ZilchBindMethod(builder, math, &Math::Refract, (Real3(*)(Real3Param, Real3Param, Real)), "Refract", "toBeRefracted, planeNormal, refractionIndex")
      ->Description = ZilchDocumentString("Calculates the refraction vector through a plane given a certain index of refraction.");
    ZilchBindMethod(builder, math, &Math::Refract, (Real4(*)(Real4Param, Real4Param, Real)), "Refract", "toBeRefracted, planeNormal, refractionIndex")
      ->Description = ZilchDocumentString("Calculates the refraction vector through a plane given a certain index of refraction.");

    // Lots of quaternion construction functions
    ZilchBindMethod(builder, math, &Math::ToQuaternion, (Quaternion (*)(Real3Param, Real)), "ToQuaternion", "axis, radians")
      ->Description = ZilchDocumentString("Generates the quaternion that rotates about the axis vector by the given radians.");
    ZilchBindMethod(builder, math, &Math::ToQuaternion, (Quaternion (*)(Real3Param, Real)), "AxisAngle",    "axis, radians")
      ->Description = ZilchDocumentString("Generates the quaternion that rotates about the axis vector by the given radians.");
    ZilchBindMethod(builder, math, &Math::ToQuaternion, (Quaternion (*)(Real3Param, Real3Param)), "ToQuaternion", "facing, up")
      ->Description = ZilchDocumentString("Generates the orientation represented by the given facing and up vectors.");
    ZilchBindMethod(builder, math, &Math::ToQuaternion, (Quaternion (*)(Real3Param, Real3Param, Real3Param)), "ToQuaternion", "facing, up, right")
      ->Description = ZilchDocumentString("Generates the orientation represented by the given facing, up, and right vectors.");
    ZilchBindMethod(builder, math, &Math::ToQuaternion, (Quaternion (*)(Real, Real, Real)), "ToQuaternion", "xRadians, yRadians, zRadians")
      ->Description = ZilchDocumentString("Generates the orientation from the given Euler angles.");
    ZilchBindMethod(builder, math, &Math::ToQuaternion, (Quaternion (*)(Real3Param)), "ToQuaternion", "eulerRadians")
      ->Description = ZilchDocumentString("Generates the orientation from the given Euler angle vector");
    ZilchBindMethod(builder, math, &Math::ToQuaternion, (Quaternion (*)(Real3Param)), "Euler",         "eulerRadians")
      ->Description = ZilchDocumentString("Generates the orientation from the given Euler angle vector");
    ZilchBindMethod(builder, math, &Math::RotationQuaternionBetween, ZilchNoOverload, "RotationQuaternionBetween", "start, end")
      ->Description = ZilchDocumentString("Generates the quaternion that rotates from parameter 1 to parameter 2.");
    

    builder.AddBoundFunction(math, "Dot", VectorDotProduct<2>, TwoParameters(this->Real2Type), this->RealType, options)->Description = ZilchDocumentString("The vector dot product");
    builder.AddBoundFunction(math, "Dot", VectorDotProduct<3>, TwoParameters(this->Real3Type), this->RealType, options)->Description = ZilchDocumentString("The vector dot product");
    builder.AddBoundFunction(math, "Dot", VectorDotProduct<4>, TwoParameters(this->Real4Type), this->RealType, options)->Description = ZilchDocumentString("The vector dot product");
    builder.AddBoundFunction(math, "Dot", VectorDotProduct<4>, TwoParameters(this->QuaternionType), this->RealType, options)->Description = ZilchDocumentString("The vector dot product");

    //builder.AddBoundFunction(math, "Perp",    Vector2Perpendicular, GenerateTwoParameters(this->Real2Type), this->RealType, options);
    builder.AddBoundFunction(math, "PerpDot", Vector2PerpDotProduct, TwoParameters(this->Real2Type), this->RealType, options)->Description = ZilchDocumentString("The dot product between p0 and a vector perpendicular to p1. This is the two-dimensional equivalent of a cross product. Can be used to get the angle between two vectors (PerpDot(p0, p1) = |p0|*|p1|*sin(theta)).");
    builder.AddBoundFunction(math, "Cross",   Vector3CrossProduct, TwoParameters(this->Real3Type), this->Real3Type, options)->Description = ZilchDocumentString("The vector cross product. Creates a new vector perpendicular to p0 and p1 using the right hand rule.");

    builder.AddBoundFunction(math, "LengthSq", VectorLengthSq<2>, OneParameter(this->Real2Type), this->RealType, options)->Description = ZilchDocumentString("The squared length of the vector. Used to avoid a square root when possible.");
    builder.AddBoundFunction(math, "LengthSq", VectorLengthSq<3>, OneParameter(this->Real3Type), this->RealType, options)->Description = ZilchDocumentString("The squared length of the vector. Used to avoid a square root when possible.");
    builder.AddBoundFunction(math, "LengthSq", VectorLengthSq<4>, OneParameter(this->Real4Type), this->RealType, options)->Description = ZilchDocumentString("The squared length of the vector. Used to avoid a square root when possible.");
    builder.AddBoundFunction(math, "LengthSq", VectorLengthSq<4>, OneParameter(this->QuaternionType), this->RealType, options)->Description = ZilchDocumentString("The squared length of the vector. Used to avoid a square root when possible.");

    builder.AddBoundFunction(math, "Length", VectorLength<2>, OneParameter(this->Real2Type), this->RealType, options);
    builder.AddBoundFunction(math, "Length", VectorLength<3>, OneParameter(this->Real3Type), this->RealType, options);
    builder.AddBoundFunction(math, "Length", VectorLength<4>, OneParameter(this->Real4Type), this->RealType, options);
    builder.AddBoundFunction(math, "Length", VectorLength<4>, OneParameter(this->QuaternionType), this->RealType, options);

    builder.AddBoundFunction(math, "Distance", VectorDistance<2>, TwoParameters(this->Real2Type), this->RealType, options)->Description = ZilchDocumentString("Returns the distance between two points.");
    builder.AddBoundFunction(math, "Distance", VectorDistance<3>, TwoParameters(this->Real3Type), this->RealType, options)->Description = ZilchDocumentString("Returns the distance between two points.");
    builder.AddBoundFunction(math, "Distance", VectorDistance<4>, TwoParameters(this->Real4Type), this->RealType, options)->Description = ZilchDocumentString("Returns the distance between two points.");
    builder.AddBoundFunction(math, "DistanceSq", VectorDistanceSq<2>, TwoParameters(this->Real2Type), this->RealType, options)->Description = ZilchDocumentString("Returns the squared distance between two points.");
    builder.AddBoundFunction(math, "DistanceSq", VectorDistanceSq<3>, TwoParameters(this->Real3Type), this->RealType, options)->Description = ZilchDocumentString("Returns the squared distance between two points.");
    builder.AddBoundFunction(math, "DistanceSq", VectorDistanceSq<4>, TwoParameters(this->Real4Type), this->RealType, options)->Description = ZilchDocumentString("Returns the squared distance between two points.");

    builder.AddBoundFunction(math, "Normalize", VectorNormalize<2>, OneParameter(this->Real2Type), this->Real2Type, options)->Description = ZilchDocumentString("Returns a vector that points in the same direction but has a length of 1.");
    builder.AddBoundFunction(math, "Normalize", VectorNormalize<3>, OneParameter(this->Real3Type), this->Real3Type, options)->Description = ZilchDocumentString("Returns a vector that points in the same direction but has a length of 1.");
    builder.AddBoundFunction(math, "Normalize", VectorNormalize<4>, OneParameter(this->Real4Type), this->Real4Type, options)->Description = ZilchDocumentString("Returns a vector that points in the same direction but has a length of 1.");
    builder.AddBoundFunction(math, "Normalize", VectorNormalize<4>, OneParameter(this->QuaternionType), this->QuaternionType, options)->Description = ZilchDocumentString("Returns a unit quaternion that represents a pure rotation.");
    
    builder.AddBoundProperty(math, "Pi", this->RealType, nullptr, Pi, MemberOptions::Static);
    builder.AddBoundProperty(math, "E", this->RealType, nullptr, E, MemberOptions::Static)->Description = ZilchDocumentString("Euler's number.");

    builder.AddBoundFunction(math, "Transform", QuaternionTransformQuaternion, TwoParameters(this->QuaternionType, "the", this->QuaternionType, "by"), this->QuaternionType, FunctionOptions::Static)->Description = ZilchDocumentString("Creates a new rotation that represents rotating by parameter 1 and then parameter 2.");
    builder.AddBoundFunction(math, "Transform", QuaternionTransformVector3, TwoParameters(this->Real3Type, "the", this->QuaternionType, "by"), this->Real3Type, FunctionOptions::Static)->Description = ZilchDocumentString("Creates a new vector that represents parameter 1 being rotated by parameter 2.");
    builder.AddBoundFunction(math, "Multiply", QuaternionMultiplyQuaternion, TwoParameters(this->QuaternionType, "by", this->QuaternionType, "the"), this->QuaternionType, FunctionOptions::Static)->Description = ZilchDocumentString("Creates a new rotation that represents rotating by parameter 2 and then parameter 1.");
    builder.AddBoundFunction(math, "Multiply", QuaternionMultiplyVector3, TwoParameters(this->QuaternionType, "by", this->Real3Type, "the"), this->Real3Type, FunctionOptions::Static)->Description = ZilchDocumentString("Creates a new vector that represents parameter 2 being rotated by parameter 1.");
    builder.AddBoundFunction(math, "Invert", QuaternionInvert, OneParameter(this->QuaternionType), this->QuaternionType, options)->Description = ZilchDocumentString("Returns the inverse rotation.");

    builder.AddBoundProperty(quaternionType, "Identity", this->QuaternionType, nullptr, QuaternionIdentity, MemberOptions::Static);

    CreateMatrixTypes(builder);

    for (size_t i = 0; i < AllRealTypes.size(); ++i)
    {
      BoundType* boundType = AllRealTypes[i];
      BoundType* boundIntegerType = AllIntegerTypes[i];
      Function* f = nullptr;

      ZilchBindBasicSplat(builder, math, Real, realType, "Abs", Math::Abs, boundType, OneParameter(boundType), "Returns the absolute value of value.");
      ZilchBindBasicSplatWithError(builder, math, Real, realType, "ACos", Math::SafeArcCos, boundType, OneParameter(boundType, "units"),"The transcendental function arc-sine", "ACos of '%s' is invalid. Values must be in the range [-1, 1].");
      f = builder.AddBoundFunction(math, "AllNonZero", AllNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
      f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / realType->Size, nullptr, boundType));
      f = builder.AddBoundFunction(math, "AnyNonZero", AnyNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
      f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / realType->Size, nullptr, boundType));
      ZilchBindBasicSplatWithError(builder, math, Real, realType, "ASin", Math::SafeArcSin, boundType, OneParameter(boundType, "units"), "The transcendental function arc-cosine", "ASin of '%s' is invalid. Values must be in the range [-1, 1].");    
      ZilchBindBasicSplat(builder, math, Real, realType, "ATan", Math::ArcTan, boundType, OneParameter(boundType, "units"), "The transcendental function arc-tangent. The return type is in radians.");
      ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "ATan2", Math::ArcTan2, boundType, TwoParameters(boundType, "y", "x"), "Performs the arc-tangent using the signs of x and y to determine what quadrant the angle lies in. Returns a value in the range of [-pi, pi]. The return type is in radians.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Ceil", Math::Ceil, boundType, OneParameter(boundType), "Rounds value upward.");
      f = builder.AddBoundFunction(math, "Ceil", ZilchComplexTwoParameterSplatBinder(Real, Integer, Real, 1, 0, Math::Ceil),
        TwoParameters(boundType, "value", integerType, "places"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value upward. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
      f = builder.AddBoundFunction(math, "Ceil", ZilchComplexThreeParameterSplatBinder(Real, Integer, Integer, Real, 1, 0, 0, Math::Ceil),
        ThreeParameters(boundType, "value", integerType, "places", integerType, "base"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value upward. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
      
      ZilchBindBasicThreeParamSplat(builder, math, Real, realType, "Clamp", Math::Clamp<Real>, boundType, ThreeParameters(boundType, "value", "min", "max"), "Limits the value between the provided min and max.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Cos", Math::Cos, boundType, OneParameter(boundType, "radians"), "The transcendental function cosine.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Cosh", Math::Cosh, boundType, OneParameter(boundType, "radians"), "The hyperbolic cosine function.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Exp", Math::Exp, boundType, OneParameter(boundType), "Returns the base-e exponentiation of value, which is e^value.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Exp2", Math::Exp2, boundType, OneParameter(boundType), "Returns the base-2 exponentiation of value, which is 2^value.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Floor", Math::Floor, boundType, OneParameter(boundType), "Rounds value downward.");

      f = builder.AddBoundFunction(math, "Floor", ZilchComplexTwoParameterSplatBinder(Real, Integer, Real, 1, 0, Math::Floor),
        TwoParameters(boundType, "value", integerType, "places"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value downward. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
      f = builder.AddBoundFunction(math, "Floor", ZilchComplexThreeParameterSplatBinder(Real, Integer, Integer, Real, 1, 0, 0, Math::Floor),
        ThreeParameters(boundType, "value", integerType, "places", integerType, "base"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value downward. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");

      ZilchBindBasicTwoParamSplatWithError(builder, math, Real, realType, "FMod", Math::SafeFMod, boundType, TwoParameters(boundType, "numerator", "denominator"), "Returns the floating-point remainder of numerator/denominator (rounded towards zero).", "Fmod(%s, %s) is invalid because the denominator would produce a zero division");
      ZilchBindBasicSplat(builder, math, Real, realType, "Frac", Math::Fractional, boundType, OneParameter(boundType), "Returns the fractional part of value, a value between 0 and 1.");

      f = builder.AddBoundFunction(math, "Lerp", ZilchComplexThreeParameterSplatBinder(Real, Real, Real, Real, 1, 1, 1, Zilch::Lerp<Real>),
        ThreeParameters(boundType, "start", boundType, "end", boundType, "t"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Linearly interpolates from start to end by the fraction t. T of 0 is start and t of 1 is end.");
      // Add another version for lerp that is always of real type
      if (boundType != realType)
      {
        f = builder.AddBoundFunction(math, "Lerp", ZilchComplexThreeParameterSplatBinder(Real, Real, Real, Real, 1, 1, 0, Zilch::Lerp<Real>),
          ThreeParameters(boundType, "start", boundType, "end", realType, "t"), boundType, FunctionOptions::Static);
        ZilchSetUserDataAndDescription(f, boundType, realType, "Linearly interpolates from start to end by the fraction t. T of 0 is start and t of 1 is end.");
      }

      ZilchBindBasicSplat(builder, math, Real, realType, "Log", Math::Log, boundType, OneParameter(boundType), "Base e logarithm.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Log10", Math::Log10, boundType, OneParameter(boundType), "Base 10 logarithm.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Log2", Math::Log2, boundType, OneParameter(boundType), "Base 2 logarithm.");
      ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "Max", Math::Max<Real>, boundType, TwoParameters(boundType), "Returns whichever value is larger.");
      ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "Min", Math::Min<Real>, boundType, TwoParameters(boundType), "Returns whichever value is smaller.");
      ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "Pow", Math::Pow, boundType, TwoParameters(boundType, "base", "exponent"), "Returns base raised to the power of the exponent.");

      ZilchBindBasicSplat(builder, math, Real, realType, "Round", Math::Round, boundType, OneParameter(boundType), "Returns the integer value closest to value.");
      f = builder.AddBoundFunction(math, "Round", ZilchComplexTwoParameterSplatBinder(Real, Integer, Real, 1, 0, Math::Round),
        TwoParameters(boundType, "value", integerType, "places"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Returns the integer value closest to value. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
      f = builder.AddBoundFunction(math, "Round", ZilchComplexThreeParameterSplatBinder(Real, Integer, Integer, Real, 1, 0, 0, Math::Round),
        ThreeParameters(boundType, "value", integerType, "places", integerType, "base"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Returns the integer value closest to value. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
      
      ZilchBindBasicSplat(builder, math, Real, realType, "RSqrt", Math::Rsqrt, boundType, OneParameter(boundType), "Reciprocal square root approximation. Used for efficiency when higher accuracy is not need.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Saturate", Math::Clamp<Real>, boundType, OneParameter(boundType), "Limits the value between 0 and 1");
      
      f = builder.AddBoundFunction(math, "Sign", ZilchComplexOneParameterSplatBinder(Real, Integer, 1, Math::Sign),
        OneParameter(boundType), boundIntegerType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Returns the sign of the value as either 1 or -1.");

      ZilchBindBasicSplat(builder, math, Real, realType, "Sin", Math::Sin, boundType, OneParameter(boundType, "radians"), "The transcendental function sine.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Sinh", Math::Sinh, boundType, OneParameter(boundType, "radians"), "The hyperbolic sine function.");

      f = builder.AddBoundFunction(math, "SmoothStep", ZilchFullThreeParameterSplatBinder(Real, Real, Real, Real, 1, 1, 1, Math::SmoothStep<Real>),
        ThreeParameters(boundType, "min", boundType, "max", boundType, "x"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Returns a smooth Hermite interpolation between 0 and 1 if x is in-between min and max.");
      // Add another version for smoothstep that is always of real type
      if (boundType != realType)
      {
        f = builder.AddBoundFunction(math, "SmoothStep", ZilchFullThreeParameterSplatBinder(Real, Real, Real, Real, 1, 1, 0, Math::SmoothStep<Real>),
          ThreeParameters(boundType, "min", boundType, "max", realType, "t"), boundType, FunctionOptions::Static);
        ZilchSetUserDataAndDescription(f, boundType, realType, "Returns a smooth Hermite interpolation between 0 and 1 if t is in-between min and max.");
      }

      ZilchBindBasicSplatWithError(builder, math, Real, realType, "Sqrt", Math::SafeSqrt, boundType, OneParameter(boundType), "Computes the square root", "Sqrt of the negative number '%s' is invalid.");
      ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "Step", Math::Step, boundType, TwoParameters(boundType, "y", "x"), "If y < x then 0 is returned, otherwise 1 is returned.")
      ZilchBindBasicSplat(builder, math, Real, realType, "Tan", Math::Tan, boundType, OneParameter(boundType, "radians"), "The transcendental function tangent.");
      ZilchBindBasicSplat(builder, math, Real, realType, "Tanh", Math::Tanh, boundType, OneParameter(boundType,  "radians"), "The hyperbolic tangent function.");
      ZilchBindBasicSplat(builder, math, Real, realType, "ToRadians", Math::DegToRad, boundType, OneParameter(boundType, "degrees"), "Converts the given degrees to radians.");
      ZilchBindBasicSplat(builder, math, Real, realType, "ToDegrees", Math::RadToDeg, boundType, OneParameter(boundType, "radians"), "Converts the given radians to degrees.");

      ZilchBindBasicSplat(builder, math, Real, realType, "Truncate", Math::Truncate, boundType, OneParameter(boundType), "Rounds value towards zero.");
      f = builder.AddBoundFunction(math, "Truncate", ZilchComplexTwoParameterSplatBinder(Real, Integer, Real, 1, 0, Math::Truncate),
        TwoParameters(boundType, "value", integerType, "places"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value towards zero. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
      f = builder.AddBoundFunction(math, "Truncate", ZilchComplexThreeParameterSplatBinder(Real, Integer, Integer, Real, 1, 0, 0, Math::Truncate),
        ThreeParameters(boundType, "value", integerType, "places", integerType, "base"), boundType, FunctionOptions::Static);
      ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value towards zero. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");

      // Approximately Equal
      BoundType* resultMatrixType = AllBooleanTypes[i];
      f = builder.AddBoundFunction(math, "ApproximatelyEqual", RealApproximatelyEqual, ThreeParameters(boundType, "p0", boundType, "p1", realType, "epsilon"), resultMatrixType, FunctionOptions::Static);
      f->UserData = (void*)(boundType->Size / realType->Size);
    }

    // Bind the integer functions separately (not many functions make sense to be splatted on integers)
    for (size_t i = 0; i < AllIntegerTypes.size(); ++i)
    {
      BoundType* boundType = AllIntegerTypes[i];
      Function* f = nullptr;
      
      ZilchBindBasicSplat(builder, math, Integer, integerType, "Abs", Math::Abs, boundType, OneParameter(boundType), "Returns the absolute value of value.");
      f = builder.AddBoundFunction(math, "AllNonZero", AllNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
      f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / integerType->Size, nullptr, boundType));
      f = builder.AddBoundFunction(math, "AnyNonZero", AnyNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
      f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / integerType->Size, nullptr, boundType));
      ZilchBindBasicThreeParamSplat(builder, math, Integer, integerType, "Clamp", Math::Clamp<Integer>, boundType, ThreeParameters(boundType, "value", "min", "max"), "Limits the value between the provided min and max.");
      ZilchBindBasicSplat(builder, math, Integer, integerType, "CountBits", Math::CountBits, boundType, OneParameter(boundType), "Counts the number of bits set on the input.");
      ZilchBindBasicTwoParamSplat(builder, math, Integer, integerType, "Max", Math::Max<Integer>, boundType, TwoParameters(boundType), "Returns whichever value is larger.");
      ZilchBindBasicTwoParamSplat(builder, math, Integer, integerType, "Min", Math::Min<Integer>, boundType, TwoParameters(boundType), "Returns whichever value is smaller.");
      ZilchBindBasicSplat(builder, math, Integer, integerType, "Sign", Math::Sign, boundType, OneParameter(boundType), "Returns the sign of the value as either 1 or -1.");
    }

    // Bind the boolean functions
    for (size_t i = 0; i < AllBooleanTypes.size(); ++i)
    {
      BoundType* boundType = AllBooleanTypes[i];
      Function* f = nullptr;

      f = builder.AddBoundFunction(math, "AllNonZero", AllNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
      f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / booleanType->Size, nullptr, boundType));
      f = builder.AddBoundFunction(math, "AnyNonZero", AnyNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
      f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / booleanType->Size, nullptr, boundType));
    }

    ZilchInitializeType(Boolean);
    ZilchInitializeType(Boolean2);
    ZilchInitializeType(Boolean3);
    ZilchInitializeType(Boolean4);
    ZilchInitializeType(Byte);
    ZilchInitializeType(Integer);
    ZilchInitializeType(Integer2);
    ZilchInitializeType(Integer3);
    ZilchInitializeType(Integer4);
    ZilchInitializeType(Real);
    ZilchInitializeType(Real2);
    ZilchInitializeType(Real3);
    ZilchInitializeType(Real4);
    ZilchInitializeType(Quaternion);
    ZilchInitializeType(String);
    ZilchInitializeType(DoubleReal);
    ZilchInitializeType(DoubleInteger);
  

    ZilchInitializeType(FileMode::Enum);
    ZilchInitializeType(StreamCapabilities::Enum);
    ZilchInitializeType(StreamOrigin::Enum);
  
    ZilchInitializeType(Type);
    ZilchInitializeType(AnyType);
    ZilchInitializeType(IndirectionType);
    ZilchInitializeType(DelegateType);
    ZilchInitializeType(BoundType);
    ZilchInitializeType(Console);
    ZilchInitializeType(Exception);
    ZilchInitializeType(EventHandler);
    ZilchInitializeType(EventsClass);
    ZilchInitializeType(EventData);
    ZilchInitializeType(ExecutableState);
    ZilchInitializeType(FilePathClass);
    ZilchInitializeType(FileStream);
    ZilchInitializeType(Function);
    ZilchInitializeType(Property);
    ZilchInitializeType(Field);
    ZilchInitializeType(Variable);
    ZilchInitializeType(Random);
    ZilchInitializeType(IEncoding);
    ZilchInitializeType(IStreamClass);
    ZilchInitializeType(StringBuilderExtended);
    ZilchInitializeType(Rune);
    ZilchInitializeType(RuneIterator);
    ZilchInitializeType(StringRangeExtended);
    ZilchInitializeType(StringSplitRangeExtended);
    ZilchInitializeType(StringSplitRangeExtended);
  }

  //***************************************************************************
  StackEntry::StackEntry() :
    ExecutingFunction(nullptr)
  {
  }

  //***************************************************************************
  StackEntry* StackTrace::GetMostRecentNonNativeStackEntry()
  {
    // Walk in newest from oldest to oldest calls
    for (int i = (int)(this->Stack.size() - 1); i >= 0; --i)
    {
      // Grab the current stack entry
      StackEntry& entry = this->Stack[i];

      // If we reached a non-native location, then return it
      if (entry.Location.IsNative == false)
      {
        // Return the most recent entry
        return &entry;
      }
    }

    // Either our stack trace was empty or we had an entirely native stack, return nothing
    return nullptr;
  }

  //***************************************************************************
  CodeLocation StackTrace::GetMostRecentNonNativeLocation()
  {
    // Get the most recent stack entry
    StackEntry* entry = this->GetMostRecentNonNativeStackEntry();

    // If the stack entry doesn't exist, return an empty location
    if (entry == nullptr)
      return CodeLocation();

    // Otherwise, return the location at the last entry
    return entry->Location;
  }

  //***************************************************************************
  String StackTrace::GetFormattedMessage(MessageFormat::Enum format)
  {
    // Create a string builder to output the stack trace
    StringBuilder builder;

    // Walk in order from oldest to newest calls
    for (size_t i = 0; i < this->Stack.size(); ++i)
    {
      // Get the current stack 
      StackEntry& stack = this->Stack[i];

      // Get the location in a formatted string
      String locationText = stack.Location.GetFormattedString(format);

      // Append the location to the full exception printout
      builder.Append(locationText);
      builder.Append('\n');
    }
    
    // Now return the full trace message
    return builder.ToString();
  }

  //***************************************************************************
  ZilchDefineType(Exception, "Exception", Core, builder, type)
  {
    // Store this type on the core library
    Core& core = Core::GetInstance();
    core.ExceptionType = type;

    ZilchBindConstructor(builder, type, Exception, nullptr);
    ZilchBindConstructor(builder, type, Exception, nullptr, StringParam);
    ZilchBindDestructor(builder, type, Exception);

    ZilchBindField(builder, type, &Exception::Message, "Message", PropertyBinding::GetSet);
    //ZilchBindMethod(GetFormattedMessage);
  }

  //***************************************************************************
  Exception::Exception()
  {
  }

  //***************************************************************************
  Exception::Exception(StringParam message) :
    Message(message)
  {
  }

  //***************************************************************************
  String Exception::GetFormattedMessage(MessageFormat::Enum format)
  {
    // Create a string builder to output the exception message and stack trace
    StringBuilder builder;
    builder.Append("********************** Zilch Exception **********************\n");

    // Convert the stack trace into a string and append it to our output
    String traceOutput = this->Trace.GetFormattedMessage(format);
    builder.Append(traceOutput);

    // If we have an error...
    if (this->Message.empty() == false)
    {
      // Append the error and a newline
      builder.Append(this->Message);
      builder.Append("\n");
    }

    // Print the end of the exception
    builder.Append("*************************************************************\n");

    // Now return the full error message
    return builder.ToString();
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/








// Redirection header based on the platform
#ifdef _MSC_VER
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>

// Undef windows defines that overlap with core functions
#undef CopyFile
#undef MoveFile
#undef DeleteFile
#undef CreateDirectory

namespace Zilch
{
  //***************************************************************************
  String StripQuotes(cstr text)
  {
    // Use this to build a quote removed message
    StringBuilder builder;

    // Remove quotes from message
    while ((*text) != '\0')
    {
      // Get the current character
      char c = *text;

      // If the character is a quote...
      if (c == '"')
      {
        // Append a single quote
        builder.Append('\'');
      }
      else
      {
        // Otherwise, append the character
        builder.Append(*text);
      }

      // Increment our text iterator
      ++text;
    }

    // Output the message
    return builder.ToString();
  }

  //***************************************************************************
  bool DebugErrorHandler(ErrorSignaler::ErrorData& errorData)
  {
    // Stores the resulting quote removed message from below
    String message;
    String expression = StripQuotes(errorData.Expression);

    // Check if no message was provided
    if (errorData.Message != nullptr)
    {
      message = StripQuotes(errorData.Message);
    }
    else
    {
      message = "No message";
    }

    // Output the command line
    String commandLine = String::Format("ErrorDialog.exe \"%s\" \"%s\" \"%s:%d\" %s",
      message.c_str(), expression.c_str(), errorData.File, errorData.Line, "Default");

    // Create a structure to facilitating starting of a process
    STARTUPINFO startUpInfo;
    memset(&startUpInfo, 0, sizeof(startUpInfo));

    // Create another structure to store process information
    PROCESS_INFORMATION processInfo;
    memset(&processInfo, 0, sizeof(processInfo));

    // Start the child process.
    BOOL result = CreateProcess
    (
      NULL,                         // No module name (use command line)
      (LPTSTR)commandLine.c_str(),  // Command line
      NULL,                         // Process handle not inheritable
      NULL,                         // Thread handle not inheritable
      FALSE,                        // Set handle inheritance to FALSE
      CREATE_NO_WINDOW,             // Creation flags
      NULL,                         // Use parent's environment block
      NULL,                         // Use parent's starting directory
      &startUpInfo,                 // Pointer to STARTUPINFO structure
      &processInfo
    );

    // If we failed to start the process...
    if (!result)
    {
      // Show a message box instead
      message = BuildString(message, "\nWould you like to continue?");
      int result = MessageBoxA(NULL, message.c_str(), "Error", MB_YESNO | MB_ICONEXCLAMATION);
      
      // Trigger a break point
      return result == IDNO;
    }

    // Now wait forever for the process to finish
    WaitForSingleObject(processInfo.hProcess, INFINITE);

    // Get the exit code of the process since it should have finished by now
    DWORD exitCode = 0;
    BOOL success = GetExitCodeProcess(processInfo.hProcess, &exitCode);

    // Close unused thread handle
    CloseHandle(processInfo.hThread);

    // If we somehow failed to get the exit code, trigger a break point
    if (!success)
    {
      return true;
    }

    // Special exit codes
    const DWORD Continue = 0;
    const DWORD DebugBreak = 1;
    const DWORD ForceShutdown = 2;

    // Based on the exit code...
    switch (exitCode)
    {
    case Continue:
      // No debug break, just continue
      return false;

    case DebugBreak:
      // Returning true will cause a break point
      return true;

    case ForceShutdown:
      // Immediately kill the application
      exit(0);
      break;

    default:
      // Force a break point, we have no idea what we got back
      return true;
    }
  }
}

#else
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

namespace Zilch
{
  //***************************************************************************
  bool DebugErrorHandler(ErrorSignaler::ErrorData& errorData)
  {
    // Just print out the error
    printf("%s(%d) : %s %s\n", errorData.File, errorData.Line, errorData.Message, errorData.Expression);

    // Returning true will cause a break point
    return true;
  }
}

#endif

namespace Zilch
{
  //***************************************************************************
  namespace Events
  {
    ZilchDefineEvent(DebuggerPauseUpdate);
    ZilchDefineEvent(DebuggerPause);
    ZilchDefineEvent(DebuggerResume);
  }

  //***************************************************************************
  Debugger::Debugger() :
    Action(DebuggerAction::Resume),
    LastState(nullptr),
    LastCallStackDepth(0),
    StepOutOverCallStackDepth(0),
    StepOutOverState(nullptr),
    Server(1),
    AllProjectsHashCode(0)
  {
    // We want to know when the console writes anything
    EventConnect(&Console::Events, Events::ConsoleWrite, &Debugger::OnConsoleWrite, this);
    
    // Connect all our event handlers up to the server
    EventConnect(&this->Server, Events::WebSocketAcceptedConnection, &Debugger::OnAcceptedConnection, this);
    EventConnect(&this->Server, Events::WebSocketDisconnected, &Debugger::OnDisconnected, this);
    EventConnect(&this->Server, Events::WebSocketError, &Debugger::OnError, this);
    EventConnect(&this->Server, Events::WebSocketReceivedData, &Debugger::OnReceivedData, this);

    // Register our message handlers
    this->AddMessageHandler("ChangeBreakpoint", OnChangeBreakpoint, this);
    this->AddMessageHandler("Resume", OnResume, this);
    this->AddMessageHandler("Pause", OnPause, this);
    this->AddMessageHandler("StepOver", OnStepOver, this);
    this->AddMessageHandler("StepIn", OnStepIn, this);
    this->AddMessageHandler("StepOut", OnStepOut, this);
    this->AddMessageHandler("QueryExpression", OnQueryExpression, this);
    this->AddMessageHandler("ViewExplorerItem", OnViewExplorerItem, this);
  }

  //***************************************************************************
  Debugger::~Debugger()
  {
  }

  //***************************************************************************
  void Debugger::Host(int port)
  {
    // If the server hasn't been initialized yet, then host the server on a given port
    if (this->Server.IsValid() == false)
      this->Server.Host(port);
  }
  
  //***************************************************************************
  bool Debugger::IsValid()
  {
    return this->Server.IsValid();
  }
  
  //***************************************************************************
  void Debugger::Update()
  {
    // Early out if we're not hosting
    if (this->Server.IsValid() == false)
      return;

    // Make sure we pump incoming messages
    this->Server.Update();

    // Loop through all the projects using a total hash to see if any project has changed (including files)
    unsigned long long projectsHash = 0;
    for (size_t i = 0; i < this->Projects.size(); ++i)
    {
      // Grab the current project
      Project* project = this->Projects[i];

      // Loop through all the code entries in this project
      for (size_t j = 0; j < project->Entries.size(); ++j)
      {
        // Grab the current code entry
        CodeEntry& entry = project->Entries[j];
        projectsHash ^= (unsigned long long)entry.GetHash();
        projectsHash *= 5209;
      }
    }

    // If the hash wasn't the same as the last time...
    if (projectsHash != this->AllProjectsHashCode)
    {
      // Update the remote explorer view
      this->UpdateExplorerView();
      this->AllProjectsHashCode = projectsHash;
    }
  }

  //***************************************************************************
  void Debugger::OnPause(const DebuggerMessage& message, void* userData)
  {
    Debugger* self = (Debugger*)userData;
    self->Action = DebuggerAction::Pause;
  }
  
  //***************************************************************************
  void Debugger::OnResume(const DebuggerMessage& message, void* userData)
  {
    Debugger* self = (Debugger*)userData;
    self->Action = DebuggerAction::Resume;
  }
  
  //***************************************************************************
  void Debugger::OnStepOver(const DebuggerMessage& message, void* userData)
  {
    Debugger* self = (Debugger*)userData;
    self->Action = DebuggerAction::StepOver;
    self->StepLocation = self->LastLocation;
    self->StepOutOverCallStackDepth = self->LastCallStackDepth;
    self->StepOutOverState = self->LastState;
  }
  
  //***************************************************************************
  void Debugger::OnStepIn(const DebuggerMessage& message, void* userData)
  {
    Debugger* self = (Debugger*)userData;
    self->Action = DebuggerAction::StepIn;
    self->StepLocation = self->LastLocation;
  }
  
  //***************************************************************************
  void Debugger::OnStepOut(const DebuggerMessage& message, void* userData)
  {
    Debugger* self = (Debugger*)userData;
    self->Action = DebuggerAction::StepOut;
    self->StepLocation = self->LastLocation;
    self->StepOutOverCallStackDepth = self->LastCallStackDepth;
    self->StepOutOverState = self->LastState;
  }
  
  //***************************************************************************
  CodeEntry* Debugger::FindCodeEntry(size_t hash)
  {
    // Loop through all the projects
    for (size_t i = 0; i < this->Projects.size(); ++i)
    {
      // Grab the current project
      Project* project = this->Projects[i];

      // Loop through all code entries in the project
      for (size_t j = 0; j < project->Entries.size(); ++j)
      {
        // Grab the current code entry from the project
        CodeEntry* entry = &project->Entries[j];
        if (entry->GetHash() == hash)
          return entry;
      }
    }

    // Loop through all the states
    for (size_t i = 0; i < this->States.size(); ++i)
    {
      // Grab the current executable state
      ExecutableState* state = this->States[i];

      // Look in the current state for the code entry...
      CodeEntry* foundEntry = state->CodeHashToCodeEntry.findValue(hash, nullptr);
      if (foundEntry != nullptr)
        return foundEntry;
    }

    // We found nothing!
    return nullptr;
  }

  //***************************************************************************
  void Debugger::OnViewExplorerItem(const DebuggerMessage& message, void* userData)
  {
    Debugger* self = (Debugger*)userData;
    
    // With the breakpoint message comes a unqiue identifier object that describes exact paths to code entries
    // This is the same as the object sent from 'AddState' with each code entry
    JsonValue* codeData = message.JsonRoot->GetMember("CodeData");
    if (codeData == nullptr)
    {
      Error("CodeData object was not specified in the 'AddBreakpoint' message");
      return;
    }
    
    // When looking for any code file that we put a breakpoint in, we can identify the code by an id
    size_t codeHash = (size_t)codeData->MemberAsLongLong("CodeHash");
    
    // Look for the code entry in a map to all code files
    CodeEntry* entry = self->FindCodeEntry(codeHash);
    if (entry == nullptr)
    {
      Error("We couldn't find the code file for the given id");
      return;
    }
    
    JsonBuilder builder;
    builder.Begin(JsonType::Object);
    {
      builder.Key("MessageType");
      builder.Value("ShowCodeEntry");
      builder.Key("Origin");
      builder.Value(entry->Origin);
      builder.Key("Code");
      builder.Value(entry->Code);
    
      builder.Key("CodeData");
      builder.Begin(JsonType::Object);
      {
        // All data sent within here is stored directly on the debugger side
        // and is directly returned to us in messages such as 'AddBreakpoint'
        builder.Key("CodeHash");
        builder.Value(entry->GetHash());
      }
      builder.End();
    }
    builder.End();
    
    String toSend = builder.ToString();
    self->SendPacket(toSend);
  }

  //***************************************************************************
  void Debugger::OnQueryExpression(const DebuggerMessage& message, void* userData)
  {
    Debugger* self = (Debugger*)userData;
    String expression = message.JsonRoot->MemberAsString("Expression");
    
    // The remote side gives every query and id, so that way when we respond to multiple it can distingquish which is which
    int queryId = message.JsonRoot->MemberAsInteger("QueryId");

    // Assume we're querying an expression for whatever state we're currently debugging
    ExecutableState* state = self->LastState;

    // If we're not debugging a state, return early
    if (state == nullptr)
      return;
    
    // Save away all the state callbacks (we don't want them to get called while we make calls)
    // Because we are swapping with an empty event handler, this also clears out all state callbacks
    EventHandler savedEvents;
    EventSwapAll(&savedEvents, state);

    // Temporary space used for traversing object paths and copying Zilch objects (Delegate is the largest object)
    byte tempSpace[sizeof(Delegate)];

    // Send a message back to answer the expression query
    JsonBuilder builder;
    builder.Begin(JsonType::Object);
    {
      builder.Key("MessageType");
      builder.Value("QueryResult");
      builder.Key("QueryId");
      builder.Value(queryId);
      builder.Key("Expression");
      builder.Value(expression);
      builder.Key("Values");
      builder.Begin(JsonType::ArrayMultiLine);
      {
        Zero::StringTokenRange splitter(expression, '.');
        if (splitter.empty() == false)
        {
          // Grab just the variable name
          String variableName = splitter.front();
          splitter.popFront();

          // Loop through the frames from top to bottom (backwards)
          for (int i = (int)state->StackFrames.size() - 1; i >= 0; --i)
          {
            // Grab the current frame
            PerFrameData* frame = state->StackFrames[i];

            // Skip any non-active frames (frames in the process of being called)
            if (frame->ProgramCounter == ProgramCounterNotActive)
              continue;

            // Get the current function
            Function* function = frame->CurrentFunction;

            // Loop through all variables in the current function
            for (size_t j = 0; j < function->Variables.size(); ++j)
            {
              // Grab the current variable
              Variable* variable = function->Variables[j];

              // If the variable's name matches our expression...
              if (variable->Name == variableName)
              {
                // Get the memory that points directly at the variable on the stack
                String valueName = variableName;
                Type* type = variable->ResultType;

                // If the frame is currently initialized
                if (frame->IsVariableInitialized(variable) == false)
                  continue;

                // Get the stack location of the variable
                byte* variableStackMemory = frame->Frame + variable->Local;
                type->GenericCopyConstruct(tempSpace, variableStackMemory);

                // If this is the first value, then write out its value (otherwise the parent would have written out our value)
                if (splitter.empty())
                {
                  // Stringify the variable (gets its value)
                  String value = type->GenericToString(tempSpace);
                  builder.Begin(JsonType::Object);
                  {
                    builder.Key("Property");
                    builder.Value(valueName);
                    builder.Key("Value");
                    builder.Value(value);
                    builder.Key("Expandable");
                    builder.Value(false);
                  }
                  builder.End();
                }

                // Until we run out of sub-strings...
                while (splitter.empty() == false)
                {
                  // Get the most virtual version of that memory (dereferences handles, gets the most derived type, etc)
                  byte* valueMemory = type->GenericGetMemory(tempSpace);
                  type = type->GenericGetVirtualType(tempSpace);

                  // Get the current property name
                  String propertyName = splitter.front();
                  splitter.popFront();
                  
                  // Grab the property or field by name
                  Property* property = nullptr;
                  BoundType* boundType = Type::GetBoundType(type);
                  if (boundType != nullptr)
                  {
                    property = boundType->GetInstanceProperty(propertyName);
                    if (property == nullptr)
                      property = boundType->GetInstanceField(propertyName);
                  }

                  // We allowe debugging of hidden properties, we just don't enumerate them
                  if (property != nullptr && property->Get != nullptr)
                  {
                    type->GenericDestruct(tempSpace);

                    valueName = propertyName;
                    type = property->PropertyType;

                    Call call(property->Get, state);

                    // Set the this handle (just as a global pointer...)
                    call.DisableThisChecks();
                    Handle* thisHandle = new (call.GetThisUnchecked()) Handle();
                    PointerManager* manager = state->GetHandleManager<PointerManager>();
                    manager->ObjectToHandle(valueMemory, *thisHandle);
                    thisHandle->Type = (BoundType*)type; // HACK DO NOT COMMIT
                    thisHandle->Manager = state->GetHandleManager<PointerManager>();

                    ExceptionReport report;
                    call.Invoke(report);

                    if (report.HasThrownExceptions())
                      goto END;

                    byte* returnValue = call.GetReturnUnchecked();
                    type->GenericCopyConstruct(tempSpace, returnValue);
                  }
                  else
                  {
                    // WE FOUND NOTHING! NOOOOOOTHING!!!
                    goto END;
                  }
                }

                // We want to avoid showing duplicate properties (when they are the exact same value)
                // We do want to however support showing hidden properties
                HashMap<String, String> evaluatedProperties;

                // Check to see if the type is a bound type
                BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

                // If the type is a bound type...
                while (boundType != nullptr)
                {
                  // Either dereference the handle or get the memory for the value
                  byte* memory = boundType->GenericGetMemory(tempSpace);

                  // Loop through all the instance properties
                  PropertyArray& properties = boundType->AllProperties;
                  for (size_t i = 0; i < properties.size(); ++i)
                  {
                    // Grab the current property
                    Property* property = properties[i];

                    // If it's a static or hidden property, skip it
                    if (property->IsStatic || property->IsHidden || property->Get == nullptr)
                      continue;

                    Call call(property->Get, state);

                    // Set the this handle (just as a global pointer...)
                    call.DisableThisChecks();
                    Handle* thisHandle = new (call.GetThisUnchecked()) Handle();
                    PointerManager* manager = state->GetHandleManager<PointerManager>();
                    manager->ObjectToHandle(memory, *thisHandle);
                    thisHandle->Type = boundType;
                    thisHandle->Manager = state->GetHandleManager<PointerManager>();

                    ExceptionReport report;
                    call.Invoke(report);

                    // The value we evaluated for this property (its return value stringified)
                    String propertyValue;

                    if (report.HasThrownExceptions())
                    {
                      // Just treat the property value as the concatenation of all the exceptions thrown
                      propertyValue = report.GetConcatenatedMessages();
                    }
                    else
                    {
                      byte* returnValue = call.GetReturnUnchecked();

                      // If the property should be hidden when null...
                      if (property->IsHiddenWhenNull)
                      {
                        // If the dereferenced property is null, then skip it
                        byte* returnValueDereferenced = property->PropertyType->GenericGetMemory(returnValue);
                        if (returnValueDereferenced == nullptr)
                          continue;
                      }

                      // Stringify the variable (gets its value)
                      propertyValue = property->PropertyType->GenericToString(returnValue);
                    }

                    // If we haven't seen this EXACT property value before...
                    String& evaluatedValue = evaluatedProperties[property->Name];
                    if (evaluatedValue != propertyValue)
                    {
                      // Let the debugger know about this property / value
                      builder.Begin(JsonType::Object);
                      {
                        builder.Key("Property");
                        builder.Value(property->Name);
                        builder.Key("Value");
                        builder.Value(propertyValue);
                        builder.Key("Expandable");
                        builder.Value(HasDebuggableProperties(property->PropertyType));
                      }
                      builder.End();
                    }

                    // Update the value stored in the evaluated property map, so that next time we'll know if we've seen this
                    evaluatedProperties[property->Name] = propertyValue;

                    // TEMPORARY - Because we do not have the ExecutableState in bound C++ functions, we can only
                    // print out fields (because we know their type and know where they exist in memory
                    //if (Field* field = TypeBinding::DynamicCast<Field*>(property))
                    //{
                    //  byte* fieldData = memory + field->Offset;
                    //  
                    //  // Stringify the variable (gets its value)
                    //  String fieldValue = field->PropertyType->GenericToString(fieldData);
                    //
                    //  // Let the debugger know about this property / value
                    //  builder.Begin(JsonType::Object);
                    //  {
                    //    builder.Key("Property");
                    //    builder.Value(field->Name);
                    //    builder.Key("Value");
                    //    builder.Value(fieldValue);
                    //    builder.Key("Expandable");
                    //    builder.Value(HasDebuggableProperties(field->PropertyType));
                    //  }
                    //  builder.End();
                    //}
                  }

                  // Iterate up to the base class (because we want to access base class properties too)
                  boundType = boundType->BaseType;
                }
                
                type->GenericDestruct(tempSpace);

                // We discovered a valid variable, time to break out of all loops
                goto END;
              }
            }
          }
        }
      }
END:
      builder.End();
    }
    builder.End();
    
    String toSend = builder.ToString();
    self->SendPacket(toSend);

    // Restore all the state callbacks
    EventSwapAll(&savedEvents, state);
  }

  //***************************************************************************
  bool Debugger::HasDebuggableProperties(Type* type)
  {
    // Grab the type as a bound type
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

    // If this is not a bound type, then it has no properties...
    if (boundType == nullptr)
      return false;
    
    // We have to walk through all properties and check for any non hidden properties
    for (size_t i = 0; i < boundType->AllProperties.size(); ++i)
    {
      // Grab the current property
      Property* property = boundType->AllProperties[i];

      // As long as this property isn't hidden or marked static, then we can debug it!
      if (property->IsHidden == false && property->IsStatic == false)
        return true;
    }

    // We didn't find a single expandable property...
    return false;
  }

  //***************************************************************************
  void Debugger::OnChangeBreakpoint(const DebuggerMessage& message, void* userData)
  {
    Debugger* self = (Debugger*)userData;

    // With the breakpoint message comes a unqiue identifier object that describes exact paths to code entries
    // This is the same as the object sent from 'AddState' with each code entry
    JsonValue* codeData = message.JsonRoot->GetMember("CodeData");
    if (codeData == nullptr)
    {
      Error("CodeData object was not specified in the 'AddBreakpoint' message");
      return;
    }

    // When looking for any code file that we put a breakpoint in, we can identify the code by an id
    size_t codeHash = (size_t)codeData->MemberAsLongLong("CodeHash");
    
    // Look for the code entry in a map to all code files
    CodeEntry* entry = self->FindCodeEntry(codeHash);
    if (entry == nullptr)
    {
      Error("We couldn't find the code file for the given id");
      return;
    }
    
    // Get the line that this is associated with
    size_t line = (size_t)message.JsonRoot->MemberAsLongLong("Line");

    // Grab breakpointed lines by the state and code entry id
    HashSet<size_t>& breakpointedLines = self->Breakpoints[entry->GetHash()];

    // We need to know whether we're adding or removing a breakpoint
    if (message.JsonRoot->MemberAsString("Action") == "Add")
      breakpointedLines.insert(line);
    else
      breakpointedLines.erase(line);
  }

  //***************************************************************************
  void Debugger::SendPacket(const JsonBuilder& message)
  {
    this->SendPacket(message.ToString());
  }

  //***************************************************************************
  void Debugger::SendPacket(StringParam message)
  {
    // Send the packet to 'all' (the only client we have connected, or drop the packet if nobody is connected)
    this->Server.SendPacketToAll(message, WebSocketPacketType::Text);
  }

  //***************************************************************************
  void Debugger::OnConsoleWrite(ConsoleEvent* event)
  {
    // The code location this is called from (may not be set if we're being called directly from C++, see below)
    CodeLocation location;

    // We want to know where this console write came from
    // Obviously we need to skip the actual call to Write or WriteLine
    // Warning: If the write was called from C++, it may not have a valid executable state
    // Moreover, if the call was made from C++ which was being called from Zilch, we'll only show the Zilch location
    if (event->State != nullptr)
    {
      // Grab the entire stack trace, possibly not the most efficient but it works
      StackTrace trace;
      event->State->GetStackTrace(trace);
      StackEntry* zilchStackEntry = trace.GetMostRecentNonNativeStackEntry();

      // If there was indeed a some Zilch function calling this (or called C++ that called this)
      if (zilchStackEntry != nullptr)
        location = zilchStackEntry->Location;
    }

    // Send a message back that we hit a breakpoint
    JsonBuilder builder;
    builder.Begin(JsonType::Object);
    {
      builder.Key("MessageType");
      builder.Value("Output");
      builder.Key("Text");
      builder.Value(event->Text);

      // If the location was set to something (otherwise we don't know where the call came from)
      if (location.IsValid())
      {
        builder.Key("Origin");
        builder.Value(location.Origin);
        builder.Key("Line");
        builder.Value(location.StartLine);
        builder.Key("CodeData");
        builder.Begin(JsonType::Object);
        {
          // This data allows the debugger to uniquely identify the
          // file this came from (so they can click on it and such)
          builder.Key("CodeHash");
          builder.Value(location.GetHash());
        }
        builder.End();
      }
    }
    builder.End();
    
    String message = builder.ToString();
    this->SendPacket(message);
  }

  //***************************************************************************
  void Debugger::OnEnterFunction(OpcodeEvent* e)
  {
    // Make sure we pump incoming messages
    this->Server.Update();

    if (e->Location == nullptr)
      return;

    // What do we do here?
  }

  //***************************************************************************
  void Debugger::OnExitFunction(OpcodeEvent* e)
  {
    // Make sure we pump incoming messages
    this->Server.Update();

    if (e->Location == nullptr)
      return;
  }
  
  //***************************************************************************
  void Debugger::OnException(ExceptionEvent* e)
  {
    CodeLocation location = e->ThrownException->Trace.GetMostRecentNonNativeLocation();
    ConsoleEvent exceptionEvent;
    exceptionEvent.Text = String::Format("Exception: %s\n", e->ThrownException->Message.c_str());
    exceptionEvent.State = e->State;
    this->OnConsoleWrite(&exceptionEvent);
    this->PauseExecution(&location, e->State);
  }

  //***************************************************************************
  void Debugger::OnOpcodePreStep(OpcodeEvent* e)
  {
    // Make sure we pump incoming messages
    this->Server.Update();

    // Cache some variables as locals
    CodeLocation* location = e->Location;
    ExecutableState* state = e->State;

    // If we didn't get a code location, just skip this (something invalid must have happened)
    if (location == nullptr)
      return;

    // If we have a timeout, just basically disable it... we're in the debugger!
    if (state->Timeouts.empty() == false)
    {
      // Just set the timeout to the max time
      state->Timeouts.back().LengthTicks = 0x7FFFFFFFFFFFE;
    }

    // Figure out if we changed to a new line by entering this opcode
    bool isNewLineOrFileFromLastLocation = location->StartLine != this->LastLocation.StartLine || location->Code != this->LastLocation.Code || state != this->LastState;
    bool isNewLineOrFileFromStepLocation = location->StartLine != this->StepLocation.StartLine || location->Code != this->StepLocation.Code;

    // Store the last code location so we can step by single lines
    this->LastLocation = *location;
    this->LastState = state;
    this->LastCallStackDepth = state->StackFrames.size();

    // Lets us know whether the action was handled (so we don't need to check for breakpoints)
    bool actionPausedExecution = false;
    
    // Based on the action that was last set by the remote client
    switch (this->Action)
    {
      // The user wanted to pause, just pause immediately on the current opcode
      case DebuggerAction::Pause:
      {
        this->PauseExecution(location, state);
        actionPausedExecution = true;
      }
      break;

      // The user wanted to step into the next function it sees
      // Basically we just break on every new line of opcode
      case DebuggerAction::StepIn:
      {
        // If we changed lines or code entry ids (files), then we want to pause
        if (isNewLineOrFileFromLastLocation)
        {
          this->PauseExecution(location, state);
          actionPausedExecution = true;
        }
      }
      break;

      // If we're stepping out of a function...
      case DebuggerAction::StepOut:
      {
        // If we're in the same state that we wanted to step out, and the call stack depth is less than what we started at
        if (isNewLineOrFileFromStepLocation && state == this->StepOutOverState && state->StackFrames.size() < this->StepOutOverCallStackDepth)
        {
          // Not necessary, but lets just clear the state and depth to make things clearer
          this->StepOutOverState = nullptr;
          this->StepOutOverCallStackDepth = 0;

          // We stepped out of a function!
          this->PauseExecution(location, state);
          actionPausedExecution = true;
        }
        break;
      }

      // The user wanted to pause on the next line (or next file, etc)...
      case DebuggerAction::StepOver:
      {
        // If we're in the same state that we wanted to step over, and the call stack depth is the same as what we started at
        if (isNewLineOrFileFromStepLocation && state == this->StepOutOverState && state->StackFrames.size() <= this->StepOutOverCallStackDepth)
        {
          // Not necessary, but lets just clear the state and depth to make things clearer
          this->StepOutOverState = nullptr;
          this->StepOutOverCallStackDepth = 0;

          // We stepped out of a function!
          this->PauseExecution(location, state);
          actionPausedExecution = true;
        }
      }
      break;
    }

    // Note: We always test for breakpoints (when resumed, when stepping in, when stepping out, etc)
    // Even when testing for breakpoints, there may be many opcode associated with one line
    // We only want to break upon the first opcode for that line
    if (isNewLineOrFileFromLastLocation && actionPausedExecution == false)
    {
      // Grab the breakpoint line list by code location/id and state
      HashSet<size_t>& breakpointedLines = this->Breakpoints[location->GetHash()];
          
      // If the breakpoints has the current line we're hitting
      if (breakpointedLines.contains(location->StartLine))
        this->PauseExecution(location, state);
    }
  }
  
  //***************************************************************************
  void Debugger::SetExecutionPoint(CodeLocation* codeLocation, ExecutableState* state)
  {
    // Send a message back that we hit a breakpoint
    JsonBuilder builder;
    builder.Begin(JsonType::Object);
    {
      builder.Key("MessageType");
      builder.Value("SetExecutionPoint");
      builder.Key("Line");
      builder.Value(codeLocation->StartLine);
      builder.Key("CodeData");
      builder.Begin(JsonType::Object);
      {
        // All data sent within here is stored directly on the debugger side
        // and is directly returned to us in messages such as 'AddBreakpoint'
        builder.Key("CodeHash");
        builder.Value(codeLocation->GetHash());
      }
      builder.End();

      builder.Key("CallStack");
      builder.Begin(JsonType::ArrayMultiLine);
      {
        // Perform a stack trace so we can grab the entire stack
        StackTrace trace;
        state->GetStackTrace(trace);

        // Loop through the entire stack trace and send it in a message
        // Note: We loop backwards so that the most recent entries appear at the top (typical for debuggers)
        for (int i = (int)trace.Stack.size() - 1; i >= 0; --i)
        {
          builder.Begin(JsonType::Object);
          {
            // Grab the current stack entry and emit a message to the debugger
            StackEntry& entry = trace.Stack[i];
            builder.Key("Text");
            builder.Value(entry.ExecutingFunction->ToString());
            builder.Key("Language");
            if (codeLocation->IsNative)
            {
              builder.Value("Native");
            }
            else
            {
              builder.Value("Zilch");
              builder.Key("Line");
              builder.Value(entry.Location.StartLine);
              builder.Key("CodeData");
              builder.Begin(JsonType::Object);
              {
                // This data allows the debugger to identify exactly which file is being shown
                builder.Key("CodeHash");
                builder.Value(entry.Location.GetHash());
              }
              builder.End();
            }
          }
          builder.End();
        }
      }
      builder.End();
    }
    builder.End();
      
    String message = builder.ToString();
    this->SendPacket(message);
  }

  //***************************************************************************
  void Debugger::ClearExecutionPoint()
  {
    // Send a message back that we hit a breakpoint
    JsonBuilder builder;
    builder.Begin(JsonType::Object);
      builder.Key("MessageType");
      builder.Value("ClearExecutionPoint");
    builder.End();
      
    String message = builder.ToString();
    this->SendPacket(message);
  }
  
  //***************************************************************************
  void AddCodeEntryToExplorerviewUpdate(HashSet<size_t>& processedCodeHashes, JsonBuilder& builder, CodeEntry& entry)
  {
    // We want to skip any code entries we've already seen
    size_t entryHash = entry.GetHash();
    if (processedCodeHashes.contains(entryHash))
      return;

    // Next time we see this hash, we'll know to skip it
    processedCodeHashes.insert(entryHash);
              
    // Write out this code entry (the id is the index combined with the state id)
    builder.Begin(JsonType::Object);
    {
      builder.Key("Id");
      builder.Value(entryHash);
      builder.Key("Name");
      builder.Value(entry.Origin);
      builder.Key("CodeData");
      builder.Begin(JsonType::Object);
      {
        // All data sent within here is stored directly on the debugger side
        // and is directly returned to us in messages such as 'ViewExplorerItem'
        builder.Key("CodeHash");
        builder.Value(entry.GetHash());
      }
      builder.End();
    }
    builder.End();
  }

  //***************************************************************************
  void Debugger::UpdateExplorerView()
  {
    JsonBuilder builder;
    builder.Begin(JsonType::Object);
    {
      builder.Key("MessageType");
      builder.Value("UpdateExplorer");

      // A simple set to see if we've already processed a code entry
      HashSet<size_t> processedCodeHashes;
      
      builder.Key("Roots");
      builder.Begin(JsonType::ArrayMultiLine);
      {
        // Loop through all the projects
        for (size_t i = 0; i < this->Projects.size(); ++i)
        {
          // Grab the current project
          Project* project = this->Projects[i];

          // Loop through all code entries in the project
          for (size_t j = 0; j < project->Entries.size(); ++j)
          {
            // Grab the current code entry from the project
            CodeEntry& entry = project->Entries[j];
            AddCodeEntryToExplorerviewUpdate(processedCodeHashes, builder, entry);
          }
        }

        // Loop through all the states
        for (size_t i = 0; i < this->States.size(); ++i)
        {
          // Grab the current executable state
          ExecutableState* state = this->States[i];

          // Loop through all dependent libraries so we can get the original source code files
          for (size_t j = 0; j < state->Dependencies.size(); ++j)
          {
            // Get the current dependent library
            LibraryRef& library = state->Dependencies[j];
                
            // We only process this library if it has any entries (otheriwse we would always show core!)
            if (library->Entries.empty())
              continue;

            // Loop through the original source code entries that built this library
            // Note: The entries may be empty if it was a generated library
            for (size_t k = 0; k < library->Entries.size(); ++k)
            {
              // Grab the current code entry
              CodeEntry& entry = library->Entries[k];
              AddCodeEntryToExplorerviewUpdate(processedCodeHashes, builder, entry);
            }
          }
        }
      }
      builder.End();
    }
    builder.End();

    String message = builder.ToString();
    this->SendPacket(message);
  }

  
  //***************************************************************************
  void Debugger::AddProject(Project* project)
  {
    // If the project already exists within the project array, then don't add it again
    if (this->Projects.findIndex(project) != Array<Project*>::InvalidIndex)
      return;

    this->Projects.push_back(project);
    this->UpdateExplorerView();
  }
  
  //***************************************************************************
  void Debugger::RemoveProject(Project* project)
  {
    // Attempt to find the project in the array of all project we're viewing
    size_t index = this->Projects.findIndex(project);

    // If it didn't exist in the array, then there's nothing for us to do!
    if (index == Array<Project*>::InvalidIndex)
      return;

    // Remove the project from the array
    this->Projects.eraseAt(index);

    // Lastly, if any client is connected then update the explorer view they have because the project is now gone
    this->UpdateExplorerView();
  }

  //***************************************************************************
  void Debugger::AddState(ExecutableState* state)
  {
    // If the state already exists within the state array, then don't add it again
    if (this->States.findIndex(state) != Array<ExecutableState*>::InvalidIndex)
      return;

    this->States.push_back(state);
    state->EnableDebugEvents = true;

    EventConnect(state, Events::OpcodePreStep, &Debugger::OnOpcodePreStep, this);
    EventConnect(state, Events::EnterFunction, &Debugger::OnEnterFunction, this);
    EventConnect(state, Events::ExitFunction, &Debugger::OnExitFunction, this);
    EventConnect(state, Events::UnhandledException, &Debugger::OnException, this);
    
    this->UpdateExplorerView();
  }
  
  //***************************************************************************
  void Debugger::RemoveState(ExecutableState* state)
  {
    // Attempt to find the state in the array of all states we're debugging
    size_t index = this->States.findIndex(state);

    // If it didn't exist in the array, then there's nothing for us to do!
    if (index == Array<ExecutableState*>::InvalidIndex)
      return;

    // Remove the state from the array
    this->States.eraseAt(index);

    // If the last state we were stepping out of was this state, then clear the step out info
    if (this->StepOutOverState == state)
    {
      this->StepOutOverState = nullptr;
      this->StepOutOverCallStackDepth = 0;
    }

    // If the last state we were debugging was this state, then clear it
    if (this->LastState == state)
      this->LastState = nullptr;

    // Disable debug events
    state->EnableDebugEvents = false;
    EventDisconnect(state, this, Events::OpcodePreStep, this);
    EventDisconnect(state, this, Events::EnterFunction, this);
    EventDisconnect(state, this, Events::ExitFunction, this);
    EventDisconnect(state, this, Events::UnhandledException, this);

    // Lastly, if any client is connected then update the explorer view they have because the state is now gone
    this->UpdateExplorerView();
  }

  //***************************************************************************
  void Debugger::AddMessageHandler(StringParam type, MessageFn callback, void* userData)
  {
    // Add the delegate to the message handlers
    DebuggerMessageDelegate delegate;
    delegate.MessageCallback = callback;
    delegate.UserData = userData;
    this->MessageHandlers.insertOrError(type, delegate);
  }

  //***************************************************************************
  void Debugger::PauseExecution(CodeLocation* codeLocation, ExecutableState* state)
  {
    // We hit a breakpoint, so pause execution
    this->Action = DebuggerAction::Pause;

    // Inform the client where we stopped in code execution
    this->SetExecutionPoint(codeLocation, state);

    // Just create a single empty event that we send just once
    DebuggerEvent toSend;
    toSend.RunningDebugger = this;
    toSend.State = state;
    toSend.Location = codeLocation;

    // Let the user know that we just paused...
    EventSend(this, Events::DebuggerPause, &toSend);

    // Loop until we hit an again that causes us to resume
    while (this->Action == DebuggerAction::Pause)
    {
      // We should probably wait on a signal here (typically we don't want to wait inside of processing received messages
      // because we often want to continue, even if there are no messages
      // For now, sleep just to prevent this from using all the cpu
      Zero::Os::Sleep(1);

      // Send out an event that lets the hosting application update its visuals (it's being debugged!)
      EventSend(this, Events::DebuggerPauseUpdate, &toSend);

      // While we're paused just pump messages (could be a breakpoint, after a step, or a true pause)
      this->Server.Update();
    }
    
    // Since we're resuming, clear execution
    this->ClearExecutionPoint();

    // Let the user know that we just resumed...
    EventSend(this, Events::DebuggerResume, &toSend);
  }

  //***************************************************************************
  void Debugger::OnAcceptedConnection(WebSocketEvent* event)
  {
    // Update the explorer view for the newly connected client
    this->UpdateExplorerView();
  }
  
  //***************************************************************************
  void Debugger::OnError(WebSocketEvent* event)
  {
    Error("Debugger Error: %s", event->ErrorStatus.Message.c_str());
  }
  
  //***************************************************************************
  void Debugger::OnDisconnected(WebSocketEvent* event)
  {
    // Make sure we clear out all the data so the program can continue
    this->Action = DebuggerAction::Resume;
    this->Breakpoints.clear();
    this->LastLocation = CodeLocation();
    this->LastCallStackDepth = 0;
    this->LastState = nullptr;
    this->StepLocation = CodeLocation();
    this->StepOutOverState = nullptr;
  }

  //***************************************************************************
  void Debugger::OnReceivedData(WebSocketEvent* event)
  {
    // Now parse the string into a json tree
    static const String Origin("Received Json");
    CompilationErrors errors;
    JsonValue* root = JsonReader::ReadIntoTreeFromString(errors, event->Data, Origin, nullptr);
    ReturnIf(root == nullptr,, "We weren't able to parse the JSON that we recieved");

    // Read the message type from the json message
    String messageType = root->MemberAsString("MessageType");

    // Grab the current handler by message type
    DebuggerMessageDelegate* delegate = this->MessageHandlers.findPointer(messageType);
    
    // As long as we registered a delegate to handle this message...
    if (delegate != nullptr)
    {
      // Invoke the debugger message callback
      DebuggerMessage message;
      message.Type = messageType;
      message.JsonRoot = root;
      delegate->MessageCallback(message, delegate->UserData);
    }
    else
    {
      Error("Unknown message type '%s'", messageType.c_str());
    }

    // Get rid of the json tree
    delete root;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes







namespace Zilch
{
  //***************************************************************************
  Delegate::Delegate() :
    BoundFunction(nullptr)
  {
    ZilchErrorIfNotStarted(Delegate);
  }

  //***************************************************************************
  bool Delegate::operator==(const Delegate& rhs) const
  {
    // First start by making sure the function indices are the same
    if (this->BoundFunction != rhs.BoundFunction)
      return false;
    
    // We also need to compare the handles
    return this->ThisHandle == rhs.ThisHandle;
  }
  
  //***************************************************************************
  bool Delegate::operator!=(const Delegate& rhs) const
  {
    return !(*this == rhs);
  }
  
  //***************************************************************************
  int Delegate::Hash() const
  {
    // Hash the function first
    int hash = (int)(this->BoundFunction->Hash() * 735977940532462813);

    // Combine that hash with the handle hash
    return hash ^ this->ThisHandle.Hash();
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes



namespace Zilch
{
  //***************************************************************************
  size_t AlignToBusWidth(size_t value)
  {
    // The machine bus width (32 bit = 4 bytes, etc)
    // For right now, we always align to 4 bytes
    const size_t BusWidth = 4;

    // If the value is already aligned...
    if (value % BusWidth == 0)
    {
      return value;
    }
    else
    {
      // Otherwise, we need to choose a value higher then the input which aligns it
      size_t alignedValue = ((value / BusWidth) + 1) * BusWidth;
      return alignedValue;
    }
  }


  //***************************************************************************
  DestructibleBuffer::DestructibleBuffer()
  {
  }
  
  //***************************************************************************
  DestructibleBuffer::DestructibleBuffer(const DestructibleBuffer& from) :
    Data(from.Data),
    Entries(from.Entries)
  {
    // We already directly copied over all the block array data (handed by its copy constructor)
    // Note: Untyped block array memcopies all its data over, but in truth we need to copy construct each of them
    for (size_t i = 0; i < this->Entries.size(); ++i)
    {
      // Grab the current entry
      Entry& entry = this->Entries[i];

      // Skip this entry (alread memcopied) if no copy constructor was provided
      if (entry.CopyConstructor == nullptr)
        continue;

      // Copy construct this element from its old memory to the new memory
      // (does not destruct the old or anything weird like that)
      DestructibleBuffer& fromNonConst = const_cast<DestructibleBuffer&>(from);
      byte* fromElement = fromNonConst.Data.GetAbsoluteElement(entry.AbsolutePosition);
      byte* toElement = this->Data.GetAbsoluteElement(entry.AbsolutePosition);
      entry.CopyConstructor(fromElement, toElement);
    }
  }

  //***************************************************************************
  DestructibleBuffer::~DestructibleBuffer()
  {
    // Clear and invoke all the destructors on our data
    this->Clear();
  }
  
  //***************************************************************************
  DestructibleBuffer& DestructibleBuffer::operator=(const DestructibleBuffer& from)
  {
    // Destruct ourselves and copy construct ourself again from the other one
    this->~DestructibleBuffer();
    new (this) DestructibleBuffer(from);
    return *this;
  }

  //**************************************************************************
  size_t DestructibleBuffer::GetSize()
  {
    return this->Data.AbsoluteSize();
  }

  //**************************************************************************
  void DestructibleBuffer::Clear()
  {
    // Loop through all the destructors
    for (size_t i = 0; i < this->Entries.size(); ++i)
    {
      // Get the current destructible object
      Entry& entry = this->Entries[i];

      // Get the pointer to where the object exists in our memory
      byte* object = this->Data.GetAbsoluteElement(entry.AbsolutePosition);

      // Invoke its destructor since we're being erased
      if (entry.Destructor != nullptr)
        entry.Destructor(object);
    }

    // Clear the destructible objects as well as the data
    this->Entries.clear();
    this->Data.Clear();
  }

  //***************************************************************************
  byte* DestructibleBuffer::Allocate(size_t size, DestructFn destructor, CopyConstructFn copyConstructor, size_t* positionOut)
  {
    // Make sure the size aligns with the bus for efficiency
    size = AlignToBusWidth(size);

    // Get a pointer directly to the new data
    size_t absolutePosition = 0;
    byte* newData = this->Data.RequestElementOfSize(size, &absolutePosition);

    // If the user also wants the position...
    if (positionOut != nullptr)
    {
      // The position is our absolute position
      *positionOut = absolutePosition;
    }

    // Clear out the new data, just for safety (this also helps when we align data)
    memset(newData, 0, size);

    // If we were given a destructor
    if (destructor != nullptr || copyConstructor != nullptr)
    {
      // Add a new destructible component
      Entry& entry = this->Entries.push_back();

      // Setup the destructible so that it destroys
      // the object at the new memory position
      entry.Destructor = destructor;
      entry.CopyConstructor = copyConstructor;
      entry.AbsolutePosition = absolutePosition;
    }

    // Return the writable data
    return newData;
  }

  //***************************************************************************
  byte* DestructibleBuffer::WriteMemory(void* source, size_t size, DestructFn destructor)
  {
    // Allocate data and use the given destructor (it may be null)
    byte* newData = this->Allocate(size, destructor);

    // Copy the user's data over the new data
    memcpy(newData, source, size);

    // Finally, return the new writable data
    return newData;
  }

  //***************************************************************************
  byte* DestructibleBuffer::Read(size_t position, size_t length, size_t* nextPositionOut)
  {
    // Make sure we only jump by full aligned blocks
    length = AlignToBusWidth(length);

    // Get the position of the memory the user is reading
    byte* memory = this->Data.GetAbsoluteElement(position);

    // Error checking
    ErrorIf(position != 0 && nextPositionOut == nullptr,
      "In cases where the position is not 0 (the front), you "
      "must get the next position via 'nextPositionOut'");

    // If the user needs us to output the next position
    if (nextPositionOut != nullptr)
    {
      // If the read causes a lapse in length...
      size_t newBlockPosition = (position % BlockSize) + length;
      if (newBlockPosition >= BlockSize)
      {
        // Move the position to the next block
        *nextPositionOut = position + (newBlockPosition - BlockSize);
      }
      else
      {
        // Move the position forward by the length
        *nextPositionOut = position + length;
      }
    }

    // Now return the memory
    return memory;
  }

  //***************************************************************************
  byte* DestructibleBuffer::GetElement(size_t position)
  {
    return this->Data.GetAbsoluteElement(position);
  }
}/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes






namespace Zilch
{
  //***************************************************************************
  DocumentationProperty::DocumentationProperty() :
    IsSettable(true),
    IsGettable(true),
    IsField(true)
  {
  }

  //***************************************************************************
  DocumentationType::DocumentationType() :
    IsValueType(false)
  {
  }

  //***************************************************************************
  RstTable::RstTable() :
    Columns(0),
    Rows(0),
    HeaderRows(0)
  {
  }

  //***************************************************************************
  void RstTable::Resize(size_t columns, size_t rows)
  {
    this->Cells.resize(columns * rows);
    this->Columns = columns;
    this->Rows = rows;
  }

  //***************************************************************************
  void RstTable::SetCell(StringParam value, size_t column, size_t row)
  {
    this->Cells[column + row * this->Columns] = value;
  }

  //***************************************************************************
  String RstTable::GetCell(size_t column, size_t row)
  {
    return this->Cells[column + row * this->Columns];
  }

  //***************************************************************************
  void RstBuilder::WriteLine(RstTable& table)
  {
    if (table.Columns == 0 || table.Rows == 0)
      return;

    // We need to get the max size of all of the entries in each column
    Array<size_t> columnLengths;
    columnLengths.resize(table.Columns);

    // Get the lengths of each of the columns
    for (size_t c = 0; c < table.Columns; ++c)
    {
      size_t columnLength = 0;

      for (size_t r = 0; r < table.Rows; ++r)
      {
        // Get the max of the running column lengths
        size_t currentLength = table.GetCell(c, r).size();
        columnLength = Math::Max(columnLength, currentLength);
      }

      columnLengths[c] = columnLength;
    }

    // We include two padding spaces
    const size_t Padding = 2;

    // Walk through all the rows and print out their values
    // Note: We pretend we have one more row than we do, but we only do that to write out the last line bar
    for (size_t r = 0; r <= table.Rows; ++r)
    {
      // Output the top bar for the current row
      for (size_t c = 0; c < table.Columns; ++c)
      {
        this->Write("+");
        size_t columnLength = columnLengths[c];

        char rowSeparator = '-';
        if (r == table.HeaderRows)
          rowSeparator = '=';

        this->Write(String::Repeat(rowSeparator, columnLength + Padding));
      }
      this->WriteLine("+");

      // Don't write out cell values for the last bar
      if (r == table.Rows)
        break;

      // Now write out the cell values (mind the space, must match padding!)
      for (size_t c = 0; c < table.Columns; ++c)
      {
        this->Write("| ");
        size_t columnLength = columnLengths[c];
        String cell = table.GetCell(c, r);
        this->Write(cell);
        this->Write(String::Repeat(' ', columnLength - cell.size()));

        // Write out the ending padding space
        this->Write(" ");
      }
      this->WriteLine("|");
    }
  }

  //***************************************************************************
  void RstBuilder::WriteLineHeading(StringRange heading, RstHeadingType::Enum type)
  {
    char lineCharacter = ' ';
    bool needsOverline = false;

    switch (type)
    {
    case RstHeadingType::Part:
      lineCharacter = '#';
      needsOverline = true;
      break;
    case RstHeadingType::Chapter:
      lineCharacter = '=';
      needsOverline = true;
      break;
    case RstHeadingType::Section:
      lineCharacter = '=';
      break;
    case RstHeadingType::SubSection:
      lineCharacter = '-';
      break;
    case RstHeadingType::SubSubSection:
      lineCharacter = '^';
      break;
    case RstHeadingType::Paragraph:
      lineCharacter = '"';
      break;
    }

    // If we need an overline
    if (needsOverline)
      this->WriteLine(String::Repeat(lineCharacter, heading.size()));

    this->WriteLine(heading);
    this->WriteLine(String::Repeat(lineCharacter, heading.size()));
  }
}/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes



namespace Zilch
{
  //***************************************************************************
  ErrorDatabase::ErrorDatabase()
  {
    // Setup all the errors using generated code
// AttributeArgumentMustBeLiteral
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "All arguments given to an attribute must be literals (numbers, strings, true/false, typeid(Type), or null).";
  error.Name = "AttributeArgumentMustBeLiteral";
  error.Reason = "";

}

// AttributeNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The attribute '%s' was not completed (missing ']').";
  error.Name = "AttributeNotComplete";
  error.Reason = "";

}

// AttributesNotAttached
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Attributes were left at the end of the scope of the program and could not be attached to anything.";
  error.Name = "AttributesNotAttached";
  error.Reason = "";

}

// AttributeTypeNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The attribute type was not found.";
  error.Name = "AttributeTypeNotFound";
  error.Reason = "";

}

// BaseClassInitializerMustComeFirst
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "To make the order of operations very clear, the base class initializer must come before any other initailizers (such as this).";
  error.Name = "BaseClassInitializerMustComeFirst";
  error.Reason = "Base classes are initialized before anything else, so it makes sense that it should actually come first.";

}

// BaseClassInitializerRequiresBaseClassInheritance
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A base class initializer can only be called when your class '%s' inherits from another class.";
  error.Name = "BaseClassInitializerRequiresBaseClassInheritance";
  error.Reason = "";

}

// BaseInitializerRequired
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Since '%s' inherits from '%s' (the base type), we require a base initializer after the constructor.";
  error.Name = "BaseInitializerRequired";
  error.Reason = "";

}

// BinaryOperatorRightOperandNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The right operand is invalid or not found for the '%s' operator '%s'.";
  error.Name = "BinaryOperatorRightOperandNotFound";
  error.Reason = "When an operator between two operands, such as the '+' operator, has a left operand (e.g. '5 + ') it must have a right operand as well.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "1.0 + ;";
    example.FixedCode = "1.0 + 2.0;\r\n";
    example.ExplanationOfFix = "*TBD*";
  }

}

// BlockCommentNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A block comment started wasn't properly closed when we reached the end of the file.";
  error.Name = "BlockCommentNotComplete";
  error.Reason = "Commonly, users accidentally delete or mistype the end of a block comment, which can cause code to be unnecessarily commented out. This can be dangerous if it was unintentional, hence the error.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "var cat : Animal := new Cat();\r\n\r\n/*\r\nvar dog : Animal := new Dog();";
    example.FixedCode = "var cat : Animal := new Cat();\r\n\r\n/*\r\nvar dog : Animal := new Dog();\r\n*/";
    example.ExplanationOfFix = "In the error case, we started a block comment (/*) but never finished it with (*/).";
  }

}

// BlockCommentNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A block comment end (*/) was found, but the beginning of the block comment (/*) was not found.";
  error.Name = "BlockCommentNotFound";
  error.Reason = "";

}

// BreakCountMustBeGreaterThanZero
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The break count is the number of loops we want to break out of, and therefore must be greater than or equal to 1.";
  error.Name = "BreakCountMustBeGreaterThanZero";
  error.Reason = "";

}

// BreakLoopNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A break statement was used, but we couldn't find the loop that it was breaking out of.";
  error.Name = "BreakLoopNotFound";
  error.Reason = "";

}

// CannotCreateType
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The type '%s' can only be created outside of Zilch.";
  error.Name = "CannotCreateType";
  error.Reason = "";

}

// CannotReplaceTemplateInstanceWithNonTemplateType
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "We tried to replace a type in a template, but couldn't do it since the type was used as an actual template type, and the type passed in as a template argument was not templatable.";
  error.Name = "CannotReplaceTemplateInstanceWithNonTemplateType";
  error.Reason = "";

}

// CannotReplaceTemplateInstanceWithTemplateArguments
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "It's complicated. I am really sorry, but it's just complicated.";
  error.Name = "CannotReplaceTemplateInstanceWithTemplateArguments";
  error.Reason = "";

}

// CastTypeNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The casting operator 'as' is missing a cast type declaration (eg. x as Real).";
  error.Name = "CastTypeNotFound";
  error.Reason = "Casting allows us to convert one type to another. The 'as' operator was chosen because it gets rid of many unnecessary parentheses (eg C-style casts). The 'as' operator takes what we want to convert on the left and the type we want to convert it to on the right.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n	return 5 as ;\r\n  }\r\n}";
    example.FixedCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n	return 5 as Real;\r\n  }\r\n}";
    example.ExplanationOfFix = "*TBD*";
  }

}

// ClassBodyNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Class declaration '%s' does not have a closing '}'.";
  error.Name = "ClassBodyNotComplete";
  error.Reason = "In order for the compiler to understand where a class definition starts and ends, an opening ({) and closing (}) scope must be used. If the scope was not closed, the compiler would be forced to assume that the class encompasses all the code below it, which could be erroneous. There are a few likely cases that this could happen: the closing scope brace has been left off, a scope or parenthesis inside the class was not properly closed, or a variable or function declaration was garbled inside the class causing it to hault its parsing.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n";
    example.FixedCode = "class Animal\r\n{\r\n}\r\n";
    example.ExplanationOfFix = "In the error case, we started the definition of the class 'Animal' but never closed the scope. We fixed it by simply adding a closing scope (}) to the end of the class.";
  }

}

// ClassBodyNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Class declaration '%s' does not have an opening '{'.";
  error.Name = "ClassBodyNotFound";
  error.Reason = "The compiler couldn't find the opening scope ({) for the class declaration, and therefore the class has no body. Check to make sure you added an opening scope and that the class name or inheritance list wasn't garbled. If you come from languages like C or C++ and you were trying to make a forward declaration, it is not required since the language globally shares all type-definitions between different scripts.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n";
    example.FixedCode = "class Animal\r\n{\r\n}";
    example.ExplanationOfFix = "In the error case, we forgot the opening scope ({). We fixed it by simply adding one in.";
  }

}

// ClassNameNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Class declaration is missing or invalid (we were unable to find the class name).";
  error.Name = "ClassNameNotFound";
  error.Reason = "Most likely the class name was invalid due to unnecessary symbols or to using a keyword in its place, or the class name was missing.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class\r\n{\r\n}";
    example.FixedCode = "class Animal\r\n{\r\n}";
    example.ExplanationOfFix = "In the error case, we forgot to add the name of the class after the 'class' keyword. We fixed this by adding the name 'Animal' after the class, thus giving the type a name.";
  }

}

// CompositionCycleDetected
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A cycle of composition was detected. Eg. Type A includes Type B, Type B includes Type C, and Type C includes Type A (which is illegal).";
  error.Name = "CompositionCycleDetected";
  error.Reason = "";

}

// ConditionMustBeABooleanType
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The expression resulted in a '%s'. Any condition must result in a Boolean (true/false) type.";
  error.Name = "ConditionMustBeABooleanType";
  error.Reason = "";

}

// ConstructorCallNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The new/local constructor call was not found.";
  error.Name = "ConstructorCallNotFound";
  error.Reason = "";

}

// ConstructorCannotAccessStaticMembers
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "You cannot access members on a type created with new/local";
  error.Name = "ConstructorCannotAccessStaticMembers";
  error.Reason = "";

}

// ContinueLoopNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A continue statement was used, but we couldn't find the loop that it was continuing from.";
  error.Name = "ContinueLoopNotFound";
  error.Reason = "";

}

// CreatedTypeNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The new/local operator was missing a created type.";
  error.Name = "CreatedTypeNotFound";
  error.Reason = "";

}

// CreationInitializeMemberExpectedInitialValue
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "When initializing the member '%s', we need to specify a value expression to initialize to, eg '%s = 9'.";
  error.Name = "CreationInitializeMemberExpectedInitialValue";
  error.Reason = "";

}

// CreationInitializerExpectedSubElement
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Failed to parse a sub-element of the creation initializer. The sub-element can be a member initialization 'Name: Value', an expression that can be added to a container, or a list of expressions to be added '{Value1, Value2, ...}'.";
  error.Name = "CreationInitializerExpectedSubElement";
  error.Reason = "";

}

// CreationInitializerNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Creation initializer read something it did not understand or is not properly closed with a '}'.";
  error.Name = "CreationInitializerNotComplete";
  error.Reason = "";

}

// CustomError
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "An error occurred: '%s'";
  error.Name = "CustomError";
  error.Reason = "";

}

// DelegateReturnTypeNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Delegate declaration is missing the return type declaration, yet the type specifier ':' was found.";
  error.Name = "DelegateReturnTypeNotFound";
  error.Reason = "";

}

// DeletingNonReferenceType
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Unable to delete a non reference type.";
  error.Name = "DeletingNonReferenceType";
  error.Reason = "";

}

// DeletingNonWritableValue
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Objects that are not writable cannot be deleted.";
  error.Name = "DeletingNonWritableValue";
  error.Reason = "";

}

// DoWhileConditionalExpressionNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Do while statement conditional expression is not properly closed.";
  error.Name = "DoWhileConditionalExpressionNotComplete";
  error.Reason = "";

}

// DoWhileConditionalExpressionNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Do while statement conditional expression was not found.";
  error.Name = "DoWhileConditionalExpressionNotFound";
  error.Reason = "";

}

// DuplicateLocalVariableName
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A local variable (or parameter) with the same name '%s' has already been defined (or you attempted to name your parameter a reserved name, such as 'this').";
  error.Name = "DuplicateLocalVariableName";
  error.Reason = "";

}

// DuplicateMemberName
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A member with the same name '%s' has already been defined.";
  error.Name = "DuplicateMemberName";
  error.Reason = "";

}

// DuplicateTypeName
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A type with the same name '%s' has already been defined in the '%s' library.";
  error.Name = "DuplicateTypeName";
  error.Reason = "";

}

// EnumBodyNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Enum/flags declaration '%s' does not have a closing '}'.";
  error.Name = "EnumBodyNotComplete";
  error.Reason = "";

}

// EnumBodyNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Enum/flags declaration '%s' does not have an opening '{'.";
  error.Name = "EnumBodyNotFound";
  error.Reason = "";

}

// EnumDuplicateValue
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A value of the same name '%s' has already been declared in the enum/flags '%s'. Names must only be used once.";
  error.Name = "EnumDuplicateValue";
  error.Reason = "";

}

// EnumNameNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Enum/flags declaration is missing a name.";
  error.Name = "EnumNameNotFound";
  error.Reason = "";

}

// EnumValueRequiresIntegerLiteral
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "When assigning a specific value to '%s' by using '=', you must specify an integer literal (e.g. 5).";
  error.Name = "EnumValueRequiresIntegerLiteral";
  error.Reason = "";

}

// ExternalTypeNamesCollide
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The type '%s' from the library '%s' collides with another type of the same name from the library '%s'. Currently this is always an error, but in the future it will not be an error until someone tries to reference that type in their code.";
  error.Name = "ExternalTypeNamesCollide";
  error.Reason = "";

}

// ForEachInKeywordNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The foreach loop requires an 'in' keyword, which specifies which range we're iterating through.";
  error.Name = "ForEachInKeywordNotFound";
  error.Reason = "";

}

// ForEachRangeExpressionNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The foreach loop expects a range expression after the 'in' keyword.";
  error.Name = "ForEachRangeExpressionNotFound";
  error.Reason = "";

}

// ForEachVariableDeclarationNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The variable declaration in a foreach loop was not found.";
  error.Name = "ForEachVariableDeclarationNotFound";
  error.Reason = "";

}

// ForLoopExpressionsNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "For loop expressions were not complete.";
  error.Name = "ForLoopExpressionsNotComplete";
  error.Reason = "";

}

// ForLoopExpressionsNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "For loop expressions were not found.";
  error.Name = "ForLoopExpressionsNotFound";
  error.Reason = "";

}

// FunctionArgumentListNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Function declaration '%s' has an invalid argument list.";
  error.Name = "FunctionArgumentListNotComplete";
  error.Reason = "Argument list in function declaration must end with a ')' for the compiler to know when it is finished.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  function TestFn(\r\n  {\r\n  }\r\n}";
    example.FixedCode = "class Animal\r\n{\r\n  function TestFn()\r\n  {\r\n  }\r\n}";
    example.ExplanationOfFix = "Just adding a ')' finishes the argument list.";
  }

}

// FunctionArgumentListNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Function declaration '%s' is missing the argument list opening '('.";
  error.Name = "FunctionArgumentListNotFound";
  error.Reason = "Function declarations must contain an argument list opening with '(' and ending with ')'.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  function TestFn\r\n  {\r\n  }\r\n}";
    example.FixedCode = "class Animal\r\n{\r\n  function TestFn()\r\n  {\r\n  }\r\n}";
    example.ExplanationOfFix = "Added an empty argument list, but an argument list nonetheless.";
  }

}

// FunctionBodyNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Function declaration '%s' does not have a closing '}'.";
  error.Name = "FunctionBodyNotComplete";
  error.Reason = "For the compiler to know the entirety of a function, the function body needs to begin and end with curly braces.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  var Number : Integer := 9;\r\n\r\n  function TestFn() : Real\r\n  {\r\n    return 1.0;\r\n\r\n  function AnotherFn() : Real\r\n  {\r\n    return 1.0;\r\n  }\r\n}\r\n";
    example.FixedCode = "class Animal\r\n{\r\n  var Number : Integer := 9;\r\n\r\n  function TestFn() : Real\r\n  {\r\n    return 1.0;\r\n  }\r\n  function AnotherFn() : Real\r\n  {\r\n    return 1.0;\r\n  }\r\n}";
    example.ExplanationOfFix = "The solution to this case is to add the closing bracket to the TestFn.";
  }

}

// FunctionBodyNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Function declaration '%s' does not have an opening '{'.";
  error.Name = "FunctionBodyNotFound";
  error.Reason = "The compiler couldn't find the opening scope ({) for the function definition. Functions consist of a series of statements and expressions, and the compiler knows which of those belong to the function by what's inside the curly braces.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n}\r\n";
    example.FixedCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n    return 1.0;\r\n  }\r\n}";
    example.ExplanationOfFix = "Adding the rest of the function, such as the braces and return call.";
  }

}

// FunctionCallExpectedAfterInitializer
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "We expect a function call after any initializer (base, this, member initialization, etc).";
  error.Name = "FunctionCallExpectedAfterInitializer";
  error.Reason = "";

}

// FunctionCallNamedArgumentNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The right hand side of a named argument '%s' is missing or invalid.";
  error.Name = "FunctionCallNamedArgumentNotFound";
  error.Reason = "";

}

// FunctionCallNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A function call was not properly closed with ')', or one of the inner expressions was invalid.";
  error.Name = "FunctionCallNotComplete";
  error.Reason = "";

}

// FunctionCallOnNonCallableType
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The left hand side of a function call () must be a callable type, like a function or delegate.";
  error.Name = "FunctionCallOnNonCallableType";
  error.Reason = "";

}

// FunctionNameNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Function declaration is missing a name.";
  error.Name = "FunctionNameNotFound";
  error.Reason = "Function must have a name in order to be called.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  function ()\r\n  {\r\n  }\r\n}";
    example.FixedCode = "class Animal\r\n{\r\n  function Foo()\r\n  {\r\n  }\r\n}";
    example.ExplanationOfFix = "test";
  }

}

// FunctionParameterNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "An argument specified (,) was found, but no parameter was defined to the right of it.";
  error.Name = "FunctionParameterNotFound";
  error.Reason = "";

}

// FunctionReturnTypeNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Function declaration '%s' has a return type specifier ':' but is missing the return type declaration.";
  error.Name = "FunctionReturnTypeNotFound";
  error.Reason = "':' was used after the parameter list, which signifies to the compiler that the function will be returning an object. The ':' must be followed by the type of object that will be returned. If you want nothing to be returned (ex 'void'), omit the usage of the ':'.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "function TestFn() :\r\n{\r\n}";
    example.FixedCode = "function TestFn()\r\n{\r\n}";
    example.ExplanationOfFix = "Fixed by removing the incomplete return type syntax.";
  }

}

// GenericError
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "%s";
  error.Name = "GenericError";
  error.Reason = "";

}

// GetFoundAfterSet
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "When writing the property '%s', the 'get' must always come before the 'set', just for the sake of consistency.";
  error.Name = "GetFoundAfterSet";
  error.Reason = "";

}

// GroupingOperatorNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A grouping operator was not properly closed, or the expression in the grouping was missing or invalid.";
  error.Name = "GroupingOperatorNotComplete";
  error.Reason = "";

}

// IfConditionalExpressionNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "If statement conditional expression is not properly closed.";
  error.Name = "IfConditionalExpressionNotComplete";
  error.Reason = "";

}

// IfConditionalExpressionNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "If statement conditional expression was not found.";
  error.Name = "IfConditionalExpressionNotFound";
  error.Reason = "";

}

// IndexerIndicesNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The index or indices were invalid or not found for the index operator '[]'.";
  error.Name = "IndexerIndicesNotFound";
  error.Reason = "";

}

// IndexerNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "An index operator was not closed with ']' or its contents were invalid.";
  error.Name = "IndexerNotComplete";
  error.Reason = "";

}

// InternalError
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "An internal error occurred: '%s'";
  error.Name = "InternalError";
  error.Reason = "";

}

// InvalidAttribute
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The attribute '%s' is not valid.%s";
  error.Name = "InvalidAttribute";
  error.Reason = "";

}

// InvalidBinaryOperation
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The binary '%s' operator '%s' is not valid with '%s' and '%s'.";
  error.Name = "InvalidBinaryOperation";
  error.Reason = "";

}

// InvalidEscapeInStringLiteral
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "An invalid escape sequence '\\%c' was used in a string literal.";
  error.Name = "InvalidEscapeInStringLiteral";
  error.Reason = "";

}

// InvalidNumberOfTemplateArguments
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "We expected %d template arguments but were only given %d.";
  error.Name = "InvalidNumberOfTemplateArguments";
  error.Reason = "";

}

// InvalidTypeCast
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Attempting to cast between two unrelated types '%s' and '%s' (like trying to convert a car into an apple).";
  error.Name = "InvalidTypeCast";
  error.Reason = "";

}

// InvalidUnaryOperation
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The unary operation is not valid on the type '%s'.";
  error.Name = "InvalidUnaryOperation";
  error.Reason = "";

}

// LocalCreateMustBeValueType
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The 'local' keyword can only be used to create value types (primitives and 'struct' types). '%s' is not a value type.";
  error.Name = "LocalCreateMustBeValueType";
  error.Reason = "The keyword 'local' is used to differentiate whether we are allocating something directly on the stack or on a class as a member. Locals must be value types because when they are copied we memory-copy the entire object (which isn't valid for reference types).";

}

// LocalVariableReferenceNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The variable '%s' could not be found. If the variable was defined above, but is in a nested scope, then we cannot access it.";
  error.Name = "LocalVariableReferenceNotFound";
  error.Reason = "";

}

// MemberAccessNameNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Member access operator found without a valid member on the right hand side.";
  error.Name = "MemberAccessNameNotFound";
  error.Reason = "";

}

// MemberNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A member by the name of '%s' (function, field, or property) could not be found on '%s'.";
  error.Name = "MemberNotFound";
  error.Reason = "";

}

// MemberVariableTypesCannotBeInferred
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The type of a member variable '%s' cannot be inferred.";
  error.Name = "MemberVariableTypesCannotBeInferred";
  error.Reason = "";

}

// MultipleInheritanceNotSupported
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A class can only inherit from a single base class.";
  error.Name = "MultipleInheritanceNotSupported";
  error.Reason = "Mutltiple ineritance has the problems :B";

}

// NativeTypesRequireConstructors
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The native type '%s' has no constructors and cannot be created.";
  error.Name = "NativeTypesRequireConstructors";
  error.Reason = "";

}

// NoArgumentConstructorsProvided
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The type '%s' has no constructors that take arguments.";
  error.Name = "NoArgumentConstructorsProvided";
  error.Reason = "";

}

// NotAllPathsReturn
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A function is declared to return a type, yet not all code paths through the function result in it returning something.";
  error.Name = "NotAllPathsReturn";
  error.Reason = "";

}

// OnlyOneDestructorAllowed
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A class is only allowed to have one destructor (otherwise, which one would we call?).";
  error.Name = "OnlyOneDestructorAllowed";
  error.Reason = "";

}

// OverloadsCannotBeTheSame
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Two methods of the same name '%s' have the exact same signature, this is not allowed.";
  error.Name = "OverloadsCannotBeTheSame";
  error.Reason = "";

}

// ParameterTypeNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Parameter declaration '%s' has a type specifier ':' but is missing the type declaration.";
  error.Name = "ParameterTypeNotFound";
  error.Reason = "Parameter names must have types associated with them. Ambiguously-typed parameters are not allowed in Zilch.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  function TestFn(count : )\r\n  {\r\n  }\r\n}";
    example.FixedCode = "class Animal\r\n{\r\n  function TestFn(count : Int)\r\n  {\r\n  }\r\n}";
    example.ExplanationOfFix = "Simply add the type of the parameter and all is good.";
  }

}

// ParameterTypeSpecifierNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Parameter declaration '%s' is missing the type specifier ':'.";
  error.Name = "ParameterTypeSpecifierNotFound";
  error.Reason = "Function parameters must have types associated with them, denoted by the syntax 'parameter : parameterType'. Zilch does not support ambiguously-typed parameters.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  function TestFn(count )\r\n  {\r\n  }\r\n}";
    example.FixedCode = "class Animal\r\n{\r\n  function TestFn(count : Int)\r\n  {\r\n  }\r\n}";
    example.ExplanationOfFix = "Adding the type specifier, ':', and a type to the parameter 'count'.";
  }

}

// ParsingNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Parsing could not be completed (we ran into something we didn't understand). The token we hit was '%s' with token type '%s'.";
  error.Name = "ParsingNotComplete";
  error.Reason = "";

}

// PropertyDeclarationNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The declaration of the property '%s' must be closed by an ending '}'.";
  error.Name = "PropertyDeclarationNotComplete";
  error.Reason = "";

}

// PropertyDelegateOperatorRequiresProperty
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The property delegate operator '@' only works on properties (which also includes data members).";
  error.Name = "PropertyDelegateOperatorRequiresProperty";
  error.Reason = "";

}

// PropertyDelegateRequiresGetOrSet
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The property delegate operator '@' requires the property to have either a 'get' or 'set' (or both). The property '%s' has neither.";
  error.Name = "PropertyDelegateRequiresGetOrSet";
  error.Reason = "";

}

// ReadingFromAWriteOnlyValue
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "An attempt was made to read from a write only value.";
  error.Name = "ReadingFromAWriteOnlyValue";
  error.Reason = "";

}

// ReferencesOnlyToNamedValueTypes
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "References (using the 'ref' keyword) can only be made to named value types, such as 'struct' types or primitives. '%s' is not a named value type.";
  error.Name = "ReferencesOnlyToNamedValueTypes";
  error.Reason = "";

}

// ReferenceToUndefinedType
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The type '%s' was referenced, but could not be found.";
  error.Name = "ReferenceToUndefinedType";
  error.Reason = "";

}

// ReturnTypeMismatch
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The '%s' type of the return value did not match the function's '%s' return type.";
  error.Name = "ReturnTypeMismatch";
  error.Reason = "";

}

// ReturnValueNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The return statement is expected to return a '%s' value, since the function declares it so (the ':' at the end specifies the return type).";
  error.Name = "ReturnValueNotFound";
  error.Reason = "";

}

// ReturnValueUnexpected
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The return statement was not expected to return a '%s' value, since the function does not declare it (no ':' at the end).";
  error.Name = "ReturnValueUnexpected";
  error.Reason = "";

}

// ScopeBodyNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The %s statement body is not properly closed.";
  error.Name = "ScopeBodyNotComplete";
  error.Reason = "";

}

// ScopeBodyNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The %s statement body was not found.";
  error.Name = "ScopeBodyNotFound";
  error.Reason = "";

}

// SendsEventStatementNameNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "In a 'sends' statement, we expect to see 'sends EventName : EventType;'. The name was not found.";
  error.Name = "SendsEventStatementNameNotFound";
  error.Reason = "";

}

// SendsEventStatementNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "In a 'sends %s' statement, we expect to see 'sends EventName : EventType;'. The statement was not complete (probably missing a ';').";
  error.Name = "SendsEventStatementNotComplete";
  error.Reason = "";

}

// SendsEventStatementTypeNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "In a 'sends %s' statement, we expect to see 'sends EventName : EventType;'. The event type was not found.";
  error.Name = "SendsEventStatementTypeNotFound";
  error.Reason = "";

}

// SendsEventStatementTypeSpecifierNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "In a 'sends %s' statement, we expect to see 'sends EventName : EventType;'. The event type specifier ':' was not found.";
  error.Name = "SendsEventStatementTypeSpecifierNotFound";
  error.Reason = "";

}

// StatementSeparatorNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The statement must end with a semicolon.";
  error.Name = "StatementSeparatorNotFound";
  error.Reason = "";

}

// StatementsWillNotBeExecutedEarlyReturn
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The statement will not get hit because all code paths return before it would get to it. Use 'debug return' to exit early for debugging purposes.";
  error.Name = "StatementsWillNotBeExecutedEarlyReturn";
  error.Reason = "";

}

// StaticCannotBeOverriding
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The function or property '%s' marked as Static cannot also be marked as Override (because it can't be virtual).";
  error.Name = "StaticCannotBeOverriding";
  error.Reason = "";

}

// StaticCannotBeVirtual
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The function or property '%s' marked as Static cannot also be marked as Virtual.";
  error.Name = "StaticCannotBeVirtual";
  error.Reason = "";

}

// StaticTypeConstructorOrAccessNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "You can only refer to a type when constructing it or accessing static members upon it";
  error.Name = "StaticTypeConstructorOrAccessNotFound";
  error.Reason = "";

}

// StringInterpolantExpectedExpression
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "When we start a string interpolant with '`' we expect an expression to follow that we will stringify.";
  error.Name = "StringInterpolantExpectedExpression";
  error.Reason = "";

}

// StringInterpolantNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "When we start a string interpolant with '`' we are expected to end it with another '`'.";
  error.Name = "StringInterpolantNotComplete";
  error.Reason = "";

}

// StringLiteralNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A string literal was started, but never finished before hitting the end of the line or stream.";
  error.Name = "StringLiteralNotComplete";
  error.Reason = "";

}

// StructsCanOnlyContainValueTypes
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The struct '%s' can only contain value types (other structs or primitive values). The member '%s' is not a value type.";
  error.Name = "StructsCanOnlyContainValueTypes";
  error.Reason = "A struct is a value type, which means it must be trivially copyable in memory and must not have a destructor. Structs are typically used for efficiency because they can be quickly copied around and stack allocated, unlike classes which must be heap allocated.";

}

// TemplateArgumentNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The argument to a template type was not found.";
  error.Name = "TemplateArgumentNotFound";
  error.Reason = "";

}

// TemplateTypeArgumentsNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Arguments for a templated type were provided, but were never closed or completed.";
  error.Name = "TemplateTypeArgumentsNotComplete";
  error.Reason = "";

}

// ThrowExceptionExpressionNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "A throw statement always requires an exception to be thrown, e.g. 'throw new Exception();'. The exception part of the throw statement wasn't found.";
  error.Name = "ThrowExceptionExpressionNotFound";
  error.Reason = "";

}

// ThrowTypeMustDeriveFromException
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The exception we're throwing must derive from the 'Exception' type.";
  error.Name = "ThrowTypeMustDeriveFromException";
  error.Reason = "";

}

// TimeoutBodyNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Timeout statement body is not properly closed.";
  error.Name = "TimeoutBodyNotComplete";
  error.Reason = "";

}

// TimeoutBodyNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Timeout statement body was not found.";
  error.Name = "TimeoutBodyNotFound";
  error.Reason = "";

}

// TimeoutSecondsExpectedIntegerLiteral
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The timeout statement only accepts Integer literals for seconds.";
  error.Name = "TimeoutSecondsExpectedIntegerLiteral";
  error.Reason = "";

}

// TimeoutSecondsMustBeNonZeroPositive
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The time in seconds given to the timeout statement must be positive and non-zero.";
  error.Name = "TimeoutSecondsMustBeNonZeroPositive";
  error.Reason = "";

}

// TimeoutSecondsNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Timeout statement's seconds is not properly closed with a ')'.";
  error.Name = "TimeoutSecondsNotComplete";
  error.Reason = "";

}

// TimeoutSecondsNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The timeout statement must be followed by a '(', the time in seconds, and a closing ')'.";
  error.Name = "TimeoutSecondsNotFound";
  error.Reason = "";

}

// TypeIdExpressionNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "In the typeid(...) expression we expect the value to be wrapped in parenthases, but we didn't find the closing ')'.";
  error.Name = "TypeIdExpressionNotComplete";
  error.Reason = "";

}

// TypeIdExpressionNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "In the typeid(...) expression we expect to find an expression wrapped in parentheses, but we couldn't find it.";
  error.Name = "TypeIdExpressionNotFound";
  error.Reason = "";

}

// UnableToResolveFunction
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The function '%s' exists, but could not be resolved since the types or names of the arguments used did not match. The arguments you gave were: %sThe possible choices were: %s";
  error.Name = "UnableToResolveFunction";
  error.Reason = "";

}

// UnaryOperatorOperandNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The operand was not found for the '%s' operator '%s'.";
  error.Name = "UnaryOperatorOperandNotFound";
  error.Reason = "The operators such as negation '-' and logical-not '!' must have an operand on the right-hand side for them to be valid syntax.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n	return - ;\r\n  }\r\n}";
    example.FixedCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n	return -1.0 ;\r\n  }\r\n}";
    example.ExplanationOfFix = "*TBD*";
  }

}

// UnidentifiedSymbol
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Invalid symbol or character '%c' encountered.";
  error.Name = "UnidentifiedSymbol";
  error.Reason = "The compiler ran into a symbol or character that it didn't understand, and therefore cannot continue.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "function #IsEmpty() : Bool32\r\n{\r\n  return mCount == 0;\r\n}";
    example.FixedCode = "function IsEmpty() : Bool32\r\n{\r\n  return mCount == 0;\r\n}";
    example.ExplanationOfFix = "In the error case, a # sign was introduced before the name of the function. The tokenizer would reach this symbol and hault, not knowing what it is.";
  }

}

// UnnecessaryVirtualAndOverride
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "When marking the method '%s' as overriding, it is unnecessary to also mark it as Virtual.";
  error.Name = "UnnecessaryVirtualAndOverride";
  error.Reason = "";

}

// VariableInitializationNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Variable declaration '%s' is missing a semicolon or the initialization expression is invalid.";
  error.Name = "VariableInitializationNotComplete";
  error.Reason = "This error occurred because the compiler was trying to parse a variable declaration with initialization and expected to find a semicolon at the end, but did not. The causes could be as simple as the semicolon is missing, or that the semicolon is in fact there, but the initialization expression was somehow garbled. If you're curious as to why a semicolon is needed, they are necessary because they act as a separator and help the parser to differentiate statements from each other, just like periods in a sentence. Imagine if a period was missing from a sentance, or worse yet if a sentance was so confusing to the point that you would expected a period!";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "var cat : Animal = new Cat()\r\nvar dog : Animal = new Dog();";
    example.FixedCode = "var cat : Animal = new Cat();\r\nvar dog : Animal = new Dog();";
    example.ExplanationOfFix = "In the error case, we forgot to put a semicolon (;) at the end of the 'cat' variable declaration. We fixed it by simply adding in a semicolon.";
  }

}

// VariableInitialValueNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Variable declaration '%s' has a missing or invalid initialization value.";
  error.Name = "VariableInitialValueNotFound";
  error.Reason = "Most probably the initial value of the variable was omitted, or a typo was made that caused the compiler to be unable to parse the initial value expression.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "var lives : Int32 := ;";
    example.FixedCode = "var lives : Int32 := 9;";
    example.ExplanationOfFix = "In the error case, the variable 'lives' was going to be initialized, but the value was left out. In the fixed case, we added a value (this value is known as the initialization expression).";
  }

}

// VariableMustBeInitialized
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Variable declaration '%s' is missing the initializer expression.";
  error.Name = "VariableMustBeInitialized";
  error.Reason = "All variables must be initialized for safety, and rather than letting the language decide some default value to initialize to, we forced the users to initialize all of their variables. Safety is a key concern for the language because it allows users to focus more on debugging logical bugs rather than bugs caused by indeterminate factors (like uninitialized variables).";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "var lives : Int32;";
    example.FixedCode = "var lives : Int32 = 9;";
    example.ExplanationOfFix = "In the error case, the variable 'lives' did not have an initializer after it, and therefore would have had an undefined value. We fixed this by giving it an initialization expression so that we would ultimately always be in control of its value.";
  }

}

// VariableNameNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Variable declaration has a missing or invalid name.";
  error.Name = "VariableNameNotFound";
  error.Reason = "One of the most common reasons for this error is that a keyword was used as a variable's name, which is not allowed because it could confuse the compiler. Also look to see if the name was left off, or if somehow the name was garbled with other symbols. If you're wondering why a variable needs a name, the reason is because a name gives us a way to refer to it in other parts of code, much like how people have names so we can refer to them and differentiate them apart.";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "var : Int32 := 9;";
    example.FixedCode = "var lives : Int32 := 9;";
    example.ExplanationOfFix = "In the error case, we forgot to name the variable. We fixed it simply by adding the variable name 'lives' after the 'var' keyword.";
  }

}

// VariableTypeMismatch
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "The value being assigned to '%s' must be of type '%s'. Its type is '%s'.";
  error.Name = "VariableTypeMismatch";
  error.Reason = "";

}

// VariableTypeNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "Variable declaration '%s' has a type specifier ':' but is missing the type declaration.";
  error.Name = "VariableTypeNotFound";
  error.Reason = "Mosty likely the type was just left out or the type contained some invalid keyword or symbol. If the type specifier (:) operator was found, then the variable expects a type. If you actually meant to make the variable an inferred type, then leave off the (:) and type declaration altogether. Inferred variables are variables whose type is gleaned by the initialization value (this feature is better known as Type Inference).";

  {
    ErrorExample& example = error.Examples.push_back();
    example.ErrorCode = "var lives : := 9;";
    example.FixedCode = "var lives : Int32 := 9;\r\n\r\n/* OR */\r\n\r\nvar lives := 9;";
    example.ExplanationOfFix = "In the error case, the type of lives was left out yet the type qualifier (:) was specified. We can fix it in two ways, first by actually specifying the type, and second by using type inference to infer the type automatically.";
  }

}

// WhileConditionalExpressionNotComplete
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "While statement conditional expression is not properly closed.";
  error.Name = "WhileConditionalExpressionNotComplete";
  error.Reason = "";

}

// WhileConditionalExpressionNotFound
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "While statement conditional expression was not found.";
  error.Name = "WhileConditionalExpressionNotFound";
  error.Reason = "";

}

// WritingToAReadOnlyValue
{
  ErrorInfo& error = this->Errors.push_back();
  error.Error = "An attempt was made to write to a read only value.";
  error.Name = "WritingToAReadOnlyValue";
  error.Reason = "";

}


  }

  //***************************************************************************
  ErrorDatabase& ErrorDatabase::GetInstance()
  {
    // Singleton pattern
    static ErrorDatabase instance;
    return instance;
  }

  //***************************************************************************
  const ErrorInfo& ErrorDatabase::GetErrorInfo(ErrorCode::Enum errorCode) const
  {
    return this->Errors[errorCode];
  }
  
  //***************************************************************************
  ErrorEvent::ErrorEvent() :
    ErrorCode(ErrorCode::Invalid)
  {
  }

  //***************************************************************************
  ErrorEvent::ErrorEvent(const ErrorInfo& info, const CodeLocation& location, ErrorCode::Enum code, va_list args) :
    Reason(info.Reason),
    Examples(info.Examples),
    Location(location),
    ExactError(String::FormatArgs(info.Error.c_str(), args)),
    ErrorCode(code)
  {
  }

  //***************************************************************************
  String ErrorEvent::GetFormattedMessage(MessageFormat::Enum format) const
  {
    // Print the error message out with the location (in a standard format)
    String message = this->Location.GetFormattedStringWithMessage(format, this->ExactError);

    // The message may have more things appended to it, so create a string builder
    StringBuilder builder;
    builder.Append(message);
    
    // Walk through all locations associated with this error (many errors have no associated locations, just the first 'Location')
    // Associated locations are things like duplicate class definitions, where it shows the other location the class was defined
    for (size_t i = 0; i < this->AssociatedOtherLocations.size(); ++i)
    {
      // Grab the current location and append it to the error message
      const CodeLocation& associatedLocation = this->AssociatedOtherLocations[i];
      String seeLocation = associatedLocation.GetFormattedString(format);
      builder.Append("      See");
      builder.Append(seeLocation);
    }

    // Compact the builder into one final string containing everything about the error
    return builder.ToString();
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes







namespace Zilch
{
  //***************************************************************************
  // For the moment we let the user use a special define to disable event safety, because right now events have issues
  #if !defined(ZilchUnsafeEvents)
    #define ZilchUnsafeEvents false
  #endif

  //***************************************************************************
  // When we attempt to 'get an event handler' from a type that is actually an EventHandler
  // then we really don't need to do anything except return ourself
  EventHandler* EventHandlerGetEventHandlerFunction(const BoundType* type, const byte* data)
  {
    return (EventHandler*)data;
  }

  //***************************************************************************
  ZilchDefineType(EventHandler, "EventHandler", Core, builder, type)
  {
    ZilchBindConstructor(builder, type, EventHandler, ZilchNoNames);
    ZilchBindDestructor(builder, type, EventHandler);
    type->GetEventHandlerFunction = EventHandlerGetEventHandlerFunction;
  }

  //***************************************************************************
  ZilchDefineType(EventsClass, "Events", Core, builder, type)
  {
    ZilchBindMethod(builder, type, &EventsClass::Send, ZilchNoOverload, "Send", "sender, eventName, event");
    ZilchBindMethod(builder, type, &EventsClass::Connect, ZilchNoOverload, "Connect", "sender, eventName, callback");
  }

  //***************************************************************************
  ZilchDefineType(EventData, "EventData", Core, builder, type)
  {
    ZilchBindConstructor(builder, type, EventData, ZilchNoNames);
    ZilchBindDestructor(builder, type, EventData);
  }

  //***************************************************************************
  // Definition of static members
  EventHandler EventHandler::Global;

  //***************************************************************************
  EventData::~EventData()
  {
  }
  
  //***************************************************************************
  EventDelegate::EventDelegate() :
    Type(nullptr)
  {
  }
  
  //***************************************************************************
  EventDelegate::~EventDelegate()
  {
    // Event delegates are always responsible for unlinking themselves from the intrusive lists
    if (this->IncomingLink.Next != nullptr)
      IncomingList::Unlink(this);
    if (this->OutgoingLink.Next != nullptr)
      OutgoingList::Unlink(this);
  }

  //***************************************************************************
  EventDelegateList::~EventDelegateList()
  {
    // Delete all outgoing connections (using safe iteration)
    OnlyDeleteObjectIn(this->Outgoing);
  }
  
  //***************************************************************************
  int EventDelegateList::Send(EventData* event)
  {
    // If we have no connections then don't do anything
    if (this->Outgoing.empty())
      return 0;

    // Store the old event name, in case this event is being forwarded
    String lastEventName = event->EventName;
    event->EventName = this->EventName;

    // Get the type of event we're sending
    BoundType* sentEventType = event->ZilchGetDerivedType();

    // Because we want to ensure complete event safety, we have to make an entire copy of
    // all event delegates (and the container that holds them all)
    // That way if the user destroy objects, disconnect or reconnect new events, etc we won't
    // have issues referencing the original list / connections
    size_t totalOutgoing = 0;
    ZilchForEach(EventDelegate& delegate, this->Outgoing.all())
    {
      // Count how many outgoing event delegates we have
      ++totalOutgoing;
    }

    // Allocate on the stack an array of pointers to the delegates
    byte* delegatesList = (byte*)alloca(EventDelegate::MaxEventDelegateSize * totalOutgoing);
    
    // Now copy all the event delegates into our stack local list (before we invoke any user code!)
    size_t i = 0;
    ZilchForEach(EventDelegate& delegate, this->Outgoing.all())
    {
      // Get the memory for the current delegate
      byte* currentDelegate = delegatesList + EventDelegate::MaxEventDelegateSize * i;
      
      // Copy construct (clone) the current delegate into the memory
      delegate.CopyInto(currentDelegate);
      ++i;
    }

    // How many connections were successfully invoked?
    int successfulInvokes = 0;

    // Now that we've made a copy of all delegates, go through and invoke them, erasing them as we go
    for (size_t j = 0; j < totalOutgoing; ++j)
    {
      // Get the memory for the current delegate
      EventDelegate* delegate = (EventDelegate*)(delegatesList + EventDelegate::MaxEventDelegateSize * j);

      // If the event is not of the correct type, then don't deliver it
      // We allow the delegate to accept a more base version of the event too
      if (ZilchUnsafeEvents || TypeBinding::IsA(sentEventType, delegate->Type))
      {
        // Invoke the delegate with the event
        successfulInvokes += delegate->Invoke(event);
      }

      // Because the delegate is a temporary copy, we can destruct it using the virtual destructor
      delegate->~EventDelegate();
    }

    // Restore the last event name
    event->EventName = lastEventName;

    // Return how many connections were successfully invoked
    return successfulInvokes;
  }

  //***************************************************************************
  EventDelegateList* EventHandler::GetOrCreateOutgoingDelegateList(StringParam eventName)
  {
    // Get the current list from the map, or insert a new entry (will be null)
    EventDelegateList*& list = this->OutgoingPerEventName[eventName];

    // If the list was null (just inserted) then allocate it right now
    // Because the list is grabbed as a reference, this will automatically update the list in the map
    if (list == nullptr)
    {
      // Create the new list and set its name
      list = new EventDelegateList();
      list->EventName = eventName;
    }
    
    // Return the list that we found or created
    return list;
  }
  
  //***************************************************************************
  EventHandler::EventHandler()
  {
  }

  //***************************************************************************
  EventHandler::~EventHandler()
  {
    // Destroy all incoming delegates
    OnlyDeleteObjectIn(this->Incoming);

    // Destroy all outgoing delegate lists (which in turn destroys those delegates)
    DeleteObjectsInContainer(this->OutgoingPerEventName);
  }
  
  //***************************************************************************
  int EventSend(EventHandler* sender, StringParam eventName, EventData* event)
  {
    // We don't allow dispatching of null events
    ReturnIf(event == nullptr, 0, "Cannot send a null event");

    // Get the event delegate list for the given event name and send the event to all of them
    EventDelegateList* delegates = sender->OutgoingPerEventName.findValue(eventName, nullptr);
    if (delegates != nullptr)
    {
      return delegates->Send(event);
    }

    // Otherwise, no events were invoked
    return 0;
  }

  //***************************************************************************
  void EventSwapAll(EventHandler* a, EventHandler* b)
  {
    a->OutgoingPerEventName.swap(b->OutgoingPerEventName);
    a->Incoming.swap(b->Incoming);
  }

  //***************************************************************************
  void EventConnect(EventHandler* sender, StringParam eventName, EventDelegate* delegate, EventHandler* receiver)
  {
    // The receiver doesn't need to do anything special, it just directly stores a reference to the delegate
    receiver->Incoming.push_back(delegate);

    // Grab the list of outgoing delegates from the sender by this event name
    EventDelegateList* outgoingDelegates = sender->GetOrCreateOutgoingDelegateList(eventName);

    // Link in the delegate to this outgoing connection
    outgoingDelegates->Outgoing.push_back(delegate);
  }
  
  //***************************************************************************
  int EventDisconnect(EventHandler* sender, EventHandler* receiver, StringParam eventName, void* thisPointerOrUniqueId)
  {
    // Grab the list of outgoing delegates from the sender by this event name
    EventDelegateList* outgoingDelegates = sender->OutgoingPerEventName.findValue(eventName, nullptr);

    // If nobody signed up for this event, then early out (nothing to disconnect)
    if (outgoingDelegates == nullptr)
      return 0;

    // Loop through all the event delegates and remove anyone that has the same unique id/this pointer
    int removeCount = 0;
    EventDelegate* delegate = &outgoingDelegates->Outgoing.front();
    while (delegate != outgoingDelegates->Outgoing.end())
    {
      // List is intrusive so the pointer must be moved
      // before erasing the current connection.
      EventDelegate* currentDelegate = delegate;
      delegate = OutgoingList::Next(delegate);

      // If the delegate returns a matching this pointer...
      if (currentDelegate->GetThisPointerOrUniqueId() == thisPointerOrUniqueId)
      {
        // We can directly remove the delegate since we do safe iteration here, and we also
        // perform copying when dispatching
        // Note: Technically due to reference counting, if the delegate is keeping an object alive
        // and then we destroy it, that can cause user code to run, which could then delete the 'Next' delegate
        delete currentDelegate;
        ++removeCount;
      }
    }

    // Return how many connections were deleted
    return removeCount;
  }

  //***************************************************************************
  ForwardingEventDelegate::ForwardingEventDelegate(EventHandler* forwardTo) :
    ForwardTo(forwardTo)
  {
    this->Type = ZilchTypeId(EventData);
  }

  //***************************************************************************
  int ForwardingEventDelegate::Invoke(EventData* event)
  {
    // Directly forward the event to the other handler
    return EventSend(this->ForwardTo, event->EventName, event);
  }

  //***************************************************************************
  void* ForwardingEventDelegate::GetThisPointerOrUniqueId()
  {
    return (void*)this->ForwardTo;
  }

  //***************************************************************************
  void EventForward(EventHandler* sender, StringParam eventName, EventHandler* receiver)
  {
    // Create a member function delegate
    ForwardingEventDelegate* eventDelegate = new ForwardingEventDelegate(receiver);
    
    // Connect the event handler up to this newly created member delegate
    EventConnect(sender, eventName, eventDelegate, receiver);
  }
  
  //***************************************************************************
  ZilchEventDelegate::ZilchEventDelegate(const Delegate& delegate, ExecutableState* state) :
    FunctionWithThis(delegate),
    State(state)
  {
    // We assume that the passed in delegate should be validated by this point, so this should not crash or be invalid
    this->Type = (BoundType*)delegate.BoundFunction->FunctionType->Parameters[0].ParameterType;
  }

  //***************************************************************************
  int ZilchEventDelegate::Invoke(EventData* event)
  {
    // If we have no executable state, then the event handler was most likely invalidated
    if (this->State == nullptr)
      return 0;

    // If we the this handle is null, then we also skip this event handler
    // In general this should never happen (because this event handler would be removed)
    // However it is possible if we copied all the event handlers that we were going to call
    // and then the object was destroyed, then we would still traverse this
    if (this->FunctionWithThis.ThisHandle.IsNull())
      return 0;

    // Now we want to call the event handler
    // At the moment, we catch all exceptions from event handlers
    ExceptionReport report;
    Call call(this->FunctionWithThis, this->State);

    // For now we have a special toggle that allows the users to receive events unsafely (as a stop gap...)
    if (ZilchUnsafeEvents)
      call.DisableParameterChecks();

    // Set the event on the call and invoke it!
    call.Set(0, event);
    call.Invoke(report);

    // If the function failed to completely run... then return that this was not a successful invoke
    if (report.HasThrownExceptions())
      return 0;

    // Otherwise, we successfully invoked a Zilch callback!
    return 1;
  }

  //***************************************************************************
  void* ZilchEventDelegate::GetThisPointerOrUniqueId()
  {
    return (void*)this->FunctionWithThis.ThisHandle.Dereference();
  }
  
  //***************************************************************************
  int EventsClass::Send(const Handle& sender, StringParam eventName, EventData* event)
  {
    // Get the state that called the function (this is thread local and therefore safe)
    ExecutableState* state = ExecutableState::CallingState;
    ExceptionReport& report = *state->StackFrames.back()->Report;

    // Make sure the event being sent is not null
    if (event == nullptr)
    {
      state->ThrowException(report, "The event being sent must not be null");
      return 0;
    }

    // Make sure the sender is not null
    byte* senderMemory = sender.Dereference();
    if (senderMemory == nullptr)
    {
      state->ThrowException(report, "The sender must not be null");
      return 0;
    }

    // Attempt to get an event handler from the memory of the sender (calls into user code for user provided types)
    EventHandler* senderHandler = sender.Type->GetEventHandler(senderMemory);
    if (senderHandler == nullptr)
    {
      state->ThrowException(report, "The sender was not a valid event handler and cannot send or receive events");
      return 0;
    }

    // Send the event out and return the number of successful invokes
    return EventSend(senderHandler, eventName, event);
  }
  
  //***************************************************************************
  void EventsClass::Connect(const Handle& sender, StringParam eventName, const Delegate& callback)
  {
    // Get the state that called the function (this is thread local and therefore safe)
    ExecutableState* state = ExecutableState::CallingState;
    ExceptionReport& report = *state->StackFrames.back()->Report;

    // If the function is null, then throw an exception
    if (callback.BoundFunction == nullptr)
    {
      state->ThrowException(report, "The callback must not be null");
      return;
    }
    
    // Make sure the delegate's return type is void
    DelegateType* signature = callback.BoundFunction->FunctionType;
    if (Type::IsSame(signature->Return, ZilchTypeId(void)) == false)
    {
      state->ThrowException(report, "The callback must not return a value (the return type must be Void)");
      return;
    }
    
    // Make sure the delegate only takes one argument
    ParameterArray& parameters = signature->Parameters;
    if (parameters.size() != 1)
    {
      state->ThrowException(report, "The callback must take only one parameter, the EventData");
      return;
    }
    
    // Make sure the delegate's parameter derives from EventData (it can also be just EventData itself)
    if (TypeBinding::GenericIsA(parameters[0].ParameterType, ZilchTypeId(EventData)) == false)
    {
      state->ThrowException(report, "The callback's parameter must be an EventData or inherit from it");
      return;
    }
    
    // If the this handle is null and its not a static function, then throw an exception
    const Handle& receiver = callback.ThisHandle;
    byte* receiverMemory = receiver.Dereference();
    if (receiverMemory == nullptr && callback.BoundFunction->This != nullptr)
    {
      state->ThrowException(report, "The callback's object (the receiver) was null, and the function was not a static function");
      return;
    }

    // Attempt to get an event handler from the memory of the receiver (calls into user code for user provided types)
    EventHandler* receiverHandler = receiver.Type->GetEventHandler(receiverMemory);
    if (receiverHandler == nullptr)
    {
      state->ThrowException(report, "The receiver was not a valid event handler and cannot send or receive events");
      return;
    }

    // Make sure the sender is not null
    byte* senderMemory = sender.Dereference();
    if (senderMemory == nullptr)
    {
      state->ThrowException(report, "The sender must not be null");
      return;
    }

    // Attempt to get an event handler from the memory of the sender (calls into user code for user provided types)
    EventHandler* senderHandler = sender.Type->GetEventHandler(senderMemory);
    if (senderHandler == nullptr)
    {
      state->ThrowException(report, "The sender was not a valid event handler and cannot send or receive events");
      return;
    }

    // Create a the event connection that will invoke the Zilch delegate
    ZilchEventDelegate* eventDelegate = new ZilchEventDelegate(callback, state);
    
    // Connect the event handler up to this newly created member delegate
    EventConnect(senderHandler, eventName, eventDelegate, receiverHandler);
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes












namespace Zilch
{
  //***************************************************************************
  ZilchDefineType(ExecutableState, "ExecutableState", Core, builder, type)
  {
    type->HandleManager = ZilchManagerId(PointerManager);

    ZilchBindField(builder, type, &CallingState, "CallingState", PropertyBinding::Get);
    ZilchBindMethod(builder, type, &ExecutableState::ExecuteStatement, ZilchNoOverload, "ExecuteStatement", ZilchNoNames);
  }

  //***************************************************************************
  namespace Events
  {
    ZilchDefineEvent(FatalError);
    ZilchDefineEvent(UnhandledException);
    ZilchDefineEvent(HandledException);
    ZilchDefineEvent(OpcodePreStep);
    ZilchDefineEvent(OpcodePostStep);
    ZilchDefineEvent(EnterFunction);
    ZilchDefineEvent(ExitFunction);
    ZilchDefineEvent(MemoryLeak);
  }
  
  //***************************************************************************
  MemoryLeakEvent::MemoryLeakEvent() :
    State(nullptr),
    AllocatedLocation(nullptr)
  {
  }

  //***************************************************************************
  OpcodeEvent::OpcodeEvent() :
    State(nullptr),
    CurrentFunction(nullptr),
    ProgramCounter(InvalidOpcodeLocation),
    StackOffset(0),
    Location(nullptr)
  {
  }
  
  //***************************************************************************
  ExceptionEvent::ExceptionEvent() :
    State(nullptr),
    ThrownException(nullptr)
  {
  }

  //***************************************************************************
  FatalErrorEvent::FatalErrorEvent() :
    ErrorCode(FatalError::Invalid)
  {
  }

  //***************************************************************************
  void PerScopeData::PerformCleanup()
  {
    // Get the things we need to cleanup
    Array<Handle*>& handleCleanup = this->HandlesToBeCleaned;
    Array<Delegate*>& delegateCleanup = this->DelegatesToBeCleaned;
    Array<Any*>& anyCleanup = this->AnysToBeCleaned;

    // We need to go through all handles on the stack and destroy them
    for (size_t i = 0; i < handleCleanup.size(); ++i)
    {
      // Invoke the destructor (which should also decrement any reference counts)
      handleCleanup[i]->~Handle();
    }

    // We need to go through all delegates on the stack and destroy them
    for (size_t i = 0; i < delegateCleanup.size(); ++i)
    {
      // Invoke the destructor (which should also destroy the 'this' handle)
      delegateCleanup[i]->~Delegate();
    }

    // We need to go through all anys on the stack and destroy them
    for (size_t i = 0; i < anyCleanup.size(); ++i)
    {
      // Invoke the destructor (which should also destroy the stored value)
      anyCleanup[i]->~Any();
    }

    // Because this type is recycled, we need to clear the arrays for its next use
    handleCleanup.clear();
    delegateCleanup.clear();
    anyCleanup.clear();
  }

  //***************************************************************************
  PerFrameData::PerFrameData(ExecutableState* state) :
    Frame(nullptr),
    NextFrame(nullptr),
    CurrentFunction(nullptr),
    ProgramCounter(ProgramCounterNotActive),
    State(state),
    Debug(CallDebug::None),
    Report(nullptr),
    Timeouts(0),
    ErrorState(StackErrorState::Normal)
  {
  }

  //***************************************************************************
  void PerFrameData::QueueAnyCleanup(Any* any)
  {
    // Error checking
    ErrorIf(this->Scopes.back()->AnysToBeCleaned.findIndex(any) != Array<Any*>::InvalidIndex,
      "We should not be queuing the same address twice for cleanup!");

    this->Scopes.back()->AnysToBeCleaned.push_back(any);
  }

  //***************************************************************************
  void PerFrameData::QueueHandleCleanup(Handle* handle)
  {
    // Error checking
    ErrorIf(this->Scopes.back()->HandlesToBeCleaned.findIndex(handle) != Array<Handle*>::InvalidIndex,
      "We should not be queuing the same address twice for cleanup!");

    this->Scopes.back()->HandlesToBeCleaned.push_back(handle);
  }

  //***************************************************************************
  void PerFrameData::QueueDelegateCleanup(Delegate* delegate)
  {
    // Error checking
    ErrorIf(this->Scopes.back()->DelegatesToBeCleaned.findIndex(delegate) != Array<Delegate*>::InvalidIndex,
      "We should not be queuing the same address twice for cleanup!");

    this->Scopes.back()->DelegatesToBeCleaned.push_back(delegate);
  }
  
  //***************************************************************************
  bool PerFrameData::IsVariableInitialized(Variable* variable)
  {
    // Get the stack location of the variable
    byte* variableStackMemory = this->Frame + variable->Local;

    // If this is a value type...
    if (variable->ResultType->IsCopyComplex() == false)
    {
      // Consider it initialized... for now
      return true;
    }
    else
    {
      // Grab the curren't function's type, because we keep reusing it
      DelegateType* delegateType = this->CurrentFunction->FunctionType;

      // If the variable is the this handle...
      byte* thisLocation = delegateType->ThisHandleStackOffset + this->Frame;
      if (thisLocation == variableStackMemory)
        return true;

      // If the pointer is any of the parameters...
      ParameterArray& parameters = delegateType->Parameters;
      for (size_t k = 0; k < parameters.size(); ++k)
      {
        // Get the current offset of the parameter...
        byte* parameterLocation = parameters[k].StackOffset + this->Frame;
                    
        // If the parameter is the current variable we're looking at...
        if (parameterLocation == variableStackMemory)
          return true;
      }

      // Walk through all scopes
      for (size_t k = 0; k < this->Scopes.size(); ++k)
      {
        // Grab the current scope
        PerScopeData* scope = this->Scopes[k];
                    
        // Loop through all handles, see if this pointer matches...
        for (size_t m = 0; m < scope->HandlesToBeCleaned.size(); ++m)
        {
          if (scope->HandlesToBeCleaned[m] == (Handle*)variableStackMemory)
            return true;
        }
                    
        // Loop through all delegates, see if this pointer matches...
        for (size_t m = 0; m < scope->DelegatesToBeCleaned.size(); ++m)
        {
          if (scope->DelegatesToBeCleaned[m] == (Delegate*)variableStackMemory)
            return true;
        }
                    
        // Loop through all any objects, see if this pointer matches...
        for (size_t m = 0; m < scope->AnysToBeCleaned.size(); ++m)
        {
          if (scope->AnysToBeCleaned[m] == (Any*)variableStackMemory)
            return true;
        }
      }
    }

    // We didn't find that it was initialized... it must not be
    return false;
  }

  //***************************************************************************
  bool PerFrameData::AttemptThrowStackExceptions(ExceptionReport& report)
  {
    // If we already know about the stack overflow, then ignore it
    if (this->State->HitStackOverflow)
      return false;
    
    // If we reached the max recursion depth (not necessarily an overflow, but definately a limit)
    if (this->ErrorState == StackErrorState::MaxRecursionReached)
    {
      this->State->HitStackOverflow = true;
      this->State->ThrowException(report, "Maximum recursion depth reached (too many function called inside of other functions)");
      return true;
    }
    // If we truly ran out of stack space...
    else if (this->ErrorState == StackErrorState::Overflowed)
    {
      this->State->HitStackOverflow = true;
      this->State->ThrowException(report, "The stack ran out of space (too many function called inside of other functions)");
      return true;
    }

    // No exceptions were thrown if we got here
    return false;
  }

  //***************************************************************************
  OperandLocation::OperandLocation() :
    Type(OperandType::NotSet),
    Memory(nullptr),
    MemorySize(0),
    Offset(0)
  {
  }

  //***************************************************************************
  Timeout::Timeout() :
    LengthTicks(0),
    AccumulatedTicks(0)
  {
  }
    
  //***************************************************************************
  ExceptionReport::ExceptionReport() :
    ForceThrownExceptions(false)
  {
  }
  
  //***************************************************************************
  void ExceptionReport::Clear()
  {
    this->ForceThrownExceptions = false;
    this->Exceptions.clear();
  }

  //***************************************************************************
  bool ExceptionReport::HasThrownExceptions()
  {
    return this->ForceThrownExceptions || this->Exceptions.empty() == false;
  }
  
  //***************************************************************************
  String ExceptionReport::GetConcatenatedMessages()
  {
    // Walk through all the exceptions and concatenate them
    StringBuilderExtended builder;
    for (size_t i = 0; i < this->Exceptions.size(); ++i)
    {
      // Read each of the exceptions from the handle
      Exception* exception = (Exception*)this->Exceptions[i].Dereference();

      // Write out the exception message
      builder.Write(exception->Message);

      // If this isn't the last exception...
      if (i != (this->Exceptions.size() - 1))
      {
        // Write out something that joins them together
        builder.Write(" / ");
      }
    }
    
    // Output the concatenated exceptions
    return builder.ToString();
  }

  //***************************************************************************
  void DefaultExceptionCallback(ExceptionEvent* e)
  {
    // Print out the standard formatted error message to the console
    printf("%s\n", e->ThrownException->GetFormattedMessage(MessageFormat::Zilch).c_str());
  }

  //***************************************************************************
  static const size_t DefaultStackSize = 2097152;
  static const String DefaultName("ExecutableState");
  ExecutableState* ExecutableState::CallingState = nullptr;

  //***************************************************************************
  ExecutableState::ExecutableState() :
    StackSize(DefaultStackSize),
    OverflowStackSize(DefaultStackSize),
    UserData(nullptr),
    MaxRecursionDepth(40),
    HitStackOverflow(false),
    TimeoutSeconds(0),
    Name(DefaultName),
    PatchId(0),
    EnableDebugEvents(false),
    DoNotAllowAllocation(0),
    UniqueIdScopeCounter(1)
  {
    ZilchErrorIfNotStarted(ExecutableState);

    // Reserve space for frames and scopes
    this->StackFrames.reserve(128);
    this->RecycledFrames.reserve(128);
    this->RecycledScopes.reserve(128);

    // Then add the rest of our handle managers
    this->HeapObjects = this->GetHandleManager<HeapManager>();
    this->StackObjects = this->GetHandleManager<StackManager>();
    this->PointerObjects = this->GetHandleManager<PointerManager>();

    // Clear the stack (including reserved space)
    size_t totalStackSize = this->StackSize + this->OverflowStackSize;
    this->Stack = new byte[totalStackSize];
    memset(this->Stack, 0xCD, totalStackSize);

    // Create a frame data that points to the beginning of the stack
    // This frame should never be popped (FrameData should have a minimum size of 1)
    PerFrameData* baseFrame = new PerFrameData(this);
    this->StackFrames.push_back(baseFrame);

    // Generate an empty function to help reduce code paths
    // When any function wants to get the next stack position,
    // they generally look at the current function + required space
    // The 'empty function' has a required space of zero (0) always
    Function* emptyFunction = new Function();

    // Initialize the frame data to defaults, except the stack pointer
    baseFrame->CurrentFunction = emptyFunction;
    baseFrame->Frame = this->Stack;
    baseFrame->NextFrame = this->Stack;
    baseFrame->ProgramCounter = ProgramCounterNotActive;
    baseFrame->State = this;
    baseFrame->Debug = CallDebug::None;
  }

  //***************************************************************************
  ExecutableState::~ExecutableState()
  {
    // We're not allowed to delete an executable state that isn't done executing
    ErrorIf(this->StackFrames.size() > 1, "Illegal to delete an ExecutableState that has a running stack frame");

    // We should always have the base frame
    ErrorIf(this->StackFrames.size() == 0, "Base frame should always exist (this is bad)");

    // In general no objects should still be existing by this point in time unless the user allocated and stored
    // handles to objects, especially non-reference counted objects
    
    // Because the entire handle manager gets torn down and will no longer allow objects to be allocated, then static memory
    // must be cleaned up first because it could access the static memory (we don't delete the memory yet, we just null it and release handles)
    // We actually delete the memory for statics AFTER destructing the handle managers
    // We could either do this, or we could destruct statics afterwards but make it throw if you try to allocate
    // We currently destruct handled objects first, and then we destruct statics (but allocations are not allowed during destructors)
    // and then afterward we actually tear down the memory for both statics and handle managers

    // We need to clean up memory for static variables (release handles/delegates)
    // Techincally code could run during this phase (even code that accesses other deleted statics)
    // To be entirely safe, we wait to delete the static memory (so we don't magically attempt to allocate it again on access)
    typedef Pair<Field*, byte*> StaticFieldPair;
    ZilchForEach(StaticFieldPair& pair, this->StaticFieldToMemory.all())
    {
      // Pull out the two values from the pair for convenience
      Field* field = pair.first;
      byte* staticMemory = pair.second;

      // Destruct the memory in place and then delete the memory
      // Note: When we actually flag statics as being initialized, keep that flag on
      // so we don't try and reinitialize it in case someone refers to it below
      field->PropertyType->GenericDestruct(staticMemory);

      // We only really need to memset the object to zero if it has a complex copy
      if (field->PropertyType->IsCopyComplex())
        memset(staticMemory, 0, field->PropertyType->GetCopyableSize());
    }
    
    // Tell all the handle managers to delete their objects (only the ones owned by this ExecutableState)
    ZilchForEach(HandleManager* manager, this->UniqueManagers.values())
    {
      // Walk through all allocated objects in this manager and delete their objects
      manager->DeleteAll(this);
    }

    // Loop through all native v-tables we created
    HashMap<BoundType*, byte*>::valuerange virtualTables = this->NativeVirtualTables.values();
    while (virtualTables.empty() == false)
    {
      // Clean up each v-table and move on
      delete virtualTables.front();
      virtualTables.popFront();
    }

    // Delete all handle managers
    ZilchForEach(HandleManager* manager, this->UniqueManagers.values())
    {
      // Delete the current handle manager
      delete manager;
    }

    // Now delete all static memory
    ZilchForEach(StaticFieldPair& pair, this->StaticFieldToMemory.all())
    {
      // Get the static memory and delete it
      byte* staticMemory = pair.second;
      delete[] staticMemory;
    }

    // Destroy the stack
    delete[] this->Stack;

    // We created a fake function as a 'base frame' function (need to clean it up)
    PerFrameData* baseFrame = this->StackFrames.back();
    delete baseFrame->CurrentFunction;
    delete baseFrame;
  }

  //***************************************************************************
  byte* ExecutableState::GetCurrentStackFrame()
  {
    return this->StackFrames.back()->Frame;
  }

  //***************************************************************************
  byte* ExecutableState::GetNextStackFrame()
  {
    // Get the current frame data
    PerFrameData* current = this->StackFrames.back();

    // Compute the frame from the current position
    // (moved forward by the used stack space)
    return current->NextFrame;
  }

  //***************************************************************************
  PerFrameData* ExecutableState::PushFrame(Function* function)
  {
    // Get the next frame before we push our own frame data
    byte* frame = this->GetNextStackFrame();

    // Call the internal function
    return this->PushFrame(frame, function);
  }

  //***************************************************************************
  PerFrameData* ExecutableState::PushFrame(byte* frame, Function* function)
  {
    // Unfortunately we incur an overhead for patched functions, however, this should
    // be descently quick if the patched functions hash table is empty (it 'early outs' internally)
    // This either finds a patched function, or returns the same function
    function = this->PatchedFunctions.findValue(function, function);

    // Store a pointer to the newly created stack frame
    PerFrameData* newFrame = nullptr;

    // If we have no recycled stack frames...
    if (this->RecycledFrames.empty())
    {
      // There was nothing to be pulled from recycling,
      // so just make a new one (will be recycled later)
      newFrame = new PerFrameData(this);
    }
    else
    {
      // Otherwise, we just pop the latest one from the recycled list
      newFrame = this->RecycledFrames.back();
      this->RecycledFrames.pop_back();
    }

    // Clear any error state set on the frame data
    newFrame->ErrorState = StackErrorState::Normal;

    // If we got more calls then the max recursion depth...
    if (this->StackFrames.size() >= this->MaxRecursionDepth)
    {
      newFrame->ErrorState = StackErrorState::MaxRecursionReached;
    }

    // Compute the next frame on the stack
    byte* nextFrame = frame + function->RequiredStackSpace;

    // Compute the end of the real stack
    byte* endOfStack = this->Stack + this->StackSize;

    // If the next frame exceeds our max stack size...
    if (nextFrame >= endOfStack)
    {
      newFrame->ErrorState = StackErrorState::Overflowed;
    }

    // If we actually hit the end of the stack, including reserve size, then there's basically nothing we can do!
    if (nextFrame >= endOfStack + this->OverflowStackSize || this->StackFrames.size() >= this->MaxRecursionDepth * 2)
    {
      // Throw a fatal error!
      FatalErrorEvent toSend;
      toSend.ErrorCode = FatalError::StackReserveOverflow;
      EventSend(this, Events::FatalError, &toSend);

      // Time to quit the process!
      Error("We hit a stack overflow more than once (used up the reserved stack space). The fatal callback was called, and now we're aborting");
      abort();
    }

    // If this is the first call being made into the state and we have a default timeout set
    // Note: This must be done before we push the stack frame below
    if (this->TimeoutSeconds != 0 && this->IsInCallStack() == false)
    {
      // Push the timeout with the number of seconds that the user set
      this->PushTimeout(newFrame, this->TimeoutSeconds);
    }

    // Take the newly allocated (or recycled) stack frame and push it onto the stack frames list
    this->StackFrames.push_back(newFrame);

    // Make sure we cleared out any scopes from before
    ErrorIf(newFrame->Scopes.empty() == false, "Improperly recycled stack frame");

    // Setup the frame data before we call the function
    // We need to initialize ALL members since this is recycled (also avoids constructors)
    // Note we don't need to set the State, as it should never change
    newFrame->Frame = frame;
    newFrame->NextFrame = nextFrame;
    newFrame->CurrentFunction = function;
    newFrame->ProgramCounter = ProgramCounterNotActive;
    newFrame->Debug = CallDebug::None;

    // Since every function gets an implicit scope, we'll add one to start
    newFrame->Scopes.push_back(this->AllocateScope());

    // Return the data we just created
    return newFrame;
  }

  //***************************************************************************
  PerFrameData* ExecutableState::PopFrame()
  {
    // Get the frame we're about to pop
    PerFrameData* frame = this->StackFrames.back();

    // We MUST save the timeout count as a temporary, because popping timeouts will decrement it
    size_t timeoutCount = frame->Timeouts;

    // Loop through all timeouts that still exist
    // Note: It is VERY important that we do this before cleaning up scopes (delegates/handles)
    // because destructors could get invoked and end up throwing exceptions again due to the timeout still existing
    for (size_t i = 0; i < timeoutCount; ++i)
    {
      // Pop any timeouts for this frame
      this->PopTimeout(frame);
    }

    // Loop through all the scopes
    for (size_t i = 0; i < frame->Scopes.size(); ++i)
    {
      // Get the current scope
      PerScopeData* scope = frame->Scopes[i];

      // Cleanup everything from this scope
      scope->PerformCleanup();

      // Recycle this scope (we will clear the scopes below)
      this->RecycledScopes.push_back(scope);
    }

    // We need to clean out all scopes (including the implicitly created first one)
    // because we are going to be recycling the frame
    frame->Scopes.clear();

    // Recycle the stack frame
    this->RecycledFrames.push_back(frame);

    // Pop the stack frame
    this->StackFrames.pop_back();

    // If we hit the stack overflow...
    if (this->HitStackOverflow)
    {
      // If we popped enough frames to come out of stack overlfow mode...
      byte* endOfStack = this->Stack + this->StackSize;
      if (frame->NextFrame < endOfStack && this->StackFrames.size() < this->MaxRecursionDepth)
      {
        // Clear the flag that lets us use extra stack space
        this->HitStackOverflow = false;
      }
    }

    // Make sure the dummy always exists
    ErrorIf(this->StackFrames.empty(), "We popped the dummy stack frame and were not supposed to!");
    
    // Validation of timeouts
    ErrorIf(this->StackFrames.size() == 1 && this->Timeouts.empty() == false,
      "If we popped the last stack frame (except the dummy) then all timeouts should be gone!");

    // Even though the frame is invalid, we should return it for debugging
    return frame;
  }

  //***************************************************************************
  Any ExecutableState::ExecuteStatement(StringParam code)
  {
    Project project;

    // If an error occurs, this callback will output the error directly into this string
    String errorMessage;
    EventConnect(&project, Events::CompilationError, OutputErrorStringCallback, &errorMessage);

    // Add the code in and treat it as a statement
    project.AddCodeFromString(code);
    LibraryRef library = project.Compile(ExpressionLibrary, this->Dependencies, EvaluationMode::Expression);
    
    // If we failed to compile the library, output whatever error occurred
    if (library == nullptr)
      return Any(errorMessage, this);

    // Patch the state with the new library
    // Ideally we wouldn't have to do this, but if the user ever does anything to refer to the calling function
    // and say, bind it to a delegate, attach it to an event handler, etc... then calling that function could crash
    // Patching it will keep it alive for the remainder of our executable state
    this->ForcePatchLibrary(library);

    static const String ProgramError("Failed to find the program type (internal error)");
    static const String MainError("Failed to find the main function (internal error)");

    // Try and find the program type
    BoundType* program = library->BoundTypes.findValue(ExpressionProgram, nullptr);
    if (program == nullptr)
      return Any(ProgramError, this);

    // Try and find the main function
    Function* main = program->FindFunction(ExpressionMain, Array<Type*>(), ZilchTypeId(Any), FindMemberOptions::Static);
    if (main == nullptr)
      return Any(MainError, this);

    // Invoke the main function and let it do whatever its going to do
    ExceptionReport report;
    Call call(main, this);
    call.Invoke(report);

    // If an exception was thrown, concatenate all the messages into a string
    if (report.HasThrownExceptions())
    {
      String messages = report.GetConcatenatedMessages();
      return Any(messages, this);
    }

    return call.Get<Any>(Call::Return);
  }

  //***************************************************************************
  void ExecutableState::InitializeStackHandle(Handle& handle, byte* location, PerScopeData* scope, BoundType* type)
  {
    // Set the handle's manager
    handle.Manager = this->StackObjects;

    // Set the type of this handle
    handle.Type = type;

    // We are always guaranteed that the handle data is cleared before we get the user data portion
    StackHandleData& data = *(StackHandleData*)handle.Data;
    data.StackLocation = location;
    data.UniqueId = scope->UniqueId;
    data.Scope = scope;
  }
  
  //***************************************************************************
  void ExecutableState::InitializePointerHandle(Handle& handle, byte* location, BoundType* type)
  {
    // Set the handle's manager
    handle.Manager = this->PointerObjects;

    // Set the type of this handle
    handle.Type = type;

    // We are always guaranteed that the handle data is cleared before we get the user data portion
    this->PointerObjects->ObjectToHandle(location, handle);
  }

  //***************************************************************************
  bool ExecutableState::PushTimeout(PerFrameData* frame, size_t seconds)
  {
    // When pushing the timeout we do a validation for any previous timeouts
    // Note: This is very important because it also updates the timer's last query
    // This will early out and skip pushing a timer
    if (this->ThrowExceptionOnTimeout(*frame->Report))
      return true;

    // Create a timeout structure...
    Timeout& timeout = this->Timeouts.push_back();
          
    // Set the length of the timeout based on the constant stored in the opcode
    timeout.LengthTicks = seconds * Timer::TicksPerSecond;

    // Increment the timeouts stored on that frame, so if an exception happens
    // or we need to unroll (return) then we know how many timeouts to pop
    ++frame->Timeouts;

#if _DEBUG
    // This is not necessary, but it's nice for debugging
    // We use this to verify that 
    timeout.Frame = frame;
#endif

    // We didn't throw an exception above, so return false
    return false;
  }

  //***************************************************************************
  bool ExecutableState::PopTimeout(PerFrameData* frame)
  {
    // We assume we're not going to throw any exceptions, see below
    bool result = false;

    // If we already have an exception that we're dealing with, then don't try and throw another!
    if (frame->Report->HasThrownExceptions() == false)
    {
      // When popping the timeout we do one last validation
      result = this->ThrowExceptionOnTimeout(*frame->Report);
    }

#if _DEBUG
    // Verify that the frame is the same one that pushed this timeout
    ErrorIf(this->Timeouts.back().Frame != frame,
      "An incorrect frame was used to pop a timeout (not the one that pushed it!)");
#endif

    // Pop the last timeout off the stack
    this->Timeouts.pop_back();

    // We no longer need to pop this timeout if the stack unrolls
    --frame->Timeouts;

    // Return whether we threw an exception or not
    return result;
  }

  //***************************************************************************
  ExceptionReport& ExecutableState::GetCallingReport()
  {
    return *CallingState->StackFrames.back()->Report;
  }
  
  //***************************************************************************
  ExecutableState* ExecutableState::GetCallingState()
  {
    return CallingState;
  }

  //***************************************************************************
  void ExecutableState::SendOpcodeEvent(StringParam eventId, PerFrameData* frame)
  {
    // If the user didn't enable debug events, then early out
    if (this->EnableDebugEvents == false)
      return;

    // If anyone is listening to the callback...
    EventDelegateList* delegates = this->OutgoingPerEventName.findValue(eventId, nullptr);
    if (delegates != nullptr)
    {
      // Get the stack offset that we're at
      size_t stackOffset = (size_t)(frame->Frame - frame->State->Stack);
      
      // Get the program counter (we use it also to lookup the opcode location)
      size_t lookupProgramCounter = frame->ProgramCounter;
      if (lookupProgramCounter == ProgramCounterNotActive)
        lookupProgramCounter = 0;
      
      // Let the user know that we've stepped once
      OpcodeEvent toSend;
      toSend.State = this;
      toSend.CurrentFunction = frame->CurrentFunction;
      toSend.ProgramCounter = frame->ProgramCounter;
      toSend.StackOffset = stackOffset;
      toSend.Location = frame->CurrentFunction->GetCodeLocationFromProgramCounter(lookupProgramCounter);
      delegates->Send(&toSend);
    }
  }

  //***************************************************************************
  PerScopeData* ExecutableState::AllocateScope()
  {
    // The new scope we'll return
    PerScopeData* newScope = nullptr;

    // If we have no recycled scopes...
    if (this->RecycledScopes.empty())
    {
      // There was nothing to be pulled from recycling,
      // so just make a new one (will be recycled later)
      newScope = new PerScopeData();
    }
    else
    {
      // Otherwise, we just pop the latest one from the recycled list
      newScope = this->RecycledScopes.back();
      this->RecycledScopes.pop_back();
    }

    // Every scope must be assigned a new id so that any references we form
    // to stack variables inside the scope will be safely pointed at
    // If the scope goes away, this unqiue id gets set back to 0, or if it gets re-used
    // then we make sure it will never have the same id it had before
    newScope->UniqueId = this->UniqueIdScopeCounter;
    ++this->UniqueIdScopeCounter;

    // Return the newly created or recycled scope
    return newScope;
  }

  //***************************************************************************
  void ExecutableState::InvokePreConstructorOrRelease(Handle& handle, ExceptionReport& report)
  {
    // Error checking
    ErrorIf(report.HasThrownExceptions(),
      "Exceptions still set on the report when attempting to invoke the pre-constructor");

    // Iterate through this type and all it's base types, so we can call pre-constructors on each of them
    // Technically, the order should not matter!
    BoundType* type = handle.Type;
    while (type != nullptr)
    {
      // If we have a pre-constructor...
      Function* preConstructor = type->PreConstructor;
      if (preConstructor != nullptr)
      {
        // Call the preconstructor
        Call call(preConstructor, this);
        call.SetHandle(Call::This, handle);
        call.Invoke(report);

        // If we failed to execute the pre constructor, return a null handle
        if (report.HasThrownExceptions())
        {
          // Clear the handle to a null handle (which should also delete the object)
          handle = Handle();
          return;
        }
      }
      
      // Iterate to the next base type
      type = type->BaseType;
    }
  }

  //***************************************************************************
  void ExecutableState::UpdateCppVirtualTable(byte* objectWithBaseVTable, BoundType* cppBaseType, BoundType* derivedType)
  {
    // Error checking
    ErrorIf(cppBaseType->BoundNativeVirtualCount > cppBaseType->RawNativeVirtualCount,
      "We should never have more bound native virtual functions than the actual v-table size");

    // First, check to see if this object is native or not
    if (cppBaseType->RawNativeVirtualCount == 0 || cppBaseType->BoundNativeVirtualCount == 0)
    {
      return;
    }

    // Get a pointer to the virtual table
    TypeBinding::VirtualTableFn*& virtualTable = *(TypeBinding::VirtualTableFn**)objectWithBaseVTable;

    // Check to see if we've already mapped up this virtual table
    byte* foundVirtualTable = this->NativeVirtualTables.findValue(cppBaseType, nullptr);

    // If we did find it (already made one)
    if (foundVirtualTable != nullptr)
    {
      // Just map the object's virtual table to this one (plus offset)
      virtualTable = (TypeBinding::VirtualTableFn*)(foundVirtualTable + sizeof(ExecutableState*));
      return;
    }

    // Compute the exact size of the native v-table in bytes
    size_t nativeVTableSizeBytes = cppBaseType->RawNativeVirtualCount * sizeof(TypeBinding::VirtualTableFn);

    // Create the new virtual table to store the executable state,
    // and a copy (with replacements) of the native virtual table
    byte* fullVirtualTable = new byte[sizeof(BoundType*) + sizeof(ExecutableState*) + nativeVTableSizeBytes];

    // Insert the type at the front of the v-table so we can resolve the virtual function
    // This must be properly destructed with the executable state
    new (fullVirtualTable) BoundType*(derivedType);

    // Insert the executable state at the front
    new (fullVirtualTable + sizeof(BoundType*)) ExecutableState*(this);

    // The full virtual table stores extra data at the front, but we only
    // want a view that looks like the native virtual table
    TypeBinding::VirtualTableFn* newVirtualTable = (TypeBinding::VirtualTableFn*)(fullVirtualTable + sizeof(BoundType*) + sizeof(ExecutableState*));

    // Now copy the actual v-table from the object into the new virtual table
    memcpy(newVirtualTable, virtualTable, nativeVTableSizeBytes);

    // We need to walk all parent types to generate the table
    BoundType* parentCppType = cppBaseType;

    // Loop until we hit the end of the parent types
    while (parentCppType != nullptr)
    {
      // Get all the instance functions
      FunctionMultiValueRange allInstanceFunctions = parentCppType->InstanceFunctions.values();

      // Loop until all the instance functions are empty
      while (allInstanceFunctions.empty() == false)
      {
        // Grab the current array of instance functions
        FunctionArray& functionArray = allInstanceFunctions.front();
        allInstanceFunctions.popFront();

        // Loop through all instance functions (those are the only virtuals!)
        for (size_t i = 0; i < functionArray.size(); ++i)
        {
          // Grab the current instance function
          Function* function = functionArray[i];

          // If the function is native virtual...
          if (function->NativeVirtual.Index != NativeVirtualInfo::NonVirtual)
          {
            // Map the thunk mixed with the bound function
            GuidType guid = derivedType->Hash() ^ function->NativeVirtual.Guid;

            BoundType* parentZilchType = derivedType;
            Function* mostDerived = nullptr;

            do
            {
              const FunctionArray* functionArray = parentZilchType->GetOverloadedInstanceFunctions(function->Name);

              if (functionArray != nullptr)
              {
                for (size_t j = 0; j < functionArray->size(); ++j)
                {
                  Function* currentFunction = (*functionArray)[j];

                  if (Type::IsSame(currentFunction->FunctionType, function->FunctionType))
                  {
                    mostDerived = currentFunction;
                  }
                }
              }

              parentZilchType = parentZilchType->BaseType;

              if (parentZilchType == nullptr)
              {
                Error("We should never reach a null base class before hitting the Cpp type");
                break;
              }
            }
            while (parentZilchType != cppBaseType);
            
            // If we found that the user overwrote the vtable entry...
            if (mostDerived != nullptr)
            {
              this->ThunksToFunctions.insertOrError(guid, mostDerived);

              // Error checking for v-table indices
              ErrorIf(function->NativeVirtual.Index >= cppBaseType->RawNativeVirtualCount,
                "We should never have a native virtual whose index is greater than the total v-table indices");

              // Override the function in the v-table with our own thunk
              newVirtualTable[function->NativeVirtual.Index] = function->NativeVirtual.Thunk;
            }
          }
        }
      }

      // Move to the next parent type
      parentCppType = parentCppType->BaseType;
    }

    // Add the virtual table to our known v-tables
    this->NativeVirtualTables.insertOrError(cppBaseType, fullVirtualTable);

    // Finally, point this object instance at the new virtual table
    virtualTable = newVirtualTable;
  }

  //***************************************************************************
  class RemappedField
  {
  public:
    byte* OldMemory;
    byte* NewMemory;
    Type* SameType;
  };
  
  //***************************************************************************
  void ExecutableState::ForcePatchLibrary(LibraryRef newLibrary)
  {
    // Increment the patch id, so that the user can re-enable certain features
    ++this->PatchId;

    // We need to store the new library on ourselves because we're going to directly store their functions (need to keep them alive!)
    this->PatchedLibraries.push_back(newLibrary);

    // Loop through all the libraries that built this executable state
    for (size_t i = 0; i < this->Dependencies.size(); ++i)
    {
      // If any library has the same name as the one we're patching with, we'll patch it (otherwise skip it!)
      LibraryRef oldLibrary = this->Dependencies[i];
      if (oldLibrary->Name != newLibrary->Name)
        continue;

      // Loop through all bound types in the old library
      BoundTypeValueRange oldBoundTypes = oldLibrary->BoundTypes.values();
      while (oldBoundTypes.empty() == false)
      {
        // Grab the current type (it may exist in the new version)
        BoundType* oldType = oldBoundTypes.front();
        oldBoundTypes.popFront();

        // Look for a type by the same name in the new library (this can totally be null!)
        BoundType* newTypeOrNull = newLibrary->BoundTypes.findValue(oldType->Name, nullptr);
        
        // If we found a new type, we need to scan through all instances of that type in memory and modify them
        if (newTypeOrNull != nullptr)
        {
          // Let the state know that we're patching
          this->PatchedBoundTypes.insert(oldType, newTypeOrNull);

          // Loop through all heap objects and check if any of them are the old type
          for (size_t i = 0; i < this->HeapObjects->Objects.size(); ++i)
          {
            // Grab the current slot and object header (which stores the type)
            ObjectSlot& slot = this->HeapObjects->Objects[i];

            if (slot.Data == nullptr)
              continue;

            ObjectHeader& header = *(ObjectHeader*)slot.Data;

            // Remember, we only compare names, which means the oldHeapType can actually be different than oldType
            // This is especially true after we've patched multiple times (the object gets updated to a newer object, but still isnt the original!)
            BoundType* oldHeapType = header.Type;
            BoundType* newHeapType = newTypeOrNull;

            // If the name matches the object's name... (if not, skip it)
            if (oldHeapType->Name != newTypeOrNull->Name)
              continue;

            // Update the type on the slot's header
            header.Type = newTypeOrNull;

            // Create a temporary buffer to copy all the values from the old heap type over
            size_t oldSize = oldHeapType->GetAllocatedSize();
            byte* temporaryBuffer = new byte[oldSize];
            memset(temporaryBuffer, 0x00, oldSize);

            byte* memory = slot.Data + sizeof(ObjectHeader);

            Array<RemappedField> remappedFields;
            HashSet<Field*> handledNewFields;

            // We have to destruct or copy all old fields to a temporary location before remapping them to the new type
            FieldMapValueRange oldInstanceFields = oldHeapType->InstanceFields.values();
            while (oldInstanceFields.empty() == false)
            {
              Field* oldInstanceField = oldInstanceFields.front();
              oldInstanceFields.popFront();

              Field* newInstanceField = newHeapType->InstanceFields.findValue(oldInstanceField->Name, nullptr);

              byte* oldInstanceFieldMemory = memory + oldInstanceField->Offset;

              // If there's a new field AND it is of the same type...
              if (newInstanceField != nullptr && Type::IsSame(oldInstanceField->PropertyType, newInstanceField->PropertyType))
              {
                byte* temporaryOldInstanceFieldMemory = temporaryBuffer + oldInstanceField->Offset;
                newInstanceField->PropertyType->GenericCopyConstruct(temporaryOldInstanceFieldMemory, oldInstanceFieldMemory);

                handledNewFields.insertOrError(newInstanceField);

                RemappedField& remappedField = remappedFields.push_back();
                remappedField.NewMemory = memory + newInstanceField->Offset;
                remappedField.OldMemory = temporaryOldInstanceFieldMemory;
                remappedField.SameType = newInstanceField->PropertyType;
              }

              // We need to destruct the old field memory (regardless of whether we're remapping it)
              // Remember, we copied it to a temporary buffer in the case we did a remap (above)
              oldInstanceField->PropertyType->GenericDestruct(oldInstanceFieldMemory);
            }

            // Walk through only the values that need to be remapped
            for (size_t i = 0; i < remappedFields.size(); ++i)
            {
              RemappedField& remappedField = remappedFields[i];
              
              remappedField.SameType->GenericCopyConstruct(remappedField.NewMemory, remappedField.OldMemory);
              remappedField.SameType->GenericDestruct(remappedField.OldMemory);
            }

            delete[] temporaryBuffer;
            
            // Now walk through all new instance fields, running initialization functions on them...
            FieldMapValueRange newInstanceFields = newHeapType->InstanceFields.values();
            while (newInstanceFields.empty() == false)
            {
              Field* newInstanceField = newInstanceFields.front();
              newInstanceFields.popFront();

              // Skip any fields we already handled (those that were copied over, for example)
              if (handledNewFields.contains(newInstanceField))
                continue;

              byte* newInstanceFieldMemory = memory + newInstanceField->Offset;
              newInstanceField->PropertyType->GenericDefaultConstruct(newInstanceFieldMemory);
            }
          }
        }
        
        // Walk through all old defined functions
        FunctionArrayRange oldFunctions = oldType->AllFunctions.all();
        while (oldFunctions.empty() == false)
        {
          // Grab the current function from the old type
          Function* oldFunction = oldFunctions.front();
          oldFunctions.popFront();
          
          Function* newFunctionOrNull = nullptr;

          // If we actually found a new type (that maps from the old type)
          // Then we're also going to attempt to find a new function that matches the signature
          if (newTypeOrNull != nullptr)
          {
            // Attempt to find a function with the exact same delegate signature and the same name (as well as being an instance or static)
            FindMemberOptions::Enum options = FindMemberOptions::DoNotIncludeBaseClasses;
            if (oldFunction->This == nullptr)
              options = (FindMemberOptions::Enum)(options | FindMemberOptions::Static);
            newFunctionOrNull = newTypeOrNull->FindFunction(oldFunction->Name, oldFunction->FunctionType, options);
          }

          // If we didn't find a new function that patches over the old function (we're going to have to create one!)
          if (newFunctionOrNull == nullptr)
          {
            // The patch function directly refers to members of the other function, because we know the lifetime
            // of those primitives should match the lifetime of the patch
            // For example, the 'Type' DelegateType is owned by the oldLibrary, same with 'This'
            Function* patchDummy = new Function();
            patchDummy->Owner               = oldFunction->Owner;
            patchDummy->Name                = oldFunction->Name;
            patchDummy->FunctionType        = oldFunction->FunctionType;
            patchDummy->IsPropertyGetOrSet  = oldFunction->IsPropertyGetOrSet;
            patchDummy->SourceLibrary       = oldFunction->SourceLibrary;
            patchDummy->This                = oldFunction->This;
            patchDummy->SourceLibrary       = oldFunction->SourceLibrary;
            patchDummy->Description         = oldFunction->Description;
            patchDummy->Remarks             = oldFunction->Remarks;
            patchDummy->Attributes          = oldFunction->Attributes;
            patchDummy->IsHidden            = oldFunction->IsHidden;
            patchDummy->IsVirtual           = oldFunction->IsVirtual;
            patchDummy->Location            = oldFunction->Location;
            // NativeVirtual
            
            // The patch dummy is a special function that returns default constructed values (runs no code)
            patchDummy->BoundFunction = VirtualMachine::PatchDummy;

            // We technically only need enough stack space to match the delegate call, and nothing else (no local variables, etc)
            // However, because we want to match the amount of data for parameter passing (and the this handle), we just use the old function's space
            patchDummy->RequiredStackSpace = oldFunction->RequiredStackSpace;

            // Map the old function to the new function (currently this overwrites!)
            this->PatchedFunctions.insert(oldFunction, patchDummy);
          }
          else
          {
            // NOTE: These are all the members we DO NOT need to patch over:
            // Owner is not copied because the type that owns this is still the same (just patching the function, not the type yet)
            // The type will be patched on its own anyways!

            // The name is not copied because it should be the exact same
            ErrorIf(oldFunction->Name != newFunctionOrNull->Name, "A function we were patching did not match its new name");
            // We found this function by type, therefore the types should be the same (maybe not the same pointer, but type identity!)
            ErrorIf(Type::IsSame(oldFunction->FunctionType, newFunctionOrNull->FunctionType) == false, "A function we were patching did not match the new delegate type");
            // A function can't suddenly change from being a property delegate to not being one...
            ErrorIf(oldFunction->IsPropertyGetOrSet != newFunctionOrNull->IsPropertyGetOrSet, "A function we were patching did not match IsPropertyGetOrSet");

            // Map the old function to the new function (currently this overwrites!)
            this->PatchedFunctions.insert(oldFunction, newFunctionOrNull);
          }
        }
      }

    }

    // Now we've gone through all the new types and all their functions,
    // its time to go back through old types and stub out their functions
  }

  //***************************************************************************
  void ExecutableState::PatchLibrary(LibraryRef newLibrary)
  {
    // We cannot patch while an executable state is currently running
    ReturnIf(this->StackFrames.size() > 1,, "Illegal to patch a library in an ExecutableState that has a running stack frame");
    this->ForcePatchLibrary(newLibrary);
  }

  //***************************************************************************
  void ExecutableState::SetTimeout(size_t seconds)
  {
    // Error checking
    ReturnIf(this->IsInCallStack(),,
      "You cannot set a timeout while inside a call-stack");

    // Store the timeout
    this->TimeoutSeconds = seconds;
  }

  //***************************************************************************
  bool ExecutableState::IsInCallStack()
  {
    // Error checking
    ErrorIf(this->StackFrames.empty(),
      "The stack frames should never be empty (we should always have a dummy!)");

    // Technically we always have 1 dummy frame that exists
    return (this->StackFrames.size() != 1);
  }

  //***************************************************************************
  Handle ExecutableState::AllocateStackObject(byte* stackLocation, PerScopeData* scope, BoundType* type, ExceptionReport& report)
  {
    // Verify that the given pointer is within our stack
    ErrorIf(stackLocation < this->Stack || stackLocation > this->Stack + this->StackSize,
      "The given stack location for allocating a stack object was not within our stack");

    // Clear the memory of the stack location
    memset(stackLocation, 0, type->Size);

    // Create a stack handle to point at the given location
    Handle handle;
    this->InitializeStackHandle(handle, stackLocation, scope, type);

    // Pre-construct the handle (initialize memory) or clear it to null if we fail
    this->InvokePreConstructorOrRelease(handle, report);

    // Return the stack handle
    return handle;
  }

  //***************************************************************************
  Handle ExecutableState::AllocateDefaultConstructedHeapObject(BoundType* type, ExceptionReport& report, HeapFlags::Enum flags)
  {
    // Grab the default constructor
    const FunctionArray* constructors = type->GetOverloadedInheritedConstructors();

    // As long as we have constructors (could be inherited!)
    if (constructors != nullptr && constructors->empty() == false)
    {
      // Find the default constructor
      Function* defaultConstructor = BoundType::GetDefaultConstructor(constructors);

      // If the default constructor is null...
      if (defaultConstructor != nullptr)
      {
        // Allocate the heap object
        Handle handle = this->AllocateHeapObject(type, report, flags);

        // If allocating the heap object with just the pre-constructor threw an exception, early out
        if (report.HasThrownExceptions())
        {
          handle.Delete();
          return Handle();
        }

        // Execute the constructor which returns a call
        Call call(defaultConstructor, this);
        call.SetHandle(Call::This, handle);
        call.Invoke(report);

        // If we failed to execute the default constructor, return a null handle
        if (report.HasThrownExceptions())
          return Handle();

        // Return the handle, even if we couldn't construct the object
        return handle;
      }
      else
      {
        // Show an error since we couldn't construct the object
        Error("The default constructor could not be found for type '%s' but constructors were provided", type->ToString().c_str());
        return Handle();
      }
    }
    // Otherwise, we have no constructors (this is ok so long as we aren't native!)
    else if (type->Native == false)
    {
      // Just default construct the object
      return this->AllocateHeapObject(type, report, flags);
    }
    
    // Show an error since we couldn't construct the object
    Error("The default constructor could not be found for type '%s' and native types require a default constructor", type->ToString().c_str());
    return Handle();
  }

  //***************************************************************************
  Handle ExecutableState::AllocateHeapObject(BoundType* type, ExceptionReport& report, HeapFlags::Enum flags)
  {
    // If we currently are not allowing allocation, then throw an exception
    // This is sort of strange, because we can't even allocate the exception...
    if (this->DoNotAllowAllocation != 0)
    {
      // Even though the exception cannot be allocated, it will still be reported to C++ callbacks and will still unroll
      ZilchTodo("We should make this throw an exception, but then it cannot be allocated currently... InternalException?");
      return Handle();
    }

    // Let the heap objects initialize the handle
    Handle handle;
    handle.Type = type;
    handle.Manager = this->GetHandleManager(type->HandleManager);
    handle.Manager->Allocate(type, handle, flags);

    //HACK (forces all handles to be direct pointers)
    //byte* obj = handle.Dereference();
    //handle.Manager = this->PointerObjects;
    //this->PointerObjects->ObjectToHandle(obj, handle);

    // Pre-construct the handle (initialize memory) or clear it to null if we fail
    this->InvokePreConstructorOrRelease(handle, report);

    // Return the handle
    return handle;
  }

  //***************************************************************************
  bool ExecutableState::ThrowExceptionOnTimeout(ExceptionReport& report)
  {
    // Get the ticks since last check (this also updates the timer to now)
    // This MUST be called before the early out so that we don't accumulate up time not spent in Zilch
    long long ticksSinceLastCheck = this->TimeoutTimer.GetAndUpdateTicks();

    // Reset the timer so the the timer always returns us 'time passed since last check'
    this->TimeoutTimer.Reset();

    // Early out if we don't have any timeouts to abide by
    if (this->Timeouts.empty())
      return false;

    // Get the time that we expect to timeout at
    Timeout& timeout = this->Timeouts.back();

    // Accumulate ticks for our timer
    timeout.AccumulatedTicks += ticksSinceLastCheck;
    
    // If we exceed the timeout, we need to throw an exception and stop everything
    if (timeout.AccumulatedTicks > timeout.LengthTicks)
    {
      // Throw an exception to say we timed out
      this->ThrowException
      (
        report,
        String::Format
        (
          "Exceeded the allowed execution time of %d second(s). Use the timeout statement to increase allowed time",
          timeout.LengthTicks / Timer::TicksPerSecond
        )
      );

      // We threw the exception and thus we return 'true', the timeout occurred
      return true;
    }

    // Otherwise, we got here so nothing bad happened
    return false;
  }

  //***************************************************************************
  void ExecutableState::ThrowNullReferenceException(ExceptionReport& report)
  {
    // Throw a null reference exception
    this->ThrowException(report, "Attempted to access a member of a null object");
  }

  //***************************************************************************
  void ExecutableState::ThrowNullReferenceException(ExceptionReport& report, StringParam customMessage)
  {
    // Throw a null reference exception
    this->ThrowException
    (
      report,
      String::Format("Attempted to access a member of a null object: %s", customMessage.c_str())
    );
  }

  //***************************************************************************
  void ExecutableState::ThrowNotImplementedException()
  {
    this->ThrowException("This method is not implemented (its implementation may be abstract and a virutal function should overwrite it)");
  }

  //***************************************************************************
  void ExecutableState::ThrowException(StringParam message)
  {
    // Grab the report from the latest stack frame
    ExceptionReport& report = *this->StackFrames.back()->Report;
    this->ThrowException(report, message);
  }

  //***************************************************************************
  void ExecutableState::ThrowException(ExceptionReport& report, StringParam message)
  {
    Core& core = Core::GetInstance();

    // Allocate a default constructed base exception
    // Note: We only allocate the exception and DO NOT default construct it
    // This is because we know the exception will be fully initialized, and moreover if we run out of allocation space
    // then returning a null handle is considered ok!
    // The StackTrace allocator originally did not support memset to zero, but we made a special one called MemsetZeroDefaultAllocator
    ExceptionReport defaultExceptionReport;
    Handle handle = this->AllocateHeapObject(core.ExceptionType, defaultExceptionReport, HeapFlags::ReferenceCounted);
    if (handle.Manager != nullptr)
      handle.Manager->SetNativeTypeFullyConstructed(handle, true);

    // Error testing
    ReturnIf(defaultExceptionReport.HasThrownExceptions(),,
      "Allocating the default exception object should NEVER throw an exception");

    // Dereference a handle and grab a pointer to the exception object
    byte* memory = handle.Dereference();

    // Because an exception can be null if we truly run out of memory, then just skip this portion
    if (memory != nullptr)
    {
      // Grab a reference to the exception memory
      Exception& exception = *(Exception*)memory;

      // Set the friendly and exact error messages of the exception
      exception.Message = message;
    }
    
    // Forward this to the normal function that throws exceptions
    this->ThrowException(report, handle);
  }

  //***************************************************************************
  void ExecutableState::ThrowException(ExceptionReport& report, Handle& handle)
  {
    ZilchTodo("We need to verify that this handle is indeed a handle to an Exception type");
    
    // Dereference a handle and grab a pointer to the exception object
    Exception* exception = (Exception*)handle.Dereference();

    // If the exception was unable to be allocated we use this instead (max stack depth, out of objects, etc)
    Exception unableToAllocateException;

    // Only add the exception to the report if it exists and was allocated
    if (exception != nullptr)
    {
      // Add the current exception to the list of active exceptions
      report.Exceptions.push_back(handle);

      // The user should never touch this, it's only for debug!
      report.ExceptionsForDebugOnly.push_back(exception);
    }
    else
    {
      // We couldn't allocate the exception, so use a dummy one on the stack with a custom message
      exception = &unableToAllocateException;
      unableToAllocateException.Message = "The exception could not be allocated (most likely we hit the max stack depth, ran out of memory, or an exception was thrown in a destructor)";

      // We still want exception behavior, but we can't actually add the exception to the report (so force it!)
      report.ForceThrownExceptions = true;
    }

    // Generate a stack trace for the exception
    this->GetStackTrace(exception->Trace);

    // Inform the user that an exception occurred
    ExceptionEvent toSend;
    toSend.State = this;
    toSend.ThrownException = exception;
    EventSend(this, Events::UnhandledException, &toSend);
  }
  
  //***************************************************************************
  void ExecutableState::GetStackTrace(StackTrace& trace)
  {
    // Walk the stack frames from the bottom to top, building a call stack
    for (size_t i = 1; i < this->StackFrames.size(); ++i)
    {
      // Grab the current frame
      PerFrameData* frame = this->StackFrames[i];

      // Detect if this is the last stack frame
      bool isLastFrame = (i == (this->StackFrames.size() - 1));

      // As long as this frame's program counter is active in some sort...
      if (frame->ProgramCounter != ProgramCounterNotActive || (isLastFrame && trace.Stack.empty()))
      {
        // Create a new stack entry for this frame
        StackEntry& stackEntry = trace.Stack.push_back();

        // Add the current function to the stack entry
        Function* function = frame->CurrentFunction;
        stackEntry.ExecutingFunction = function;

        // If this is a frame that we're managing (so we can get more call stack information)
        // (Non-Active-Functions): For right now, since we don't have better location information about where the
        // function is (using the first opcode is WRONG and points at the wrong location)
        // We just opt to print the function out as if it's native, the user can search for it...
        size_t programCounter = frame->ProgramCounter;
        if (programCounter != ProgramCounterNative && programCounter != ProgramCounterNotActive)
        {
          // Get the code location (or null if for some reason we can't find it...)
          CodeLocation* codeLocation = function->OpcodeLocationToCodeLocation.findPointer(programCounter);

          // If we found the code location
          if (codeLocation != nullptr)
          {
            // Set the code location on the stack entry
            stackEntry.Location = *codeLocation;
          }
          else
          {
            Error("Unable to find code location for an opcode that belongs to a function (invalid opcode offset?)");
          }
        }
        else
        {
          // Initialize the location to the bound function
          stackEntry.Location.Origin = function->SourceLibrary->Name;
          stackEntry.Location.Library = function->SourceLibrary->Name;
          stackEntry.Location.Class = function->Owner->Name;
          stackEntry.Location.Function = function->Name;
        }
      }
    }
  }

  //***************************************************************************
  HandleManager* ExecutableState::GetHandleManager(HandleManagerId id) const
  {
    // See if we have a unique manager on us...
    HandleManager* manager = this->UniqueManagers.findValue(id, nullptr);

    // If we found the unqiue manager, just return it
    if (manager != nullptr)
    {
      return manager;
    }

    // Get a reference to the managers
    HandleManagers& managers = HandleManagers::GetInstance();

    // Otherwise, look for a shared manager
    manager = managers.GetSharedManager(id);

    // If we found the shared manager, just return it
    if (manager != nullptr)
    {
      return manager;
    }

    // Otherwise, we need to see if we can create one
    CreateHandleManagerFn creator = managers.GetUniqueCreator(id);

    // If the creator is valid...
    if (creator != nullptr)
    {
      // Run the creator to create the manager
      // The creator needs an executable state (will not modify it, but stores it)
      manager = creator(const_cast<ExecutableState*>(this));

      // Insert the manager into the map
      this->UniqueManagers.insert(id, manager);

      // Return the manager
      return manager;
    }
    else
    {
      // Error handling
      Error("We were not able to instantiate a handle manager or find a shared one for id '%d'", id);
      return nullptr;
    }
  }

  //***************************************************************************
  const byte* ExecutableState::GetRawStack()
  {
    return this->Stack;
  }
  
  //***************************************************************************
  byte* ExecutableState::GetStaticField(Field* field, ExceptionReport& report)
  {
    // Look for the static memory in a map of the fields on our state
    // Static fields are done per executable state, so they get wiped each time we quit
    byte*& staticMemory = this->StaticFieldToMemory[field];

    // If no memory was allocated yet, then allocate some and clear it
    if (staticMemory == nullptr)
    {
      // Allocate enough memory to store the field
      size_t fieldSize = field->PropertyType->GetCopyableSize();
      staticMemory = new byte[field->PropertyType->GetCopyableSize()];
      
      // All handles, value types, etc support being memset to 0
      memset(staticMemory, 0, fieldSize);

      // If an initializer exists, then invoke that
      if (field->Initializer != nullptr)
      {
        // Unless an exception gets thrown, the field should be initialized after this
        // Note that user code may cause cycles in initialization (which is why we memset first)
        Call call(field->Initializer, this);
        call.Invoke(report);
      }
    }

    // Return the pointer to the static memory
    return staticMemory;
  }

  //***************************************************************************
  void Call::PerformStandardChecks(size_t size, Type* userType, Type* actualType, CheckPrimitive::Enum primitive, Direction::Enum io)
  {
    // Check that the size is the same
    ErrorIf(AlignToBusWidth(size) < actualType->GetCopyableSize(),
      "The size of the types did not match");

    // If this is a value type...
    if (primitive == CheckPrimitive::Value)
    {
      // Check that the size of the value we're writing to is correct
      ErrorIf(actualType->IsCopyComplex(),
        "The type must be a value type");

      if (userType != nullptr)
      {
        if (Type::IsSame(userType, actualType) == false)
        {
          if (!((Type::IsEnumOrFlagsType(actualType)) && Type::IsSame(userType, ZilchTypeId(Integer))))
          {
            // Make sure we're trying to set the same type as the parameter
            Error("The user's type and the parameter/return/this type are not compatable");
          }
        }
        
      }

    }
    // If this is a reference/handle type...
    else if (primitive == CheckPrimitive::Handle)
    {
      // If the user type is a bound type
      BoundType* boundUserType = TypeBinding::DynamicCast<BoundType*>(userType);
      if (boundUserType != nullptr)
      {
        // If this is a value type being pointed at by a handle...
        if (boundUserType->CopyMode == TypeCopyMode::ValueType)
        {
          IndirectionType* indirectionActualType = TypeBinding::DynamicCast<IndirectionType*>(actualType);

          if (indirectionActualType != nullptr)
          {
            // For now, we can't do much else
            userType = nullptr;
          }
          else
          {
            Error("Handles that refer to value types can only be passed in when the type is a ref type (indirect type)");
          }
        }
      }

      // Make sure the return type is a handle type
      ErrorIf(Type::IsHandleType(actualType) == false,
        "The parameter/return/this type is not a handle type");

      // If there was a provided user type to check
      if (userType != nullptr)
      {
        // Make sure the given type is a handle type
        ErrorIf(Type::IsHandleType(userType) == false,
          "The user's type is not a handle type");
        
        // We need to verify that the parameter is the same type
        // If we're getting a value...
        if (io == Direction::Get)
        {
          // Error checking
          ErrorIf(TypeBinding::GenericIsA(actualType, userType) == false,
            "When getting a handle, the parameter/return/this must either "
            "derive from or be the same type as what we're trying to get");
        }
        // Otherwise we're setting a value
        else
        {
          // Error checking
          ErrorIf(TypeBinding::GenericIsA(userType, actualType) == false,
            "When setting a handle, the handle must either derive "
            "from or be the same type as the parameter/return/this");
        }
      }
    }
    // If this is a delegate type...
    else if (primitive == CheckPrimitive::Delegate)
    {
      // Check that the delegate types are the same
      ErrorIf(Type::IsDelegateType(actualType) == false,
        "The parameter/return/this type is not a delegate type");

      // Check that the delegate types are the same
      ErrorIf(userType != nullptr && Type::IsDelegateType(userType) == false,
        "The user's type is not a delegate type");

      // Check that the delegate types are the same
      ErrorIf(userType != nullptr && Type::IsSame(userType, actualType) == false,
        "Attempting to pass in a delegate of an incorrect type");
    }
    // It must be the 'any' type...
    else
    {
      // Make sure this is the 'any type'
      ErrorIf(Type::IsAnyType(actualType) == false,
        "The parameter/return/this type is not the 'any' type");

      // If the user type was provided, make sure it's also the any type
      ErrorIf(userType != nullptr && Type::IsAnyType(userType) == false,
        "The user's type is not the 'any' type");
    }
  }

  //***************************************************************************
  byte* Call::GetChecked(size_t index, size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io)
  {
    // If we're setting this... we need to mark that we did for debugging!
    if (io == Direction::Set)
    {
      // Mark and perform debug checks
      this->MarkAsSet(index);
    }

    // Based on the type of index...
    switch (index)
    {
    // It's an index that represents the return
    case Return:
      return this->GetReturnChecked(size, userType, primitive, io);
      
    // It's an index that represents the 'this' handle
    case This:
      return this->GetThisChecked(size, userType, primitive, io);
      
    // It's an index that represents any parameter
    default:
      return this->GetParameterChecked(index, size, userType, primitive, io);
    }
  }

  //***************************************************************************
  byte* Call::GetThisChecked(size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io)
  {
    // As long as the user didn't disable checks...
    if (!(this->Data->Debug & CallDebug::NoThisChecking))
    {
      // Make sure we don't try to request the 'this' handle as something weird
      ErrorIf(primitive != CheckPrimitive::Handle,
        "The 'this' handle for a function can only be retrieved as"
        " a handle/reference type, not as a value or delegate");

      // Get a reference to the this variable
      Variable* thisVariable = this->Data->CurrentFunction->This;

      // Error checking for if we're static
      ErrorIf(thisVariable == nullptr,
        "Cannot get the 'this' handle stack location for a static function");
    
      // Run a series of checks that tries to verify anything we can about what the user is doing
      this->PerformStandardChecks(size, userType, thisVariable->ResultType, primitive, io);
    }

    // Get the stack pointer where the 'this' should go
    return this->GetThisUnchecked();
  }

  //***************************************************************************
  byte* Call::GetReturnChecked(size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io)
  {
    // As long as the user didn't disable checks...
    if (!(this->Data->Debug & CallDebug::NoReturnChecking))
    {
      // Verify that this is not a void type
      ErrorIf(Core::GetInstance().VoidType == this->Data->CurrentFunction->FunctionType->Return,
        "The return type is void and cannot be get/set");
    
      // Run a series of checks that tries to verify anything we can about what the user is doing
      this->PerformStandardChecks(size, userType, this->Data->CurrentFunction->FunctionType->Return, primitive, io);
    }
    
    // Get the stack pointer where the return should go
    return this->GetReturnUnchecked();
  }

  //***************************************************************************
  byte* Call::GetParameterChecked(size_t parameterIndex, size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io)
  {
    // Get a reference to the parameters
    ParameterArray& parameters = this->Data->CurrentFunction->FunctionType->Parameters;
    
    // Error checking for the index
    ErrorIf(parameterIndex >= parameters.size(),
      "Attempting to access an invalid parameter by index (out of bounds)");
    
    // Get the current parameter
    DelegateParameter& parameter = parameters[parameterIndex];

    // As long as the user didn't disable checks...
    if (!(this->Data->Debug & CallDebug::NoParameterChecking))
    {
      // Run a series of checks that tries to verify anything we can about what the user is doing
      this->PerformStandardChecks(size, userType, parameter.ParameterType, primitive, io);
    }
    
    // Get the stack pointer where the parameter should go
    return this->Data->Frame + parameter.StackOffset;
  }

  //***************************************************************************
  void Call::SetValue(size_t index, const byte* input, size_t size)
  {
    // Get the stack location and perform checks
    byte* stack = this->GetChecked(index, size, nullptr, CheckPrimitive::Value, Direction::Set);

    // Copy the input into the stack position
    memcpy(stack, input, size);
  }
  
  //***************************************************************************
  void Call::SetHandle(size_t index, const Handle& value)
  {
    // Get the stack location and perform checks
    byte* stack = this->GetChecked(index, sizeof(Handle), value.Type, CheckPrimitive::Handle, Direction::Set);

    // Now copy the handle to the stack
    new (stack) Handle(value);
  }
  
  //***************************************************************************
  void Call::SetDelegate(size_t index, const Delegate& value)
  {
    // Get the exact function we're referencing
    Function* function = value.BoundFunction;

    // Get the stack location and perform checks
    byte* stack = this->GetChecked(index, sizeof(Delegate), function->FunctionType, CheckPrimitive::Delegate, Direction::Set);

    // Now copy the handle to the stack
    new (stack) Delegate(value);
  }
  
  //***************************************************************************
  void Call::GetValue(size_t index, byte* output, size_t size)
  {
    // Get the stack location and perform checks
    byte* stack = this->GetChecked(index, size, nullptr, CheckPrimitive::Value, Direction::Get);
    
    // Copy the stack into the output
    memcpy(output, stack, size);
  }
    
  //***************************************************************************
  Handle& Call::GetHandle(size_t index)
  {
    // Get the stack location and perform checks
    byte* stack = this->GetChecked(index, sizeof(Handle), nullptr, CheckPrimitive::Handle, Direction::Get);

    // Return a reference to the stack
    return *(Handle*)stack;
  }
    
  //***************************************************************************
  Delegate& Call::GetDelegate(size_t index)
  {
    // Get the stack location and perform checks
    byte* stack = this->GetChecked(index, sizeof(Delegate), nullptr, CheckPrimitive::Delegate, Direction::Get);

    // Return a reference to the stack
    return *(Delegate*)stack;
  }

  //***************************************************************************
  ExecutableState* Call::GetState()
  {
    return this->Data->State;
  }

  //***************************************************************************
  byte* Call::GetStackUnchecked()
  {
    return this->Data->Frame;
  }
    
  //***************************************************************************
  byte* Call::GetThisUnchecked()
  {
    // Get the stack offsetted by to the 'this' handle location
    return this->Data->Frame + this->Data->CurrentFunction->FunctionType->ThisHandleStackOffset;
  }

  //***************************************************************************
  byte* Call::GetParametersUnchecked()
  {
    // Get the stack offsetted by the size of the return (to where the parameters are)
    return this->Data->Frame + this->Data->CurrentFunction->FunctionType->Return->GetCopyableSize();
  }

  //***************************************************************************
  byte* Call::GetParameterUnchecked(size_t parameterIndex)
  {
    // Get a reference to the parameters
    ParameterArray& parameters = this->Data->CurrentFunction->FunctionType->Parameters;

    // Error checking for the index
    ErrorIf(parameterIndex >= parameters.size(),
      "Attempting to access an invalid parameter index (out of bounds)");

    // Return the stack offsetted by the current parameter's position
    return this->Data->Frame + parameters[parameterIndex].StackOffset;
  }

  //***************************************************************************
  byte* Call::GetReturnUnchecked()
  {
    // General error checking for our own assumptions
    ErrorIf(this->Data->CurrentFunction->FunctionType->ReturnStackOffset != 0,
      "Unexpected stack return location (internal error)");

    // The returns always exist at the beginning
    return this->Data->Frame;
  }

  //***************************************************************************
  Function* Call::GetFunction()
  {
    return this->Data->CurrentFunction;
  }
  
  //***************************************************************************
  void Call::DisableParameterChecks()
  {
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoParameterChecking);
  }
  
  //***************************************************************************
  void Call::DisableThisChecks()
  {
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoThisChecking);
  }
  
  //***************************************************************************
  void Call::DisableReturnChecks()
  {
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoReturnChecking);
  }
  
  //***************************************************************************
  void Call::DisableParameterDestruction()
  {
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoParameterDestruction);
  }
  
  //***************************************************************************
  void Call::DisableThisDestruction()
  {
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoThisDestruction);
  }
  
  //***************************************************************************
  void Call::DisableReturnDestruction()
  {
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoReturnDestruction);
  }

  //***************************************************************************
  void Call::MarkAsSet(size_t index)
  {
    // Based on the type of index...
    switch (index)
    {
    // It's an index that represents the return
    case Return:
      this->MarkReturnAsSet();
      break;
      
    // It's an index that represents the 'this' handle
    case This:
      this->MarkThisAsSet();
      break;
      
    // It's an index that represents any parameter
    default:
      this->MarkParameterAsSet(index);
      break;
    }
  }

  //***************************************************************************
  void Call::MarkReturnAsSet()
  {
    // Make sure we only call this once
    ErrorIf((this->Data->Debug & CallDebug::SetReturn) != 0,
      "Attempting to set the return twice");
      
    // For debugging, mark that we set the return
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::SetReturn);
  }

  //***************************************************************************
  void Call::MarkThisAsSet()
  {
    // Make sure we only call this once
    ErrorIf((this->Data->Debug & CallDebug::SetThis) != 0,
      "Attempting to set the this handle twice");
      
    // For debugging, mark that we set the 'this' handle
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::SetThis);
  }

  //***************************************************************************
  void Call::MarkParameterAsSet(size_t parameterIndex)
  {
    // We have a bit for each parameter we set
    CallDebug::Enum parameterFlag = (CallDebug::Enum)(1 << parameterIndex);

    // Make sure we only call this once
    ErrorIf((this->Data->Debug & parameterFlag) != 0,
      "Attempting to set the parameter twice");
      
    // For debugging, mark that we set this parameter
    this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | parameterFlag);
  }

  //***************************************************************************
  Call::Call(Function* function, ExecutableState* state)
  {
    // If this is call being generated for the user, then we have to push the frame
    // The virtual machine will do these steps for us when it's performing the call
    ErrorIf(function == nullptr, "Attempting to invoke a null function in Call");

    // Push a new stack frame for the function we want to invoke
    this->Data = state->PushFrame(function);
  }

  //***************************************************************************
  Call::Call(const Delegate& delegate, ExecutableState* state)
  {
    // The delegate directly stores the function to be executed on it
    Function* function = delegate.BoundFunction;
    ErrorIf(function == nullptr, "Attempting to invoke a null delegate in Call");

    // Push a new stack frame for the function we want to invoke
    this->Data = state->PushFrame(function);

    // If this is a non-static delegate
    if (function->This != nullptr)
    {
      // Set the this handle
      this->SetHandle(Call::This, delegate.ThisHandle);
    }
  }

  //***************************************************************************
  Call::Call(PerFrameData* data)
  {
    // We still need to grab the stack
    this->Data = data;

    // For calls being made by the VM, we don't care about parameters or 'this' being checked
    // We also don't want anything to be destructed
    // Having said that, we still want the return to be checked as it's set by the called
    this->Data->Debug = (CallDebug::Enum)
      (CallDebug::NoParameterChecking     |
       CallDebug::NoThisChecking          |
       CallDebug::NoParameterDestruction  |
       CallDebug::NoThisDestruction       |
       CallDebug::NoReturnDestruction);
  }

  //***************************************************************************
  Call::~Call()
  {
    //HACK WE CURRENTLY DONT HANDLE EXCEPTIONS
    ZilchTodo("Make sure we handle exceptions here (could have thrown before returning)");

    // For convenience, get the current function
    Function* function = this->Data->CurrentFunction;
    ExecutableState* state = this->Data->State;

    // Get the stack offset that we're at
    size_t stackOffset = (size_t)(this->Data->Frame - this->Data->State->Stack);

    // Grab the parameters of the function type
    ParameterArray& parameters = function->FunctionType->Parameters;

    // If parameter destruction is enabled...
    if ((this->Data->Debug & CallDebug::NoParameterDestruction) == 0)
    {
      // Loop through all the parameters and destruct anything that needs to be destructed
      for (size_t i = 0; i < parameters.size(); ++i)
      {
        // Get the current parameter
        DelegateParameter& parameter = parameters[i];

        // Get the stack offset of that parameter
        byte* stack = this->Data->Frame + parameter.StackOffset;

        // Release / destruct that parameter
        parameter.ParameterType->GenericDestruct(stack);
      }
    }

    // If 'this' handle destruction is enabled...
    if ((this->Data->Debug & CallDebug::NoThisDestruction) == 0)
    {
      // If this is an instance (non-static) function
      if (function->This != nullptr)
      {
        // Get the stack offset of the this handle
        byte* thisStack = this->Data->Frame + function->FunctionType->ThisHandleStackOffset;

        // Destroy the this handle
        ((Handle*)thisStack)->~Handle();
      }
    }
    
    // If we're ignoring outputs (return)
    if ((this->Data->Debug & CallDebug::NoReturnDestruction) == 0)
    {
      // Get the core library just for the void type
      Core& core = Core::GetInstance();

      // As long as our return isn't void...
      if (function->FunctionType->Return != core.VoidType)
      {
        // Get the return stack frame (should be right at the front)
        byte* returnStack = this->Data->Frame;
      
        // Verify that return position is always at the front
        ErrorIf(function->FunctionType->ReturnStackOffset != 0,
          "Internal error, the return stack position was not 0");

        // Finally, release/destruct the return value
        function->FunctionType->Return->GenericDestruct(returnStack);
      }
    }

    // If the call was invoked, we need to pop
    if (this->Data->Debug & CallDebug::Invoked)
    {
      state->SendOpcodeEvent(Events::ExitFunction, this->Data);
    }

    // Pop all frames up to our own
    // Note: This is very important since it's possible that other frames may exist that have no Call owner
    // If an exception gets thrown between PrepForCall / FunctionCall opcodes, we will have an extra frame on the stack
    PerFrameData* poppedFrame = nullptr;
    do
    {
      // Pop the frame and get back what we just popped
      poppedFrame = state->PopFrame();
    }
    // Loop until we pop our own
    while (poppedFrame != this->Data);

    // Clear out our data, just for safety
    this->Data = nullptr;
  }
  
  //***************************************************************************
  void Call::Invoke(ExceptionReport& report)
  {
    // If this stack frame needed to throw any exceptions (such as stack overflow or maximum recursion depth...)
    if (this->Data->AttemptThrowStackExceptions(report))
    {
      // Early out, there's no need to do anything else from this call
      return;
    }

    // Make sure we're not doing a call inside a call
    // At some point in time a code refactor happened that introduced the PerFrameData* onto the Call object
    // The scary part about this was that we were still getting the topFrame using 'state->StackFrames.back()',
    // instead of just accessing the PerFrameData* we stored (currently called Data), not sure why this was
    // as maybe it was just missed code in a cleanup, but if we ever falsely get this assert this may be why!
    ErrorIf(this->Data != this->Data->State->StackFrames.back(),
      "The function being invoked should always be the top of the frame (it is illegal to run a Call inside another Call)");

    // Store the top frame locally for efficiency
    PerFrameData* topFrame = this->Data;

    // Check if any exceptions are left on the state
    ErrorIf(report.HasThrownExceptions(),
      "Attempting to call another function when there are exceptions present in the report");

    // Make sure we don't call this twice
    ErrorIf((topFrame->Debug & CallDebug::Invoked) != 0,
      "Attempting to invoke the function twice via the same call");

    // Make sure the 'this' handle was set
    ErrorIf(!(topFrame->Debug & CallDebug::NoThisChecking) &&
      topFrame->CurrentFunction->This != nullptr &&
      (topFrame->Debug & CallDebug::SetThis) == 0,
      "The 'this' handle was not set before invoking the function");

    // Make a bit mask that includes 1s for all parameters that we have
    CallDebug::Enum allParameters = (CallDebug::Enum)((1 << topFrame->CurrentFunction->FunctionType->Parameters.size()) - 1);

    // Make sure all parameters have been set
    ErrorIf(!(topFrame->Debug & CallDebug::NoParameterChecking) &&
      allParameters != (topFrame->Debug & allParameters),
      "Not all of the parameters were set");

    // Set the exception reporter on the top frame
    topFrame->Report = &report;

    // Get a reference to the state for convenience
    ExecutableState* state = topFrame->State;

    // Also grab the current function we're executing
    Function* function = topFrame->CurrentFunction;
    size_t stackOffset = (size_t)(topFrame->Frame - state->Stack);

    // If this function is a non-static function
    if (function->This != nullptr)
    {
      // We need to check to see if the 'this' handle is valid
      // Technically this is slower and maybe we should only do it for functions that are not the VM function
      // It does make it a lot safer (so people writing external functions can always assume 'this' is valid)
      Handle& thisHandle = *(Handle*)(topFrame->Frame + function->This->Local);

      // Dereference the handle and get a pointer back (may be null)
      byte* thisData = thisHandle.Dereference();

      // If the 'this' handle was actually null...
      if (thisData == nullptr)
      {
        // Throw the null reference exception and jump out
        state->ThrowNullReferenceException(report, "Attempted to call a member function on a null object");

        // We didn't even invoke the function, don't destruct the return type
        this->DisableReturnDestruction();
        return;
      }
    }

    // If anyone wants to know if we entered a function...
    state->SendOpcodeEvent(Events::EnterFunction, this->Data);

    // Set the flag that says we've invoked the function
    topFrame->Debug = (CallDebug::Enum)(topFrame->Debug | CallDebug::Invoked);
    
    // Get the bound function we're going to run
    BoundFn boundFunction = function->BoundFunction;

    // If the function is not our own...
    if (boundFunction != VirtualMachine::ExecuteNext)
    {
      // We need to let any debugging/exceptions know that we're
      // entering a C++ bound function (for building the call stack)
      topFrame->ProgramCounter = ProgramCounterNative;
    }

    // Set the thread local calling state to the current state invoking
    // this function (so the function always knows the caller!)
    ExecutableState* lastCallingState = ExecutableState::CallingState;
    ExecutableState::CallingState = state;

    // Actually execute the function
    boundFunction(*this, report);

    // Get whether the return value was set
    bool returnWasSet = (this->Data->Debug & CallDebug::SetReturn) != 0;

    // If we threw any exceptions and the return value was not set, we will want to disable return destruction
    if (report.HasThrownExceptions() && returnWasSet == false)
      this->DisableReturnDestruction();
    
    // Reset the calling state back to the last one
    ExecutableState::CallingState = lastCallingState;

    // Get a reference to the core library
    Core& core = Core::GetInstance();

    // Make sure the return value was set (we can ignore this if an exception gets thrown)
    ErrorIf(!(this->Data->Debug & CallDebug::NoReturnChecking) &&
      (this->Data->Debug & CallDebug::SetReturn) == 0 &&
      !report.HasThrownExceptions() && 
      Type::IsSame(function->FunctionType->Return, core.VoidType) == false,
      "The return value was not set after a call (ignored when exceptions are thrown)");
  }

  //***************************************************************************
  template <>
  void Call::Set<Any>(size_t index, const Any& value)
  {
    // Get the stack location and perform checks
    byte* stack = this->GetChecked(index, sizeof(Any), ZilchTypeId(Any), CheckPrimitive::Any, Direction::Set);
      
    // Write the value to the stack
    new (stack) Any(value);
  }

  //***************************************************************************
  template <> void Call::Set<      Any*>(size_t index,       Any* const& value) { Set<Any>(index, *value); }
  template <> void Call::Set<      Any&>(size_t index,              Any& value) { Set<Any>(index,  value); }
  template <> void Call::Set<const Any*>(size_t index, const Any* const& value) { Set<Any>(index, *value); }
  template <> void Call::Set<const Any&>(size_t index,        const Any& value) { Set<Any>(index,  value); }
  
  //***************************************************************************
  template <>
  Any* Call::Get<Any*>(size_t index)
  {
    // Get the stack location and perform checks
    byte* stack = this->GetChecked(index, sizeof(Any), ZilchTypeId(Any), CheckPrimitive::Any, Direction::Get);
      
    // Read the value from the stack and return it (or convert it)
    return (Any*)stack;
  }
  
  //***************************************************************************
  template <>       Any  Call::Get<      Any >(size_t index) { return *Get<Any*>(index); }
  template <>       Any& Call::Get<      Any&>(size_t index) { return *Get<Any*>(index); }
  template <> const Any* Call::Get<const Any*>(size_t index) { return  Get<Any*>(index); }
  template <> const Any& Call::Get<const Any&>(size_t index) { return *Get<Any*>(index); }
  
  //***************************************************************************
  template <>
  void Call::Set<Handle>(size_t index, const Handle& value)
  {
    this->SetHandle(index, value);
  }

  //***************************************************************************
  template <> void Call::Set<      Handle*>(size_t index,       Handle* const& value) { Set<Handle>(index, *value); }
  template <> void Call::Set<      Handle&>(size_t index,              Handle& value) { Set<Handle>(index,  value); }
  template <> void Call::Set<const Handle*>(size_t index, const Handle* const& value) { Set<Handle>(index, *value); }
  template <> void Call::Set<const Handle&>(size_t index,        const Handle& value) { Set<Handle>(index,  value); }

  //***************************************************************************
  template <>
  Handle* Call::Get<Handle*>(size_t index)
  {
    return &this->GetHandle(index);
  }
  
  //***************************************************************************
  template <>       Handle  Call::Get<      Handle >(size_t index) { return *Get<Handle*>(index); }
  template <>       Handle& Call::Get<      Handle&>(size_t index) { return *Get<Handle*>(index); }
  template <> const Handle* Call::Get<const Handle*>(size_t index) { return  Get<Handle*>(index); }
  template <> const Handle& Call::Get<const Handle&>(size_t index) { return *Get<Handle*>(index); }
  
  //***************************************************************************
  template <>
  void Call::Set<Delegate>(size_t index, const Delegate& value)
  {
    this->SetDelegate(index, value);
  }

  //***************************************************************************
  template <> void Call::Set<      Delegate*>(size_t index,       Delegate* const& value) { Set<Delegate>(index, *value); }
  template <> void Call::Set<      Delegate&>(size_t index,              Delegate& value) { Set<Delegate>(index,  value); }
  template <> void Call::Set<const Delegate*>(size_t index, const Delegate* const& value) { Set<Delegate>(index, *value); }
  template <> void Call::Set<const Delegate&>(size_t index,        const Delegate& value) { Set<Delegate>(index,  value); }
  
  //***************************************************************************
  template <>
  Delegate* Call::Get<Delegate*>(size_t index)
  {
    return &this->GetDelegate(index);
  }
  
  //***************************************************************************
  template <>       Delegate  Call::Get<      Delegate >(size_t index) { return *Get<Delegate*>(index); }
  template <>       Delegate& Call::Get<      Delegate&>(size_t index) { return *Get<Delegate*>(index); }
  template <> const Delegate* Call::Get<const Delegate*>(size_t index) { return  Get<Delegate*>(index); }
  template <> const Delegate& Call::Get<const Delegate&>(size_t index) { return *Get<Delegate*>(index); }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes



namespace Zilch
{
  //***************************************************************************
  ZilchDefineType(FilePathClass, "FilePath", Core, builder, type)
  {
    ZilchBindMethod(builder, type, &FilePathClass::CombineDirectories, (String (*)(StringParam, StringParam)), "CombineDirectories", "dir0, dir1")->Description = CombineDirectoriesDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::CombineDirectories, (String (*)(StringParam, StringParam, StringParam)), "CombineDirectories", "dir0, dir1, dir2")->Description = CombineDirectoriesDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::CombineDirectories, (String (*)(StringParam, StringParam, StringParam, StringParam)), "CombineDirectories", "dir0, dir1, dir2, dir3")->Description = CombineDirectoriesDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::CombineDirectories, (String (*)(StringParam, StringParam, StringParam, StringParam, StringParam)), "CombineDirectories", "dir0, dir1, dir2, dir3, dir4")->Description = CombineDirectoriesDocumentation();

    ZilchBindMethod(builder, type, &FilePathClass::CombineDirectoriesAndFile, (String (*)(StringParam, StringParam)), "CombineDirectoriesAndFile", "dir0, fileName")->Description = CombineDirectoriesAndFileDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::CombineDirectoriesAndFile, (String (*)(StringParam, StringParam, StringParam)), "CombineDirectoriesAndFile", "dir0, dir1, fileName")->Description = CombineDirectoriesAndFileDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::CombineDirectoriesAndFile, (String (*)(StringParam, StringParam, StringParam, StringParam)), "CombineDirectoriesAndFile", "dir0, dir1, dir2, fileName")->Description = CombineDirectoriesAndFileDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::CombineDirectoriesAndFile, (String (*)(StringParam, StringParam, StringParam, StringParam, StringParam)), "CombineDirectoriesAndFile", "dir0, dir1, dir2, dir3, fileName")->Description = CombineDirectoriesAndFileDocumentation();

    //// Bind the array version of Combine
    //Array<Type*> arrayElement;
    //arrayElement.push_back(ZilchTypeId(String));
    //LibraryArray coreArray;
    //coreArray.push_back(Core::GetInstance().GetBuilder()->BuiltLibrary);
    //BoundType* arrayOfStrings = builder.InstantiateTemplate("Array", arrayElement, coreArray).Type;
    //Function* combineFunction = builder.AddBoundFunction(type, "Combine", &FilePathClass::Combine, OneParameter(arrayOfStrings, "parts"), ZilchTypeId(String), FunctionOptions::Static);
    //combineFunction->Description = CombineDocumentation();

    ZilchBindProperty(builder, type, &FilePathClass::GetDirectorySeparator, nullptr, "DirectorySeparator")->Description = DirectorySeparatorDocumentation();

    ZilchBindMethod(builder, type, &FilePathClass::ChangeExtension, ZilchNoOverload, "ChangeExtension", ZilchNoNames)->Description = ChangeExtensionDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::GetExtensionWithDot, ZilchNoOverload, "GetExtensionWithDot", ZilchNoNames)->Description = GetExtensionWithDotDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::GetExtensionWithoutDot, ZilchNoOverload, "GetExtensionWithoutDot", ZilchNoNames)->Description = GetExtensionWithoutDotDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::GetFileNameWithExtension, ZilchNoOverload, "GetFileNameWithExtension", ZilchNoNames)->Description = GetFileNameWithExtensionDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::GetFileNameWithoutExtension, ZilchNoOverload, "GetFileNameWithoutExtension", ZilchNoNames)->Description = GetFileNameWithoutExtensionDocumentation();

    ZilchBindMethod(builder, type, &FilePathClass::AddTrailingDirectorySeparator, ZilchNoOverload, "AddTrailingDirectorySeparator", ZilchNoNames)->Description = AddTrailingDirectorySeparatorDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::RemoveTrailingDirectorySeparator, ZilchNoOverload, "RemoveTrailingDirectorySeparator", ZilchNoNames)->Description = RemoveTrailingDirectorySeparatorDocumentation();

    ZilchBindMethod(builder, type, &FilePathClass::GetDirectoryPath, ZilchNoOverload, "GetDirectoryPath", ZilchNoNames)->Description = GetDirectoryPathDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::GetDirectoryName, ZilchNoOverload, "GetDirectoryName", ZilchNoNames)->Description = GetDirectoryNameDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::GetCanonicalizedPathFromAbsolutePath, ZilchNoOverload, "GetCanonicalizedPathFromAbsolutePath", ZilchNoNames)->Description = GetCanonicalizedPathFromAbsolutePathDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::GetComparablePathFromAbsolutePath, ZilchNoOverload, "GetComparablePathFromAbsolutePath", ZilchNoNames)->Description = GetComparablePathFromAbsolutePathDocumentation();
    ZilchBindMethod(builder, type, &FilePathClass::IsRelative, ZilchNoOverload, "IsRelative", ZilchNoNames)->Description = IsRelativeDocumentation();

    ZilchBindProperty(builder, type, &FilePathClass::GetWorkingDirectory, &FilePathClass::SetWorkingDirectory, "WorkingDirectory")->Description = WorkingDirectoryDocumentation();
    ZilchBindProperty(builder, type, &FilePathClass::GetTemporaryDirectory, ZilchNoSetter, "TemporaryDirectory")->Description = TemporaryDirectoryDocumentation();
    ZilchBindProperty(builder, type, &FilePathClass::GetUserLocalDirectory, ZilchNoSetter, "UserLocalDirectory")->Description = UserLocalDirectoryDocumentation();

    ZilchBindProperty(builder, type, &FilePathClass::GetUserDocumentsDirectory, ZilchNoSetter, "UserDocumentsDirectory")->Description = UserDocumentsDirectoryDocumentation();
    ZilchBindProperty(builder, type, &FilePathClass::GetExecutableDirectory, ZilchNoSetter, "ExecutableDirectory")->Description = ExecutableDirectoryDocumentation();
    ZilchBindProperty(builder, type, &FilePathClass::GetExecutableFile, ZilchNoSetter, "ExecutableFile")->Description = ExecutableFileDocumentation();
  }

  //***************************************************************************
  String FilePathClass::CombineDirectories(StringParam dir0, StringParam dir1)
  {
    return AddTrailingDirectorySeparator(Zero::FilePath::Combine(dir0, dir1));
  }

  //***************************************************************************
  String FilePathClass::CombineDirectories(StringParam dir0, StringParam dir1, StringParam dir2)
  {
    return AddTrailingDirectorySeparator(Zero::FilePath::Combine(dir0, dir1, dir2));
  }

  //***************************************************************************
  String FilePathClass::CombineDirectories(StringParam dir0, StringParam dir1, StringParam dir2, StringParam dir3)
  {
    return AddTrailingDirectorySeparator(Zero::FilePath::Combine(dir0, dir1, dir2, dir3));
  }

  //***************************************************************************
  String FilePathClass::CombineDirectories(StringParam dir0, StringParam dir1, StringParam dir2, StringParam dir3, StringParam dir4)
  {
    return AddTrailingDirectorySeparator(Zero::FilePath::Combine(dir0, dir1, dir2, dir3, dir4));
  }

  //***************************************************************************
  String FilePathClass::CombineDirectoriesAndFile(StringParam dir0, StringParam fileName)
  {
    return Zero::FilePath::Combine(dir0, fileName);
  }

  //***************************************************************************
  String FilePathClass::CombineDirectoriesAndFile(StringParam dir0, StringParam dir1, StringParam fileName)
  {
    return Zero::FilePath::Combine(dir0, dir1, fileName);
  }

  //***************************************************************************
  String FilePathClass::CombineDirectoriesAndFile(StringParam dir0, StringParam dir1, StringParam dir2, StringParam fileName)
  {
    return Zero::FilePath::Combine(dir0, dir1, dir2, fileName);
  }

  //***************************************************************************
  String FilePathClass::CombineDirectoriesAndFile(StringParam dir0, StringParam dir1, StringParam dir2, StringParam dir3, StringParam fileName)
  {
    return Zero::FilePath::Combine(dir0, dir1, dir2, dir3, fileName);
  }

  //***************************************************************************
  String FilePathClass::GetDirectorySeparator()
  {
    static String DirectorySeparator(Zero::cDirectorySeparatorCstr);
    return DirectorySeparator;
  }

  //***************************************************************************
  String FilePathClass::ChangeExtension(StringParam path, StringParam extension)
  {
    // First we get the last dot in the path (it may not exist)
    size_t pathLastDot = path.FindLastOf('.');
    StringRange pathRangeWithoutExtension = path.all();

    // If the last dot exists, then adjust the string range to not include it at all
    if (pathLastDot != StringRange::InvalidIndex)
      pathRangeWithoutExtension.end = pathRangeWithoutExtension.begin + pathLastDot;

    // Check if the first character is a .'. so we know whether the user passed in '.jpeg' vs just 'jpeg'
    StringRange extensionRangeWithoutLeadingDot = extension.all();
    if (extension.empty() == false && extension.front() == '.')
      ++extensionRangeWithoutLeadingDot.begin;

    // Concatenate the path and extension together (both should not have the dot, so add it in ourselves)
    return BuildString(pathRangeWithoutExtension, ".", extensionRangeWithoutLeadingDot);
  }

  //***************************************************************************
  String FilePathClass::GetExtensionWithDot(StringParam path)
  {
    // This gets the extension without the dot '.'
    // If there is no extension, our function is defined to return nothing
    StringRange extension = Zero::FilePath::GetExtension(path);
    if (extension.empty())
      return extension;

    // Prepend the dot and return the extension
    return BuildString(".", extension);
  }

  //***************************************************************************
  String FilePathClass::GetExtensionWithoutDot(StringParam path)
  {
    // This gets the extension without the dot '.' always
    return Zero::FilePath::GetExtension(path);
  }

  //***************************************************************************
  String FilePathClass::GetFileNameWithExtension(StringParam path)
  {
    return Zero::FilePath::GetFileName(path);
  }

  //***************************************************************************
  String FilePathClass::GetFileNameWithoutExtension(StringParam path)
  {
    return Zero::FilePath::GetFileNameWithoutExtension(path);
  }
  
  //***************************************************************************
  String FilePathClass::AddTrailingDirectorySeparator(StringParam path)
  {
    // First check if the path already ends in a directory separator, if not add it in
    StringRange directorySeparator(Zero::cDirectorySeparatorCstr);
    if (path.EndsWith(directorySeparator))
      return path;
    else
      return BuildString(path, Zero::cDirectorySeparatorCstr);
  }
  
  //***************************************************************************
  String FilePathClass::RemoveTrailingDirectorySeparator(StringParam path)
  {
    // First check if the path already ends in a directory separator, if it does then remove it
    StringRange directorySeparator(Zero::cDirectorySeparatorCstr);
    if (path.EndsWith(directorySeparator))
    {
      StringRange pathRange = path.all();
      --pathRange.end;
      return pathRange;
    }
    else
    {
      return path;
    }
  }

  //***************************************************************************
  String FilePathClass::GetDirectoryPath(StringParam path)
  {
    // This function does not include the trailing directory separator
    StringRange directoryPath = Zero::FilePath::GetDirectoryPath(path);

    // Increment the end to include the path separator (if its within the range of the orignal path we passed in)
    if (directoryPath.begin >= path.begin() && directoryPath.end < path.end())
      ++directoryPath.end;

    return directoryPath;
  }

  //***************************************************************************
  String FilePathClass::GetDirectoryName(StringParam path)
  {
    return Zero::FilePath::GetDirectoryName(path);
  }

  //***************************************************************************
  String FilePathClass::GetCanonicalizedPathFromAbsolutePath(StringParam absolutePath)
  {
    // We want to check if it has an ending separator because our FilePathClass::Normalize removes it (but we want it to be added back in)
    bool hasEndingSeparator = false;
    if (absolutePath.size() > 0 && (absolutePath.back() == '\\' || absolutePath.back() == '/'))
      hasEndingSeparator = true;

    // Our path normalizationg changes all slashes to be the OS slashes, and removes redudant slashes
    String normalized = Zero::FilePath::Normalize(absolutePath);
    if (hasEndingSeparator)
      normalized = BuildString(normalized, Zero::cDirectorySeparatorCstr);

    // Let the operating system specific behavior canonicalize the path
    String canonicalized = Zero::CanonicalizePath(normalized);
    return canonicalized;
  }

  //***************************************************************************
  String FilePathClass::GetComparablePathFromAbsolutePath(StringParam path)
  {
    // First do path normaliziation and canonicalization
    String comparablePath = GetCanonicalizedPathFromAbsolutePath(path);

    // If the current file system is case insensative, then technically "Player.png" should compare the same as "player.PNG"
    // To make strings properly comparable, we make them all lowercase
    if (Zero::cFileSystemCaseInsensitive)
      comparablePath = comparablePath.ToLower();
    return comparablePath;
  }
  
  //***************************************************************************
  bool FilePathClass::IsRelative(StringParam path)
  {
    // Return that empty paths are relative (it doesn't really matter what we do here)
    if (path.empty())
      return true;

    // If we have the unix 'root directory', then its not relative
    if (path.front() == '/')
      return false;

    // Look for a windows network or UNC path
    if (path.StartsWith("\\\\"))
      return false;

    // If we find a ':' character then we assume its rooted because that is otherwise an invalid character
    // This may fail on older operating systems (we'll have to let this run wild and see what people say)
    if (path.FindFirstOf(':') != StringRange::InvalidIndex)
      return false;

    // Otherwise, assume its relative if we got here!
    return true;
  }

  //***************************************************************************
  String FilePathClass::GetWorkingDirectory()
  {
    return AddTrailingDirectorySeparator(Zero::GetWorkingDirectory());
  }

  //***************************************************************************
  void FilePathClass::SetWorkingDirectory(StringParam path)
  {
    Zero::SetWorkingDirectory(path);
  }

  //***************************************************************************
  String FilePathClass::GetTemporaryDirectory()
  {
    return AddTrailingDirectorySeparator(Zero::GetTemporaryDirectory());
  }

  //***************************************************************************
  String FilePathClass::GetUserLocalDirectory()
  {
    return AddTrailingDirectorySeparator(Zero::GetUserLocalDirectory());
  }

  //***************************************************************************
  String FilePathClass::GetUserDocumentsDirectory()
  {
    return AddTrailingDirectorySeparator(Zero::GetUserDocumentsDirectory());
  }

  //***************************************************************************
  String FilePathClass::GetExecutableDirectory()
  {
    return AddTrailingDirectorySeparator(Zero::GetApplicationDirectory());
  }

  //***************************************************************************
  String FilePathClass::GetExecutableFile()
  {
    return Zero::GetApplication();
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes



namespace Zilch
{
  //***************************************************************************
  ZilchDefineExternalType(FileMode::Enum, "FileMode", Core, builder, type)
  {
    ZilchBindEnum(builder, type, SpecialType::Flags);
    ZilchBindEnumValue(builder, type, FileMode::Read,         "Read");
    ZilchBindEnumValue(builder, type, FileMode::Write,        "Write");
    ZilchBindEnumValue(builder, type, FileMode::Append,       "Append");
    ZilchBindEnumValue(builder, type, FileMode::ShareRead,    "ShareRead");
    ZilchBindEnumValue(builder, type, FileMode::ShareWrite,   "ShareWrite");
    ZilchBindEnumValue(builder, type, FileMode::ShareDelete,  "ShareDelete");
    ZilchBindEnumValue(builder, type, FileMode::Sequential,   "Sequential");
  }

  //***************************************************************************
  ZilchDefineType(FileStream, "FileStream", Core, builder, type)
  {
    // Even though this is an interface, because it is native, it must have a constructor that can be implemented
    ZilchBindConstructor(builder, type, FileStream, "filePath, mode", StringParam, FileMode::Enum);
    ZilchBindDestructor(builder, type, FileStream);
  }
  
  //***************************************************************************
  FileStream::FileStream(StringParam filePath, FileMode::Enum mode)
  {
    Zero::FileShare::Enum zeroShare = (Zero::FileShare::Enum)0;
    Zero::FileMode::Enum zeroMode = Zero::FileMode::Read;
    Zero::FileAccessPattern::Enum zeroAccessPattern = Zero::FileAccessPattern::Random;

    bool read   = (mode & FileMode::Read)   != 0;
    bool write  = (mode & FileMode::Write)  != 0;
    bool append = (mode & FileMode::Append) != 0;

    if (append && read)
    {
      ExecutableState::CallingState->ThrowException("Cannot Append and Read from the same FileStream");
      return;
    }

    // Translate our mode flags into the Zero enum
    if (append)
      zeroMode = Zero::FileMode::Append;
    else if (read && write)
      zeroMode = Zero::FileMode::ReadWrite;
    else if (write)
      zeroMode = Zero::FileMode::Write;
    else
      zeroMode = Zero::FileMode::Read;

    // Enable any optimizations
    if (mode & FileMode::Sequential)
      zeroAccessPattern = Zero::FileAccessPattern::Sequential;

    // We always have these capabilities
    this->Capabilities = (StreamCapabilities::Enum)(StreamCapabilities::GetCount | StreamCapabilities::Seek);

    if (mode & FileMode::ShareRead)
      zeroShare = (Zero::FileShare::Enum)(zeroShare | Zero::FileShare::Read);
    if (mode & FileMode::ShareWrite)
      zeroShare = (Zero::FileShare::Enum)(zeroShare | Zero::FileShare::Write);
    if (mode & FileMode::ShareDelete)
      zeroShare = (Zero::FileShare::Enum)(zeroShare | Zero::FileShare::Delete);

    // Setup stream capabilities based on flags passed in
    if (read)
      this->Capabilities = (StreamCapabilities::Enum)(this->Capabilities | StreamCapabilities::Read);
    if (write)
      this->Capabilities = (StreamCapabilities::Enum)(this->Capabilities | StreamCapabilities::Write);

    // Open the file and throw an exception if we fail
    Status status;
    this->InternalFile.Open(filePath, zeroMode, zeroAccessPattern, zeroShare, &status);
    if (status.Failed())
    {
      String message = String::Format("Unable to open the file '%s': %s", filePath.c_str(), status.Message.c_str());
      ExecutableState::CallingState->ThrowException(message);
    }
  }
  
  //***************************************************************************
  StreamCapabilities::Enum FileStream::GetCapabilities()
  {
    return this->Capabilities;
  }
  
  //***************************************************************************
  DoubleInteger FileStream::GetPosition()
  {
    return this->InternalFile.Tell();
  }
  
  //***************************************************************************
  DoubleInteger FileStream::GetCount()
  {
    return this->InternalFile.CurrentFileSize();
  }
  
  //***************************************************************************
  bool FileStream::Seek(DoubleInteger position, StreamOrigin::Enum origin)
  {
    return this->InternalFile.Seek(position, (Zero::FileOrigin::Enum)origin);
  }
  
  //***************************************************************************
  Integer FileStream::Write(ArrayClass<Byte>& data, Integer byteStart, Integer byteCount)
  {
    IStreamClass::Write(data, byteStart, byteCount);
    if (ExecutableState::GetCallingReport().HasThrownExceptions())
      return 0;

    return (Integer)this->InternalFile.Write(data.NativeArray.data() + byteStart, (size_t)byteCount);
  }
  
  //***************************************************************************
  Integer FileStream::WriteByte(Byte byte)
  {
    return (Integer)this->InternalFile.Write(&byte, 1);
  }
  
  //***************************************************************************
  Integer FileStream::Read(ArrayClass<Byte>& data, Integer byteStart, Integer byteCount)
  {
    IStreamClass::Read(data, byteStart, byteCount);
    if (ExecutableState::GetCallingReport().HasThrownExceptions())
      return 0;

    return (Integer)this->InternalFile.Read(data.NativeArray.data() + byteStart, (size_t)byteCount);
  }
  
  //***************************************************************************
  Integer FileStream::ReadByte()
  {
    IStreamClass::ReadByte();
    if (ExecutableState::GetCallingReport().HasThrownExceptions())
      return 0;

    // Read a single byte
    Byte byte = 0;
    size_t bytesRead = this->InternalFile.Read(&byte, 1);

    // If we didn't read anything, then return -1 (we're returning an Integer)
    if (bytesRead == 0)
      return -1;

    // Otherwise, return just the byte
    return (Integer)byte;
  }
  
  //***************************************************************************
  void FileStream::Flush()
  {
    this->InternalFile.Flush();
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes





namespace Zilch
{
  //***************************************************************************
  CodeFormat::CodeFormat() :
    IsTabs(false),
    Identation(2),
    StripWhiteSpaceFromEmptyLines(false),
    IndentGlobalDefault(IndentStyle::Indented),
    IndentClassContents(IndentStyle::UseGlobalDefault),
    IndentEnumContents(IndentStyle::UseGlobalDefault),
    IndentFunctionContents(IndentStyle::UseGlobalDefault),
    IndentPropertyContents(IndentStyle::UseGlobalDefault),
    IndentGetSetContents(IndentStyle::UseGlobalDefault),
    IndentScopeContents(IndentStyle::UseGlobalDefault),
    LineStyleGlobalDefaultScope(LineStyle::NextLine),
    LineStyleClassScope(LineStyle::UseGlobalDefault),
    LineStyleEnumScope(LineStyle::UseGlobalDefault),
    LineStyleFunctionScope(LineStyle::UseGlobalDefault),
    LineStylePropertyScope(LineStyle::UseGlobalDefault),
    LineStyleGetSetScope(LineStyle::UseGlobalDefault),
    LineStyleBlockScope(LineStyle::UseGlobalDefault),
    LineStyleInitializerList(LineStyle::SameLine),
    SpaceStyleGlobalDefaultColon(SpaceStyle::BeforeAndAfter),
    SpaceStyleInheritanceColon(SpaceStyle::UseGlobalDefault),
    SpaceStyleInitializerListColon(SpaceStyle::UseGlobalDefault),
    SpaceStyleTypeColon(SpaceStyle::UseGlobalDefault),
    SpaceStyleNamedArgumentColon(SpaceStyle::UseGlobalDefault),
    SpaceStyleGlobalDefaultComma(SpaceStyle::After),
    SpaceStyleInheritanceComma(SpaceStyle::UseGlobalDefault),
    SpaceStyleInitializerListComma(SpaceStyle::UseGlobalDefault),
    SpaceStyleFunctionDefinitionParameterComma(SpaceStyle::UseGlobalDefault),
    SpaceStyleFunctionCallParameterComma(SpaceStyle::UseGlobalDefault),
    SpaceStyleTemplateDefinitionParameterComma(SpaceStyle::UseGlobalDefault),
    SpaceStyleTemplateInstantiationParameterComma(SpaceStyle::UseGlobalDefault),
    SpaceStyleGlobalDefaultParenthesis(SpaceStyle::None),
    SpaceStyleFunctionDefinitionBeginParenthesis(SpaceStyle::None),
    SpaceStyleFunctionDefinitionEndParenthesis(SpaceStyle::None),
    SpaceAfterComment(true),
    CommentWordWrapLength(100)
  {
  }

  //***************************************************************************
  ZilchCodeBuilder::ZilchCodeBuilder() :
    Indentation(0),
    Line(1),
    Character(1)
  {
  }

  //***************************************************************************
  void ZilchCodeBuilder::WriteKeywordOrSymbol(Grammar::Enum token)
  {
    this->Write(Grammar::GetKeywordOrSymbol(token));
  }

  //***************************************************************************
  void ZilchCodeBuilder::WriteKeywordOrSymbolSpaceStyle(Grammar::Enum token, SpaceStyle::Enum specific, SpaceStyle::Enum globalDefault)
  {
    // This tells us if we want to place spaces before or after (or around) the token
    SpaceStyle::Enum spaceStyle = GetSpaceStyle(specific, globalDefault);

    // Prepend a space if we require it
    if (spaceStyle == SpaceStyle::BeforeAndAfter || spaceStyle == SpaceStyle::Before)
    {
      this->WriteSpace();
    }

    this->WriteKeywordOrSymbol(token);

    // Append a space if we require it
    if (spaceStyle == SpaceStyle::BeforeAndAfter || spaceStyle == SpaceStyle::After)
    {
      this->WriteSpace();
    }
  }
  
  //***************************************************************************
  void ZilchCodeBuilder::BeginScope(ScopeType::Enum scope)
  {
    // Scopes are responsible for starting their own line, and the next
    // For that matter, any kind of statement or thing that belongs on
    // its own line is repsonsible for emitting its own line before

    // Technically these should always be set as long as the 'scope' value is valid, however we need
    // to initialize them to defaults so the compiler doesn't complain about 'potentially uninitialized' values
    LineStyle::Enum specificLineStyle = LineStyle::NextLine;
    IndentStyle::Enum specificIndentStyle = IndentStyle::Indented;

    // Depending on the scope type we're adding, we could have different rules
    switch (scope)
    {
      // We're adding scope to a class (contains properties, fields, methods, etc)
      case ScopeType::Class:
        specificLineStyle = this->Format.LineStyleClassScope;
        specificIndentStyle = this->Format.IndentClassContents;
        break;
      // We're adding scope to a class (contains properties, fields, methods, etc)
      case ScopeType::Enumeration:
        specificLineStyle = this->Format.LineStyleEnumScope;
        specificIndentStyle = this->Format.IndentEnumContents;
        break;
      // We're adding scope to a function's statements
      case ScopeType::Function:
        specificLineStyle = this->Format.LineStyleFunctionScope;
        specificIndentStyle = this->Format.IndentFunctionContents;
        break;
      // We're adding scope to a property
      case ScopeType::Property:
        specificLineStyle = this->Format.LineStylePropertyScope;
        specificIndentStyle = this->Format.IndentPropertyContents;
        break;
      // We're adding scope to a get/set
      case ScopeType::GetSet:
        specificLineStyle = this->Format.LineStyleGetSetScope;
        specificIndentStyle = this->Format.IndentGetSetContents;
        break;
      // We're adding scope to any other type of block (if statement, while loop, etc)
      case ScopeType::Block:
        specificLineStyle = this->Format.LineStyleBlockScope;
        specificIndentStyle = this->Format.IndentScopeContents;
        break;
    }

    // For every situation, we could have a specific line or indent style, or we could fall back to the global
    LineStyle::Enum lineStyle = GetLineStyle(specificLineStyle, this->Format.LineStyleGlobalDefaultScope);
    IndentStyle::Enum indentStyle = GetIndentStyle(specificIndentStyle, this->Format.IndentGlobalDefault);

    // It would be nice if scope was just a simple integer, however, because some styles require that certain
    // scopes are indented, and others are not, and in some the braces themselves are indented...
    // We need to push this structure into a stack instead (a stack of scopes)
    ScopeStyle scopeStyle;
    scopeStyle.InnardsIndented = (indentStyle == IndentStyle::Indented);

    // Based on the line style...
    switch (lineStyle)
    {
      case LineStyle::NextLine:
        // Just write out a standard indented line
        this->WriteLineIndented();
        break;

      case LineStyle::NextLineIndented:
        // Just write out a standard indented line with one extra indent
        this->WriteLineIndented();
        this->WriteIndent();

        // In this case, it means that even the ending brace needs to be indented...
        scopeStyle.BracesIndented = true;
        break;

      case LineStyle::SameLine:
        // We always write out a space (this should probably become an option in the future)
        this->Write(" ");
        break;
    }

    // Now write out the 'begin scope' token, typically '{'
    this->WriteKeywordOrSymbol(Grammar::BeginScope);

    // Add the scope to the scope stack so that when we 'EndScope' / pop it off, we know what to do
    this->Scopes.push_back(scopeStyle);

    // If we're indenting the inside, then increase the indentation for the next line
    if (scopeStyle.InnardsIndented)
    {
      ++this->Indentation;
    }

    // If the user also requested the braces be indented, our standard behavior is to indent the innards yet again
    if (scopeStyle.BracesIndented)
    {
      ++this->Indentation;
    }
  }
  
  //***************************************************************************
  void ZilchCodeBuilder::EndScope()
  {
    // Trim any previously writen lines or spaces
    this->TrimEnd();

    // Make sure we have scopes to end, and we didn't call this one too many times
    ErrorIf(this->Scopes.empty(),
      "Attempting to pop a scope when there we're no scopes present");

    // Get the latest scope
    ScopeStyle& scope = this->Scopes.back();

    // If it's innards were indented, decrease the indent
    if (scope.InnardsIndented)
    {
      --this->Indentation;
    }

    // Note: When emitting anything, we always assume we're on the last line, which means we must emit our own line
    // Note: If you look in BeginScope, having 'BracesIndented' will actually increase the tabbing again
    // At this point in time, we've only decreased the tabbing due to 'InnardsIndented', which means
    // that this line we emit will still have tabbing for braces, which is good for when we emit the end brace
    this->WriteLineIndented();

    // If it's braces were indented, decrease the indent again (see 2nd note above and BeginScope)
    if (scope.BracesIndented)
    {
      --this->Indentation;
    }
    
    // Now write out the 'end scope' token, typically '}'
    this->WriteKeywordOrSymbol(Grammar::EndScope);
    
    // We've officially finished this scope off!
    this->Scopes.pop_back();
  }

  //**************************************************************************
  void ZilchCodeBuilder::WriteLine()
  {
    // Invoke the base so we just write a standard newline
    StringBuilderExtended::WriteLine();

    // Also increment our line count
    ++this->Line;
  }

  //**************************************************************************
  void ZilchCodeBuilder::WriteLineIndented()
  {
    // Create a new line
    this->WriteLine();

    // Write indents up to the indentation level we're at
    for (size_t i = 0; i < this->Indentation; ++i)
    {
      this->WriteIndent();
    }
  }

  //**************************************************************************
  void ZilchCodeBuilder::Write(const UserToken& token)
  {
    this->Write(token.Token);
  }

  //**************************************************************************
  void ZilchCodeBuilder::WriteLineStyle(LineStyle::Enum specific, LineStyle::Enum globalDefault)
  {
    // Get the resulting line style
    LineStyle::Enum lineStyle = GetLineStyle(specific, globalDefault);

    // Based on the line style...
    switch (lineStyle)
    {
      case LineStyle::NextLine:
        // Just write out a standard indented line
        this->WriteLineIndented();
        break;

      case LineStyle::NextLineIndented:
        // Just write out a standard indented line with one extra indent
        this->WriteLineIndented();
        this->WriteIndent();
        break;

      case LineStyle::SameLine:
        // We always write out a space (this should probably become an option in the future)
        this->Write(" ");
        break;
    }
  }

  //***************************************************************************
  void ZilchCodeBuilder::WriteIndent()
  {
    // We make constants so we don't keep allocating this
    static const String Tab("\t");
    static const String Space(" ");

    // If we use tabs to format, then indent with tabs
    if (this->Format.IsTabs)
    {
      this->Repeat(this->Format.Identation, Tab);
    }
    else
    {
      this->Repeat(this->Format.Identation, Space);
    }
  }

  //***************************************************************************
  void ZilchCodeBuilder::WriteSpace()
  {
    this->Write(" ");
  }
  
  //***************************************************************************
  void ZilchCodeBuilder::WriteSingleLineComment(StringParam text)
  {
    this->Write("//");
    if (this->Format.SpaceAfterComment)
      this->WriteSpace();

    this->Write(text);
  }
  
  //***************************************************************************
  void ZilchCodeBuilder::TrimEnd()
  {
    size_t amountToBackup = 0;
    for (long long i = (long long)(this->GetSize() - 1); i >= 0; --i)
    {
      byte b = (*this)[(size_t)i];
      if (isspace(b) == false)
        break;

      ++amountToBackup;
    }

    this->Backup(amountToBackup);
  }

  //***************************************************************************
  String ZilchCodeBuilder::ToString()
  {
    //HACK need to run post pass to trim trailing space / empty lines
    return StringBuilderExtended::ToString();
  }

  //***************************************************************************
  size_t ZilchCodeBuilder::GetLine()
  {
    return this->Line;
  }

  //***************************************************************************
  ZilchCodeBuilder::ScopeStyle::ScopeStyle() :
    BracesIndented(false),
    InnardsIndented(false)
  {
  }

  //***************************************************************************
  ScopeLastNode::ScopeLastNode() :
    LastNode(nullptr),
    AssociatedScope(nullptr)
  {
  }

  //***************************************************************************
  CodeFormatterContext::CodeFormatterContext()
  {
  }

  //***************************************************************************
  LineStyle::Enum ZilchCodeBuilder::GetLineStyle(LineStyle::Enum specific, LineStyle::Enum globalDefault)
  {
    ErrorIf(globalDefault == LineStyle::UseGlobalDefault,
      "The global default cannot be set to 'LineStyle::UseGlobalDefault'");

    // Return the specific line style as long as it's not falling back on the default
    if (specific != LineStyle::UseGlobalDefault)
    {
      return specific;
    }

    // Return the default line format
    return globalDefault;
  }

  //***************************************************************************
  IndentStyle::Enum ZilchCodeBuilder::GetIndentStyle(IndentStyle::Enum specific, IndentStyle::Enum globalDefault)
  {
    ErrorIf(globalDefault == IndentStyle::UseGlobalDefault,
      "The global default cannot be set to 'IndentStyle::UseGlobalDefault'");

    // Return the specific indent style as long as it's not falling back on the default
    if (specific != IndentStyle::UseGlobalDefault)
    {
      return specific;
    }

    // Return the default indent format
    return globalDefault;
  }
  
  //***************************************************************************
  SpaceStyle::Enum ZilchCodeBuilder::GetSpaceStyle(SpaceStyle::Enum specific, SpaceStyle::Enum globalDefault)
  {
    ErrorIf(globalDefault == IndentStyle::UseGlobalDefault,
      "The global default cannot be set to 'SpaceStyle::UseGlobalDefault'");

    // Return the specific space style as long as it's not falling back on the default
    if (specific != SpaceStyle::UseGlobalDefault)
    {
      return specific;
    }

    // Return the default space format
    return globalDefault;
  }

  //***************************************************************************
  CodeFormatter::CodeFormatter()
  {
    this->Walker.RegisterNonLeafBase(&CodeFormatter::FormatCommentsAndLines);
    
    this->Walker.Register(&CodeFormatter::FormatBinaryOperator);
    this->Walker.Register(&CodeFormatter::FormatUnaryOperator);
    this->Walker.RegisterDerived<PropertyDelegateOperatorNode>(&CodeFormatter::FormatUnaryOperator);
    this->Walker.Register(&CodeFormatter::FormatTypeCast);
    this->Walker.Register(&CodeFormatter::FormatIndexerCall);
    this->Walker.Register(&CodeFormatter::FormatFunctionCall);
    this->Walker.Register(&CodeFormatter::FormatMemberAccess);
    this->Walker.Register(&CodeFormatter::FormatStaticTypeNode);
    this->Walker.Register(&CodeFormatter::FormatLocalVariable);
    this->Walker.Register(&CodeFormatter::FormatParameter);
    this->Walker.Register(&CodeFormatter::FormatMemberVariable);
    this->Walker.Register(&CodeFormatter::FormatValue);
    this->Walker.Register(&CodeFormatter::FormatStringInterpolant);
    this->Walker.Register(&CodeFormatter::FormatDelete);
    this->Walker.Register(&CodeFormatter::FormatReturn);
    this->Walker.Register(&CodeFormatter::FormatIf);
    this->Walker.Register(&CodeFormatter::FormatSendsEvent);
    this->Walker.Register(&CodeFormatter::FormatBreak);
    this->Walker.Register(&CodeFormatter::FormatDebugBreak);
    this->Walker.Register(&CodeFormatter::FormatContinue);
    this->Walker.Register(&CodeFormatter::FormatLoop);
    this->Walker.Register(&CodeFormatter::FormatWhile);
    this->Walker.Register(&CodeFormatter::FormatDoWhile);
    this->Walker.Register(&CodeFormatter::FormatFor);
    // this->Walker.RegisterDerived<ForEachNode>(&CodeFormatter::FormatFor);
    this->Walker.Register(&CodeFormatter::FormatForEach);
    this->Walker.Register(&CodeFormatter::FormatFunction);
    /*Initializer*/
    this->Walker.Register(&CodeFormatter::FormatConstructor);
    this->Walker.Register(&CodeFormatter::FormatDestructor);
    this->Walker.Register(&CodeFormatter::FormatClass);
    //this->Walker.Register(&CodeFormatter::FormatTypeDefine);
    this->Walker.RegisterDerived<LocalVariableReferenceNode>(&CodeFormatter::FormatValue);
    this->Walker.Register(&CodeFormatter::FormatThrow);
    this->Walker.Register(&CodeFormatter::FormatTypeId);
    this->Walker.Register(&CodeFormatter::FormatEnumValue);
    this->Walker.Register(&CodeFormatter::FormatEnum);
    
    // This must come after all statements and expressions are registered
    this->Walker.RegisterNonLeafBase(&CodeFormatter::FormatStatement);
  }

  //***************************************************************************
  String CodeFormatter::FormatTree(SyntaxTree& syntaxTree, const CodeFormat& format)
  {
    // Create the context and setup the format rules
    CodeFormatterContext context;
    context.Builder.Format = format;

    // Get the nodes in the order they were declared
    NodeList<SyntaxNode>& inOrderNodes = syntaxTree.Root->NonTraversedNonOwnedNodesInOrder;

    // Walk the given syntax tree and emit code for each type of node
    for (size_t i = 0; i < inOrderNodes.size(); ++i)
    {
      // Traverse the current node
      SyntaxNode* childNode = inOrderNodes[i];
      this->Walker.Walk(this, childNode, &context);
    }

    // Finally compact the string builder into a single string
    return context.Builder.ToString();
  }

  //***************************************************************************
  bool CodeFormatter::IsDirectlyWithinScope(SyntaxNode* node)
  {
    // Note: This should be solved with interfaces or virtual functions
    if (TypeBinding::DynamicCast<RootNode*>(node->Parent) != nullptr)
      return true;

    if (TypeBinding::DynamicCast<ClassNode*>(node->Parent) != nullptr)
      return true;

    if (TypeBinding::DynamicCast<EnumNode*>(node->Parent) != nullptr)
      return true;

    return StatementNode::IsNodeUsedAsStatement(node);
  }

  //***************************************************************************
  size_t CodeFormatter::CountAttributes(SyntaxNode* node)
  {
    // Note: This should be solved with interfaces or virtual functions
    if (LocalVariableNode* attributeParent = TypeBinding::DynamicCast<LocalVariableNode*>(node))
    {
      return attributeParent->Attributes.size();
    }

    if (MemberVariableNode* attributeParent = TypeBinding::DynamicCast<MemberVariableNode*>(node))
    {
      return attributeParent->Attributes.size();
    }

    if (GenericFunctionNode* attributeParent = TypeBinding::DynamicCast<GenericFunctionNode*>(node))
    {
      return attributeParent->Attributes.size();
    }

    if (ClassNode* attributeParent = TypeBinding::DynamicCast<ClassNode*>(node))
    {
      return attributeParent->Attributes.size();
    }

    if (EnumNode* attributeParent = TypeBinding::DynamicCast<EnumNode*>(node))
    {
      return attributeParent->Attributes.size();
    }

    return 0;
  }
  
  //***************************************************************************
  void CodeFormatter::FormatCommentsAndLines(SyntaxNode*& node, CodeFormatterContext* context)
  {
    // This will always run, even if other handlers will handle it
    
    ZilchCodeBuilder& builder = context->Builder;
    
    if (IsDirectlyWithinScope(node))
    {
      bool scopeFound = false;

      for (int i = (int)(context->FormatScopes.size() - 1); i >= 0; --i)
      {
        ScopeLastNode& scope = context->FormatScopes[i];

        if (scope.AssociatedScope == node->Parent)
        {
          scopeFound = true;
          break;
        }
      }

      ScopeLastNode* foundScope = nullptr;

      if (scopeFound)
      {
        while (context->FormatScopes.back().AssociatedScope != node->Parent)
        {
          context->FormatScopes.pop_back();
        }

        foundScope = &context->FormatScopes.back();
      }
      else
      {
        foundScope = &context->FormatScopes.push_back();
        foundScope->AssociatedScope = node->Parent;
      }
      
      int lineDifference = 0;

      if (foundScope->LastNode != nullptr)
      {
        lineDifference = (int)(node->Location.StartLine - foundScope->LastNode->Location.EndLine);
      }
      
      lineDifference -= (int)node->Comments.size();
      lineDifference -= (int)CountAttributes(node);

      // Since we will always emit one line, we skip one
      for (int i = 1; i < lineDifference; ++i)
      {
        builder.WriteLineIndented();
      }

      foundScope->LastNode = node;
    }


    //if (TypeBinding::DynamicCast<ClassNode*>(node->Parent) != nullptr)
    //{
    //  
    //  if (context->LastMember != nullptr)
    //  {
    //    
    //  }
    //}
    //else if (TypeBinding::DynamicCast<RootNode*>(node->Parent) != nullptr)
    //{
    //  if (context->LastClassOrEnum != nullptr)
    //  {
    //    lineDifference = (int)(node->Location.StartLine - context->LastClassOrEnum->Location.EndLine);
    //  }
    //}
    //else if (StatementNode::IsNodeUsedAsStatement(node))
    //{
    //  if (context->LastStatement != nullptr)
    //  {
    //    lineDifference = node->Location.StartLine - context->LastStatement->Location.EndLine;
    //  }
    //}



    for (size_t i = 0; i < node->Comments.size(); ++i)
    {
      String& comment = node->Comments[i];

      builder.WriteLineIndented();

      builder.WriteKeywordOrSymbol(Grammar::CommentLine);

      size_t leadingSpaces = 0;
      StringRange range = comment.all();
      while (range.empty() == false)
      {
        size_t character = range.front();
        range.popFront();

        if (character == ' ')
          ++leadingSpaces;
        else
          break;
      }

      range = comment.all();

      if (builder.Format.SpaceAfterComment)
      {
        if (leadingSpaces == 0)
        {
          builder.WriteSpace();
        }
      }
      else
      {
        if (leadingSpaces == 1)
        {
          ++range.begin;
        }
      }
      
      builder.Write(range);
    }

    if (StatementNode::IsNodeUsedAsStatement(node))
    {
      // The only exception we have to the rule of 'you must write a line before you write yourself'
      // is in expressions, which we don't know if they are going to be used as an expression or a statement
      // Therefore we handle newlines before expressions here
      builder.WriteLineIndented();
    }

    // If someone else ends up handling the children, that is fine
    // but we need to explicitly say that we didn't handle any children
    context->Flags = WalkerFlags::ChildrenNotHandled;
  }

  //***************************************************************************
  void CodeFormatter::FormatDelete(DeleteNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    builder.WriteKeywordOrSymbol(Grammar::Delete);
    builder.WriteSpace();
    context->Walker->Walk(this, node->DeletedObject, context);
  }

  //***************************************************************************
  void CodeFormatter::FormatBreak(BreakNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.WriteKeywordOrSymbol(Grammar::Break);
  }

  //***************************************************************************
  void CodeFormatter::FormatDebugBreak(DebugBreakNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.WriteKeywordOrSymbol(Grammar::Debug);
    builder.WriteSpace();
    builder.WriteKeywordOrSymbol(Grammar::Break);
  }

  //***************************************************************************
  void CodeFormatter::FormatThrow(ThrowNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.WriteKeywordOrSymbol(Grammar::Throw);
    builder.WriteSpace();
    context->Walker->Walk(this, node->Exception, context);
  }

  //***************************************************************************
  void CodeFormatter::FormatContinue(ContinueNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.WriteKeywordOrSymbol(Grammar::Continue);
  }

  //***************************************************************************
  void CodeFormatter::FormatForEach(ForEachNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.WriteKeywordOrSymbol(Grammar::ForEach);
    
    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);

    if (node->NonTraversedVariable != nullptr)
    {
      // We don't want to do the standard walk here, because it would treat it as a statement!
      this->FormatLocalVariable(node->NonTraversedVariable, context);
    }

    builder.WriteSpace();
    builder.WriteKeywordOrSymbol(Grammar::In);
    builder.WriteSpace();
    
    if (node->NonTraversedRange != nullptr)
    {
      context->Walker->Walk(this, node->NonTraversedRange, context);
    }

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);

    builder.BeginScope(ScopeType::Block);
    context->Walker->Walk(this, node->Statements, context);
    builder.EndScope();
  }

  //***************************************************************************
  void CodeFormatter::FormatFor(ForNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.WriteKeywordOrSymbol(Grammar::For);
    
    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);

    if (node->Initialization != nullptr)
    {
      context->Walker->Walk(this, node->Initialization, context);
    }
    
    if (node->ValueVariable != nullptr)
    {
      // We don't want to do the standard walk here, because it would treat it as a statement!
      this->FormatLocalVariable(node->ValueVariable, context);
    }
    
    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::StatementSeparator, SpaceStyle::UseGlobalDefault, SpaceStyle::After);

    if (node->Condition != nullptr)
    {
      context->Walker->Walk(this, node->Condition, context);
    }
    
    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::StatementSeparator, SpaceStyle::UseGlobalDefault, SpaceStyle::After);

    if (node->Iterator != nullptr)
    {
      context->Walker->Walk(this, node->Iterator, context);
    }

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);

    builder.BeginScope(ScopeType::Block);
    context->Walker->Walk(this, node->Statements, context);
    builder.EndScope();
  }

  //***************************************************************************
  void CodeFormatter::FormatDoWhile(DoWhileNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    
    builder.WriteKeywordOrSymbol(Grammar::Do);

    builder.BeginScope(ScopeType::Block);
    context->Walker->Walk(this, node->Statements, context);
    builder.EndScope();

    // HACK, may need line style here...
    builder.WriteLineIndented();
    builder.WriteKeywordOrSymbol(Grammar::While);

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);
    context->Walker->Walk(this, node->Condition, context);
    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
  }

  //***************************************************************************
  void CodeFormatter::FormatLoop(LoopNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    
    builder.WriteKeywordOrSymbol(Grammar::Loop);
    builder.BeginScope(ScopeType::Block);
    context->Walker->Walk(this, node->Statements, context);
    builder.EndScope();
  }

  //***************************************************************************
  void CodeFormatter::FormatWhile(WhileNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    
    builder.WriteKeywordOrSymbol(Grammar::While);

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);
    context->Walker->Walk(this, node->Condition, context);
    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);

    builder.BeginScope(ScopeType::Block);
    context->Walker->Walk(this, node->Statements, context);
    builder.EndScope();
  }

  //***************************************************************************
  void CodeFormatter::FormatIf(IfNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    if (node->IsFirstPart == false)
    {
      builder.WriteKeywordOrSymbol(Grammar::Else);
    }

    if (node->Condition != nullptr)
    {
      if (node->IsFirstPart == false)
      {
        builder.WriteSpace();
      }

      builder.WriteKeywordOrSymbol(Grammar::If);
      // HACK, this needs a space style!
      builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);
      context->Walker->Walk(this, node->Condition, context);
      // HACK, this needs a space style!
      builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
    }

    builder.BeginScope(ScopeType::Block);
    context->Walker->Walk(this, node->Statements, context);
    builder.EndScope();
  }

  //***************************************************************************
  void CodeFormatter::FormatReturn(ReturnNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    
    builder.WriteKeywordOrSymbol(Grammar::Return);
    
    if (node->ReturnValue != nullptr)
    {
      builder.WriteSpace();
      context->Walker->Walk(this, node->ReturnValue, context);
    }
  }

  //***************************************************************************
  void CodeFormatter::FormatTypeId(TypeIdNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.WriteKeywordOrSymbol(Grammar::Typeid);
    
    // HACK, this needs a space style!
    // NOTE: Probably the same space style as function calling!
    builder.WriteKeywordOrSymbol(Grammar::BeginFunctionCall);

    if (node->Value != nullptr)
    {
      context->Walker->Walk(this, node->Value, context);
    }
    else
    {
      builder.Write(node->CompileTimeSyntaxType->ToString());
    }

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbol(Grammar::EndFunctionCall);
  }

  //***************************************************************************
  void CodeFormatter::FormatStringInterpolant(StringInterpolantNode*& node, CodeFormatterContext* context)
  {
    // The string interpolant doesn't really need to do anything,
    // just walk it's children (which are expressions and string literals)
    ZilchCodeBuilder& builder = context->Builder;
    context->Walker->GenericWalkChildren(this, node, context);
  }

  //***************************************************************************
  void CodeFormatter::FormatValue(ValueNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.Write(node->Value.Token);
  }

  //***************************************************************************
  void CodeFormatter::FormatUnaryOperator(UnaryOperatorNode*& node, CodeFormatterContext* context)
  {
    // Note: Our formatter makes the assumption that all unary operators are to the left
    ZilchCodeBuilder& builder = context->Builder;

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(node->Operator->TokenId, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
    context->Walker->Walk(this, node->Operand, context);
  }

  //***************************************************************************
  void CodeFormatter::FormatTypeCast(TypeCastNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    context->Walker->Walk(this, node->Operand, context);
    
    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::As, SpaceStyle::UseGlobalDefault, SpaceStyle::BeforeAndAfter);

    builder.Write(node->Type->ToString());
  }

  //***************************************************************************
  void CodeFormatter::FormatIndexerCall(IndexerCallNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    
    context->Walker->Walk(this, node->LeftOperand, context);

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginIndex, SpaceStyle::UseGlobalDefault, SpaceStyle::None);

    for (size_t i = 0; i < node->Arguments.size(); ++i)
    {
      ExpressionNode* argument = node->Arguments[i];

      context->Walker->Walk(this, argument, context);
      
      bool isNotLast = (i != (node->Arguments.size() - 1));
      if (isNotLast)
      {
        // HACK, this needs a space style!
        builder.WriteKeywordOrSymbolSpaceStyle(Grammar::ArgumentSeparator, SpaceStyle::UseGlobalDefault, builder.Format.SpaceStyleGlobalDefaultComma);
      }
    }

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndIndex, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
  }

  //***************************************************************************
  void CodeFormatter::FormatBinaryOperator(BinaryOperatorNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    // We only need a grouping operator if our parent is another binary operator with a higher precedence
    bool needsGroup = false;

    BinaryOperatorNode* parentBinOp = TypeBinding::DynamicCast<BinaryOperatorNode*>(node->Parent);
    if (parentBinOp != nullptr)
    {
      Shared& shared = Shared::GetInstance();

      UntypedOperator ourPrecedence = shared.GetOperatorPrecedence(node->Operator->TokenId, OperatorArity::Binary);
      UntypedOperator parentPrecedence = shared.GetOperatorPrecedence(parentBinOp->Operator->TokenId, OperatorArity::Binary);

      // If the parent has a higher precedence, then we need to wrap ourselves in a group
      // Note: Higher precedence is denoted by a lower number, which is silly but seems to be how
      // other languages do it (http://en.cppreference.com/w/cpp/language/operator_precedence)
      if (parentPrecedence.Precedence < ourPrecedence.Precedence)
      {
        needsGroup = true;
      }
      // If we have the same level of precedence, then there's a chance we may need parenthesis based on
      else if (parentPrecedence.Precedence == ourPrecedence.Precedence)
      {
        // Technically, if the operator is actually associative (as in math associative) we can ignore
        // grouping when it's parent operator is the same *unless* we allow operator overloading to change that

        // If we have a left to right associativity
        if (parentPrecedence.Associativity == OperatorAssociativity::LeftToRight)
        {
          if (parentBinOp->RightOperand == node)
          {
            needsGroup = true;
          }
        }
        else
        {
          if (parentBinOp->LeftOperand == node)
          {
            needsGroup = true;
          }
        }
      }
    }

    if (needsGroup)
    {
      // HACK, this needs a space style!
      builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
    }

    context->Walker->Walk(this, node->LeftOperand, context);

    SpaceStyle::Enum globalOperatorSpaceStyle = SpaceStyle::BeforeAndAfter;

    // HACK, maybe every operator needs it's own spacing, or access operators have a special mode
    if (node->Operator->TokenId == Grammar::Access          ||
        node->Operator->TokenId == Grammar::DynamicAccess   ||
        node->Operator->TokenId == Grammar::NonVirtualAccess)
    {
      globalOperatorSpaceStyle = SpaceStyle::None;
    }

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbolSpaceStyle(node->Operator->TokenId, SpaceStyle::UseGlobalDefault, globalOperatorSpaceStyle);
    
    context->Walker->Walk(this, node->RightOperand, context);

    if (needsGroup)
    {
      // HACK, this needs a space style!
      builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
    }
  }
  
  //***************************************************************************
  void CodeFormatter::FormatStatement(StatementNode*& node, CodeFormatterContext* context)
  {
    // This will always run, even if other handlers will handle it
    
    // If this node is not being used as a direct statement
    // For example, an expression is a statement, but isn't always used as a statement
    if (StatementNode::IsNodeUsedAsStatement(node) == false)
      return;

    ZilchCodeBuilder& builder = context->Builder;
    
    // As long as the statement isn't a scoped based node (if, for, while, etc)
    // then we know it requires delimiting
    if (TypeBinding::DynamicCast<ScopeNode*>(node) == nullptr)
    {
      builder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
    }

    // If someone else ends up handling the children, that is fine
    // but we need to explicitly say that we didn't handle any children
    context->Flags = WalkerFlags::ChildrenNotHandled;
  }

  //***************************************************************************
  void CodeFormatter::FormatClass(ClassNode*& node, CodeFormatterContext* context)
  {
    if (node->TemplateInstantiation != nullptr)
      return;
    
    ZilchCodeBuilder& builder = context->Builder;

    this->FormatAttributes(node->Attributes, builder);

    builder.WriteLineIndented();

    builder.WriteKeywordOrSymbol(Grammar::Class);

    builder.WriteSpace();
    builder.Write(node->Name);

    if (node->Inheritance.empty() == false)
    {
      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::Inheritance,
        builder.Format.SpaceStyleInheritanceColon,
        builder.Format.SpaceStyleGlobalDefaultColon
      );

      for (size_t i = 0; i < node->Inheritance.size(); ++i)
      {
        SyntaxType* syntaxType = node->Inheritance[i];

        builder.Write(syntaxType->ToString());
      
        bool isNotLast = (i != (node->Inheritance.size() - 1));
        if (isNotLast)
        {
          builder.WriteKeywordOrSymbolSpaceStyle
          (
            Grammar::ArgumentSeparator,
            builder.Format.SpaceStyleInheritanceComma,
            builder.Format.SpaceStyleGlobalDefaultComma
          );
        }
      }
    }

    builder.BeginScope(ScopeType::Class);

    // Get the nodes in the order they were declared
    NodeList<SyntaxNode>& inOrderNodes = node->NonTraversedNonOwnedNodesInOrder;

    // Walk the given syntax tree and emit code for each type of node
    for (size_t i = 0; i < inOrderNodes.size(); ++i)
    {
      // Traverse the current node
      SyntaxNode* childNode = inOrderNodes[i];
      this->Walker.Walk(this, childNode, context);
    }

    builder.EndScope();
  }
  
  //***************************************************************************
  void CodeFormatter::FormatAttributes(NodeList<AttributeNode>& attributes, ZilchCodeBuilder& builder)
  {
    if (attributes.empty() == false)
    {
      builder.WriteLineIndented();
    }

    for (size_t i = 0; i < attributes.size(); ++i)
    {
      AttributeNode* attribute = attributes[i];
      builder.WriteKeywordOrSymbol(Grammar::BeginIndex);
      builder.Write(attribute->TypeName->Token);
      builder.WriteKeywordOrSymbol(Grammar::EndIndex);
    }
  }

  //***************************************************************************
  void CodeFormatter::FormatEnum(EnumNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    this->FormatAttributes(node->Attributes, builder);

    builder.WriteLineIndented();

    if (node->IsFlags)
    {
      builder.WriteKeywordOrSymbol(Grammar::Flags);
    }
    else
    {
      builder.WriteKeywordOrSymbol(Grammar::Enumeration);
    }

    builder.WriteSpace();
    builder.Write(node->Name);

    if (node->Inheritance != nullptr)
    {
      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::Inheritance,
        builder.Format.SpaceStyleInheritanceColon,
        builder.Format.SpaceStyleGlobalDefaultColon
      );

      builder.Write(node->Inheritance->ToString());
    }

    builder.BeginScope(ScopeType::Enumeration);

    // Walk all the values defined in the enum (in order)
    for (size_t i = 0; i < node->Values.size(); ++i)
    {
      EnumValueNode* enumValueNode = node->Values[i];
      this->Walker.Walk(this, enumValueNode, context);
      // HACK, need a style for 'trailing comma'
      builder.WriteKeywordOrSymbol(Grammar::ArgumentSeparator);
    }

    builder.EndScope();
  }

  //***************************************************************************
  void CodeFormatter::FormatEnumValue(EnumValueNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.WriteLineIndented();
    
    builder.Write(node->Name);
    if (node->Value != nullptr)
    {
      // HACK, needs space style
      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::Assignment,
        SpaceStyle::UseGlobalDefault,
        SpaceStyle::BeforeAndAfter
      );
      builder.Write(node->Value->Token);
    }
  }

  //***************************************************************************
  // NodeType is a GenericFunctionNode
  template <typename NodeType, typename FunctionType>
  void CodeFormatter::FormatGenericFunctionHelper(NodeType* node, CodeFormatterContext* context, FunctionType emitPostArgs)
  {
    ZilchCodeBuilder& builder = context->Builder;

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbol(Grammar::BeginFunctionParameters);

    for (size_t i = 0; i < node->Parameters.size(); ++i)
    {
      ParameterNode* parameter = node->Parameters[i];

      builder.Write(parameter->Name);

      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::TypeSpecifier,
        builder.Format.SpaceStyleTypeColon,
        builder.Format.SpaceStyleGlobalDefaultColon
      );

      builder.Write(parameter->ResultSyntaxType->ToString());

      bool isNotLast = (i != (node->Parameters.size() - 1));
      if (isNotLast)
      {
        builder.WriteKeywordOrSymbolSpaceStyle
        (
          Grammar::ArgumentSeparator,
          builder.Format.SpaceStyleFunctionDefinitionParameterComma,
          builder.Format.SpaceStyleGlobalDefaultComma
        );
      }
    }

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbol(Grammar::EndFunctionParameters);

    emitPostArgs(node, builder);

    builder.BeginScope(ScopeType::Function);

    for (size_t i = 0; i < node->Statements.size(); ++i)
    {
      StatementNode* statement = node->Statements[i];
      context->Walker->Walk(this, statement, context);
    }

    builder.EndScope();
  }
  
  //***************************************************************************
  void FormatFunctionPostArgs(FunctionNode* node, ZilchCodeBuilder& builder)
  {
    if (node->ReturnType != nullptr)
    {
      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::TypeSpecifier,
        builder.Format.SpaceStyleTypeColon,
        builder.Format.SpaceStyleGlobalDefaultColon
      );

      builder.Write(node->ReturnType->ToString());
    }
  }

  //***************************************************************************
  void CodeFormatter::FormatFunction(FunctionNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    
    this->FormatAttributes(node->Attributes, builder);

    builder.WriteLineIndented();

    builder.WriteKeywordOrSymbol(Grammar::Function);

    builder.WriteSpace();
    builder.Write(node->Name);
    
    this->FormatGenericFunctionHelper(node, context, FormatFunctionPostArgs);
  }

  //***************************************************************************
  void FormatConstructorPostArgs(ConstructorNode* node, ZilchCodeBuilder& builder)
  {
  }

  //***************************************************************************
  void CodeFormatter::FormatConstructor(ConstructorNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    
    this->FormatAttributes(node->Attributes, builder);

    builder.WriteLineIndented();

    builder.WriteKeywordOrSymbol(Grammar::Constructor);
    
    this->FormatGenericFunctionHelper(node, context, FormatConstructorPostArgs);
  }

  //***************************************************************************
  void CodeFormatter::FormatSendsEvent(SendsEventNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    
    builder.WriteLineIndented();
    builder.WriteKeywordOrSymbol(Grammar::Sends);
    builder.WriteSpace();
    builder.Write(node->Name->Token);
    builder.WriteKeywordOrSymbolSpaceStyle
    (
      Grammar::TypeSpecifier,
      builder.Format.SpaceStyleNamedArgumentColon,
      builder.Format.SpaceStyleGlobalDefaultColon
    );
    builder.Write(node->EventType->ToString());
    builder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
  }

  //***************************************************************************
  void FormatDestructorPostArgs(DestructorNode* node, ZilchCodeBuilder& builder)
  {
  }

  //***************************************************************************
  void CodeFormatter::FormatDestructor(DestructorNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    this->FormatAttributes(node->Attributes, builder);

    builder.WriteLineIndented();
    builder.WriteKeywordOrSymbol(Grammar::Destructor);
    
    this->FormatGenericFunctionHelper(node, context, FormatDestructorPostArgs);
  }

  //***************************************************************************
  void CodeFormatter::FormatFunctionCall(FunctionCallNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    context->Walker->Walk(this, node->LeftOperand, context);

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbol(Grammar::BeginFunctionCall);

    for (size_t i = 0; i < node->Arguments.size(); ++i)
    {
      ExpressionNode* expression = node->Arguments[i];

      if (node->ArgumentNames.empty() == false)
      {
        String& name = node->ArgumentNames[i];
        builder.Write(name);

        builder.WriteKeywordOrSymbolSpaceStyle
        (
          Grammar::TypeSpecifier,
          builder.Format.SpaceStyleNamedArgumentColon,
          builder.Format.SpaceStyleGlobalDefaultColon
        );
      }
      
      context->Walker->Walk(this, expression, context);

      bool isNotLast = (i != (node->Arguments.size() - 1));
      if (isNotLast)
      {
        builder.WriteKeywordOrSymbolSpaceStyle
        (
          Grammar::ArgumentSeparator,
          builder.Format.SpaceStyleFunctionCallParameterComma,
          builder.Format.SpaceStyleGlobalDefaultComma
        );
      }
    }

    // HACK, this needs a space style!
    builder.WriteKeywordOrSymbol(Grammar::EndFunctionCall);
  }

  //***************************************************************************
  void CodeFormatter::FormatMemberAccess(MemberAccessNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    context->Walker->Walk(this, node->LeftOperand, context);
    builder.WriteKeywordOrSymbol(node->Operator);
    builder.Write(node->Name);
  }

  //***************************************************************************
  void CodeFormatter::FormatMemberVariable(MemberVariableNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    this->FormatAttributes(node->Attributes, builder);
    
    builder.WriteLineIndented();
    builder.WriteKeywordOrSymbol(Grammar::Variable);
    builder.WriteSpace();
    builder.Write(node->Name);

    if (node->IsInferred() == false)
    {
      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::TypeSpecifier,
        builder.Format.SpaceStyleTypeColon,
        builder.Format.SpaceStyleGlobalDefaultColon
      );
      builder.Write(node->ResultSyntaxType->ToString());
    }

    if (node->IsProperty)
    {
      builder.BeginScope(ScopeType::Property);

      // Note: We don't actually want to walk the function nodes,
      // because they will emit function signatures, instead we just walk their statements
      // We also don't want to use 'GenericWalkChildren' because that will walk parameters

      if (node->Get != nullptr)
      {
        builder.WriteLineIndented();
        builder.WriteKeywordOrSymbol(Grammar::Get);
        builder.BeginScope(ScopeType::GetSet);
        context->Walker->Walk(this, node->Get->Statements, context);
        builder.EndScope();
      }
      
      if (node->Set != nullptr)
      {
        builder.WriteLineIndented();
        builder.WriteKeywordOrSymbol(Grammar::Set);
        builder.BeginScope(ScopeType::GetSet);
        context->Walker->Walk(this, node->Set->Statements, context);
        builder.EndScope();
      }
      
      builder.EndScope();
    }
    else if (node->InitialValue != nullptr)
    {
      // HACK, this needs a space style! 
      // PROBABLY BINARY OPERATOR SPACE STYLE
      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::Assignment,
        SpaceStyle::UseGlobalDefault,
        SpaceStyle::BeforeAndAfter
      );
      context->Walker->Walk(this, node->InitialValue, context);
      builder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
    }
  }

  //***************************************************************************
  void CodeFormatter::FormatParameter(ParameterNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    builder.Write(node->Name);
    builder.WriteKeywordOrSymbolSpaceStyle
    (
      Grammar::TypeSpecifier,
      builder.Format.SpaceStyleTypeColon,
      builder.Format.SpaceStyleGlobalDefaultColon
    );
    builder.Write(node->ResultSyntaxType->ToString());
  }

  //***************************************************************************
  void CodeFormatter::FormatLocalVariable(LocalVariableNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;
    this->FormatAttributes(node->Attributes, builder);

    builder.WriteKeywordOrSymbol(Grammar::Variable);
    builder.WriteSpace();
    builder.Write(node->Name);

    if (node->IsInferred() == false)
    {
      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::TypeSpecifier,
        builder.Format.SpaceStyleTypeColon,
        builder.Format.SpaceStyleGlobalDefaultColon
      );
      builder.Write(node->ResultSyntaxType->ToString());
    }

    // Some variable nodes don't have initial values, or defaults
    if (node->InitialValue != nullptr)
    {
      // HACK, this needs a space style! 
      // PROBABLY BINARY OPERATOR SPACE STYLE
      builder.WriteKeywordOrSymbolSpaceStyle
      (
        Grammar::Assignment,
        SpaceStyle::UseGlobalDefault,
        SpaceStyle::BeforeAndAfter
      );
      context->Walker->Walk(this, node->InitialValue, context);
    }
  }

  //***************************************************************************
  void CodeFormatter::FormatStaticTypeNode(StaticTypeNode*& node, CodeFormatterContext* context)
  {
    ZilchCodeBuilder& builder = context->Builder;

    // If it's inferred, we don't bother writing anything
    if (node->Mode == CreationMode::New)
    {
      builder.WriteKeywordOrSymbol(Grammar::New);
      builder.WriteSpace();
    }
    else if (node->Mode == CreationMode::Local)
    {
      builder.WriteKeywordOrSymbol(Grammar::Local);
      builder.WriteSpace();
    }

    builder.Write(node->ReferencedSyntaxType->ToString());
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes








namespace Zilch
{
  //***************************************************************************
  ZilchDefineType(Function, "Function", Core, builder, type)
  {
  }

  //***************************************************************************
  NativeVirtualInfo::NativeVirtualInfo() :
    Index(NonVirtual),
    Thunk(nullptr),
    Guid(InvalidGuid)
  {
  }

  //***************************************************************************
  bool NativeVirtualInfo::Validate()
  {
    // Error checking for the native virtual calls
    ReturnIf
    (
      (this->Index == NonVirtual && this->Thunk != nullptr) ||
      (this->Index != NonVirtual && this->Thunk == nullptr),
      false,
      "You must provide both the virtual index and thunk, or neither"
    );

    // Error check the guid
    ReturnIf
    (
      this->Index != NonVirtual && this->Guid == InvalidGuid,
      false,
      "The guid provided was not valid"
    );

    // Otherwise, we validated
    return true;
  }

  //***************************************************************************
  Function::Function() :
    BoundFunction(nullptr),
    NativeConstructor(nullptr),
    FunctionType(nullptr),
    RequiredStackSpace(0),
    This(nullptr),
    SourceLibrary(nullptr),
    UserData(nullptr),
    IsPropertyGetOrSet(false),
    IsVirtual(false)
  {
  }
  
  //***************************************************************************
  Type* Function::GetTypeOrNull()
  {
    return this->FunctionType;
  }

  //***************************************************************************
  GuidType Function::Hash() const
  {
    // Store the resulting hash
    GuidType result = 0;

    // If this function has a this pointer
    if (this->This != nullptr)
    {
      // Take the hash of the 'this' type, and hash it with the delegate type hash
      result = this->This->ResultType->Hash();
    }

    // Add in the delegate type hash
    result ^= this->FunctionType->Hash() * 27697;

    // Add in the hash of the function name
    result ^= this->Name.hash() * 13;

    // Hash the owner and add that in
    result ^= this->Owner->Hash() * 4738837;

    // Return the resulting hash
    return result;
  }

  //***************************************************************************
  String Function::ToString() const
  {
    // The string we build for a function is the name of the class, then the name of the function
    // and then the entire signature, ex: Animal.Attack(damage : Integer) : String
    StringBuilder builder;

    // This should NEVER be null, but we have a case where we're getting a crash
    // For now, we're going to skip writing the name and access symbol, but we'll put an assert in to try and catch it
    if (this->Owner != nullptr)
    {
      builder.Append(this->Owner->Name);
      builder.Append(Grammar::GetKeywordOrSymbol(Grammar::Access));
    }
    else
    {
      Error("The Owner should not be null inside the Function");
    }

    builder.Append(this->Name);
    this->FunctionType->BuildSignatureString(builder);
    return builder.ToString();
  }

  //***************************************************************************
  CodeLocation* Function::GetCodeLocationFromProgramCounter(size_t programCounter)
  {
    // We don't know the location of native and non-active program counters
    if (programCounter == ProgramCounterNative || programCounter == ProgramCounterNotActive)
      return nullptr;

    // Now get the code location for the given opcode inside the function
    CodeLocation* codeLocation = this->OpcodeLocationToCodeLocation.findPointer(programCounter);
    if (codeLocation == nullptr)
      return nullptr;

    // Return the code location we found
    return codeLocation;
  }

  //***************************************************************************
  Opcode& Function::AllocateArgumentFreeOpcode(Instruction::Enum instruction, DebugOrigin::Enum debugOrigin, const CodeLocation& debugLocation)
  {
    return AllocateOpcode<Opcode>(instruction, debugOrigin, debugLocation);
  }

  //***************************************************************************
  OperandIndex Function::AllocateRegister(size_t size)
  {
    // Get the last index of the registers array
    size_t index = this->RequiredStackSpace;

    // Allocate the spot in the registers
    this->RequiredStackSpace += AlignToBusWidth(size);

    // Return the index
    return (OperandIndex)index;
  }

  //***************************************************************************
  size_t Function::GetCurrentOpcodeIndex()
  {
    return this->OpcodeBuilder.RelativeSize();
  }
}/**************************************************************\
* Author: Trevor Sundberg
\**************************************************************/

// Includes



namespace Zilch
{
  // The symbols or keywords we use, if available for given grammar symbols
  static String KeywordsOrSymbols[] = 
  {
    "Invalid",
    "End",
    "Error",
    "Whitespace",
    "UpperIdentifier",
    "LowerIdentifier",
    "IntegerLiteral",
    "DoubleIntegerLiteral",
    "RealLiteral",
    "DoubleRealLiteral",
    "CharacterLiteral",
    "StringLiteral",
    "BeginStringInterpolate",
    "EndStringInterpolate",
    "EndBeginStringInterpolate",
    "abstract",
    "alias",
    "alignof",
    "assert",
    "auto",
    "case",
    "catch",
    "checked",
    "const",
    "default",
    "dynamic",
    "explicit",
    "export",
    "extern",
    "finally",
    "fixed",
    "friend",
    "global",
    "goto",
    "immutable",
    "implicit",
    "import",
    "in",
    "include",
    "inline",
    "interface",
    "internal",
    "is",
    "local",
    "lock",
    "module",
    "mutable",
    "namespace",
    "operator",
    "out",
    "override",
    "package",
    "params",
    "partial",
    "positional",
    "private",
    "protected",
    "public",
    "readonly",
    "register",
    "require",
    "scope",
    "sealed",
    "signed",
    "sizeof",
    "stackalloc",
    "static",
    "switch",
    "timeout",
    "try",
    "typedef",
    "typename",
    "unchecked",
    "unsafe",
    "unsigned",
    "using",
    "virtual",
    "volatile",
    "where",
    "yield",
    "any",
    "and",
    "as",
    "base",
    "break",
    "class",
    "constructor",
    "continue",
    "debug",
    "delegate",
    "delete",
    "destructor",
    "do",
    "else",
    "enum",
    "false",
    "flags",
    "for",
    "foreach",
    "function",
    "get",
    "if",
    "loop",
    "new",
    "not",
    "null",
    "or",
    "ref",
    "return",
    "sends",
    "set",
    "struct",
    "throw",
    "true",
    "typeid",
    "typeof",
    "var",
    "while",
    ".",
    "->",
    "~>",
    ":",
    ",",
    "=>",
    "=",
    "-=",
    "+=",
    "/=",
    "*=",
    "%=",
    "^=",
    "<<=",
    ">>=",
    "$=",
    "|=",
    "&=",
    "==",
    "!=",
    "<",
    "<=",
    ">",
    ">=",
    "-",
    "+",
    "/",
    "*",
    "%",
    "^",
    "--",
    "++",
    "<<",
    ">>",
    "$",
    "|",
    "&",
    "~",
    "@",
    "||",
    "&&",
    "!",
    ";",
    "[",
    "]",
    "(",
    ")",
    "{",
    "}",
    "//",
    "/*",
    "*/",
  };

  // The human readable names we give to every symbol
  static String Names[] = 
  {
    "Invalid",
    "End",
    "Error",
    "Whitespace",
    "UpperIdentifier",
    "LowerIdentifier",
    "IntegerLiteral",
    "DoubleIntegerLiteral",
    "RealLiteral",
    "DoubleRealLiteral",
    "CharacterLiteral",
    "StringLiteral",
    "BeginStringInterpolate",
    "EndStringInterpolate",
    "EndBeginStringInterpolate",
    "Abstract",
    "Alias",
    "Alignof",
    "Assert",
    "Auto",
    "Case",
    "Catch",
    "Checked",
    "Const",
    "Default",
    "Dynamic",
    "Explicit",
    "Export",
    "Extern",
    "Finally",
    "Fixed",
    "Friend",
    "Global",
    "Goto",
    "Immutable",
    "Implicit",
    "Import",
    "In",
    "Include",
    "Inline",
    "Interface",
    "Internal",
    "Is",
    "Local",
    "Lock",
    "Module",
    "Mutable",
    "Namespace",
    "Operator",
    "Out",
    "Override",
    "Package",
    "Params",
    "Partial",
    "Positional",
    "Private",
    "Protected",
    "Public",
    "Readonly",
    "Register",
    "Require",
    "Scope",
    "Sealed",
    "Signed",
    "Sizeof",
    "Stackalloc",
    "Static",
    "Switch",
    "Timeout",
    "Try",
    "Typedef",
    "Typename",
    "Unchecked",
    "Unsafe",
    "Unsigned",
    "Using",
    "Virtual",
    "Volatile",
    "Where",
    "Yield",
    "Any",
    "And",
    "As",
    "Base",
    "Break",
    "Class",
    "Constructor",
    "Continue",
    "Debug",
    "Delegate",
    "Delete",
    "Destructor",
    "Do",
    "Else",
    "Enumeration",
    "False",
    "Flags",
    "For",
    "ForEach",
    "Function",
    "Get",
    "If",
    "Loop",
    "New",
    "Not",
    "Null",
    "Or",
    "Ref",
    "Return",
    "Sends",
    "Set",
    "Struct",
    "Throw",
    "True",
    "Typeid",
    "Typeof",
    "Variable",
    "While",
    "Access",
    "DynamicAccess",
    "NonVirtualAccess",
    "TypeSpecifier / NameSpecifier / Inheritance / InitializerList",
    "ArgumentSeparator",
    "RefersTo",
    "Assignment",
    "AssignmentSubtract",
    "AssignmentAdd",
    "AssignmentDivide",
    "AssignmentMultiply",
    "AssignmentModulo",
    "AssignmentExponent",
    "AssignmentLeftShift",
    "AssignmentRightShift",
    "AssignmentBitwiseXor",
    "AssignmentBitwiseOr",
    "AssignmentBitwiseAnd",
    "Equality",
    "Inequality",
    "LessThan",
    "LessThanOrEqualTo",
    "GreaterThan",
    "GreaterThanOrEqualTo",
    "Negative / Subtract",
    "Positive / Add",
    "Divide",
    "Multiply",
    "Modulo",
    "Exponent",
    "Decrement",
    "Increment",
    "BitshiftLeft",
    "BitshiftRight",
    "BitwiseXor",
    "BitwiseOr",
    "BitwiseAnd",
    "BitwiseNot",
    "PropertyDelegate",
    "LogicalOr",
    "LogicalAnd",
    "LogicalNot",
    "StatementSeparator",
    "BeginIndex / BeginTemplate / BeginAttribute / OldBeginInitializer",
    "EndIndex / EndTemplate / EndAttribute / OldEndInitializer",
    "BeginFunctionCall / BeginFunctionParameters / BeginGroup",
    "EndFunctionCall / EndFunctionParameters / EndGroup",
    "BeginScope / BeginInitializer",
    "EndScope / EndInitializer",
    "CommentLine",
    "CommentStart",
    "CommentEnd",
  };

  //***************************************************************************
  const String& Grammar::GetName(Grammar::Enum value)
  {
    // We add one because of the 'Invalid' index
    return Names[value + 1];
  }

  //***************************************************************************
  const String& Grammar::GetKeywordOrSymbol(Grammar::Enum value)
  {
    // We add one because of the 'Invalid' index
    return KeywordsOrSymbols[value + 1];
  }

  //***************************************************************************
  const Array<String>& Grammar::GetUsedKeywords()
  {
    static Array<String> results;
    if (results.empty())
    {
      results.push_back("any");
      results.push_back("and");
      results.push_back("as");
      results.push_back("base");
      results.push_back("break");
      results.push_back("class");
      results.push_back("constructor");
      results.push_back("continue");
      results.push_back("debug");
      results.push_back("delegate");
      results.push_back("delete");
      results.push_back("destructor");
      results.push_back("do");
      results.push_back("else");
      results.push_back("enum");
      results.push_back("false");
      results.push_back("flags");
      results.push_back("for");
      results.push_back("foreach");
      results.push_back("function");
      results.push_back("get");
      results.push_back("if");
      results.push_back("loop");
      results.push_back("new");
      results.push_back("not");
      results.push_back("null");
      results.push_back("or");
      results.push_back("ref");
      results.push_back("return");
      results.push_back("sends");
      results.push_back("set");
      results.push_back("struct");
      results.push_back("throw");
      results.push_back("true");
      results.push_back("typeid");
      results.push_back("typeof");
      results.push_back("var");
      results.push_back("while");
    }
    return results;
  }

  //***************************************************************************
  const Array<String>& Grammar::GetSpecialKeywords()
  {
    static Array<String> results;
    if (results.empty())
    {
      results.push_back("this");
      results.push_back("value");
      results.push_back("event");
    }
    return results;
  }

  //***************************************************************************
  const Array<String>& Grammar::GetReservedKeywords()
  {
    static Array<String> results;
    if (results.empty())
    {
      results.push_back("abstract");
      results.push_back("alias");
      results.push_back("alignof");
      results.push_back("assert");
      results.push_back("auto");
      results.push_back("case");
      results.push_back("catch");
      results.push_back("checked");
      results.push_back("const");
      results.push_back("default");
      results.push_back("dynamic");
      results.push_back("explicit");
      results.push_back("export");
      results.push_back("extern");
      results.push_back("finally");
      results.push_back("fixed");
      results.push_back("friend");
      results.push_back("global");
      results.push_back("goto");
      results.push_back("immutable");
      results.push_back("implicit");
      results.push_back("import");
      results.push_back("in");
      results.push_back("include");
      results.push_back("inline");
      results.push_back("interface");
      results.push_back("internal");
      results.push_back("is");
      results.push_back("local");
      results.push_back("lock");
      results.push_back("module");
      results.push_back("mutable");
      results.push_back("namespace");
      results.push_back("operator");
      results.push_back("out");
      results.push_back("override");
      results.push_back("package");
      results.push_back("params");
      results.push_back("partial");
      results.push_back("positional");
      results.push_back("private");
      results.push_back("protected");
      results.push_back("public");
      results.push_back("readonly");
      results.push_back("register");
      results.push_back("require");
      results.push_back("scope");
      results.push_back("sealed");
      results.push_back("signed");
      results.push_back("sizeof");
      results.push_back("stackalloc");
      results.push_back("static");
      results.push_back("switch");
      results.push_back("timeout");
      results.push_back("try");
      results.push_back("typedef");
      results.push_back("typename");
      results.push_back("unchecked");
      results.push_back("unsafe");
      results.push_back("unsigned");
      results.push_back("using");
      results.push_back("virtual");
      results.push_back("volatile");
      results.push_back("where");
      results.push_back("yield");
    }
    return results;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes







namespace Zilch
{

  //***************************************************************************
#ifdef ZILCH_HANDLE_DEBUG
    // Statics implemented for debugging
    Handle* Handle::DebugHead = nullptr;
    Handle* Handle::DebugTail = nullptr;
#endif

  //***************************************************************************
  Handle::Handle()
  {
    ZilchErrorIfNotStarted(Handle);

    // Clear out the handle object to a null handle
    this->Clear();

#ifdef ZILCH_HANDLE_DEBUG
    // Link ourselves to the global list of handles
    this->DebugLink();
#endif
  }

  //***************************************************************************
  Handle::Handle(const Handle& rhs) :
    Type(rhs.Type),
    Manager(rhs.Manager),
    Offset(rhs.Offset),
    Flags(rhs.Flags)
  {
    // The data of a handle type is always memory-copyable
    memcpy(this->Data, rhs.Data, sizeof(this->Data));
    
#ifdef ZILCH_HANDLE_DEBUG
    // Link ourselves to the global list of handles
    this->DebugLink();
#endif

    // Increment the reference count since we're now referencing the same thing
    this->AddReference();
  }

  //***************************************************************************
  Handle::Handle(ExecutableState* state, BoundType* type, const byte* data) :
    Type(type),
    Offset(0),
    Flags(HandleFlags::None)
  {
    // Grab the handle manager for this type
    HandleManager* manager = state->GetHandleManager(type->HandleManager);
    this->Manager = manager;

    // Zero out the data (this is a gaurantee we make before we ask the manager to initialize the data)
    memset(this->Data, 0, sizeof(this->Data));

    // Construct this handle from the manager
    manager->ObjectToHandle(data, *this);
  }

  //***************************************************************************
  Handle::~Handle()
  {
#ifdef ZILCH_HANDLE_DEBUG
    // Unlink ourselves from the global list of handles
    this->DebugUnlink();
#endif

    // Decrement the reference count for ourselves
    this->ReleaseReference();

#ifdef ZILCH_HANDLE_DEBUG
    // We cannot clear 'Type' because it actually needs to be auto-destructed
    memset(&this->Manager, 0xCD, sizeof(this->Manager));
    memset(&this->Offset, 0xCD, sizeof(this->Offset));
    memset(&this->Data, 0xCD, sizeof(this->Data));
    memset(&this->Flags, 0xCD, sizeof(this->Flags));
#endif
  }


#ifdef ZILCH_HANDLE_DEBUG
  //***************************************************************************
  void Handle::ValidateAllHandles()
  {
    // Loop forwards through the list and validate each handle
    {
      HashSet<Handle*> visited;

      Handle* value = DebugHead;
      Handle* lastHandle = nullptr;
      while (value != nullptr)
      {
        ErrorIf(visited.contains(value),
          "Attempted to visit a link twice");
        visited.insert(value);
        value->Validate();
        lastHandle = value;
        value = value->DebugNext;
      }
    }

    // Loop backwards through the list and validate each handle
    {
      HashSet<Handle*> visited;

      Handle* value = DebugTail;
      Handle* lastHandle = nullptr;
      while (value != nullptr)
      {
        ErrorIf(visited.contains(value),
          "Attempted to visit a link twice");
        visited.insert(value);
        value->Validate();
        lastHandle = value;
        value = value->DebugPrev;
      }
    }
  }

  //***************************************************************************
  void Handle::Validate() const
  {
    // Verify the next and prev values
    ErrorIf(this->DebugNext == nullptr && this->DebugPrev == nullptr && DebugHead != this,
      "A handle was possibly mem-cleared");
    ErrorIf(this->DebugNext != nullptr && this->DebugNext == this->DebugPrev,
      "Possibly corrupted handle");
    ErrorIf(this->DebugNext == (Handle*)0xCDCDCDCD || this->DebugPrev == (Handle*)0xCDCDCDCD,
      "Possibly corrupted handle");

    // Make sure the offset size is ok
    ErrorIf(this->Offset > 0x7777,
      "Possibly corrupted handle based on the large offset size");

    // Clear all flags and see if any other bits were set
    ErrorIf((this->Flags & ~(HandleFlags::NoReferenceCounting | HandleFlags::InitializedByConstructor)) != 0,
      "Possibly corrupted handle (bits set even when we cleared all flags)");
    
    // See if we have a manager
    if (this->Manager)
    {
      // Verify that we can access the manager
      ErrorIf(this->Manager->GetName().empty(),
        "Possibly corrupted handle (could not get the handle manager name)");

      // Attempt to derefence the handle, see what happens
      this->Manager->HandleToObject(*this);
    }

    // See if we have a type...
    if (this->Type)
    {
      // Check that we can get the type name
      ErrorIf(this->Type->ToString().empty(),
        "Possibly corrupted handle (could not get the type name)");
    }

    // Make sure we either have no type and no manager, or a type and a manager
    //ErrorIf((this->Manager != nullptr) != (this->Type != nullptr),
    //  "Possibly corrupted handle (manager or type incosistently set)");
  }

  //***************************************************************************
  void Handle::DebugLink()
  {
    this->Flags |= HandleFlags::InitializedByConstructor;
    this->DebugNext = nullptr;

    if (DebugTail)
    {
      ErrorIf(DebugTail->DebugNext != nullptr);

      DebugTail->DebugNext = this;
      this->DebugPrev = DebugTail;
      DebugTail = this;
    }
    else
    {
      ErrorIf(DebugHead != nullptr);

      DebugHead = this;
      DebugTail = this;
      this->DebugPrev = nullptr;
    }
  }

  //***************************************************************************
  void Handle::DebugUnlink()
  {
    // We only want to unlink this if it was ever linked in the first place
    if ((this->Flags & HandleFlags::InitializedByConstructor) == 0)
      return;

    // First, just attempt to validate ourselves
    this->Validate();

    // If I am the tail...
    if (this->DebugNext == nullptr)
    {
      ErrorIf(this != DebugTail);
      DebugTail = this->DebugPrev;
    }
    else
    {
      ErrorIf(this == DebugTail);
      this->DebugNext->DebugPrev = this->DebugPrev;
    }

    // If I am the head...
    if (this->DebugPrev == nullptr)
    {
      ErrorIf(this != DebugHead);
      DebugHead = this->DebugNext;
    }
    else
    {
      ErrorIf(this == DebugHead);
      this->DebugPrev->DebugNext = this->DebugNext;
    }

    this->DebugNext = (Handle*)0xCDCDCDCD;
    this->DebugPrev = (Handle*)0xCDCDCDCD;
  }

#endif

  //***************************************************************************
  Handle& Handle::operator=(const Handle& rhs)
  {
    // Check for self assignment (which we ignore)
    if (this == &rhs)
    {
      // Return ourselves for chaining
      return *this;
    }

#ifdef ZILCH_HANDLE_DEBUG
    // Unlink ourselves from the global list of handles
    this->Validate();
    rhs.Validate();
#endif

    // Decrement the reference count for ourselves
    this->ReleaseReference();

    // Copy all the members over
    this->Type = rhs.Type;
    this->Manager = rhs.Manager;
    this->Offset = rhs.Offset;
    this->Flags = rhs.Flags;
    
    // The data of a handle type is always memory-copyable
    memcpy(this->Data, rhs.Data, sizeof(this->Data));

    // Increment the reference count since we're now referencing the same thing
    this->AddReference();

    // Return ourselves for chaining
    return *this;
  }

  //***************************************************************************
  bool Handle::operator==(const Handle& rhs) const
  {
    // Check whether either handle is null
    byte* objectLhs = this->Dereference();
    byte* objectRhs = rhs.Dereference();
    bool nullLhs = (objectLhs == nullptr);
    bool nullRhs = (objectRhs == nullptr);

    ZilchTodo("There are two dereferences for comparing user handles, we should refactor this code path to make it one");

    // If both are non null, then we need to do more checking
    if (!nullLhs && !nullRhs)
    {
      // First, check that both of them use the same handle manager
      if (this->Manager != rhs.Manager)
      {
        // If they don't use the same handle manager, then at least dereference and check if the memory is the same
        return objectLhs == objectRhs;
      }

      // We can also check if the types are the same
      //if (this->Type != rhs.Type)
      //  return false;

      // We shouldn't need to check if the managers are null since both objects are non-null
      // Now ask the handle manager if these two handles / objects are equal
      return this->Manager->IsEqual(*this, rhs, objectLhs, objectRhs);
    }
    // Otherwise, if either of them is null, or both...
    else
    {
      // If they are both null, then the handles are equal
      // If the left is null but not the right, or the right is null
      // but not the left, then they are not equal
      return nullLhs && nullRhs;
    }
  }

  //***************************************************************************
  bool Handle::operator!=(const Handle& rhs) const
  {
    return !(*this == rhs);
  }
  
  //***************************************************************************
  int Handle::Hash() const
  {
    // If this handle is the null manager... (this is the trivial case of a cleared handle)
    if (this->Manager == nullptr)
    {
      // We must always return a 0 hash for null handles
      return 0;
    }

    // Otherwise let the manager handle it
    return this->Manager->Hash(*this);
  }

  //***************************************************************************
  bool Handle::IsNull() const
  {
    // Just dereference the handle and see if it's null
    return (this->Dereference() == nullptr);
  }

  //***************************************************************************
  bool Handle::IsReferenceCounted()
  {
    return !(this->Flags & HandleFlags::NoReferenceCounting);
  }

  //***************************************************************************
  void Handle::Clear()
  {
    // Clear out all our members
    this->Flags = HandleFlags::None;
    this->Type = nullptr;
    this->Manager = nullptr;
    this->Offset = 0;

    // Clear out the handle object
    memset(this->Data, 0, sizeof(this->Data));
  }

  //***************************************************************************
  byte* Handle::Dereference() const
  {
    // If this handle is the null manager... (this is the trivial case of a cleared handle)
    if (this->Manager == nullptr || this->Type == nullptr)
    {
      return nullptr;
    }

    ZilchTodo("If a handle returns null but is not the 'null handle manager' then it should be an optimization to Clear it");

    // Dereference the handle and get a pointer to the object (or nullptr if it's a null handle)
    return this->Manager->HandleToObject(*this) + this->Offset;
  }

  //***************************************************************************
  void Handle::AddReference()
  {
    // Increment the reference count since we're now referencing the same thing
    // We need to check for null because we do not want to randomly increment reference counts of invalid handles
    if (this->Manager && this->IsReferenceCounted() && this->IsNull() == false)
    {
      // Add a reference via the manager
      this->Manager->AddReference(*this);
    }
  }

  //***************************************************************************
  void Handle::ReleaseReference()
  {
    // If the handle has a manager...
    if (this->Manager && this->IsReferenceCounted())
    {
      // We could put this responsibility upon the managers themselves, however,
      // we should never call release on a handle to an object that may have been deleted
      // For example, new an object in Zilch, then create a temporary handle, and delete the original
      // The temporary handle will get ref counted up, and after the scope ends down again
      // The ref count down should NOT be applied to then manager since the object was deleted
      if (this->IsNull() == false)
      {
        // Ask the manager to release the reference
        ReleaseResult::Enum result = this->Manager->ReleaseReference(*this);

        // If we're supposed to delete the object...
        if (result == ReleaseResult::DeleteObject)
        {
          // Invoke the destructor and ask the manager to delete the memory
          this->DestructAndDelete();
        }
      }
    }
  }

  //***************************************************************************
  void Handle::DestructAndDelete()
  {
    // Mark the stack copy of the handle as not being reference counted
    // That way, when it runs the destructor it won't attempt to increment the reference count again
    this->Flags |= HandleFlags::NoReferenceCounting;

    // Make sure this only gets called from places where we know we have a manager
    HandleManager* manager = this->Manager;
    ErrorIf(manager == nullptr,
      "This should only get called from non-null handles");

    // Grab the state from the manager (this could be null!)
    ExecutableState* state = manager->State;

    // Get a pointer to our own object's data
    byte* self = this->Dereference();

    // Error checking
    ErrorIf(self == nullptr,
      "Somehow we're attempting to delete a null object!");

    // If the state is valid (this is not a shared handle...)
    if (state != nullptr)
    {
      // Don't allow any sort of allocation while we are destructing objects
      ++state->DoNotAllowAllocation;

      // Store the type 
      BoundType* type = this->Type;

      // See if we've patched this type with another type
      type = state->PatchedBoundTypes.findValue(type, type);

      // While we haven't reached the root class
      while (type != nullptr)
      {
        // Invoke the destructor
        if (type->Destructor != nullptr)
        {
          // Only invoke the destructor if its is not native, or it is native and fully constructed
          if (type->Native == false || manager->GetNativeTypeFullyConstructed(*this))
          {
            // We currently execute the destructor and basically ignore any exceptions
            // They still get reported, but will be caught here
            ExceptionReport report;
            Call call(type->Destructor, state);
            call.SetHandle(Call::This, *this);
            call.Invoke(report);
          }
        }

        // Invoke the post-destructor
        if (type->PostDestructor != nullptr)
        {
          type->PostDestructor(type, self);
        }

        // If the type is native, don't bother traversing up any further
        if (type->Native)
          break;

        // Iterate up to the base type
        type = type->BaseType;
      }

      // We may allow allocation again (depends on if this is the last destructor on the stack)
      // Allocation is allowed again when this is 0
      --state->DoNotAllowAllocation;
    }

    // Delete this handle
    manager->Delete(*this);
  }

  //***************************************************************************
  bool Handle::Delete()
  {
    // If the handle is already null, then don't bother with it!
    // Note for below: this actually checks for 'Null' typed handles
    // Moreover, after this we can assume that the manager is valid
    if (this->IsNull())
      return true;

    // Make sure this only gets called from places where we know we have a manager
    ErrorIf(this->Manager == nullptr,
      "This should only get called from non-null handles");
    
    // If we have an offset, we cannot be deleted
    if (this->Offset != 0)
    {
      return false;
    }

    // We make a stack copy just in case this handle resides in memory that we are about to delete
    // Note: Leave this up here just in case CanDelete would return false if we made the copy
    // Note: Even though we mark THIS handle as being no longer reference counted, since this is an explicit delete
    // then OTHER handles could still be live that cause reference counts
    // We could technically turn off reference counting on the object with the manager, however, we don't need ot because
    // this stack copy will increment the reference by 1, and the call to 'this->Clear()' does NOT release the reference
    // Therefore we add a dangling reference, but we're about to delete this object so its all ok!
    Handle stackCopy(*this);

    // If we cannot delete the handle, then early out!
    if (this->Manager->CanDelete(stackCopy) == false)
    {
      return false;
    }

    // Clear this handle to a null handle (for safety)
    // This is safe to do because we're only deleting our stack copy
    // Note: See stack copy notes above for why this does NOT decrement a reference
    this->Clear();

    // Invoke the destructor on the stack copy
    stackCopy.DestructAndDelete();
    return true;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes





namespace Zilch
{
  //***************************************************************************
  HandleManagers& HandleManagers::GetInstance()
  {
    static HandleManagers instance;
    return instance;
  }

  //***************************************************************************
  HandleManagers::HandleManagers() :
    UniqueCounter(0),
    Locked(false)
  {
  }

  //***************************************************************************
  HandleManagers::~HandleManagers()
  {
    // Destroy all the shared managers
    for (size_t i = 0; i < this->Shared.size(); ++i)
    {
      // Delete all the shared entries
      delete this->Shared[i];
    }

    // Clear the shared array, as well as the creators
    this->Shared.clear();
    this->Unique.clear();
  }

  //***************************************************************************
  void HandleManagers::AddSharedManager(HandleManagerId id, HandleManager* manager)
  {
    // Error checking
    ReturnIf(this->Locked,,
      "We cannot add to the handle managers after we've created the ZilchSetup");

    this->Shared.insert(id, manager);
  }

  //***************************************************************************
  void HandleManagers::AddUniqueCreator(HandleManagerId id, CreateHandleManagerFn creator)
  {
    // Error checking
    ReturnIf(this->Locked,,
      "We cannot add to the handle managers after we've created the ZilchSetup");

    this->Unique.insert(id, creator);
  }
  
  //***************************************************************************
  HandleManager* HandleManagers::GetSharedManager(HandleManagerId id)
  {
    return this->Shared.findValue(id, nullptr);
  }

  //***************************************************************************
  CreateHandleManagerFn HandleManagers::GetUniqueCreator(HandleManagerId id)
  {
    return this->Unique.findValue(id, nullptr);
  }

  //***************************************************************************
  HandleManagerId HandleManagers::GetNextId()
  {
    // Error checking
    ReturnIf(this->Locked, (HandleManagerId)-1,
      "We cannot get new unique ids for handle managers after we've created the ZilchSetup");

    return this->UniqueCounter++;
  }

  //***************************************************************************
  void HandleManagers::Lock()
  {
    this->Locked = true;
  }

  //***************************************************************************
  HandleManager::~HandleManager()
  {
  }

  //***************************************************************************
  HandleManager::HandleManager(ExecutableState* state) :
    State(state)
  {
  }

  //***************************************************************************
  bool HandleManager::IsEqual
  (
    const Handle& handleLhs,
    const Handle& handleRhs,
    const byte* objectLhs,
    const byte* objectRhs
  )
  {
    // Compare the dereferenced handles
    return objectLhs == objectRhs;
  }

  //***************************************************************************
  void HandleManager::AddReference(const Handle& handle)
  {
  }

  //***************************************************************************
  ReleaseResult::Enum HandleManager::ReleaseReference(const Handle& handle)
  {
    return ReleaseResult::KeepAlive;
  }

  //***************************************************************************
  int HandleManager::Hash(const Handle& handle)
  {
    // Dereference the handle
    byte* pointer = this->HandleToObject(handle);

    // Return the pointer as if it were a hash (works for null to, which would return 0)
    return (int)(size_t)pointer;
  }
  
  //***************************************************************************
  void HandleManager::DeleteAll(ExecutableState* state)
  {
  }

  //***************************************************************************
  void HandleManager::Delete(const Handle& handle)
  {
  }
  
  //***************************************************************************
  bool HandleManager::CanDelete(const Handle& handle)
  {
    return false;
  }
  
  //***************************************************************************
  void HandleManager::SetNativeTypeFullyConstructed(const Handle& handle, bool value)
  {
  }

  //***************************************************************************
  bool HandleManager::GetNativeTypeFullyConstructed(const Handle& handle)
  {
    // By default we return true and assume everything worked
    // This could crash if an exception occurs and we never fully constructed the base, and then we invoke the C++ destructor
    return true;
  }

  //***************************************************************************
  HeapManager::HeapManager(ExecutableState* state) :
    HandleManager(state)
  {
    // Resize the object slots so we can hold objects
    this->Objects.resize(100000);

    // Initialize the counter to zero
    this->UidCount = 0;
    this->ObjectCount = 0;

    // The first slot will be the next free slot
    this->NextFreeSlot = this->Objects.data();

    // Loop through all the object slots
    for (size_t index = 0; index < this->Objects.size(); ++index)
    {
      // Grab a reference to the current slot
      ObjectSlot& slot = this->Objects[index];

      // Clear out the object
      slot.Data = nullptr;
      slot.UniqueId = InvalidUid;
      slot.ReferenceCount = 0;

      // If the index is at the end...
      if (index == (this->Objects.size() - 1))
      {
        // There are no more free slots
        slot.NextFreeSlot = nullptr;
      }
      else
      {
        // Set the next free slot to be one ahead
        slot.NextFreeSlot = &slot + 1;
      }
    }
  }

  //***************************************************************************
  String HeapManager::GetName()
  {
    static String Name("Heap Object");
    return Name;
  }
  
  //***************************************************************************
  byte* HeapManager::HandleToObject(const Handle& handle)
  {
    HeapHandleData& data = *(HeapHandleData*)handle.Data;

    // If the slot data has been cleared, then we're also null
    if (data.Slot == nullptr)
      return nullptr;

    // If the unique-ids for that slot don't match (it was reused)
    // then we return null since this handle is no longer valid
    if (data.UniqueId != data.Slot->UniqueId)
      return nullptr;

    // If we were pointing at a valid slot, but the data was cleared...
    if (data.Slot->Data == nullptr)
      return nullptr;

    // The data should be valid allocated memory
    // Since the beginning our memory is actually a pointer to an
    // object slot, we need to offset to get to the actual objects data
    return data.Slot->Data + sizeof(ObjectHeader);
  }
  
  //***************************************************************************
  void HeapManager::Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags)
  {
    // Set the handle to use the next free slot in the object
    ObjectSlot* slot = this->NextFreeSlot;

    // If we didn't get a slot...
    if (slot == nullptr)
    {
      // Clear out the handle and report the error
      Error("Cannot allocate the object of type %s, we ran out of slots / memory!", type->ToString().c_str());
      handleToInitialize.Manager = nullptr;
      return;
    }
    
    // Set the next free slot on the executable state
    this->NextFreeSlot = slot->NextFreeSlot;

    // Create a buffer that's the size of the object we'd like to allocate
    // At the beginning of the buffer, we put the object slot pointer so that
    // 'ObjectToHandle' can recreate a handle via the slot data pointer
    size_t objectSize = type->GetAllocatedSize();
    size_t fullSize = sizeof(ObjectHeader) + objectSize + 256;
    byte* memory = new byte[fullSize];

    // All primitives should support being zeroed out
    memset(memory, 0, fullSize);

    // Store a pointer back to the slot on the memory itself
    ObjectHeader& header = *(ObjectHeader*)memory;
    header.Slot = slot;
    header.Type = type;

    // Initialize the handle
    // We are pointing at this via the 'handle to initialize' so the reference count is 1
    slot->ReferenceCount = 1;
    slot->Flags = (HeapObjectFlags::Enum)customFlags;
    slot->NextFreeSlot = nullptr;
    slot->Data = memory;
    slot->UniqueId = this->UidCount;

    // Increment the unique ID counter
    ++this->UidCount;

    // We allocated an object, increment that too
    ++this->ObjectCount;

    // If specified, we won't do reference counting on this handle
    // This means the only way to destroy the handle is via delete
    if (customFlags & HeapObjectFlags::NonReferenceCounted)
      handleToInitialize.Flags = HandleFlags::NoReferenceCounting;

    // We are always guaranteed that the handle data is cleared before we get the user data portion
    HeapHandleData& data = *(HeapHandleData*)handleToInitialize.Data;
    data.Slot = slot;
    data.UniqueId = slot->UniqueId;
  }
  
  //***************************************************************************
  void HeapManager::ObjectToHandle(const byte* object, Handle& handleToInitialize)
  {
    // The first part of the memory is a pointer back to the object slot
    ObjectHeader& header = *(ObjectHeader*)(object - sizeof(ObjectHeader));
    ObjectSlot* slot = header.Slot;

    // If specified, we won't do reference counting on this handle
    // This means the only way to destroy the handle is via delete
    if (slot->Flags & HeapObjectFlags::NonReferenceCounted)
      handleToInitialize.Flags = HandleFlags::NoReferenceCounting;
    else
      ++slot->ReferenceCount;
    
    // We are always guaranteed that the handle data is cleared before we get the user data portion
    HeapHandleData& data = *(HeapHandleData*)handleToInitialize.Data;
    data.Slot = slot;
    data.UniqueId = slot->UniqueId;
  }
  
  //***************************************************************************
  void HeapManager::DeleteAll(ExecutableState* state)
  {
    // Note: The executable state has a special flag set to not allow allocation of any more
    // objects (and all destructors catch exceptions that occur)
    // This is so we don't need to continue cleaning up objects at the end, since we know all will be destructed

    // Theoretically all memory from a system should be cleaned up by itself
    // We really need to incorporate leak detection here
    // Leak detection includes the stack frame of who allocated it
    // as well as all those still referencing it

    // Loop through all the object slots and report leaks only (do not delete the memory yet)
    for(size_t index = 0; index < this->Objects.size(); ++index)
    {
      // Grab a reference to the current slot
      ObjectSlot* slot = &this->Objects[index];

      // If the slot is already null, skip it
      if(slot->Data == nullptr)
        continue;

      // The slot->Data actually points at the ObjectHeader (not generally the pointer everyone has access to)
      // and our 'ObjectToHandle' expects a pointer to directly to the object, so make sure to offset it!
      // See other functions such as Allocate or Dereference to understand ObjectHeader's memory layout
      byte* directObjectPointer = slot->Data + sizeof(ObjectHeader);

      // Create a temporary handle to point at the object
      ZilchTodo("Make ObjectToHandle actually fill out the Type and Manager");
      Handle handle;
      handle.Manager = this;
      handle.Type = ((ObjectHeader*)slot->Data)->Type;
      this->ObjectToHandle(directObjectPointer, handle);

      // Send out an event letting the user know that a memory leak occurred
      MemoryLeakEvent toSend;
      toSend.State = state;
      toSend.LeakedObject = &handle;
      EventSend(state, Events::MemoryLeak, &toSend);
    }

    // Loop through all the object slots
    for (size_t index = 0; index < this->Objects.size(); ++index)
    {
      // Grab a reference to the current slot
      ObjectSlot* slot = &this->Objects[index];

      // If the slot is already null, skip it
      if (slot->Data == nullptr)
        continue;
      
      // The slot->Data actually points at the ObjectHeader (not generally the pointer everyone has access to)
      // and our 'ObjectToHandle' expects a pointer to directly to the object, so make sure to offset it!
      // See other functions such as Allocate or Dereference to understand ObjectHeader's memory layout
      byte* directObjectPointer = slot->Data + sizeof(ObjectHeader);

      // Create a temporary handle to point at the object
      ZilchTodo("Make ObjectToHandle actually fill out the Type and Manager");
      Handle handle;
      handle.Manager = this;
      handle.Type = ((ObjectHeader*)slot->Data)->Type;
      this->ObjectToHandle(directObjectPointer, handle);

      // Delete the object forcibly
      bool deleted = handle.Delete();
      ErrorIf(deleted != true,
        "Delete on the handle returned that the object was not deleted (it always should be deletable)");
      ErrorIf(slot->Data != nullptr,
        "The object's memory should have been freed and nulled by this point");

      // This part should already have been done and should be entirely pointless, however
      // we put it in as an extra guard in for some reason the object could not be deleted, such
      // as if CanDelete somehow returned false
      delete[] slot->Data;
      slot->Data = nullptr;
    }
  }
  
  //***************************************************************************
  void HeapManager::Delete(const Handle& handle)
  {
    // Get the associated slot
    HeapHandleData& data = *(HeapHandleData*)handle.Data;
    ObjectSlot* slot = data.Slot;

    // Delete the data in the slot and null it out
    delete[] slot->Data;
    slot->Data = nullptr;

    // Set the next free slot on the executable state
    slot->NextFreeSlot = this->NextFreeSlot;
    this->NextFreeSlot = slot;

    // We freed an object, decrement the object count
    --this->ObjectCount;
  }

  //***************************************************************************
  bool HeapManager::CanDelete(const Handle& handle)
  {
    // Currently we can always delete heap handles
    return true;
  }

  //***************************************************************************
  void HeapManager::AddReference(const Handle& handle)
  {
    // Get the associated slot
    HeapHandleData& data = *(HeapHandleData*)handle.Data;
    ObjectSlot* slot = data.Slot;

    ++slot->ReferenceCount;
  }

  //***************************************************************************
  ReleaseResult::Enum HeapManager::ReleaseReference(const Handle& handle)
  {
    // Get the associated slot
    HeapHandleData& data = *(HeapHandleData*)handle.Data;
    ObjectSlot* slot = data.Slot;

    --slot->ReferenceCount;

    // If the reference count reached zero, nobody else
    // knows about it so it's time to free this object!
    if (slot->ReferenceCount == 0)
    {
      // Return that the object must be deleted
      return ReleaseResult::DeleteObject;
    }
    else
    {
      // The decrementing of the reference didn't kill the object
      return ReleaseResult::KeepAlive;
    }
  }
  
  //***************************************************************************
  void HeapManager::SetNativeTypeFullyConstructed(const Handle& handle, bool value)
  {
    HeapHandleData& data = *(HeapHandleData*)handle.Data;
    ObjectSlot* slot = data.Slot;
    slot->Flags = (HeapObjectFlags::Enum)(slot->Flags | HeapObjectFlags::NativeFullyConstructed);
  }
  
  //***************************************************************************
  bool HeapManager::GetNativeTypeFullyConstructed(const Handle& handle)
  {
    HeapHandleData& data = *(HeapHandleData*)handle.Data;
    ObjectSlot* slot = data.Slot;
    return (slot->Flags & HeapObjectFlags::NativeFullyConstructed) != 0;
  }

  //***************************************************************************
  StackManager::StackManager(ExecutableState* state) :
    HandleManager(state)
  {
  }

  //***************************************************************************
  String StackManager::GetName()
  {
    static String Name("Stack Object");
    return Name;
  }
  
  //***************************************************************************
  void StackManager::Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags)
  {
    Error("Allocating an object using a the StackObjectManager is not supported");
  }
  
  //***************************************************************************
  byte* StackManager::HandleToObject(const Handle& handle)
  {
    StackHandleData& data = *(StackHandleData*)handle.Data;
    
    // If the scope we're looking at has a different id than this handle, then
    // it means the original stack/scope we looked at is gone, so the value is no longer valid
    if (data.Scope->UniqueId != data.UniqueId)
      return nullptr;

    // The stack handle must be valid
    return data.StackLocation;
  }
  
  //***************************************************************************
  void StackManager::ObjectToHandle(const byte* object, Handle& handleToInitialize)
  {
    StackHandleData& data = *(StackHandleData*)handleToInitialize.Data;
    data.StackLocation = const_cast<byte*>(object);
    Error("Use ExecutableState's InitializeStackHandle to create a handle to an object on the stack");
  }
  
  //***************************************************************************
  PointerManager::PointerManager(ExecutableState* state) :
    HandleManager(state)
  {
  }

  //***************************************************************************
  String PointerManager::GetName()
  {
    static String Name("Global Pointer");
    return Name;
  }
  
  //***************************************************************************
  byte* PointerManager::HandleToObject(const Handle& handle)
  {
    return *(byte**)handle.Data;
  }
  
  //***************************************************************************
  void PointerManager::Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags)
  {
    Error("Allocating an object using a the PointerManager is not supported");
  }
  
  //***************************************************************************
  void PointerManager::ObjectToHandle(const byte* object, Handle& handleToInitialize)
  {
    handleToInitialize.Flags |= HandleFlags::NoReferenceCounting;
    *((const void**)handleToInitialize.Data) = object;
  }

  //***************************************************************************
  StringManager::StringManager(ExecutableState* state) :
    HandleManager(state)
  {
  }

  //***************************************************************************
  String StringManager::GetName()
  {
    static String Name("String");
    return Name;
  }
  
  //***************************************************************************
  byte* StringManager::HandleToObject(const Handle& handle)
  {
    // Interpret the user data as if it was the 'String' type
    return (byte*)(String*)handle.Data;
  }

  //***************************************************************************
  int StringManager::Hash(const Handle& handle)
  {
    // Every string has it's own hash value
    return (int)((String*)handle.Data)->hash();
  }
  
  //***************************************************************************
  void StringManager::Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags)
  {
    Error("Allocating an object using a the StringManager is not supported");
  }
  
  //***************************************************************************
  void StringManager::ObjectToHandle(const byte* object, Handle& handleToInitialize)
  {
    String& str = *(String*)object;
    new (handleToInitialize.Data) String(str);
  }
  
  //***************************************************************************
  bool StringManager::IsEqual
  (
    const Handle& handleLhs,
    const Handle& handleRhs,
    const byte* objectLhs,
    const byte* objectRhs
  )
  {
    // Get the two string nodes so we can compare them
    String& stringLhs = *(String*)objectLhs;
    String& stringRhs = *(String*)objectRhs;
      
    // Compare the two nodes, then compare the hash values and lengths, then directly compare the strings
    return stringLhs == stringRhs;
  }
  
  //***************************************************************************
  void StringManager::AddReference(const Handle& handle)
  {
    // Directly increment a refernece on the string node
    String& str = *(String*)handle.Data;
    String::StringNode* node = str.GetNode();
    node->addRef();
  }
  
  //***************************************************************************
  ReleaseResult::Enum StringManager::ReleaseReference(const Handle& handle)
  {
    // Directly decrement a refernece on the string node, delete it if it reaches 0
    String& str = *(String*)handle.Data;
    String::StringNode* node = str.GetNode();
    node->release();
    return ReleaseResult::Ignore;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes






namespace Zilch
{
  //***************************************************************************
  AnyHashMap::AnyHashMap() :
    ModifyId(0)
  {
  }
  
  //***************************************************************************
  void AnyHashMap::Modified()
  {
    ++this->ModifyId;
  }
  
  //***************************************************************************
  AnyHashMapRange::AnyHashMapRange() :
    ModifyId(0)
  {
  }

  //***************************************************************************
  HashMapUserData::HashMapUserData() :
    KeyType(nullptr),
    ValueType(nullptr),
    PairRangeType(nullptr),
    ValueRangeType(nullptr),
    KeyRangeType(nullptr)
  {
  }

  //***************************************************************************
  inline HashMapUserData& GetHashMapUserData(Call& call)
  {
    return call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);
  }
  
  //***************************************************************************
  inline AnyHashMap* GetHashMapThis(Call& call)
  {
    return (AnyHashMap*)call.GetHandle(Call::This).Dereference();
  }

  //***************************************************************************
  void HashMapGetOrDefault(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // The first index is always the key, read that
    byte* keyData = call.GetParameterUnchecked(0);

    // The second index is a default value that gets returned when we fail to find the key
    byte* defaultValueData = call.GetParameterUnchecked(1);

    // Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
    Any key(keyData, userData.KeyType);
    Any* value = (*self).findPointer(key);

    // Get a pointer to the return value data (on the stack)
    byte* returnValue = call.GetReturnUnchecked();
    call.DisableReturnChecks();
    
    // If we found the value, copy it to the return, otherwise copy the default to the return
    if (value != nullptr)
      value->CopyStoredValueTo(returnValue);
    else
      userData.ValueType->GenericCopyConstruct(returnValue, defaultValueData);
  }

  //***************************************************************************
  void HashMapGetOrDefaultNull(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // The first index is always the key, read that
    byte* keyData = call.GetParameterUnchecked(0);

    // Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
    Any key(keyData, userData.KeyType);
    Any* value = (*self).findPointer(key);

    // Get a pointer to the return value data (on the stack)
    byte* returnValue = call.GetReturnUnchecked();
    call.DisableReturnChecks();
    
    // If we found the value, copy it to the return, otherwise copy the default to the return
    if (value != nullptr)
      value->CopyStoredValueTo(returnValue);
    else
      userData.ValueType->GenericDefaultConstruct(returnValue);
  }

  //***************************************************************************
  void HashMapGetOrError(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // The first index is always the key, read that
    byte* keyData = call.GetParameterUnchecked(0);

    // Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
    Any key(keyData, userData.KeyType);

    Any* value = (*self).findPointer(key);

    if (value == nullptr)
    {
      call.GetState()->ThrowException(report, String::Format("The key '%s' was not found within the map", key.ToString().c_str()));
      return;
    }

    // Get a pointer to the return value data (on the stack)
    byte* returnValue = call.GetReturnUnchecked();
    call.DisableReturnChecks();

    // Generically copy the contained type to the return value
    value->CopyStoredValueTo(returnValue);
  }

  //***************************************************************************
  void HashMapContains(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // The first index is always the key, read that
    byte* keyData = call.GetParameterUnchecked(0);

    // Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
    Any key(keyData, userData.KeyType);
    
    bool containsKey = self->containsKey(key);
    call.Set(Call::Return, containsKey);
  }

  //***************************************************************************
  // Returns true if it overwrote the value, false otherwise
  void HashMapSetOrOverwrite(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // Read the first parameter as the key, and the second as the value
    byte* keyData = call.GetParameterUnchecked(0);
    byte* valueData = call.GetParameterUnchecked(1);

    // Construct an 'any' for the key and value
    Any key(keyData, userData.KeyType);
    Any value(valueData, userData.ValueType);

    bool keyExisted = (self->findPointer(key) != nullptr);

    // Insert the value into the map under that key
    (*self)[key] = value;

    call.Set<Boolean>(Call::Return, keyExisted);
  }

  //***************************************************************************
  // Returns true if it set the value, false otherwise
  void HashMapSetOrIgnore(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // Read the first parameter as the key, and the second as the value
    byte* keyData = call.GetParameterUnchecked(0);
    byte* valueData = call.GetParameterUnchecked(1);

    // Construct an 'any' for the key and value
    Any key(keyData, userData.KeyType);
    Any value(valueData, userData.ValueType);
    
    bool noKeyDoInsert = (self->findPointer(key) == nullptr);

    // Insert the value into the map under that key only if one doesn't already exist
    if (noKeyDoInsert)
      (*self)[key] = value;

    call.Set<Boolean>(Call::Return, noKeyDoInsert);
  }

  //***************************************************************************
  void HashMapSetOrError(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // Read the first parameter as the key, and the second as the value
    byte* keyData = call.GetParameterUnchecked(0);
    byte* valueData = call.GetParameterUnchecked(1);

    // Construct an 'any' for the key and value
    Any key(keyData, userData.KeyType);
    Any value(valueData, userData.ValueType);
    
    // Insert the value into the map under that key only if one doesn't already exist
    if (Any* foundValue = self->findPointer(key))
    {
      String message = String::Format("The key '%s' already existed within the map with a value of '%s'", key.ToString().c_str(), foundValue->ToString().c_str());
      call.GetState()->ThrowException(report, message);
      return;
    }
    
    // Actually insert the value into the map
    (*self)[key] = value;
  }

  //***************************************************************************
  void HashMapRemoveOrError(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // The first index is always the key, read that
    byte* keyData = call.GetParameterUnchecked(0);

    // Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
    Any key(keyData, userData.KeyType);
 
    Any* value = (*self).findPointer(key);

    if (value == nullptr)
    {
      call.GetState()->ThrowException(report, String::Format("The key '%s' was not found within the map", key.ToString().c_str()));
      return;
    }

    (*self).erase(key);
  }

  //***************************************************************************
  // Returns true if the key was removed, false otherwise
  void HashMapRemoveOrIgnore(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // The first index is always the key, read that
    byte* keyData = call.GetParameterUnchecked(0);

    // Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
    Any key(keyData, userData.KeyType);
 
    Any* value = (*self).findPointer(key);

    bool foundValueToRemove = (value != nullptr);

    if (foundValueToRemove)
      (*self).erase(key);

    call.Set<Boolean>(Call::Return, foundValueToRemove);
  }

  //***************************************************************************
  void HashMapClear(Call& call, ExceptionReport& report)
  {
    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // Just clear the map, pretty simple!
    self->clear();
  }

  //***************************************************************************
  void HashMapGetCount(Call& call, ExceptionReport& report)
  {
    // Get ourselves (the hash map)
    AnyHashMap* self = GetHashMapThis(call);

    // Return the size of the hash map (how many elements are in it)
    call.Set(Call::Return, (Integer)self->size());
  }

  //***************************************************************************
  template <BoundType* HashMapUserData::*RangeMemberType>
  void HashMapAll(Call& call, ExceptionReport& report)
  {
    // Get ourselves (the hash map)
    Handle& selfHandle = call.GetHandle(Call::This);
    AnyHashMap* self = (AnyHashMap*)selfHandle.Dereference();
    
    // The user data contains information about the types used in the hash map
    HashMapUserData& userData = GetHashMapUserData(call);

    // Create the range type that we will return
    Handle rangeHandle = call.GetState()->AllocateDefaultConstructedHeapObject(userData.*RangeMemberType, report, HeapFlags::ReferenceCounted);

    // If we threw an exception, we need to early out and let the stack unroll
    if (report.HasThrownExceptions())
      return;

    // Get the range's data (should have been constructed!)
    AnyHashMapRange* range = (AnyHashMapRange*)rangeHandle.Dereference();
    range->Range = self->all();
    range->OriginalRange = range->Range;
    range->ModifyId = self->ModifyId;
    range->HashMap = selfHandle;

    // Return the handle to the array range
    call.SetHandle(Call::Return, rangeHandle);
  }

  //***************************************************************************
  BoundType* Core::InstantiateHashMap
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  )
  {
    // Error checking
    ErrorIf(templateTypes.size() != 2,
      "The HashMap template should only take two template arguments");

    // Get the key and value types for the hash map
    Type* keyType = templateTypes[0];
    Type* valueType = templateTypes[1];

    // We could have put core in our userdata, but no real need
    Core& core = Core::GetInstance();
    
    BoundType* pairRangeType = builder.InstantiateTemplate("HashMapRange", ZilchTypes(keyType, valueType), Module()).Type;
    BoundType* keyRangeType = builder.InstantiateTemplate("HashMapKeyRange", ZilchTypes(keyType), Module()).Type;
    BoundType* valueRangeType = builder.InstantiateTemplate("HashMapValueRange", ZilchTypes(valueType), Module()).Type;

    // Create the array type instance (arrays and any other containers should be reference types!)
    BoundType* containerType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(AnyHashMap));

    HashMapUserData containerUserData;
    containerUserData.KeyType = keyType;
    containerUserData.ValueType = valueType;
    containerUserData.PairRangeType = pairRangeType;
    containerUserData.KeyRangeType = keyRangeType;
    containerUserData.ValueRangeType = valueRangeType;
    containerType->ComplexUserData.WriteObject(containerUserData);

    // Bind the constructor and destructor of that type
    ZilchBindConstructor(builder, containerType, AnyHashMap, nullptr);
    ZilchBindDestructor(builder, containerType, AnyHashMap);
    
    ParameterArray keyOnlyParameters = OneParameter(keyType, "key");
    ParameterArray setParameters = TwoParameters(keyType, "key", valueType, "value");

    // Add the constructor
    builder.AddBoundFunction(containerType, "GetOrDefault", HashMapGetOrDefault, TwoParameters(keyType, "key", valueType, "defaultValue"), valueType, FunctionOptions::None);
    builder.AddBoundFunction(containerType, "GetOrDefault", HashMapGetOrDefaultNull, keyOnlyParameters, valueType, FunctionOptions::None);
    builder.AddBoundFunction(containerType, "GetOrError", HashMapGetOrError, keyOnlyParameters, valueType, FunctionOptions::None);

    builder.AddBoundFunction(containerType, "Contains", HashMapContains, keyOnlyParameters, core.BooleanType, FunctionOptions::None);

    builder.AddBoundFunction(containerType, "SetOrOverwrite", HashMapSetOrOverwrite, setParameters, core.BooleanType, FunctionOptions::None);
    builder.AddBoundFunction(containerType, "SetOrIgnore", HashMapSetOrIgnore, setParameters, core.BooleanType, FunctionOptions::None);
    builder.AddBoundFunction(containerType, "SetOrError", HashMapSetOrError, setParameters, core.VoidType, FunctionOptions::None);

    // Operator overloading
    builder.AddBoundFunction(containerType, OperatorInsert, HashMapSetOrError, setParameters, core.VoidType, FunctionOptions::None);
    builder.AddBoundFunction(containerType, OperatorGet, HashMapGetOrError, keyOnlyParameters, valueType, FunctionOptions::None);
    builder.AddBoundFunction(containerType, OperatorSet, HashMapSetOrOverwrite, setParameters, core.BooleanType, FunctionOptions::None);

    builder.AddBoundFunction(containerType, "RemoveOrError", HashMapRemoveOrError, keyOnlyParameters, core.VoidType, FunctionOptions::None);
    builder.AddBoundFunction(containerType, "RemoveOrIgnore", HashMapRemoveOrIgnore, keyOnlyParameters, core.BooleanType, FunctionOptions::None);

    builder.AddBoundFunction(containerType, "Clear", HashMapClear, ParameterArray(), core.VoidType, FunctionOptions::None);

    builder.AddBoundProperty(containerType, "Count", core.IntegerType, nullptr, HashMapGetCount, MemberOptions::None);

    builder.AddBoundProperty(containerType, "All", pairRangeType, nullptr, HashMapAll<&HashMapUserData::PairRangeType>, MemberOptions::None);
    builder.AddBoundProperty(containerType, "Keys", keyRangeType, nullptr, HashMapAll<&HashMapUserData::KeyRangeType>, MemberOptions::None);
    builder.AddBoundProperty(containerType, "Values", valueRangeType, nullptr, HashMapAll<&HashMapUserData::ValueRangeType>, MemberOptions::None);

    // Return the array type we instantiated
    return containerType;
  }
  
  //***************************************************************************
  void AnyHashMapRange::MoveNext()
  {
    ExecutableState* state = ExecutableState::CallingState;

    // If the hash map we originated from is null, then also throw an exception
    if (this->HashMap.IsNull())
    {
      state->ThrowException("The hash map this range referenced is null (or deleted) and cannot be ");
      return;
    }

    // Check if the difference (how much we've gone forward) is past the count
    if (this->IsEmpty())
    {
      // Throw an exception since the range was empty and we called MoveNext
      state->ThrowException("The range reached the end, but then an attempt was made to make it iterate forward more");
      return;
    }

    this->Range.popFront();
  }
  
  //***************************************************************************
  void AnyHashMapRange::Reset()
  {
    this->Range = this->OriginalRange;
  }
  
  //***************************************************************************
  bool AnyHashMapRange::IsEmpty()
  {
    return this->Range.empty();
  }
  
  //***************************************************************************
  bool AnyHashMapRange::IsNotEmpty()
  {
    return !this->Range.empty();
  }
  
  //***************************************************************************
  void HashMapRangeAll(Call& call, ExceptionReport& report)
  {
    call.Set(Call::Return, call.Get<Handle>(Call::This));
  }
  
  //***************************************************************************
  void HashMapRangeCurrent(Call& call, ExceptionReport& report)
  {
    // Read the element size from the current function's user-data
    ExecutableState* state = call.GetState();
    HashMapRangeMode::Enum mode = (HashMapRangeMode::Enum)(size_t)call.GetFunction()->Owner->UserData;

    // Get this object
    AnyHashMapRange* self = (AnyHashMapRange*)call.GetHandle(Call::This).Dereference();
    
    // If the hash map we originated from is null, then also throw an exception
    AnyHashMap* hashMap = (AnyHashMap*)self->HashMap.Dereference();
    if (self->HashMap.IsNull())
    {
      state->ThrowException("The hash map this range referenced is null (or deleted) and cannot be ");
      return;
    }

    // Check if the array was modified
    if (self->ModifyId != hashMap->ModifyId)
    {
      // It was modified, so throw an exception and early out
      state->ThrowException("The collection was modified and therefore the range cannot be used");
      return;
    }

    // If we've already reached the end...
    if (self->IsEmpty())
    {
      // Throw an exception since the range was empty and we called Current
      call.GetState()->ThrowException(report, "The range reached the end and an attempt was made to get the current value");
      return;
    }

    // Grab the key-value pair that we'll be returning (either part of it, or the whole thing)
    AnyKeyValue& keyValue = self->Range.front();

    // If this is a pair then we need to allocate a KeyValue pair
    switch (mode)
    {
      case HashMapRangeMode::Pair:
      {
        // Create the range type that we will return
        BoundType* keyValueType = (BoundType*)call.GetFunction()->FunctionType->Return;
        Handle keyValueHandle = call.GetState()->AllocateDefaultConstructedHeapObject(keyValueType, report, HeapFlags::ReferenceCounted);

        // If we threw an exception, we need to early out and let the stack unroll
        if (report.HasThrownExceptions())
          return;

        // Copy over the key-value pair (both Any types)
        AnyKeyValue* returnedKeyValue = (AnyKeyValue*)keyValueHandle.Dereference();
        *returnedKeyValue = keyValue;

        // Return the handle to the KeyValue
        call.SetHandle(Call::Return, keyValueHandle);
        break;
      }

      // Otherwise, we just directly return the key or value
      case HashMapRangeMode::Key:
      case HashMapRangeMode::Value:
      {
        // Get a pointer to the return value data (on the stack)
        byte* returnValue = call.GetReturnUnchecked();
        call.DisableReturnChecks();

        // Copy the value at the array to the return type (this properly deals with the Any type)
        if (mode == HashMapRangeMode::Key)
          CopyFromAnyOrActualType(keyValue.first, returnValue);
        else
          CopyFromAnyOrActualType(keyValue.second, returnValue);
        break;
      }
    }
  }

  //***************************************************************************
  BoundType* Core::InstantiateHashMapRange
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  )
  {
    BoundType* rangeType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(AnyHashMapRange));

    // The user-data will be the 'HashMapRangeMode' enumeration
    rangeType->UserData = userData;

    ZilchBindConstructor(builder, rangeType, AnyHashMapRange, nullptr);
    ZilchBindDestructor(builder, rangeType, AnyHashMapRange);

    Type* currentType = nullptr;
    if (templateTypes.size() == 2)
    {
      // Get the key and value types for the hash map
      Type* keyType = templateTypes[0];
      Type* valueType = templateTypes[1];

      // The type we return when accessing 'Current' is a KeyValue[Key, Value]
      currentType = builder.InstantiateTemplate("KeyValue", ZilchTypes(keyType, valueType), Module()).Type;
    }
    else
    {
      // The type we return when accessing 'Current' is either the key or value (whatever T was passed in)
      currentType = templateTypes[0];
    }

    ZilchBindMethod(builder, rangeType, &AnyHashMapRange::MoveNext, ZilchNoOverload, "MoveNext", ZilchNoNames);
    ZilchBindMethod(builder, rangeType, &AnyHashMapRange::Reset, ZilchNoOverload, "Reset", ZilchNoNames);
    ZilchBindProperty(builder, rangeType, &AnyHashMapRange::IsEmpty, nullptr, "IsEmpty");
    ZilchBindProperty(builder, rangeType, &AnyHashMapRange::IsNotEmpty, nullptr, "IsNotEmpty");
    builder.AddBoundProperty(rangeType, "All", rangeType, nullptr, HashMapRangeAll, MemberOptions::None);
    builder.AddBoundProperty(rangeType, "Current", currentType, nullptr, HashMapRangeCurrent, MemberOptions::None);
    return rangeType;
  }

  //***************************************************************************
  class KeyValueUserData
  {
  public:
    KeyValueUserData() :
      KeyType(nullptr),
      ValueType(nullptr)
    {
    }

    Type* KeyType;
    Type* ValueType;
  };
  
  //***************************************************************************
  void KeyValueConstructor(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

    // Get ourselves (the key-value pair)
    byte* selfData = call.GetHandle(Call::This).Dereference();

    AnyKeyValue* self = new (selfData) AnyKeyValue();

    self->first.DefaultConstruct(userData.KeyType);
    self->second.DefaultConstruct(userData.ValueType);
  }
  
  //***************************************************************************
  void KeyValueGetKey(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

    // Get ourselves (the key-value pair)
    AnyKeyValue* self = (AnyKeyValue*)call.GetHandle(Call::This).Dereference();

    // Get a pointer to the return value data (on the stack)
    byte* returnValue = call.GetReturnUnchecked();
    call.DisableReturnChecks();

    // Copy the key to the stack (in the return place)
    self->first.CopyStoredValueTo(returnValue);
  }
  
  //***************************************************************************
  void KeyValueSetKey(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

    // Get ourselves (the key-value pair)
    AnyKeyValue* self = (AnyKeyValue*)call.GetHandle(Call::This).Dereference();

    // Grab the first parameter and set our key to it
    byte* newKeyData = call.GetParameterUnchecked(0);
    self->first.AssignFrom(newKeyData, userData.KeyType);
  }
  
  //***************************************************************************
  void KeyValueGetValue(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

    // Get ourselves (the key-value pair)
    AnyKeyValue* self = (AnyKeyValue*)call.GetHandle(Call::This).Dereference();

    // Get a pointer to the return value data (on the stack)
    byte* returnValue = call.GetReturnUnchecked();
    call.DisableReturnChecks();

    // Copy the value to the stack (in the return place)
    self->second.CopyStoredValueTo(returnValue);
  }
  
  //***************************************************************************
  void KeyValueSetValue(Call& call, ExceptionReport& report)
  {
    // The user data contains information about the types used in the hash map
    KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

    // Get ourselves (the key-value pair)
    AnyKeyValue* self = (AnyKeyValue*)call.GetHandle(Call::This).Dereference();

    // Grab the first parameter and set our value to it
    byte* newValueData = call.GetParameterUnchecked(0);
    self->second.AssignFrom(newValueData, userData.ValueType);
  }

  //***************************************************************************
  BoundType* Core::InstantiateKeyValue
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  )
  {
    // Error checking
    ErrorIf(templateTypes.size() != 2,
      "The KeyValue template should only take two template arguments");

    // Get the key and value types for the hash map
    Type* keyType = templateTypes[0];
    Type* valueType = templateTypes[1];

    // Create the pair type instance
    BoundType* keyValueType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(AnyKeyValue));

    KeyValueUserData newUserData;
    newUserData.KeyType = keyType;
    newUserData.ValueType = valueType;
    keyValueType->ComplexUserData.WriteObject(newUserData);

    // Bind the constructor and destructor of that type
    builder.AddBoundDefaultConstructor(keyValueType, KeyValueConstructor);
    ZilchBindDestructor(builder, keyValueType, AnyKeyValue);

    builder.AddBoundProperty(keyValueType, "Key", keyType, KeyValueSetKey, KeyValueGetKey, MemberOptions::None);
    builder.AddBoundProperty(keyValueType, "Value", valueType, KeyValueSetValue, KeyValueGetValue, MemberOptions::None);

    return keyValueType;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes






namespace Zilch
{
  //***************************************************************************
  JsonBuilder::JsonBuilder() :
    IsMember(false),
    IsWrittenTo(false),
    IsCompactMode(false)
  {
  }

  //***************************************************************************
  JsonMember::JsonMember() :
    Value(nullptr)
  {
  }

  //***************************************************************************
  JsonMember::~JsonMember()
  {
    delete this->Value;
  }

  //***************************************************************************
  JsonValue::JsonValue() :
    Type(JsonValueType::Invalid),
    RealValue(0.0),
    IntegralValue(0)
  {
  }
    
  //***************************************************************************
  JsonValue* JsonValue::GetMember(StringParam name, JsonErrorMode::Enum errorMode)
  {
    ErrorIf(this->Type != JsonValueType::Object && errorMode == JsonErrorMode::ReportError,
      "This value was not an object type, and therefore cannot have members");

    JsonValue* value = this->Members.findValue(name, nullptr);

    ErrorIf(value == nullptr && errorMode == JsonErrorMode::ReportError,
      "Unable to find json member by the name of '%s'", name.c_str());

    return value;
  }
  
  //***************************************************************************
  JsonValue* JsonValue::IndexValue(size_t index, JsonErrorMode::Enum errorMode)
  {
    ErrorIf(this->Type != JsonValueType::Array && errorMode == JsonErrorMode::ReportError,
      "This value was not an array type, and therefore cannot be indexed");

    ReturnIf(index >= this->ArrayElements.size(), nullptr,
      "The index given was outside the range provided by the array");
    
    return this->ArrayElements[index];
  }

  //***************************************************************************
  bool JsonValue::AsBool(bool defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (this->Type == JsonValueType::True)
    {
      return true;
    }
    else if (this->Type == JsonValueType::False)
    {
      return false;
    }
    else if (errorMode == JsonErrorMode::ReportError)
    {
      Error("The json value was not a bool value");
    }

    return defaultValue;
  }

  //***************************************************************************
  String JsonValue::AsString(StringParam defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (this->Type == JsonValueType::String)
    {
      return this->StringValue;
    }
    else if (errorMode == JsonErrorMode::ReportError)
    {
      Error("The json value was not a String value");
    }

    return defaultValue;
  }

  //***************************************************************************
  double JsonValue::AsDouble(double defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (this->Type == JsonValueType::Real)
    {
      return this->RealValue;
    }
    else if (errorMode == JsonErrorMode::ReportError)
    {
      Error("The json value was not a Real value");
    }

    return defaultValue;
  }

  //***************************************************************************
  float JsonValue::AsFloat(float defaultValue, JsonErrorMode::Enum errorMode)
  {
    return (float)AsDouble(defaultValue, errorMode);
  }

  //***************************************************************************
  long long JsonValue::AsLongLong(long long defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (this->Type == JsonValueType::Integer)
    {
      return this->IntegralValue;
    }
    else if (errorMode == JsonErrorMode::ReportError)
    {
      Error("The json value was not an Integer value");
    }

    return defaultValue;
  }

  //***************************************************************************
  int JsonValue::AsInteger(int defaultValue, JsonErrorMode::Enum errorMode)
  {
    return (int)AsLongLong(defaultValue, errorMode);
  }

  //***************************************************************************
  bool JsonValue::MemberAsBool(StringParam name, bool defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = GetMember(name, errorMode))
      return value->AsBool(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  String JsonValue::MemberAsString(StringParam name, StringParam defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = GetMember(name, errorMode))
      return value->AsString(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  double JsonValue::MemberAsDouble(StringParam name, double defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = GetMember(name, errorMode))
      return value->AsDouble(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  long long JsonValue::MemberAsLongLong(StringParam name, long long defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = GetMember(name, errorMode))
      return value->AsLongLong(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  int JsonValue::MemberAsInteger(StringParam name, int defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = GetMember(name, errorMode))
      return value->AsInteger(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  float JsonValue::MemberAsFloat(StringParam name, float defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = GetMember(name, errorMode))
      return value->AsFloat(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  bool JsonValue::IndexAsBool(size_t index, bool defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = IndexValue(index, errorMode))
      return value->AsBool(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  String JsonValue::IndexAsString(size_t index, StringParam defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = IndexValue(index, errorMode))
      return value->AsString(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  double JsonValue::IndexAsDouble(size_t index, double defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = IndexValue(index, errorMode))
      return value->AsDouble(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  long long JsonValue::IndexAsLongLong(size_t index, long long defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = IndexValue(index, errorMode))
      return value->AsLongLong(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  int JsonValue::IndexAsInteger(size_t index, int defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = IndexValue(index, errorMode))
      return value->AsInteger(defaultValue, errorMode);
    return defaultValue;
  }

  //***************************************************************************
  float JsonValue::IndexAsFloat(size_t index, float defaultValue, JsonErrorMode::Enum errorMode)
  {
    if (JsonValue* value = IndexValue(index, errorMode))
      return value->AsFloat(defaultValue, errorMode);
    return defaultValue;
  }
  
  //***************************************************************************
  JsonValue* JsonReader::ReadIntoTreeFromFile(CompilationErrors& errors, StringParam fileName, void* userData)
  {
    String json;
    
    if (Project::ReadTextFile(fileName, json) == false)
    {
      return nullptr;
    }

    return ReadIntoTreeFromString(errors, json, fileName, userData);
  }

  //***************************************************************************
  JsonValue* JsonReader::ReadIntoTreeFromString(CompilationErrors& errors, StringParam json, StringParam origin, void* userData)
  {
    Array<UserToken> tokens;
    Array<UserToken> comments;

    Tokenizer tokenizer(errors);
    tokenizer.EnableStringInterpolation = false;

    CodeEntry entry;
    entry.Code = json;
    entry.CodeUserData = userData;
    entry.Origin = origin;

    if (tokenizer.Parse(entry, tokens, comments) == false)
      return nullptr;

    UniquePointer<JsonValue> root;

    Array<JsonValue*> objectArrayStack;

    // Normally we'd have to worry about this being a pointer to an element in an array that's resizing
    // however, this will only ever point to the back element and therefore will be valid
    JsonMember* member = nullptr;
    bool foundColon = false;
    bool isNegative = false;

    for (size_t i = 0; i < tokens.size(); ++i)
    {
      UserToken& token = tokens[i];

      JsonValue* createdValue = nullptr;

      if (isNegative && token.TokenId != Grammar::IntegerLiteral && token.TokenId != Grammar::RealLiteral)
      {
        errors.Raise(token.Location, ErrorCode::GenericError, "The negative sign must be followed by an Integer or Real literal");
        return nullptr;
      }

      switch(token.TokenId)
      {
        case Grammar::True:
        {
          createdValue = new JsonValue();
          createdValue->Type = JsonValueType::True;
        }
        break;

        case Grammar::False:
        {
          createdValue = new JsonValue();
          createdValue->Type = JsonValueType::True;
        }
        break;

        case Grammar::Null:
        {
          createdValue = new JsonValue();
          createdValue->Type = JsonValueType::Null;
        }
        break;

        case Grammar::Negative:
        {
          isNegative = true;
          break;
        }

        case Grammar::IntegerLiteral:
        {
          createdValue = new JsonValue();
          createdValue->Type = JsonValueType::Integer;
          Zero::ToValue(token.Token, createdValue->IntegralValue);

          if (isNegative)
          {
            createdValue->IntegralValue = -createdValue->IntegralValue;
            isNegative = false;
          }
        }
        break;

        case Grammar::RealLiteral:
        {
          createdValue = new JsonValue();
          createdValue->Type = JsonValueType::Real;
          Zero::ToValue(token.Token, createdValue->RealValue);
          
          if (isNegative)
          {
            createdValue->RealValue = -createdValue->RealValue;
            isNegative = false;
          }
        }
        break;

        case Grammar::StringLiteral:
        {
          String strValue = ReplaceStringEscapesAndStripQuotes(token.Token);

          // If we're inside an object and not a member...
          if (objectArrayStack.empty() == false && objectArrayStack.back()->Type == JsonValueType::Object && member == nullptr)
          {
            // We're starting a member!
            member = new JsonMember();
            objectArrayStack.back()->OrderedMembers.push_back(member);
            member->Key = strValue;
          }
          else
          {
            createdValue = new JsonValue();
            createdValue->Type = JsonValueType::String;
            createdValue->StringValue = strValue;
          }
        }
        break;

        case Grammar::NameSpecifier:
        {
          if (member == nullptr)
          {
            errors.Raise(token.Location, ErrorCode::GenericError, "Invalid member ':' found");
            return nullptr;
          }

          foundColon = true;
        }
        break;

        case Grammar::BeginScope:
        {
          createdValue = new JsonValue();
          createdValue->Type = JsonValueType::Object;
        }
        break;

        case Grammar::BeginIndex:
        {
          createdValue = new JsonValue();
          createdValue->Type = JsonValueType::Array;
        }
        break;

        case Grammar::EndScope:
        case Grammar::EndIndex:
        {
          if (objectArrayStack.empty())
          {
            errors.Raise(token.Location, ErrorCode::GenericError, "Unexpected end of an object or array");
            return nullptr;
          }

          objectArrayStack.pop_back();
        }
        break;

        case Grammar::ArgumentSeparator:
        {
          if (objectArrayStack.empty())
          {
            errors.Raise(token.Location, ErrorCode::GenericError, "Unexpected argument separator");
            return nullptr;
          }
        }
        break;

        default:
        {
          errors.Raise(token.Location, ErrorCode::GenericError, "Unexpected token type");
          return nullptr;
        }
      }
        
      if (createdValue != nullptr)
      {
        if (member != nullptr)
        {
          if (foundColon == false)
          {
            errors.Raise(token.Location, ErrorCode::GenericError, "A colon ':' was not found when specifying the value");
            return nullptr;
          }

          foundColon = false;
          member->Value = createdValue;
          objectArrayStack.back()->Members.insert(member->Key, member->Value);
          member = nullptr;
        }
        else
        {
          if (objectArrayStack.empty())
          {
            if(createdValue->Type != JsonValueType::Object)
            {
              errors.Raise(token.Location, ErrorCode::GenericError, "The root of a Json tree must be an object");
              return nullptr;
            }

            root = createdValue;
          }
          else
          {
            JsonValue* array = objectArrayStack.back();

            if(array->Type != JsonValueType::Array)
            {
              errors.Raise(token.Location, ErrorCode::GenericError, "We can only add values to an array (not to an object unless we use the member syntax)");
              return nullptr;
            }

            array->ArrayElements.push_back(createdValue);
          }
        }

        if (createdValue->Type == JsonValueType::Object || createdValue->Type == JsonValueType::Array)
        {
          objectArrayStack.push_back(createdValue);
        }
      }
    }

    return root.Release();
  }

  //***************************************************************************
  String JsonBuilder::ToString() const
  {
    // Error checking
    ErrorIf(this->Stack.size() != 0,
      "The resulting Json object will be incomplete");

    // Output the final string
    return this->Builder.ToString();
  }

  //***************************************************************************
  void JsonBuilder::WriteTree(JsonValue* value)
  {
    switch (value->Type)
    {
      case JsonValueType::True:
        this->Value(true);
        break;
      case JsonValueType::False:
        this->Value(false);
        break;
      case JsonValueType::Null:
        this->Null();
        break;
      case JsonValueType::String:
        this->Value(value->StringValue);
        break;
      case JsonValueType::Integer:
        this->Value(value->IntegralValue);
        break;
      case JsonValueType::Real:
        this->Value(value->RealValue);
        break;
      case JsonValueType::Object:
        this->Begin(JsonType::Object);
        for (size_t i = 0; i < value->OrderedMembers.size(); ++i)
        {
          JsonMember* member = value->OrderedMembers[i];
          this->Key(member->Key);
          this->WriteTree(member->Value);
        }
        this->End();
        break;
      case JsonValueType::Array:
        this->Begin(JsonType::ArrayMultiLine);
        for (size_t i = 0; i < value->ArrayElements.size(); ++i)
        {
          JsonValue* element = value->ArrayElements[i];
          this->WriteTree(element);
        }
        this->End();
        break;
      default:
        Error("Invalid json value type");
        break;
    }
  }

  //***************************************************************************
  void JsonBuilder::Key(StringRange name)
  {
    // If the stack size is zero...
    ReturnIf(this->Stack.size() == 0,,
      "You must be in the middle of an object to start a key/member (currently at the root!)");

    // Error checking
    ErrorIf(this->Stack.back() != JsonType::Object,
      "You must be in the middle of an object to start a key/member");

    // Error checking
    ErrorIf(this->IsMember,
      "A member of the object was already started");

    // Make sure to append a trailing comma if it's needed (after the last value)
    this->AttemptComma();

    this->AttemptNewline();

    // Append the quoted name with a following ':'
    this->Builder.Write("\"");
    this->Builder.Write(name);
    this->Builder.Write("\":");

    if (this->IsCompactMode == false)
    {
      this->Builder.Write(" ");
    }

    // We're now writing to a member
    this->IsMember = true;

    // Mark that we have yet to write anything since we started a new member
    this->IsWrittenTo = false;
  }

  //***************************************************************************
  void JsonBuilder::Value(int value)
  {
    this->RawValue(String::Format("%d", value));
  }

  //***************************************************************************
  void JsonBuilder::Value(unsigned int value)
  {
    this->RawValue(String::Format("%u", value));
  }

  //***************************************************************************
  void JsonBuilder::Value(long long value)
  {
    this->RawValue(String::Format("%lld", value));
  }

  //***************************************************************************
  void JsonBuilder::Value(long value)
  {
    this->RawValue(String::Format("%ld", value));
  }
  
  //***************************************************************************
  void JsonBuilder::Value(unsigned long value)
  {
    this->RawValue(String::Format("%lu", value));
  }

  //***************************************************************************
  void JsonBuilder::Value(unsigned long long value)
  {
    this->RawValue(String::Format("%llu", value));
  }

  //***************************************************************************
  void JsonBuilder::Value(double value)
  {
    this->RawValue(String::Format("%f", value));
  }

  //***************************************************************************
  void JsonBuilder::Value(cstr value)
  {
    this->Value(StringRange(value));
  }

  //***************************************************************************
  void JsonBuilder::Value(StringRange value)
  {
    // We need to build an escaped string
    StringBuilder escapedString;

    // Start with quotes on the front (and we'll add one to the end later)
    escapedString.Append("\"");

    // Loop through all the characters in the string
    for (size_t i = 0; i < value.size(); ++i)
    {
      // Get the current character
      char c = value[i];

      // Based on the character type...
      switch (c)
      {
      case '\\':
        // Escape the escape character
        escapedString.Append("\\\\");
        break;
      case '\n':
        // Escape the newline character
        escapedString.Append("\\n");
        break;
      case '\r':
        // Escape the carriage return character
        escapedString.Append("\\r");
        break;
      case '"':
        // Escape the quote character
        escapedString.Append("\\\"");
        break;
      case '\0':
        // Escape the quote character
        escapedString.Append("\\u0000");
        break;
      default:
        // Just append the character like normal
        escapedString.Append(c);
        break;
      }
    }

    // Finish with an ending quote
    escapedString.Append("\"");

    // Get the resulting string we just built
    String result = escapedString.ToString();

    // Set the string as a value
    this->RawValue(result);
  }

  //***************************************************************************
  void JsonBuilder::Value(Boolean value)
  {
    // Write true or false dependent upon the value
    if (value)
    {
      this->RawValue("true");
    }
    else
    {
      this->RawValue("false");
    }
  }

  //***************************************************************************
  void JsonBuilder::Null()
  {
      this->RawValue("null");
  }

  //***************************************************************************
  void JsonBuilder::AttemptComma()
  {
    // If we're at the root, no comma is needed
    if (this->Stack.size() == 0)
    {
      return;
    }

    // If we're not written to
    if (this->IsWrittenTo)
    {
      this->Builder.Write(",");

      if (this->IsCompactMode == false)
      {
        this->Builder.Write(" ");
      }
    }
  }

  //***************************************************************************
  void JsonBuilder::AttemptNewline()
  {
    if (this->IsCompactMode == false)
    {
      // Get the last thing (object or array) that we started
      if (this->Stack.empty() || this->Stack.back() != JsonType::ArraySingleLine)
      {
        this->Builder.WriteLine();

        for (size_t i = 0; i < this->Stack.size(); ++i)
        {
          this->Builder.Write("  ");
        }
      }
    }
  }
  
  //***************************************************************************
  void JsonBuilder::RawValue(StringParam value)
  {
    // Error checking
    this->VerifyCanWriteValue();

    // Make sure to append a trailing comma if it's needed (after the last value)
    this->AttemptComma();

    if (this->IsMember == false)
    {
      this->AttemptNewline();
    }

    // Add the value to the builder
    this->Builder.Append(value);

    // For the node above us, we've always written to it when we get here
    this->IsWrittenTo = true;

    // No matter what, we either just wrote an array value or finished writing to a member
    this->IsMember = false;
  }

  //***************************************************************************
  void JsonBuilder::Begin(JsonType::Enum type)
  {
    // Error checking
    this->VerifyCanWriteValue();

    // Make sure to append a trailing comma if it's needed (after the last value)
    this->AttemptComma();
    
    if (!(type == JsonType::ArraySingleLine && this->IsMember))
    {
      this->AttemptNewline();
    }
    
    // Push the type on the stack so we know later what we're doing
    this->Stack.push_back(type);

    // If the type is an object...
    if (type == JsonType::Object)
    {
      // Start the object
      this->Builder.Write("{");
    }
    // Otherwise it's an array
    else
    {
      // Start the array
      this->Builder.Write("[");
    }

    // Mark that we have yet to write anything
    this->IsWrittenTo = false;

    // No matter what, we either just wrote an array value or finished writing to a member
    this->IsMember = false;
  }

  //***************************************************************************
  void JsonBuilder::End()
  {
    // Error checking
    ReturnIf(this->Stack.empty(),,
      "There is no object or array to end (End was called one too many times)");

    // Get what we're in the top of the stack
    JsonType::Enum type = this->Stack.back();

    // Push the type on the stack so we know later what we're doing
    this->Stack.pop_back();

    if (type != JsonType::ArraySingleLine)
    {
      this->AttemptNewline();
    }

    // If the type is an object...
    if (type == JsonType::Object)
    {
      // End the object
      this->Builder.Write("}");
    }
    // Otherwise it's an array
    else
    {
      // End the array
      this->Builder.Write("]");
    }

    // For the node above us, we've always written to it when we get here
    this->IsWrittenTo = true;
  }

  //***************************************************************************
  void JsonBuilder::VerifyCanWriteValue()
  {
    // We can always write a value if we are at the root
    if (this->Stack.size() == 0)
    {
      // We can't write to the root twice...
      ErrorIf(this->Builder.GetSize() != 0,
        "Attempting to write to the root when something was already written");
      
      // Early out since there's nothing else to check
      return;
    }

    // Get the last thing (object or array) that we started
    JsonType::Enum last = this->Stack.back();

    // Verify that, if we're in the middle of an object, it must be as a member
    ErrorIf(last == JsonType::Object && this->IsMember == false,
      "You must make a member in order to add values inside of an object");
  }
}/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes














namespace Zilch
{
  //***************************************************************************
  const BoundFn LibraryBuilder::DoNotGenerate = (BoundFn)0x01;
  const BoundFn LibraryBuilder::NoOperation = (BoundFn)0x02;

  //***************************************************************************
  InstantiateTemplateDelegate::InstantiateTemplateDelegate() :
    Callback(nullptr),
    UserData(nullptr)
  {
  }

  //***************************************************************************
  String InstantiateTemplateInfo::GetFullName(const Array<Type*>& templateArguments)
  {
    // Create a string builder to build the template name
    StringBuilder builder;

    // Start with the base name, eg 'Array'
    builder.Append(this->BaseName);

    // Use the template bracket
    builder.Append('[');

    // Loop through the arguments and append the argument type names
    for (size_t i = 0; i < templateArguments.size(); ++i)
    {
      // Append the argument type name
      builder.Append(templateArguments[i]->ToString());

      // Figure out whether we're at the end of the list or not
      bool isNotAtEnd = (i != templateArguments.size() - 1);

      // As long as we aren't at the end of the list...
      if (isNotAtEnd)
      {
        // Add an argument separator between the template types
        builder.Append(", ");
      }
    }

    // Close the template bracket
    builder.Append(']');

    // Return the name
    return builder.ToString();
  }

  //***************************************************************************
  GuidType DelegateTypePolicy::operator() (DelegateType* type)
  {
    return type->Hash();
  }

  //***************************************************************************
  bool DelegateTypePolicy::equal(DelegateType* a, DelegateType* b)
  {
    // Make sure we have the same number of parameters
    if (a->Parameters.size() != b->Parameters.size())
      return false;

    // Make sure the returns are the same type (or non existant type for none)
    if (a->Return != b->Return)
      return false;

    // Loop through and compare each of the parameters
    for (size_t i = 0; i < a->Parameters.size(); ++i)
    {
      // Grab the two parameters
      const DelegateParameter& aParameter = a->Parameters[i];
      const DelegateParameter& bParameter = b->Parameters[i];

      // Compare the types
      if (aParameter.ParameterType != bParameter.ParameterType)
        return false;

      // Compare the names
      if (aParameter.Name != bParameter.Name)
        return false;
    }

    // If we got here, then it must match!
    return true;
  }

  //***************************************************************************
  LibraryBuilder::LibraryBuilder(StringParam name) :
    UserData(nullptr),
    ComputedDelegateAndFunctionSizes(false)
  {
    // Start out by creating a new library that we'll populate
    this->BuiltLibrary = LibraryRef(new Library());
    this->BuiltLibrary->Name = name;
  }

  //***************************************************************************
  String LibraryBuilder::GetName()
  {
    return this->BuiltLibrary->Name;
  }

  //***************************************************************************
  Function* LibraryBuilder::AddBoundFunction
  (
    BoundType* owner,
    StringParam name,
    BoundFn function,
    const ParameterArray& parameters,
    Type* returnType,
    FunctionOptions::Flags options,
    NativeVirtualInfo nativeVirtual
  )
  {
    // First add a raw function to the library
    Function* func = this->CreateRawFunction(owner, name, function, parameters, returnType, options, nativeVirtual);

    // If the function is valid...
    if (func != nullptr)
    {
      // Add the function to the bound type
      owner->AddRawFunction(func);
    }

    // Return the function that was created
    return func;
  }

  //***************************************************************************
  Function* LibraryBuilder::AddExtensionFunction
  (
    BoundType* forType,
    StringParam name,
    BoundFn function,
    const ParameterArray& parameters,
    Type* returnType,
    FunctionOptions::Flags options
  )
  {
    // First add a raw function to the library
    Function* createdFunction = this->CreateRawFunction(forType, name, function, parameters, returnType, options);

    // If the function is valid...
    if (createdFunction != nullptr)
      this->AddRawExtensionFunction(createdFunction);

    // Return the function that was created
    return createdFunction;
  }

  //***************************************************************************
  void LibraryBuilder::AddRawExtensionFunction(Function* function)
  {
    // Get the guid for the type that we're extending
    BoundType* forType = function->Owner;
    GuidType guid = forType->Hash();

    // Store the extension map (could be static or instance)
    FunctionMultiMap* overloadedFunctionsByName = nullptr;

    // Add the property to the library extension map
    if (function->This != nullptr)
      overloadedFunctionsByName = &this->BuiltLibrary->InstanceExtensionFunctions[guid];
    else
      overloadedFunctionsByName = &this->BuiltLibrary->StaticExtensionFunctions[guid];

    // Get the array of overloaded functions
    FunctionArray& overloads = (*overloadedFunctionsByName)[function->Name];

    // Add the property to the named map
    overloads.push_back(function);
  }

  //***************************************************************************
  Function* LibraryBuilder::AddBoundPreConstructor(BoundType* owner, BoundFn function)
  {
    // Error checking
    ErrorIf(owner->PreConstructor != nullptr,
      "A type cannot have two pre-constructors! A pre-constructor is a simple "
      "initializer (like memset) that runs before any constructors get run");

    // First add a raw function to the library
    Function* func = this->CreateRawPreConstructor(owner, function);
    
    // If the function is valid...
    if (func != nullptr)
    {
      // Add the function to the bound type
      owner->PreConstructor = func;
    }

    // Return the function that was created
    return func;
  }
  
  //***************************************************************************
  Function* LibraryBuilder::AddBoundConstructor(BoundType* owner, BoundFn function, const ParameterArray& parameters)
  {
    // First add a raw function to the library
    Function* func = this->CreateRawConstructor(owner, function, parameters);
    
    // If the function is valid...
    if (func != nullptr)
    {
      // Add the function to the bound type
      owner->Constructors.push_back(func);
    }

    // Return the function that was created
    return func;
  }
  
  //***************************************************************************
  Function* LibraryBuilder::AddBoundDefaultConstructor(BoundType* owner, BoundFn function)
  {
    // First add a raw function to the library
    Function* func = this->CreateRawDefaultConstructor(owner, function);

    // If the function is valid...
    if (func != nullptr)
    {
      // Add the function to the bound type
      owner->Constructors.push_back(func);
    }

    // Return the function that was created
    return func;
  }
  
  //***************************************************************************
  Function* LibraryBuilder::AddBoundDestructor(BoundType* owner, BoundFn function)
  {
    // Error checking
    ErrorIf(owner->Destructor != nullptr,
      "A type cannot have two destructors! A destructor is a function "
      "that is responsible for cleaning up after an object.");

    // First add a raw function to the library
    Function* func = this->CreateRawDestructor(owner, function);

    // If the function is valid...
    if (func != nullptr)
    {
      // Make sure the user doesn't define two destructors
      ErrorIf(owner->Destructor != nullptr,
        "A class may only have one destructor");

      // Add the function to the bound type
      owner->Destructor = func;
    }

    // Return the function that was created
    return func;
  }

  //***************************************************************************
  Property* LibraryBuilder::AddBoundProperty(BoundType* owner, StringParam name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options)
  {
    // First add a raw property to the library
    Property* property = this->CreateRawProperty(owner, name, type, set, get, options);

    // If the property is valid...
    if (property != nullptr)
    {
      // Add the property to the bound type
      owner->AddRawProperty(property);

      // Make sure to add the getter function to the bound functions list
      if (property->Get != nullptr)
        owner->AddRawFunction(property->Get);

      // Make sure to add the setter function to the bound functions list
      if (property->Set != nullptr)
        owner->AddRawFunction(property->Set);
    }

    // Return the property that was created
    return property;
  }

  //***************************************************************************
  InstantiatedTemplate LibraryBuilder::InstantiateTemplate(StringParam baseName, const Array<Type*>& arguments, const LibraryArray& fromLibraries)
  {
    // What we'll return to the user
    InstantiatedTemplate result;
    
    // Assume we failed because we couldn't find anything of the same name
    result.Result = TemplateResult::FailedNameNotFound;

    // Loop through all of our dependent libraries
    for (size_t i = 0; i < fromLibraries.size(); ++i)
    {
      // Get the current dependent library
      const LibraryRef& library = fromLibraries[i];

      // Get a pointer (or null) to the callback delegate
      InstantiateTemplateInfo* info = library->TemplateHandlers.findPointer(baseName);

      // If there is a template by that name...
      if (info != nullptr)
      {
        // If the number of arguments is valid
        if (arguments.size() != info->TemplateArgumentNames.size())
        {
          // Fail out because the user provided an invalid number of arguments
          result.Result = TemplateResult::FailedInvalidArgumentCount;
          result.ExpectedArguments = info->TemplateArgumentNames.size();
          return result;
        }

        // Get a reference to the delegate for convenience
        InstantiateTemplateDelegate& delegate = info->Delegate;

        // Get the fully qualified name
        String fullyQualifiedTemplateName = info->GetFullName(arguments);

        // Check to see if we already have this type...
        result.Type = this->BoundTypes.findValue(fullyQualifiedTemplateName, nullptr);

        // If we didn't find the type (it was not yet instantiated)
        if (result.Type == nullptr)
        {
          // Invoke the callback to instantiate the type
          result.Type = delegate.Callback(*this, baseName, fullyQualifiedTemplateName, arguments, delegate.UserData);

          // If we found the created type
          if (result.Type != nullptr)
          {
            // We sucessfully instantiated a template
            result.Result = TemplateResult::Success;

            // Error checking
            ErrorIf(result.Type->Name != fullyQualifiedTemplateName,
              "The template instantiator needs to create a type with the given fully qualified name");
          }
          else
          {
            // We performed the callback, but got no type back
            result.Result = TemplateResult::FailedInstantiatorDidNotReturnType;
          }
        }
        else
        {
          // We sucessfully found a template
          result.Result = TemplateResult::Success;
        }

        // We found the instantiator and attempted to use it, so break out!
        break;
      }
    }

    // Return the result with the type or an error
    return result;
  }

  //***************************************************************************
  Property* LibraryBuilder::AddExtensionProperty(BoundType* forType, StringParam name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options)
  {
    // First add a raw property to the library
    Property* property = this->CreateRawProperty(forType, name, type, set, get, options);

    // If the property is valid...
    if (property != nullptr)
    {
      // Get the guid for the type that we're extending
      GuidType guid = forType->Hash();

      // Store the extension map (could be static or instance)
      PropertyMap* propertiesByName = nullptr;

      // We also need to get the function extension map so we can add the getter and setter functions
      // Technically these functions aren't referencable, except if native code looks them up (just to be proper!)
      FunctionMultiMap* functionsByName = nullptr;
      
      // Add the property to the library extension map
      if (options & FunctionOptions::Static)
      {
        propertiesByName = &this->BuiltLibrary->StaticExtensionProperties[guid];
        functionsByName = &this->BuiltLibrary->StaticExtensionFunctions[guid];
      }
      else
      {
        propertiesByName = &this->BuiltLibrary->InstanceExtensionProperties[guid];
        functionsByName = &this->BuiltLibrary->InstanceExtensionFunctions[guid];
      }

      // Add the property to the named map
      bool inserted = propertiesByName->insertNoOverwrite(name, property);
      ErrorIf(inserted == false,
        "Another property with the same name (%s) was added to the extension methods map for type (%s), "
        "or two types came out with the same guid (which would be bad)",
        name.c_str(), forType->Name.c_str());

      // Make sure to add the getter function to the bound functions list
      if (property->Get != nullptr)
        (*functionsByName)[property->Get->Name].push_back(property->Get);

      // Make sure to add the setter function to the bound functions list
      if (property->Set != nullptr)
        (*functionsByName)[property->Set->Name].push_back(property->Set);
    }

    // Return the property that was created
    return property;
  }

  //***************************************************************************
  Field* LibraryBuilder::AddBoundField(BoundType* owner, StringParam name, Type* type, size_t offset, MemberOptions::Flags options)
  {
    // First add a raw field to the library
    Field* field = this->CreateRawField(owner, name, type, offset, options);

    // If the field is valid...
    if (field != nullptr)
    {
      // Add the field to the bound type
      owner->AddRawField(field);
    }

    // Return the field that was created
    return field;
  }

  //***************************************************************************
  Function* LibraryBuilder::CreateRawFunction
  (
    BoundType* owner,
    String name,
    BoundFn boundFunction,
    const ParameterArray& parameters,
    Type* returnType,
    FunctionOptions::Flags options,
    NativeVirtualInfo nativeVirtual
  )
  {
    // Verify that the name is correct
    name = FixIdentifier(name, TokenCheck::IsUpper);

    // Error checking for our owner type
    ReturnIf(owner == nullptr, nullptr, "The owner must never be null");

    // Error checking for the native virtual calls
    if (nativeVirtual.Validate() == false)
      return nullptr;

    // Create the actual function we use for the compiler
    // Note that we leave the source library as not set,
    // because the library has yet to be built
    Function* function      = new Function();
    function->Name          = name;
    function->BoundFunction = boundFunction;
    function->Owner         = owner;

    // Setup any native virtual behavior
    function->NativeVirtual = nativeVirtual;

    // If the user is creating a native virtual function...
    if (nativeVirtual.Index != NativeVirtualInfo::NonVirtual)
    {
      // Just make sure the user marked this function as virtual, just for consistency
      ErrorIf((options & FunctionOptions::Virtual) == 0,
        "The FunctionOptions::Virtual flag must be set when creating a native virtual function");
      options |= FunctionOptions::Virtual;
    }

    // If the function is virtual...
    if (options & FunctionOptions::Virtual)
    {
      // The function cannot also be static
      ErrorIf((options & FunctionOptions::Static) != 0,
        "Static functions cannot be marked as virtual");

      // Mark the function as being virtual
      function->IsVirtual = true;
    }

    // Create a delegate type for the function
    function->FunctionType = this->GetDelegateType(parameters, returnType);

    // If the function is static (we have no 'this' reference)
    if (options & FunctionOptions::Static)
    {
      // Otherwise, the this pointer is null since it's a static method
      function->This = nullptr;
    }
    else
    {
      // Create a variable for the this pointer
      Variable* thisVariable = this->CreateRawVariable(function, ThisKeyword);
      thisVariable->ResultType = this->ToHandleType(owner);
      function->This = thisVariable;
    }
    
    // Push the function into a list
    this->BuiltLibrary->OwnedFunctions.push_back(function);

    // Return the created function
    return function;
  }

  //***************************************************************************
  Function* LibraryBuilder::CreateRawPreConstructor(BoundType* owner, BoundFn function)
  {
    // Get a reference to the core library
    Core& core = Core::GetInstance();

    // Create the function
    return this->CreateRawFunction(owner, PreConstructorName, function, ParameterArray(), core.VoidType, FunctionOptions::None);
  }

  //***************************************************************************
  Function* LibraryBuilder::CreateRawConstructor(BoundType* owner, BoundFn function, const ParameterArray& parameters)
  {
    // Get a reference to the core library
    Core& core = Core::GetInstance();

    // If the type is native, then we want this constructor to call SetNativeTypeFullyConstructed on the handle manager
    BoundFn invokedFunction = function;
    if (owner->Native)
      invokedFunction = VirtualMachine::NativeConstructor;

    // Create the constructor and set the 'original' bound-function on it (may not be used)
    Function* constructor = this->CreateRawFunction(owner, ConstructorName, invokedFunction, parameters, core.VoidType, FunctionOptions::None);
    constructor->NativeConstructor = function;
    return constructor;
  }

  //***************************************************************************
  Function* LibraryBuilder::CreateRawDefaultConstructor(BoundType* owner, BoundFn function)
  {
    return this->CreateRawConstructor(owner, function, ParameterArray());
  }

  //***************************************************************************
  Function* LibraryBuilder::CreateRawDestructor(BoundType* owner, BoundFn function)
  {
    // Get a reference to the core library
    Core& core = Core::GetInstance();

    // Create the function
    return this->CreateRawFunction(owner, DestructorName, function, ParameterArray(), core.VoidType, FunctionOptions::None);
  }

  //***************************************************************************
  Property* LibraryBuilder::CreateRawProperty(BoundType* owner, String name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options)
  {
    // Verify that the name is correct
    name = FixIdentifier(name, TokenCheck::IsUpper);

    // Create the property
    Property* property = new Property();
    property->Owner = owner;

    // Pass it to the library so it can delete the property
    this->BuiltLibrary->OwnedProperties.push_back(property);

    // Set the name of the property
    property->Name = name;

    // Set the type of the property
    property->PropertyType = type;

    // The functions are always positional
    FunctionOptions::Flags functionOptions = FunctionOptions::None;

    // If we are adding a static property
    if (options & MemberOptions::Static)
    {
      // Set this property as static (and any functions we generate as static)
      property->IsStatic = true;
      functionOptions |= FunctionOptions::Static;
    }
    
    // We must have at least a get or a set (or both)
    if (get != nullptr || set != nullptr)
    {
      // Check if we were given a get function
      if (get != nullptr && get != DoNotGenerate)
      {
        // Generate the get function
        property->Get = this->CreateRawFunction
        (
          owner,
          BuildGetterName(name),
          get,
          ParameterArray(),
          type,
          functionOptions
        );
        property->Get->IsHidden = true;
        property->Get->IsPropertyGetOrSet = true;
      }

      // Check if we were given a set function
      if (set != nullptr && set != DoNotGenerate)
      {
        // The set takes a single parameter
        ParameterArray parameters;
        DelegateParameter& value = parameters.push_back();
        value.Name = ValueKeyword;
        value.ParameterType = type;

        // Get a reference to the core so we can get the void type (setters have no return value)
        Core& core = Core::GetInstance();

        // Generate the set function
        property->Set = this->CreateRawFunction
        (
          owner,
          BuildSetterName(name),
          set,
          parameters,
          core.VoidType,
          functionOptions
        );
        property->Set->IsHidden = true;
        property->Set->IsPropertyGetOrSet = true;
      }
    }
    else
    {
      Error("Properties must have at least a getter or a setter (or both).");
    }

    // Return a reference to the property
    return property;
  }

  //***************************************************************************
  const String& LibraryBuilder::AddStringLiteral(cstr text)
  {
    this->BuiltLibrary->StringLiterals.push_back(text);
    return this->BuiltLibrary->StringLiterals.back();
  }
  
  //***************************************************************************
  const String& LibraryBuilder::AddStringLiteral(StringParam text)
  {
    this->BuiltLibrary->StringLiterals.push_back(text);
    return this->BuiltLibrary->StringLiterals.back();
  }
  
  //***************************************************************************
  const String& LibraryBuilder::AddStringLiteral(StringRange text)
  {
    this->BuiltLibrary->StringLiterals.push_back(text);
    return this->BuiltLibrary->StringLiterals.back();
  }

  //***************************************************************************
  void FieldSetter(Call& call, ExceptionReport& report)
  {
    // Get the field and its offset
    Field* field = (Field*)call.GetFunction()->UserData;

    // Grab a handle to the this object and dereference it
    Handle& handle = call.GetHandle(Call::This);
    byte* memory = handle.Dereference();

    // Get the memory offsetted to the field
    byte* fieldMemory = memory + field->Offset;

    // Get a direct pointer to the parameter (could be a primitive, such as a handle)
    byte* parameterMemory = call.GetParameterUnchecked(0);

    // Generically destruct the existing field (release reference, etc) the current parameter's memory
    field->PropertyType->GenericDestruct(fieldMemory);

    // Now copy construct the parameter they are trying to set over the field memory
    field->PropertyType->GenericCopyConstruct(fieldMemory, parameterMemory);
  }

  //***************************************************************************
  void FieldGetter(Call& call, ExceptionReport& report)
  {
    // Get the field and its offset
    Field* field = (Field*)call.GetFunction()->UserData;

    // Grab a handle to the this object and dereference it
    Handle& handle = call.GetHandle(Call::This);
    byte* memory = handle.Dereference();

    // Get the memory offsetted to the field
    byte* fieldMemory = memory + field->Offset;

    // Get a direct pointer to the return (not initialized yet!)
    byte* returnMemory = call.GetReturnUnchecked();
    call.DisableReturnChecks();

    // Now copy construct the parameter they are trying to set over the field memory
    field->PropertyType->GenericCopyConstruct(returnMemory, fieldMemory);
  }

  //***************************************************************************
  Field* LibraryBuilder::CreateRawField(BoundType* owner, String name, Type* type, size_t offset, MemberOptions::Flags options)
  {
    // Verify that the name is correct
    name = FixIdentifier(name, TokenCheck::IsUpper);

    // Create the member
    Field* field = new Field();
    field->Owner = owner;

    // Pass it to the library so it can delete the member
    this->BuiltLibrary->OwnedProperties.push_back(field);

    // Set the name of the member
    field->Name = name;

    // Set the type of the member
    field->PropertyType = type;

    // Set whether or not the member is static (accessed on a class or instance)
    field->IsStatic = (options & MemberOptions::Static) != 0;

    // Set the member's offset to the given offset
    field->Offset = offset;

    // Return a reference to the member
    return field;
  }

  //***************************************************************************
  Variable* LibraryBuilder::CreateRawVariable(Function* function, String name)
  {
    // Create the variable and set it's name
    Variable* variable = new Variable();
    variable->Owner = function;
    variable->Name = FixIdentifier(name, TokenCheck::IsLower);
    variable->Location = function->Location;

    // Pass it to the library so it can delete the member
    this->BuiltLibrary->OwnedVariables.push_back(variable);

    // Also add it to the function (so it can be debugged easily)
    function->Variables.push_back(variable);

    // Return the created variable
    return variable;
  }

  //***************************************************************************
  void LibraryBuilder::AddTemplateInstantiator(StringParam baseName, InstantiateTemplateCallback callback, const StringArray& templateArgumentNames, void* userData)
  {
    // Create the delegate that we will call
    InstantiateTemplateInfo info;
    info.Delegate.Callback = callback;
    info.Delegate.UserData = userData;
    info.TemplateArgumentNames = templateArgumentNames;
    info.BaseName = baseName;

    // Perform the callback
    bool inserted = this->BuiltLibrary->TemplateHandlers.insertNoOverwrite(baseName, info);
    ErrorIf(inserted == false, "Another template instantiator of the same name (%s) was added to the Library Builder.", baseName.c_str());
  }

  //***************************************************************************
  BoundType* LibraryBuilder::AddBoundType(StringParam name, TypeCopyMode::Enum copyMode, size_t size, size_t nativeVirtualCount)
  {
    // Create a new bound type with the given name / size
    BoundType* type = new BoundType(name, copyMode, size, nativeVirtualCount);

    // Add the created type to this library
    this->AddRawBoundType(type);

    // Return the created type
    return type;
  }

  //***************************************************************************
  void LibraryBuilder::AddRawBoundType(BoundType* type)
  {
    // Make sure to store a strong reference, since we now own the type
    this->BuiltLibrary->OwnedTypes.push_back(type);

    // Map the bound type's name to its type object
    bool inserted = this->BoundTypes.insertNoOverwrite(type->Name, type);
    ErrorIf(inserted == false, "Another type with the same name (%s) was added to the LibraryBuilder.", type->Name.c_str());
  }

  //***************************************************************************
  BoundType* LibraryBuilder::FindBoundType(StringParam name)
  {
    return this->BoundTypes.findValue(name, nullptr);
  }

  //***************************************************************************
  void LibraryBuilder::GenerateGetSetFields()
  {
    // Grab a reference to the library for convenience
    LibraryRef library = this->BuiltLibrary;

    // Loop through all the fields
    for (size_t i = 0; i < library->OwnedProperties.size(); ++i)
    {
      // If the current property is a field...
      Field* field = TypeBinding::DynamicCast<Field*>(library->OwnedProperties[i]);
      if (field == nullptr)
        continue;

      // Function options for the getter and setter
      // In the future, this may be virtual too
      FunctionOptions::Enum functionOptions = FunctionOptions::None;

      // If the member is static, then the getter and setter are static too
      if (field->IsStatic)
        functionOptions = FunctionOptions::Static;

      // If we don't have a get function yet...
      if (field->Get == nullptr)
      {
        // Generate the get function
        field->Get = this->CreateRawFunction
        (
          field->Owner,
          BuildGetterName(field->Name),
          FieldGetter,
          ParameterArray(),
          field->PropertyType,
          functionOptions
        );
        field->Get->IsHidden = true;
        field->Get->IsPropertyGetOrSet = true;

        // The userdata for the getter and setter is just the original field
        // This works out well because in the Syntaxer, we defer the computation of offset
        // This way, we don't need to know the offset (the field will be updated!)
        field->Get->UserData = field;
        field->Owner->AddRawFunction(field->Get);
      }
      
      // If we don't have a set function yet...
      if (field->Set == nullptr)
      {
        // Generate the set function
        field->Set = this->CreateRawFunction
        (
          field->Owner,
          BuildSetterName(field->Name),
          FieldSetter,
          OneParameter(field->PropertyType, ValueKeyword),
          ZilchTypeId(void),
          functionOptions
        );
        field->Set->IsHidden = true;
        field->Set->IsPropertyGetOrSet = true;

        // The userdata for the getter and setter is just the original field
        // This works out well because in the Syntaxer, we defer the computation of offset
        // This way, we don't need to know the offset (the field will be updated!)
        field->Set->UserData = field;
        field->Owner->AddRawFunction(field->Set);
      }
    }
  }

  //***************************************************************************
  bool LibraryBuilder::CheckIdentifier(StringParam identifier, TokenCheck::Flags flags)
  {
    // Just attempt to fix the identifier (this will assert if the flag is set)
    String fixedIdentifier = FixIdentifier(identifier, flags);
    
    // Return if the output is the exact same as the input
    return (fixedIdentifier == identifier);
  }

  //***************************************************************************
  String LibraryBuilder::FixIdentifier(StringParam ident, TokenCheck::Flags flags, char invalidCharacter)
  {
    // Should we be asserting in this function?
    String identifier = ident;
    bool asserts = (flags & TokenCheck::Asserts) != 0;
    bool expectUpperIdentifier = (flags & TokenCheck::IsUpper) != 0;
    bool expectLowerIdentifier = (flags & TokenCheck::IsLower) != 0;
    bool removeOuterBrackets = (flags & TokenCheck::RemoveOuterBrackets) != 0;
    bool noMultipleInvalidCharacters = (flags & TokenCheck::NoMultipleInvalidCharacters) != 0;

    // Check if the given identifier was empty
    if (identifier.empty())
    {
      ErrorIf(asserts, "The identifier must be at least one character in length!");
      if (expectLowerIdentifier)
        return EmptyLowerIdentifier;
      else
        return EmptyUpperIdentifier;
    }

    // Get the first and last character
    {
      char first = identifier.front();
      char last  = identifier.back();

      // Check if this is a special identifier
      if (first == '[' && last == ']')
      {
        // If the user wishes to remove the outer brackets, then strip them off and continue
        if (removeOuterBrackets)
          identifier = identifier.sub_string(1, identifier.size() - 2);
        // Otherwise it doesn't matter what comes in between, this is special (hidden effectively
        else
          return identifier;
      }
    }

    // We're going to build the identifier name and return it
    StringBuilder builder;
    bool readFirstLetter = false;

    // Walk through all characters in the identifier
    for (size_t i = 0; i < identifier.size(); ++i)
    {
      char c = identifier[i];

      // If we have yet to read the first letter...
      if (readFirstLetter == false)
      {
        // The first letter must always be [A-Z]
        if (CharacterUtilities::IsAlpha(c))
        {
          // We read a letter! Check to see if its a mismatch for the upper or lower identifier
          readFirstLetter = true;
          bool isUpper = CharacterUtilities::IsUpper(c);
          bool isLower = !isUpper;

          if (isUpper && expectLowerIdentifier)
          {
            // Append an lowercase version of the first letter
            ErrorIf(asserts, "The first letter '%c' must be lowercase", c);
            builder.Append((char)tolower(c));
          }
          else if (isLower && expectUpperIdentifier)
          {
            // Append an uppercase version of the first letter
            ErrorIf(asserts, "The first letter '%c' must be uppercase", c);
            builder.Append((char)toupper(c));
          }
          else
          {
            // The first letter was fine, append it as is
            builder.Append(c);
          }
        }
        else
        {
          // We don't append anything here because we haven't hit the first character yet...
          ErrorIf(asserts, "The first character '%c' must be a letter", c);
        }
      }
      // If any part of the rest of the identifier is NOT alpha-numeric or underscore
      else if (CharacterUtilities::IsAlphaNumeric(c) == false && c != '_')
      {
        ErrorIf(asserts, "Character '%c' in the identifier must be either a letter, number, or underscore (no other symbols)", c);

        // We should only append invalid characters if the user specified one (not null)
        // and if the user doesn't want multiple of the same character
        bool shouldAppendInvalidCharacter =
          invalidCharacter != '\0' &&
          (noMultipleInvalidCharacters == false ||
          builder.GetSize() == 0 ||
          builder[builder.GetSize() - 1] != invalidCharacter);

        // Append the invalid character
        if (shouldAppendInvalidCharacter)
          builder.Append(invalidCharacter);
      }
      // It was a completely valid character
      else
      {
        builder.Append(c);
      }
    }

    // If the builder is empty, then we didn't event hit a valid first letter...
    // Perform the same behavior as above when the original identifier was empty
    if (builder.GetSize() == 0)
    {
      ErrorIf(asserts, "The identifier must be at least one character in length!");
      if (expectLowerIdentifier)
        return EmptyLowerIdentifier;
      else
        return EmptyUpperIdentifier;
    }

    // Get the fixed identifier of the builder and return it
    String fixedIdentifier = builder.ToString();
    return fixedIdentifier;
  }

  //***************************************************************************
  bool LibraryBuilder::CheckUpperIdentifier(StringParam identifier)
  {
    return CheckIdentifier(identifier, TokenCheck::IsUpper);
  }

  //***************************************************************************
  bool LibraryBuilder::CheckLowerIdentifier(StringParam identifier)
  {
    return CheckIdentifier(identifier, TokenCheck::IsLower);
  }

  //***************************************************************************
  void LibraryBuilder::SetEntries(const Array<CodeEntry>& entries)
  {
    this->BuiltLibrary->Entries = entries;
  }
  
  //***************************************************************************
  Plugin* LibraryBuilder::LoadPlugin(Status& status, StringParam pluginFile)
  {
    // In order to not lock the library and support dynamic reloading, we make a copy of any plugin files
    // Ideally we want to load the same libraries and not duplicate code loading,
    // therefore we use the hash of the library to uniquely identify it
    File file;
    file.Open(pluginFile, Zero::FileMode::Read, Zero::FileAccessPattern::Sequential, Zero::FileShare::Read, &status);
    if (status.Failed())
    {
      status.SetFailed("We failed to open the plugin file for Read only access (does it exist or is there permission?)");
      return nullptr;
    }

    // Get the hash of the shared library and then close the file
    String sha1Hash = Sha1Builder::GetHashString(file);
    file.Close();

    // Copy the library to a new temporary location
    StringRange pluginName = Zero::FilePath::GetFileNameWithoutExtension(pluginFile);
    String fileName = BuildString(pluginName, ".", sha1Hash, ".zilchPlugin");
    String pluginLocation = Zero::FilePath::Combine(Zero::GetTemporaryDirectory(), fileName);
    
    // Only copy if the file doesn't already exist
    if (Zero::FileExists(pluginLocation) == false)
    {
      // If we fail to copy the file, then just load the plugin directly...
      if (Zero::CopyFile(pluginLocation, pluginFile) == false)
        pluginLocation = pluginFile;
    }
    
    // Attempt to load the plugin file
    ExternalLibrary lib;
    lib.Load(pluginLocation.c_str());

    // If we failed to load the library, then early out
    if (lib.IsValid() == false)
    {
      status.SetFailed("The plugin dynamic/shared library was not a valid library and could not be loaded");
      return nullptr;
    }

    // Look for the create plugin functionality, early out if we don't find it
    CreateZilchPluginFn createPlugin = (CreateZilchPluginFn)lib.GetFunctionByName("CreateZilchPlugin");
    if (createPlugin == nullptr)
    {
      status.SetFailed("The 'CreateZilchPlugin' function was not exported within the dll (did you use the ZeroExport macro?)");
      return nullptr;
    }

    // Finally, attempt to create a plugin (the user should return us a plugin at this point)
    Plugin* plugin = createPlugin();
    if (plugin == nullptr)
    {
      status.SetFailed("We found the 'CreateZilchPlugin' function and called it, but it returned null so no plugin was created");
      return nullptr;
    }

    // We successfully loaded the plugin
    // For now, we'll just keep the code loaded forever until we get a good mechanism for releasing plugins
    lib.mUnloadOnDestruction = false;
    UniquePointer<Plugin> ownedPlugin(plugin);
    this->BuiltLibrary->OwnedPlugins.push_back(ZeroMove(ownedPlugin));
    return plugin;
  }
  
  //***************************************************************************
  void LibraryBuilder::LoadPlugins(StringParam directory, Array<Plugin*>& pluginsOut)
  {
    static const String PluginExtension("zilchPlugin");

    // Walk through all the files in the directory looking for anything ending with .zilchPlugin
    Zero::FileRange range(directory);
    while (range.empty() == false)
    {
      // If this file has the .zilchPlugin extension
      Zero::FileEntry fileEntry = range.frontEntry();
      String filePath = fileEntry.GetFullPath();
      if (Zero::FilePath::GetExtension(fileEntry.mFileName) == PluginExtension)
      {
        // Attempt to load the plugin (this may fail!)
        Status status;
        Plugin* plugin = this->LoadPlugin(status, filePath);

        // If we successfully created a plugin, then output it
        if (plugin != nullptr)
          pluginsOut.push_back(plugin);
      }
      range.popFront();
    }
  }

  //***************************************************************************
  void LibraryBuilder::ComputeDelegateAndFunctionSizesOnce()
  {
    // If we already computed the sizes/offsets, then early out
    if (this->ComputedDelegateAndFunctionSizes)
      return;

    // We only want to do this once (otherwise required stack offsets for functions can get messed up,
    // eg if we added locals and then went back and recomputed the sizes and overwrite the stack offsets)
    this->ComputedDelegateAndFunctionSizes = true;

    // For how we give parameter positions, check CodeGenerator.cpp around line 233
    // Returns go at the beginning, parameters go after returns, and the
    // this handle (if it exists) goes after the parameters

    // Create a range to iterate through all the delegate types
    DelegateTypeSet::range delegateTypes = this->DelegateTypes.all();

    // Loop through all the delegate types in the range
    while (delegateTypes.empty() == false)
    {
      // Get a pointer to the current type and iterate to the next
      DelegateType* delegateType = delegateTypes.front();
      delegateTypes.popFront();

      // Set the return stack offset, which is always zero
      delegateType->ReturnStackOffset = 0;

      // The cumulative offset of each parameter on the stack
      OperandIndex parameterStackOffset = 0;

      // Move the first parameter forward by the return value's size
      // (void has a size of zero, so this always works!)
      parameterStackOffset += (OperandIndex)AlignToBusWidth(delegateType->Return->GetCopyableSize());

      // Walk through the parameters and assign stack offsets
      for (size_t i = 0; i < delegateType->Parameters.size(); ++i)
      {
        // Grab the current delegate parameter
        DelegateParameter& parameter = delegateType->Parameters[i];

        // Set the parameter's stack offset
        parameter.StackOffset = parameterStackOffset;

        // Push forward the next parameter's stack offset by this parameter's size
        parameterStackOffset += (OperandIndex)AlignToBusWidth(parameter.ParameterType->GetCopyableSize());

        // Get a reference to the core library
        Core& core = Core::GetInstance();

        // Make sure all delegates have returns
        ErrorIf(parameter.ParameterType == nullptr || parameter.ParameterType == core.VoidType,
          "Delegate/function parameters cannot be null or void");
      }

      // Finally, the 'this' handle comes right after all the parameters
      delegateType->ThisHandleStackOffset = parameterStackOffset;
      delegateType->TotalStackSizeExcludingThisHandle = parameterStackOffset;
    }

    // Now that we computed all delegate type sizes / stack offsets, we can update any functions to reflect those offsets
    // This is also generally required to be done before code generation so we know required stack size (just for parameters and returns)
    FunctionArray& functions = this->BuiltLibrary->OwnedFunctions;
    for (size_t i = 0; i < functions.size(); ++i)
    {
      // The base required stack space for any function is the parameters and return sizes totaled
      Function* function = functions[i];
      function->RequiredStackSpace = function->FunctionType->TotalStackSizeExcludingThisHandle;

      // If the function has a this handle
      if (function->This != nullptr)
      {
        // The this handle is the last parameter (after the returns and the parameters)
        function->This->Local = (OperandLocal)function->FunctionType->ThisHandleStackOffset;

        // Add the size of the this handle
        function->RequiredStackSpace += function->This->ResultType->GetCopyableSize();
      }
    }
  }
  
  //***************************************************************************
  String GetInheritedDescription(Function* function)
  {
    // FindFunction will walk up the base class chain for me, but we need to make sure we look for the same type of functions
    FindMemberOptions::Enum options = FindMemberOptions::None;
    if (function->This == nullptr)
      options = FindMemberOptions::Static;

    // Walk up parent functions starting with our function
    Function* foundFunction = function;
    ZilchLoop
    {
      // If we have a valid description, return it, otherwise look for a
      // base class version of this function that may have a description
      if (foundFunction->Description.empty() == false)
        return foundFunction->Description;

      // Grab the base type of the owner of this function (could be null)
      BoundType* baseType = foundFunction->Owner->BaseType;
      if (baseType == nullptr)
        break;

      // Find will automatically walk up base classes to look for the function
      // We are puposefully looking on our base class for the same exact function as ourselves
      // This will return null if we have no parent function
      foundFunction = baseType->FindFunction(function->Name, function->FunctionType, options);
      if (foundFunction == nullptr)
        break;
    }

    // We didn't find a valid description
    return String();
  }

  //***************************************************************************
  LibraryRef LibraryBuilder::CreateLibrary()
  {
    // Grab a reference to the library for convenience
    LibraryRef library = this->BuiltLibrary;

    // Generate getters and setters for any field that hasn't already been generated
    this->GenerateGetSetFields();

    // We need to create all the bound functions
    for (size_t i = 0; i < library->OwnedFunctions.size(); ++i)
    {
      // Get the current bound function
      Function* function = this->BuiltLibrary->OwnedFunctions[i];

      // If the function has no description, then grab it from its base class
      function->Description = GetInheritedDescription(function);

      // Compact the byte code into a single byte buffer (may be no opcode!)
      function->CompactedOpcode.resize(function->OpcodeBuilder.RelativeSize());
      function->OpcodeBuilder.RelativeCompact(function->CompactedOpcode.data());

      // Add the function to the library so it can be looked up
      function->SourceLibrary = library.Object;
    }

    // Create a range to iterate through all the named types
    BoundTypeRange boundTypes = this->BoundTypes.all();

    // Loop through all the named types in the range
    while (boundTypes.empty() == false)
    {
      // Get a pointer to the current type and iterate to the next
      BoundTypeMap::pair& pair = boundTypes.front();
      BoundType* boundType = pair.second;
      boundTypes.popFront();

      // Insert all the named types into the map
      library->BoundTypes.insertOrError(pair.first, boundType);

      // Set the type's source library to the current library
      boundType->SourceLibrary = library.Object;
    }
    
    // Make sure all delegates know thier sizes (may be computed more than once due to code-gen needing the sizes)
    this->ComputeDelegateAndFunctionSizesOnce();

    // Clear out our built library so we don't use the this builder anymore
    this->BuiltLibrary = nullptr;
    return library;
  }
  

  //***************************************************************************
  Type* LibraryBuilder::ToHandleType(BoundType* type)
  {
    // If the type is a reference type...
    if (type->CopyMode == TypeCopyMode::ReferenceType)
    {
      // The reference type itself is effectively a handle
      return type;
    }
    else
    {
      // Otherwise we need to make a reference to it
      return this->ReferenceOf(type);
    }
  }

  //***************************************************************************
  IndirectionType* LibraryBuilder::ReferenceOf(BoundType* type)
  {
    // If the type is a reference type...
    if (type->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Show an error
      Error("It is not legal to get a reference of a non-value type");
      return nullptr;
    }

    // Now attempt to find the qualified type
    IndirectionType*& indirectionType = this->IndirectTypes[type];

    // If we found the type...
    if (indirectionType != nullptr)
    {
      // Return the type we found
      return indirectionType;
    }
    else
    {
      // Create a newly qualified type
      indirectionType = new IndirectionType();

      // Make sure to store a strong reference, since we now own the type
      this->BuiltLibrary->OwnedTypes.push_back(indirectionType);

      // Setup the qualifiers and the true type that it references
      indirectionType->ReferencedType = type;
      indirectionType->UserData = type->UserData;
      indirectionType->SourceLibrary = this->BuiltLibrary.Object;

      // Return the qualified type
      return indirectionType;
    }
  }

  //***************************************************************************
  BoundType* LibraryBuilder::Dereference(IndirectionType* qualifiedType)
  {
    // Just return the referenced type (there can only be one level of indirection
    return qualifiedType->ReferencedType;
  }

  //***************************************************************************
  DelegateType* LibraryBuilder::GetDelegateType(const ParameterArray& parameters, Type* returnType)
  {
    // Create a delegate type and fill it in
    DelegateType* delegateType = new DelegateType();
    delegateType->Parameters = parameters;
    delegateType->Return = returnType;
    delegateType->SourceLibrary = this->BuiltLibrary.Object;

    // Generate names for nameless parameters
    size_t parameterCount = delegateType->Parameters.size();
    for (size_t i = 0; i < parameterCount; ++i)
    {
      // If the parameter already has a name, skip it
      DelegateParameter& parameter = delegateType->Parameters[i];
      if (parameter.Name.empty() == false)
        continue;

      // If there is only one parameter, then use the name 'value'
      if (parameterCount == 1)
      {
        // Value is a nice generic word that can be used in most every situation
        parameter.Name = ValueKeyword;
        parameter.IsNameGenerated = true;
      }
      else
      {
        // Use a special version of the type name as a parameter name
        String lowerCamelName = parameter.ParameterType->GetShortLowerCamelCaseName();
        parameter.Name = String::Format("%s%d", lowerCamelName.c_str(), i);
        parameter.IsNameGenerated = true;
      }
    }

    // Make sure all delegates have returns
    ErrorIf(returnType == nullptr,
      "To mark a delegate/function as having no return, use the void type via ZilchTypeId(void)");

    // Attmpt to find a delegate of the same type
    DelegateType* foundType = this->DelegateTypes.findValue(delegateType, nullptr);

    // If we already had that delegate type...
    if (foundType != nullptr)
    {
      // Delete the temporary delegate we created above to find it
      delete delegateType;

      // Return the one that was already in the set
      return foundType;
    }
    else
    {
      // Make sure to store a strong reference, since we now own the type
      this->BuiltLibrary->OwnedTypes.push_back(delegateType);

      // Add the delegate type to the set
      // (we should never overwrite since we JUST checked that above)
      this->DelegateTypes.insertOrError(delegateType);

      // Return the newly created delegate type
      return delegateType;
    }
  }

  //***************************************************************************
  CodeEntry::CodeEntry() :
    CodeUserData(nullptr)
  {
  }
  
  //***************************************************************************
  size_t CodeEntry::GetHash()
  {
    return this->Code.hash() ^ this->Origin.hash() * 5689;
  }

  //***************************************************************************
  Library::Library() :
    UserData(nullptr),
    GeneratedDefinitionStubCode(false),
    TolerantMode(false)
  {
  }
  
  //***************************************************************************
  void Library::GenerateDefinitionStubCode()
  {
    // If we already generated the stub code, our library should not have changed so early out
    if (this->GeneratedDefinitionStubCode)
      return;
    this->GeneratedDefinitionStubCode = true;

    // Walk through all bound types and generate stub code for each one
    ZilchForEach(BoundType* type, this->BoundTypes.values())
    {
      // Generate stub code for this bound type and set all the native
      // locations for the class/struct, properties, functions, etc
      StubCode stubGenerator;
      stubGenerator.SetNativeLocations = true;
      stubGenerator.GeneratedOriginOrName = BuildString("[", type->Name, "]");
      stubGenerator.Generate(type);
      stubGenerator.Finalize();
    }
  }

  //***************************************************************************
  void VisitBoundType(HashSet<BoundType*>& visitedTypes, BoundType* type, Array<BoundType*>& typesInOrder)
  {
    // If we already visited this type, then skip it
    if (visitedTypes.contains(type))
      return;
    visitedTypes.insert(type);

    // Check if we have a base type, if so visit it first (pretty much the entire point of this!)
    BoundType* base = type->BaseType;
    if (base != nullptr)
      VisitBoundType(visitedTypes, base, typesInOrder);

    // Push back our type (note that base types would have been pushed before ours)
    typesInOrder.push_back(type);
  }
  
  //***************************************************************************
  void Library::GetTypesInDependencyOrder(Array<BoundType*>& typesOut)
  {
    HashSet<BoundType*> visitedTypes;

    // Loop through all types created in this library
    for (size_t i = 0; i < this->OwnedTypes.size(); ++i)
    {
      // Only consider bound types...
      BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(this->OwnedTypes[i]);
      if (boundType == nullptr)
        continue;

      // Visiting a type walks its base types first, and then adds them to the 'typesOut' array
      VisitBoundType(visitedTypes, boundType, typesOut);
    }
  }

  //***************************************************************************
  Library::~Library()
  {
    for (size_t i = 0; i < this->OwnedTypes.size(); ++i)
    {
      Type* type = this->OwnedTypes[i];
      delete type;
    }

    for (size_t i = 0; i < this->OwnedFunctions.size(); ++i)
    {
      Function* function = this->OwnedFunctions[i];
      delete function;
    }

    for (size_t i = 0; i < this->OwnedProperties.size(); ++i)
    {
      Property* property = this->OwnedProperties[i];
      delete property;
    }

    for (size_t i = 0; i < this->OwnedVariables.size(); ++i)
    {
      Variable* variable = this->OwnedVariables[i];
      delete variable;
    }
  }
  
  //***************************************************************************
  Module::Module()
  {
    // Always add the core library (both for the linker, and as a compiler dependence)
    this->push_back(Core::GetInstance().GetLibrary());
  }

  //***************************************************************************
  BoundType* Module::FindType(StringParam name)
  {
    // Loop through all libraries
    for (size_t i = 0; i < this->size(); ++i)
    {
      // Grab the current library
      LibraryRef& library = (*this)[i];

      // Attempt to find the type in this library
      BoundType* type = library->BoundTypes.findValue(name, nullptr);
      
      // If we found the type...
      if (type != nullptr)
        return type;
    }

    // Otherwise we found nothing
    return nullptr;
  }

  //***************************************************************************
  ExecutableState* Module::Link() const
  {
    // Create an executable state to link everything together into
    ExecutableState* state = new ExecutableState();

    // Store references to the dependent libraries we were compiled from
    state->Dependencies = *this;

    // Loop through all dependent libraries
    for (size_t i = 0; i < this->size(); ++i)
    {
      // Grab the current library
      const LibraryRef& library = (*this)[i];

      // Loop through all code entries
      for (size_t j = 0; j < library->Entries.size(); ++j)
      {
        // Grab the current code entry
        CodeEntry* entry = &library->Entries[j];

        // Map the code entry id to the entry itself on the state (we should never collide here!)
        state->CodeHashToCodeEntry.insertNoOverwrite(entry->GetHash(), entry);
      }
    }

    return state;
  }

  //***************************************************************************
  void Module::BuildTypeDocumentation(BoundType* type, DocumentationType* docType)
  {
    // Add the type to the docs
    docType->Name = type->Name;

    // Set the description and remarks
    docType->Description = type->Description;
    docType->Remarks = type->Remarks;

    // If we have a base class, make sure we set it
    if (type->BaseType != nullptr)
    {
      // Set the base type name (we should be able to look it up later)
      docType->BaseName = type->BaseType->Name;
    }

    // If the type is a value type...
    if (type->CopyMode == TypeCopyMode::ValueType)
    {
      docType->IsValueType = true;
    }

    // Get the constructor functions
    this->BuildFunctionDocumentation(docType->Constructors, type->Constructors);

    // Add all instance and static functions to the documentation
    this->BuildFunctionDocumentation(docType->InstanceMethods, type->InstanceFunctions);
    this->BuildFunctionDocumentation(docType->StaticMethods, type->StaticFunctions);

    // Add all the properties and members
    this->BuildPropertyDocumentation(docType->InstanceProperties, type->InstanceFields);
    this->BuildPropertyDocumentation(docType->InstanceProperties, type->InstanceProperties);
    this->BuildPropertyDocumentation(docType->StaticProperties, type->StaticFields);
    this->BuildPropertyDocumentation(docType->StaticProperties, type->StaticProperties);
  }
  
  //***************************************************************************
  bool DocumentationFunctionSorter(DocumentationFunction* left, DocumentationFunction* right)
  {
    // Compare the names with each other
    return left->Name < right->Name;
  }

  //***************************************************************************
  void Module::BuildFunctionDocumentation(Array<DocumentationFunction*>& addTo, const FunctionMultiMap& functions)
  {
    // Get the instance functions
    FunctionMultiValueRange functionArrays = functions.values();

    // Normally it's a map of strings to overloaded functions, so we need to loop through all arrays
    while (functionArrays.empty() == false)
    {
      // Grab the current instance function array and move to the next
      FunctionArray& functionArray = functionArrays.front();
      functionArrays.popFront();

      // Build documentation for those functions
      this->BuildFunctionDocumentation(addTo, functionArray);
    }

    // Sort the methods by name
    sort(addTo.all(), DocumentationFunctionSorter);
  }

  //***************************************************************************
  void Module::BuildFunctionDocumentation(Array<DocumentationFunction*>& addTo, const FunctionArray& functions)
  {
    // Loop through all the functions in an array
    for (size_t i = 0; i < functions.size(); ++i)
    {
      // Grab the current function
      Function* function = functions[i];

      // Skip the special getter and setter functions (those are documented by properties)
      if (function->IsPropertyGetOrSet)
        continue;

      // Create the function's documentation
      DocumentationFunction* docFunction = new DocumentationFunction();
      docFunction->Name = function->Name;

      // Set the description and remarks
      docFunction->Description = function->Description;
      docFunction->Remarks = function->Remarks;

      // Add the doc function to the array
      addTo.push_back(docFunction);

      // Create the signature for the function
      docFunction->Signature = function->FunctionType->GetSignatureString();

      // Get the return type of the function
      docFunction->ReturnType = function->FunctionType->Return->ToString();

      // Get the parameters for the function we're binding
      ParameterArray& parameters = function->FunctionType->Parameters;
      
      // Loop through all the parameters
      for (size_t j = 0; j < parameters.size(); ++j)
      {
        // Grab the current parameter
        DelegateParameter& parameter = parameters[j];

        // Create a documentation mirrored parameter to describe it
        DocumentationParameter* docParameter = new DocumentationParameter();
        docParameter->Name = parameter.Name;
        docParameter->Type = parameter.ParameterType->ToString();

        // Add it to the documentation function
        docFunction->Parameters.push_back(docParameter);
      }

      // If this function is a constructor, it has no description, and it takes no arguments (defaulted)...
      if (function->Name == ConstructorName && docFunction->Description.empty() && docFunction->Parameters.empty())
      {
        // Set the description to something special
        docFunction->Description = "*Default constructor*";
      }
    }
  }

  //***************************************************************************
  void Module::BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const FieldMap& members)
  {
    // Get a range of all the properties
    FieldMapValueRange range = members.values();

    // Walk through all the properties
    while (range.empty() == false)
    {
      // Get the current property and move forward
      Field* field = range.front();
      range.popFront();

      // Build documentation for the property
      this->BuildPropertyDocumentation(addTo, field);
    }
  }

  //***************************************************************************
  bool DocumentationPropertySorter(DocumentationProperty* left, DocumentationProperty* right)
  {
    // Compare the names with each other
    return left->Name < right->Name;
  }

  //***************************************************************************
  void Module::BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const PropertyMap& properties)
  {
    // Get a range of all the properties
    PropertyMapValueRange range = properties.values();

    // Walk through all the properties
    while (range.empty() == false)
    {
      // Get the current property and move forward
      Property* property = range.front();
      range.popFront();

      // Build documentation for the property
      this->BuildPropertyDocumentation(addTo, property);
    }

    // Sort the instance properties by name
    sort(addTo.all(), DocumentationPropertySorter);
  }

  //***************************************************************************
  void Module::BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const Property* property)
  {
    // Create the documentation property to represent the property
    DocumentationProperty* docProperty = new DocumentationProperty();
    docProperty->Name = property->Name;
    docProperty->IsGettable = (property->Get != nullptr);
    docProperty->IsSettable = (property->Set != nullptr);
    docProperty->IsField = (TypeBinding::DynamicCast<const Field*>(property) != nullptr);
    docProperty->Type = property->PropertyType->ToString();

    // Set the description and remarks
    docProperty->Description = property->Description;
    docProperty->Remarks = property->Remarks;

    // Add the property to the array
    addTo.push_back(docProperty);
  }

  //***************************************************************************
  bool DocumentationTypeSorter(DocumentationType* left, DocumentationType* right)
  {
    // Compare the names with each other
    return left->Name < right->Name;
  }

  //***************************************************************************
  DocumentationModule* Module::BuildDocumentation()
  {
    // Create the documentation module object
    DocumentationModule* docs = new DocumentationModule();

    // Loop through all the libraries
    for (size_t i = 0; i < this->size(); ++i)
    {
      // Grab the current library
      LibraryRef& library = (*this)[i];
      
      // Create a documentation object that represents a library
      DocumentationLibrary* docLibrary = new DocumentationLibrary();
      docLibrary->Name = library->Name;

      // Add the library to the docs
      docs->Libraries.push_back(docLibrary);
      
      // Loop through all the types in the library
      BoundTypeValueRange typeRange = library->BoundTypes.values();
      while (typeRange.empty() == false)
      {
        // Grab the current type
        BoundType* type = typeRange.front();
        typeRange.popFront();

        // Add the type to the docs
        DocumentationType* docType = new DocumentationType();

        // Add the type to the documentation for the library
        docLibrary->TypesSorted.push_back(docType);
        docLibrary->TypesByName.insert(type->Name, docType);

        // Build the documentation for this type
        this->BuildTypeDocumentation(type, docType);
      }

      // Create a temporary library builder to build templates
      LibraryBuilder builder("Documenation");

      // Loop through all template handlers, instantiate them as templates that take the 'Any' type
      HashMap<String, InstantiateTemplateInfo>::valuerange templates = library->TemplateHandlers.values();
      while (templates.empty() == false)
      {
        // Get the current template and move to the next one
        InstantiateTemplateInfo& templateInfo = templates.front();
        templates.popFront();

        // We attempt to instantiate the template using fake types
        // TODO: Create full typedefs of the Any type
        Array<Type*> arguments;
        for (size_t i = 0; i < templateInfo.TemplateArgumentNames.size(); ++i)
        {
          String argumentName = templateInfo.TemplateArgumentNames[i];
          BoundType* fakeType = builder.BoundTypes.findValue(argumentName, nullptr);

          if (fakeType == nullptr)
            fakeType = builder.AddBoundType(templateInfo.TemplateArgumentNames[i], TypeCopyMode::ReferenceType, 0);

          arguments.push_back(fakeType);
        }

        InstantiatedTemplate finalTemplate = builder.InstantiateTemplate(templateInfo.BaseName, arguments, *this);

        if (finalTemplate.Result == TemplateResult::Success)
        {
          BoundType* type = finalTemplate.Type;

          // Add the type to the docs
          DocumentationType* docType = new DocumentationType();

          // Add the type to the documentation for the library
          docLibrary->TypesSorted.push_back(docType);
          docLibrary->TypesByName.insert(type->Name, docType);

          // Build the documentation for this type
          this->BuildTypeDocumentation(type, docType);
        }
      }

      // Sort the types by name
      sort(docLibrary->TypesSorted.all(), DocumentationTypeSorter);
    }

    // Return the newly created documentation module
    return docs;
  }
  
  //***************************************************************************
  void Module::BuildJsonConstructors(JsonBuilder& json, const Array<DocumentationFunction*>& constructors, StringParam name)
  {
    // Early out if we have no functions
    if (constructors.empty())
      return;

    json.Key(name);
    json.Begin(JsonType::Object);
    {
      json.Key("columns");
      json.Begin(JsonType::ArraySingleLine);
      json.Value("Signature");
      json.Value("Description");
      json.End();

      json.Key("rows");
      json.Begin(JsonType::ArrayMultiLine);
      for (size_t i = 0; i < constructors.size(); ++i)
      {
        DocumentationFunction* constructor = constructors[i];

        json.Begin(JsonType::ArraySingleLine);
        json.Value(BuildString("constructor", constructor->Signature));
        json.Value(constructor->Description);
        json.End();
      }
      json.End();
    }
    json.End();
  }

  //***************************************************************************
  void Module::BuildJsonMethods(JsonBuilder& json, const Array<DocumentationFunction*>& functions, StringParam name)
  {
    // Early out if we have no functions
    if (functions.empty())
      return;

    json.Key(name);
    json.Begin(JsonType::Object);
    {
      json.Key("columns");
      json.Begin(JsonType::ArraySingleLine);
      json.Value("Name / Signature");
      json.Value("Description");
      json.End();

      json.Key("rows");
      json.Begin(JsonType::ArrayMultiLine);
      for (size_t i = 0; i < functions.size(); ++i)
      {
        DocumentationFunction* function = functions[i];

        json.Begin(JsonType::ArraySingleLine);
        json.Value(BuildString(function->Name, function->Signature));
        json.Value(function->Description);
        json.End();
      }
      json.End();
    }
    json.End();
  }
  
  //***************************************************************************
  void Module::BuildJsonProperties(JsonBuilder& json, const Array<DocumentationProperty*>& properties, StringParam name)
  {
    // Early out if we have no functions
    if (properties.empty())
      return;

    json.Key(name);
    json.Begin(JsonType::Object);

    {
      json.Key("columns");
      json.Begin(JsonType::ArraySingleLine);
      json.Value("Name");
      json.Value("Type");
      json.Value("Description");
      json.End();

      json.Key("rows");
      json.Begin(JsonType::ArrayMultiLine);
      for (size_t i = 0; i < properties.size(); ++i)
      {
        DocumentationProperty* property = properties[i];

        json.Begin(JsonType::ArraySingleLine);
        json.Value(property->Name);
        json.Value(property->Type);
        json.Value(property->Description);
        json.End();
      }
      json.End();
    }
    json.End();
  }
  
  //***************************************************************************
  void BuildBaseChain(StringBuilderExtended& builder, DocumentationLibrary* library, DocumentationType* type)
  {
    if (type->BaseName.empty())
      return;

    DocumentationType* baseType = library->TypesByName[type->BaseName];

    BuildBaseChain(builder, library, baseType);

    builder.Write(baseType->Name);
    builder.Write(" |rarr| ");
  }

  //***************************************************************************
  void Module::BuildDocumentationRst(StringParam directory)
  {
    DocumentationModule* docs = this->BuildDocumentation();

    for (size_t i = 0; i < docs->Libraries.size(); ++i)
    {
      DocumentationLibrary* library = docs->Libraries[i];

      for (size_t j = 0; j < library->TypesSorted.size(); ++j)
      {
        RstBuilder builder;

        builder.WriteLine(".. include:: <isonum.txt>");
        builder.WriteLine();

        DocumentationType* type = library->TypesSorted[j];

        BuildBaseChain(builder, library, type);
        builder.WriteLine();
        builder.WriteLine();
        
        builder.WriteLineHeading(type->Name, RstHeadingType::Section);

        builder.Write("  ");
        builder.Write(type->Description);

        if (type->Description.empty() == false)
          builder.Write(" ");

        if (type->IsValueType)
          builder.WriteLine("(struct)");
        else
          builder.WriteLine("(class)");

        builder.WriteLine();

        if (type->Remarks.empty() == false)
        {
          builder.WriteLineHeading("Remarks", RstHeadingType::SubSection);
        
          for (size_t i = 0; i < type->Remarks.size(); ++i)
          {
            builder.Write("  ");
            builder.WriteLine(type->Remarks[i]);
          }
          builder.WriteLine();
        }
        
        if (type->Constructors.empty() == false)
        {
          builder.WriteLineHeading("Constructors", RstHeadingType::SubSection);

          RstTable table;
          table.Resize(2, type->Constructors.size() + 1);
          table.HeaderRows = 1;
          table.SetCell("Signature", 0, 0);
          table.SetCell("Row", 1, 0);

          for (size_t i = 0; i < type->Constructors.size(); ++i)
          {
            DocumentationFunction* function = type->Constructors[i];
            
            table.SetCell(function->Signature, 0, i + 1);
            table.SetCell(function->Description, 1, i + 1);
          }

          builder.WriteLine(table);
          builder.WriteLine();
        }

        if (type->InstanceProperties.empty() == false)
        {
          builder.WriteLineHeading("Instance Properties", RstHeadingType::SubSection);

          RstTable table;
          table.Resize(3, type->InstanceProperties.size() + 1);
          table.HeaderRows = 1;
          table.SetCell("Name", 0, 0);
          table.SetCell("Type", 1, 0);
          table.SetCell("Description", 2, 0);

          for (size_t i = 0; i < type->InstanceProperties.size(); ++i)
          {
            DocumentationProperty* property = type->InstanceProperties[i];

            String typeLink = BuildString(":doc:`", property->Type, "`");
            
            table.SetCell(property->Name, 0, i + 1);
            table.SetCell(typeLink, 1, i + 1);
            table.SetCell(property->Description, 2, i + 1);
          }

          builder.WriteLine(table);
          builder.WriteLine();
        }

        if (type->StaticProperties.empty() == false)
        {
          builder.WriteLineHeading("Static Properties", RstHeadingType::SubSection);

          RstTable table;
          table.Resize(3, type->StaticProperties.size() + 1);
          table.HeaderRows = 1;
          table.SetCell("Name", 0, 0);
          table.SetCell("Type", 1, 0);
          table.SetCell("Description", 2, 0);

          for (size_t i = 0; i < type->StaticProperties.size(); ++i)
          {
            DocumentationProperty* property = type->StaticProperties[i];

            String typeLink = BuildString(":doc:`", property->Type, "`");
            
            table.SetCell(property->Name, 0, i + 1);
            table.SetCell(typeLink, 1, i + 1);
            table.SetCell(property->Description, 2, i + 1);
          }

          builder.WriteLine(table);
          builder.WriteLine();
        }
        
        
        if (type->InstanceMethods.empty() == false)
        {
          builder.WriteLineHeading("Instance Methods", RstHeadingType::SubSection);

          RstTable table;
          table.Resize(2, type->InstanceMethods.size() + 1);
          table.HeaderRows = 1;
          table.SetCell("Name / Signature", 0, 0);
          table.SetCell("Description", 1, 0);

          for (size_t i = 0; i < type->InstanceMethods.size(); ++i)
          {
            DocumentationFunction* function = type->InstanceMethods[i];

            String nameAndSignature = BuildString(function->Name, function->Signature);

            table.SetCell(nameAndSignature, 0, i + 1);
            table.SetCell(function->Description, 1, i + 1);
          }

          builder.WriteLine(table);
          builder.WriteLine();
        }
        
        if (type->StaticMethods.empty() == false)
        {
          builder.WriteLineHeading("Static Methods", RstHeadingType::SubSection);

          RstTable table;
          table.Resize(2, type->StaticMethods.size() + 1);
          table.HeaderRows = 1;
          table.SetCell("Name / Signature", 0, 0);
          table.SetCell("Description", 1, 0);

          for (size_t i = 0; i < type->StaticMethods.size(); ++i)
          {
            DocumentationFunction* function = type->StaticMethods[i];

            String nameAndSignature = BuildString(function->Name, function->Signature);

            table.SetCell(nameAndSignature, 0, i + 1);
            table.SetCell(function->Description, 1, i + 1);
          }

          builder.WriteLine(table);
          builder.WriteLine();
        }

        String typeRst = builder.ToString();

        //HACK should be using file path stuff (platform agnostic!)
        String rstFileName = BuildString(directory, "\\", type->Name, ".rst");
        
        Zero::WriteToFile(rstFileName.c_str(), (byte*)typeRst.c_str(), typeRst.size());
      }
    }
  }
  
  //***************************************************************************
  String Module::BuildDocumentationHtml()
  {
    JsonBuilder json;

    DocumentationModule* docs = this->BuildDocumentation();

    json.Begin(JsonType::Object);

    json.Key("start");
    json.Value("GettingStarted");

    {
      json.Key("libraries");
      json.Begin(JsonType::Object);

      for (size_t i = 0; i < docs->Libraries.size(); ++i)
      {
        DocumentationLibrary* library = docs->Libraries[i];

        json.Key(library->Name);
        json.Begin(JsonType::Object);

        {
          json.Key("types");
          json.Begin(JsonType::Object);

          for (size_t j = 0; j < library->TypesSorted.size(); ++j)
          {
            DocumentationType* type = library->TypesSorted[j];
            
            json.Key(type->Name);
            json.Begin(JsonType::Object);

            {
              json.Key("base");
              json.Value(type->BaseName);
              json.Key("description");
              json.Value(type->Description);
              json.Key("isValueType");
              json.Value(type->IsValueType);
              json.Key("remarks");
              json.Begin(JsonType::ArrayMultiLine);

              {
                for (size_t k = 0; k < type->Remarks.size(); ++k)
                {
                  String& remark = type->Remarks[k];

                  json.Value(remark);
                }
              }

              json.End();

              json.Key("tables");
              json.Begin(JsonType::Object);
              {
                this->BuildJsonConstructors(json, type->Constructors, "Constructors");

                this->BuildJsonMethods(json, type->InstanceMethods, "Instance Methods");
                this->BuildJsonMethods(json, type->StaticMethods, "Static Methods");
                
                this->BuildJsonProperties(json, type->InstanceProperties, "Instance Properties");
                this->BuildJsonProperties(json, type->StaticProperties, "Static Properties");
              }
              json.End();
            }


            json.End();
          }

          json.End();
        }

        json.End();
      }

      // End the libraries
      json.End();
    }

    // End the module
    json.End();

    return json.ToString();
  }

  //***************************************************************************
  InstantiatedTemplate::InstantiatedTemplate() :
    Type(nullptr),
    Result(TemplateResult::FailedInstantiatorDidNotReturnType),
    ExpectedArguments(0)
  {
  }

  //***************************************************************************
  ParameterArray OneParameter(Type* type)
  {
    ParameterArray parameters;
    parameters.push_back(type);
    return parameters;
  }

  //***************************************************************************
  ParameterArray OneParameter(Type* type, StringParam name)
  {
    ParameterArray parameters;

    DelegateParameter& a = parameters.push_back();
    a.Name = name;
    a.ParameterType = type;

    return parameters;
  }

  //***************************************************************************
  ParameterArray TwoParameters(Type* type)
  {
    ParameterArray parameters;
    parameters.push_back(type);
    parameters.push_back(type);
    return parameters;
  }

  //***************************************************************************
  ParameterArray TwoParameters(Type* type, StringParam name1, StringParam name2)
  {
    ParameterArray parameters;

    DelegateParameter& a = parameters.push_back();
    a.Name = name1;
    a.ParameterType = type;

    DelegateParameter& b = parameters.push_back();
    b.Name = name2;
    b.ParameterType = type;

    return parameters;
  }

  //***************************************************************************
  ParameterArray TwoParameters(Type* type1, Type* type2)
  {
    ParameterArray parameters;
    parameters.push_back(type1);
    parameters.push_back(type2);
    return parameters;
  }

  //***************************************************************************
  ParameterArray TwoParameters(Type* type1, StringParam name1, Type* type2, StringParam name2)
  {
    ParameterArray parameters;

    DelegateParameter& a = parameters.push_back();
    a.Name = name1;
    a.ParameterType = type1;

    DelegateParameter& b = parameters.push_back();
    b.Name = name2;
    b.ParameterType = type2;

    return parameters;
  }

  //***************************************************************************
  ParameterArray ThreeParameters(Type* type)
  {
    ParameterArray parameters;
    parameters.push_back(type);
    parameters.push_back(type);
    parameters.push_back(type);
    return parameters;
  }

  //***************************************************************************
  ParameterArray ThreeParameters(Type* type1, StringParam name1, Type* type2, StringParam name2, Type* type3, StringParam name3)
  {
    ParameterArray parameters;

    DelegateParameter& a = parameters.push_back();
    a.Name = name1;
    a.ParameterType = type1;

    DelegateParameter& b = parameters.push_back();
    b.Name = name2;
    b.ParameterType = type2;

    DelegateParameter& c = parameters.push_back();
    c.Name = name3;
    c.ParameterType = type3;

    return parameters;
  }

  //***************************************************************************
  ParameterArray ThreeParameters(Type* type, StringParam name1, StringParam name2, StringParam name3)
  {
    ParameterArray parameters;

    DelegateParameter& a = parameters.push_back();
    a.Name = name1;
    a.ParameterType = type;

    DelegateParameter& b = parameters.push_back();
    b.Name = name2;
    b.ParameterType = type;

    DelegateParameter& c = parameters.push_back();
    c.Name = name3;
    c.ParameterType = type;

    return parameters;
  }

  //***************************************************************************
  ParameterArray ThreeParameters(Type* type1, Type* type2, Type* type3)
  {
    ParameterArray parameters;
    parameters.push_back().ParameterType = type1;
    parameters.push_back().ParameterType = type2;
    parameters.push_back().ParameterType = type3;
    return parameters;
  }
  
  //***************************************************************************
  ParameterArray FourParameters(Type* type)
  {
    ParameterArray parameters;
    parameters.push_back().ParameterType = type;
    parameters.push_back().ParameterType = type;
    parameters.push_back().ParameterType = type;
    parameters.push_back().ParameterType = type;
    return parameters;
  }
  
  //***************************************************************************
  ParameterArray FourParameters(Type* type, StringParam name1, StringParam name2, StringParam name3, StringParam name4)
  {
    ParameterArray parameters;

    DelegateParameter& a = parameters.push_back();
    a.Name = name1;
    a.ParameterType = type;

    DelegateParameter& b = parameters.push_back();
    b.Name = name2;
    b.ParameterType = type;

    DelegateParameter& c = parameters.push_back();
    c.Name = name3;
    c.ParameterType = type;

    DelegateParameter& d = parameters.push_back();
    d.Name = name4;
    d.ParameterType = type;

    return parameters;
  }
  
  //***************************************************************************
  ParameterArray FiveParameters(Type* type)
  {
    ParameterArray parameters;
    parameters.push_back().ParameterType = type;
    parameters.push_back().ParameterType = type;
    parameters.push_back().ParameterType = type;
    parameters.push_back().ParameterType = type;
    parameters.push_back().ParameterType = type;
    return parameters;
  }
  
  //***************************************************************************
  ParameterArray FiveParameters(Type* type, StringParam name1, StringParam name2, StringParam name3, StringParam name4, StringParam name5)
  {
    ParameterArray parameters;

    DelegateParameter& a = parameters.push_back();
    a.Name = name1;
    a.ParameterType = type;

    DelegateParameter& b = parameters.push_back();
    b.Name = name2;
    b.ParameterType = type;

    DelegateParameter& c = parameters.push_back();
    c.Name = name3;
    c.ParameterType = type;

    DelegateParameter& d = parameters.push_back();
    d.Name = name4;
    d.ParameterType = type;

    DelegateParameter& e = parameters.push_back();
    e.Name = name5;
    e.ParameterType = type;

    return parameters;
  }

  ////***************************************************************************
  //ExtensionPropertyMapRange::ExtensionPropertyMapRange(LibraryArray& libraries, bool isStatic, Type* type) :
  //  CurrentMap(nullptr),
  //  LibraryIndex(0),
  //  BaseIterator(type),
  //  Libraries(libraries),
  //  IsStatic(isStatic),
  //  ExtensionType(type)
  //{
  //}

  ////***************************************************************************
  //void ExtensionPropertyMapRange::popFront()
  //{

  //}

  ////***************************************************************************
  //void ExtensionPropertyMapRange::UpdateCurrentMap()
  //{
  //  LibraryRef& library = this->Libraries[this->LibraryIndex];

  //  // Get the guid of the type (this should be legal here since we've collected all members)
  //  GuidType guid = this->BaseIterator->Hash();
  //  
  //  // Get the array of properties (may be empty)
  //  PropertyMap* properties = nullptr;
  //      
  //  // If we're resolving a static member
  //  if (this->IsStatic)
  //  {
  //    properties = library->StaticExtensionProperties.findPointer(guid);
  //  }
  //  else
  //  {
  //    properties = library->InstanceExtensionProperties.findPointer(guid);
  //  }

  //  // If we got a valid array of properties...
  //  if (properties != nullptr)
  //  {
  //    return properties;
  //  }
  //}

  ////***************************************************************************
  //PropertyMap* ExtensionPropertyMapRange::front()
  //{

  //    // We need to look up the entire heirarchy (the property could be on any base classes)
  //    Type* baseIterator = type;
  //    while (baseIterator != nullptr)
  //    {


  //      
  //        
  //      // Iterate to the next type
  //      baseIterator = Type::GetBaseType(baseIterator);
  //    }
  //}
}
/**************************************************************\
* Author: Joshua Davis
* Copyright 2014, DigiPen Institute of Technology
\**************************************************************/

// Includes






namespace Zilch
{
  //***************************************************************************
  // Helper functions to Index into a matrix while allowing them to be row or column basis
  byte* IndexIntoMatrix(byte* memory, size_t indexX, size_t indexY, size_t sizeX, size_t sizeY, size_t elementSize)
  {
#if ColumnBasis == 1
    return memory + (indexX + indexY * sizeX) * elementSize;
#else
    return memory + (indexY + indexX * sizeY) * elementSize;
#endif
  }
  
  const byte* IndexIntoMatrix(const byte* memory, size_t indexX, size_t indexY, size_t sizeX, size_t sizeY, size_t elementSize)
  {
#if ColumnBasis == 1
    return memory + (indexX + indexY * sizeX) * elementSize;
#else
    return memory + (indexY + indexX * sizeY) * elementSize;
#endif
  }
  
  //***************************************************************************
  bool ValidateMatrixIndices(size_t x, size_t y, size_t sizeX, size_t sizeY, Call& call, ExceptionReport& report)
  {
    // Make sure the indices are within range
    if (y >= sizeY)
    {
      call.GetState()->ThrowException(report, String::Format("The y index used to access a component of a matrix was out of range [0-%d]", sizeY - 1));
      return false;
    }
    if (x >= sizeX)
    {
      call.GetState()->ThrowException(report, String::Format("The x index used to access a component of a matrix was out of range [0-%d]", sizeX - 1));
      return false;
    }

    return true;
  }
  
  //***************************************************************************
  void MultiplyAddReal(byte* outData, byte* inputA, byte* inputB)
  {
    Real& out = *(Real*)outData;
    Real& a = *(Real*)inputA;
    Real& b = *(Real*)inputB;
    out += a * b;
  }
  
  //***************************************************************************
  void MultiplyAddInteger(byte* outData, byte* inputA, byte* inputB)
  {
    Integer& out = *(Integer*)outData;
    Integer& a = *(Integer*)inputA;
    Integer& b = *(Integer*)inputB;
    out += a * b;
  }
  
  //***************************************************************************
  void MultiplyAddBoolean(byte* outData, byte* inputA, byte* inputB)
  {
    Boolean& out = *(Boolean*)outData;
    Boolean& a = *(Boolean*)inputA;
    Boolean& b = *(Boolean*)inputB;
    out = out || (a && b);
  }
  
  //***************************************************************************
  String MatrixToString(const BoundType* type, const byte* data)
  {
    MatrixUserData& userData = type->ComplexUserData.ReadObject<MatrixUserData>(0);
    Core& core = Core::GetInstance();
    //get the type of the matrix (Real, etc...)
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    StringBuilder builder;
    builder.Append("[");
    for (size_t y = 0; y < userData.SizeY; ++y)
    {
      builder.Append("(");
      for (size_t x = 0; x < userData.SizeX; ++x)
      {
        const byte* item = IndexIntoMatrix(data, x, y, userData.SizeX, userData.SizeY, elementType->Size);

        builder.Append(elementType->GenericToString(item));

        //don't add a comma after the last item
        if (x != userData.SizeX - 1)
          builder.Append(", ");
      }

      builder.Append(")");
      //don't add a comma after the last item
      if (y != userData.SizeY - 1)
        builder.Append(", ");
    }
    builder.Append("]");
    return builder.ToString();
  }
  
  //***************************************************************************
  void MatrixDefaultConstructor(Call& call, ExceptionReport& report)
  {
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // Get ourselves (the matrix)
    byte* memory = call.GetHandle(Call::This).Dereference();
    // Zero out the matrix memory
    memset(memory, 0, userData.SizeX * userData.SizeY * elementType->Size);
  }
  
  //***************************************************************************
  void MatrixConstructor(Call& call, ExceptionReport& report)
  {
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // Get ourselves (the matrix)
    byte* matrixData = call.GetHandle(Call::This).Dereference();
    byte* parameters = call.GetParametersUnchecked();
    for (size_t y = 0; y < userData.SizeY; ++y)
    {
      for (size_t x = 0; x < userData.SizeX; ++x)
      {
        byte* matrixItem = IndexIntoMatrix(matrixData, x, y, userData.SizeX, userData.SizeY, elementType->Size);
        byte* parameterItem = parameters + (x + y * userData.SizeX) * elementType->Size;
        
        memcpy(matrixItem, parameterItem, elementType->Size);
      }
    }
  }
  
  //***************************************************************************
  void MatrixGet(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

    // Read the index off the stack
    Integer indexY = call.Get<Integer>(0);
    Integer indexX = call.Get<Integer>(1);

    // Make sure the indices are correct
    if (ValidateMatrixIndices(indexX, indexY, userData.SizeX, userData.SizeY, call, report) == false)
      return;

    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // Get ourselves (the matrix)
    byte* memory = call.GetHandle(Call::This).Dereference();

    // Index to the item we are getting and set the return to that
    byte* item = IndexIntoMatrix(memory, indexX, indexY, userData.SizeX, userData.SizeY, elementType->Size);
    byte* returnData = call.GetReturnUnchecked();
    elementType->GenericCopyConstruct(returnData, item);
  }
  
  //***************************************************************************
  void MatrixSet(Call& call, ExceptionReport& report)
  {
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

    // Read the index off the stack
    Integer indexY = call.Get<Integer>(0);
    Integer indexX = call.Get<Integer>(1);

    // Make sure the indices are correct
    if (ValidateMatrixIndices(indexX, indexY, userData.SizeX, userData.SizeY, call, report) == false)
      return;

    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // Get ourselves (the matrix)
    byte* memory = call.GetHandle(Call::This).Dereference();

    // Index to the item in the matrix and set it to the passed in value
    byte* setData = call.GetParameterUnchecked(2);
    byte* item = IndexIntoMatrix(memory, indexX, indexY, userData.SizeX, userData.SizeY, elementType->Size);
    elementType->GenericCopyConstruct(item, setData);
  }

  //***************************************************************************
  void MatrixGetByIndex(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

    // Read the index off the stack
    Integer index = call.Get<Integer>(0);

    size_t totalCount = userData.SizeX * userData.SizeY;
    if(index >= (Integer)totalCount)
    {
      call.GetState()->ThrowException(report, String::Format("The index used to access a component of a matrix was out of the range [0-%d]", totalCount - 1));
      return;
    }

    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // Get ourselves (the matrix)
    byte* memory = call.GetHandle(Call::This).Dereference();

    // Index to the item we are getting and set the return to that
    byte* item = memory + index * elementType->Size;
    byte* returnData = call.GetReturnUnchecked();
    elementType->GenericCopyConstruct(returnData, item);
  }
  
  //***************************************************************************
  void MatrixSetByIndex(Call& call, ExceptionReport& report)
  {
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

    // Read the index off the stack
    Integer index = call.Get<Integer>(0);

    size_t totalCount = userData.SizeX * userData.SizeY;
    if(index >= (Integer)totalCount)
    {
      call.GetState()->ThrowException(report, String::Format("The index used to access a component of a matrix was out of the range [0-%d]", totalCount - 1));
      return;
    }

    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // Get ourselves (the matrix)
    byte* memory = call.GetHandle(Call::This).Dereference();

    // Index to the item in the matrix and set it to the passed in value
    byte* setData = call.GetParameterUnchecked(1);
    byte* item = memory + index * elementType->Size;
    elementType->GenericCopyConstruct(item, setData);
  }
  
  //***************************************************************************
  void MatrixGetVector(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

    // Read the index off the stack
    Integer indexY = call.Get<Integer>(0);

    if (indexY < 0 || indexY >= (Integer)userData.SizeY)
    {
      call.GetState()->ThrowException(report, String::Format("The y index used to access a component of a matrix was out of range [0-%d]", userData.SizeY - 1));
      return;
    }

    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // Get ourselves (the matrix)
    byte* memory = call.GetHandle(Call::This).Dereference();
    byte* returnData = call.GetReturnUnchecked();

    for (size_t indexX = 0; indexX < userData.SizeX; ++indexX)
    {
      // Index to the item we are getting and set the return to that
      byte* matrixItem = IndexIntoMatrix(memory, indexX, indexY, userData.SizeX, userData.SizeY, elementType->Size);
      byte* returnItem = returnData + indexX * elementType->Size;

      memcpy(returnItem, matrixItem, elementType->Size);
    }
  }
  
  //***************************************************************************
  void MatrixSetVector(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

    // Read the index off the stack
    Integer indexY = call.Get<Integer>(0);

    if (indexY < 0 || indexY >= (Integer)userData.SizeY)
    {
      call.GetState()->ThrowException(report, String::Format("The y index used to access a component of a matrix was out of range [0-%d]", userData.SizeY - 1));
      return;
    }

    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // Get ourselves (the matrix)
    byte* memory = call.GetHandle(Call::This).Dereference();
    byte* vectorData = call.GetParameterUnchecked(1);

    for (size_t indexX = 0; indexX < userData.SizeX; ++indexX)
    {
      // Index to the item we are getting and set the return to that
      byte* vectorItem = vectorData + indexX * elementType->Size;
      byte* matrixItem = IndexIntoMatrix(memory, indexX, indexY, userData.SizeX, userData.SizeY, elementType->Size);
      
      memcpy(matrixItem, vectorItem, elementType->Size);
    }
  }
  
  //***************************************************************************
  void MatrixCount(Call& call, ExceptionReport& report)
  {
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
    call.Set(Call::Return, (Integer)(userData.SizeX * userData.SizeY));
  }

  //***************************************************************************
  void MatrixCountX(Call& call, ExceptionReport& report)
  {
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
    call.Set(Call::Return, (Integer)userData.SizeX);
  }
  
  //***************************************************************************
  void MatrixCountY(Call& call, ExceptionReport& report)
  {
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
    call.Set(Call::Return, (Integer)userData.SizeY);
  }
  
  //***************************************************************************
  void MatrixTranspose(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];
    
    byte* inMatrix = call.GetParameterUnchecked(0);
    byte* outMatrix = call.GetReturnUnchecked();

    // Swap the x and y elements
    for (size_t y = 0; y < userData.SizeY; ++y)
    {
      for (size_t x = 0; x < userData.SizeX; ++x)
      {
        byte* inputElement = IndexIntoMatrix(inMatrix, x, y, userData.SizeX, userData.SizeY, elementType->Size);
        byte* outputElement = IndexIntoMatrix(outMatrix, y, x, userData.SizeY, userData.SizeX, elementType->Size);

        elementType->GenericCopyConstruct(outputElement, inputElement);
      }
    }
  }
  
  //***************************************************************************
  // Only doing the determinant for RealNxN matrices
  // (by just calling the math library's matrix functions)
  template <typename MatrixType>
  void RealMatrixDeterminant(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();

    byte* inMatrix = call.GetParameterUnchecked(0);
    Real* output = (Real*)call.GetReturnUnchecked();

    MatrixType mat((Real*)inMatrix);
    *output = mat.Determinant();
  }

  //***************************************************************************
  // Only doing the determinant for RealNxN matrices
  // (by just calling the math library's matrix functions)
  template <typename MatrixType>
  void RealMatrixInverse(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();

    byte* inMatrix = call.GetParameterUnchecked(0);
    byte* output = call.GetReturnUnchecked();

    MatrixType mat((Real*)inMatrix);
    MatrixType result = mat.Inverted();
    memcpy(output, &result, sizeof(MatrixType));
  }
  
  //***************************************************************************
  void MatrixEqual(Call& call, ExceptionReport& report)
  {
    // This should eventually be the innards of operator== and return a bool matrix,
    // but for usage in unit tests this is implemented to verify results
    MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    Handle& selfHandle = call.GetHandle(Call::This);
    byte* matrixA = (byte*)selfHandle.Dereference();
    byte* matrixB = call.GetParameterUnchecked(0);

    // See if all the elements in the matrices are equal
    bool IsEqual = true;
    for (size_t y = 0; y < userData.SizeY; ++y)
    {
      for (size_t x = 0; x < userData.SizeX; ++x)
      {
        byte* elementA = IndexIntoMatrix(matrixA, x, y, userData.SizeX, userData.SizeY, elementType->Size);
        byte* elementB = IndexIntoMatrix(matrixB, x, y, userData.SizeX, userData.SizeY, elementType->Size);

        bool result = memcmp(elementA, elementB, elementType->Size) == 0;
        IsEqual &= result;
      }
    }

    call.Set(Call::Return, IsEqual);
  }
  
  //***************************************************************************
  // Special user data for the transform function. This needs the
  // dimensionality of both matrices as well as the data type.
  class MatrixTransformUserData
  {
  public:
    MatrixTransformUserData(size_t matrix0SizeX, size_t matrix0SizeY,
                            size_t matrix1SizeX, size_t matrix1SizeY,
                            size_t elementTypeIndex) :
      Matrix0SizeX(matrix0SizeX),
      Matrix0SizeY(matrix0SizeY), 
      Matrix1SizeX(matrix1SizeX),
      Matrix1SizeY(matrix1SizeY), 
      ElementTypeIndex(elementTypeIndex)
    {
    }

    size_t Matrix0SizeX;
    size_t Matrix0SizeY;
    size_t Matrix1SizeX;
    size_t Matrix1SizeY;
    size_t ElementTypeIndex;
  };
  
  //***************************************************************************
  void MatrixTransform(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();
    MatrixTransformUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixTransformUserData>(0);
    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // We flip the matrix order in the function so it reads nicer (Transform(the, by))
    // but to do the math we need to flip them back to the right order
    byte* matrix0 = call.GetParameterUnchecked(0);
    byte* matrix1 = call.GetParameterUnchecked(1);
    byte* returnMatrix = call.GetReturnUnchecked();
    
    for (size_t matrix0Y = 0; matrix0Y < userData.Matrix0SizeY; ++matrix0Y)
    {
      for (size_t matrix1X = 0; matrix1X < userData.Matrix1SizeX; ++matrix1X)
      {
        byte* returnElement = IndexIntoMatrix(returnMatrix, matrix1X, matrix0Y, userData.Matrix1SizeX, userData.Matrix1SizeY, elementType->Size);
        // To properly accumulate the multiplications the initial value first needs to be zeroed out
        memset(returnElement, 0, elementType->Size);

        for (size_t matrix1Y = 0; matrix1Y < userData.Matrix1SizeY; ++matrix1Y)
        {
          // The x of matrix 0 and the y of matrix 1 are the
          // same (just make this variable for clarity)
          size_t matrix0X = matrix1Y;

          byte* matrix0Element = IndexIntoMatrix(matrix0, matrix0X, matrix0Y, userData.Matrix0SizeX, userData.Matrix0SizeY, elementType->Size);
          byte* matrix1Element = IndexIntoMatrix(matrix1, matrix1X, matrix1Y, userData.Matrix1SizeX, userData.Matrix1SizeY, elementType->Size);

          // We need to accumulate the multiplications of matrix0 and matrix1 but
          // we don't know what the inner type is or how to perform add or multiply,
          // so call a function that knows how to add our current type
          core.TypeMultiplyAddFunctions[userData.ElementTypeIndex](returnElement, matrix0Element, matrix1Element);
        }
      }
    }
  }
  
  //***************************************************************************
  // Hardcoded for reals (because I don't care to make it generic now...) (JoshD)
  void MatrixTransformPoint(Call& call, ExceptionReport& report)
  {
    call.DisableReturnChecks();
    MatrixTransformUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixTransformUserData>(0);
    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

    // We flip the matrix order in the function so it reads nicer (Transform(the, by))
    // but to do the math we need to flip them back to the right order
    Real* matrix0 = (Real*)call.GetParameterUnchecked(0);
    Real* vector0 = (Real*)call.GetParameterUnchecked(1);
    Real* returnVector = (Real*)call.GetReturnUnchecked();

    size_t expandedVectorSize = userData.Matrix1SizeY + 1;
    Real* tempReturnVector = (Real*)alloca(elementType->Size * (userData.Matrix1SizeY + 1));

    for (size_t matrix0Y = 0; matrix0Y < userData.Matrix0SizeY; ++matrix0Y)
    {
      Real* returnElement = (Real*)IndexIntoMatrix((byte*)tempReturnVector, 0, matrix0Y, userData.Matrix1SizeX, userData.Matrix1SizeY, elementType->Size);
      // To properly accumulate the multiplications the initial value first needs to be zeroed out
      memset(returnElement, 0, elementType->Size);

      for (size_t vector0Y = 0; vector0Y < userData.Matrix1SizeY; ++vector0Y)
      {
        size_t matrix0X = vector0Y;

        Real* matrix0Element = (Real*)IndexIntoMatrix((byte*)matrix0, matrix0X, matrix0Y, userData.Matrix0SizeX, userData.Matrix0SizeY, elementType->Size);
        Real* vector0Element = (Real*)IndexIntoMatrix((byte*)vector0,        0, vector0Y, userData.Matrix1SizeX, userData.Matrix1SizeY, elementType->Size);
        
        *returnElement += (*matrix0Element) * (*vector0Element);
      }

      Real* matrix0Element = (Real*)IndexIntoMatrix((byte*)matrix0, userData.Matrix0SizeX - 1, matrix0Y, userData.Matrix0SizeX, userData.Matrix0SizeY, elementType->Size);
      *returnElement += *matrix0Element;
    }

    // Do the w division
    size_t lastElementIndex = expandedVectorSize - 1;
    for(size_t i = 0; i < expandedVectorSize - 1; ++i)
      returnVector[i] = tempReturnVector[i] / tempReturnVector[lastElementIndex];
  }
  
  //***************************************************************************
  void GenerateMatrixMembers(LibraryBuilder& builder, BoundType* type, MatrixUserData& matrixUserData)
  {
    Core& core = Core::GetInstance();
    BoundType* elementType = core.MatrixElementTypes[matrixUserData.ElementTypeIndex];

    char componentNames[] = {'0', '1', '2', '3'};

    for (size_t sizeY = 0; sizeY < matrixUserData.SizeY; ++sizeY)
    {
      for (size_t sizeX = 0; sizeX < matrixUserData.SizeX; ++sizeX)
      {
        StringBuilder nameBuilder;
        nameBuilder.Append("M");
        nameBuilder.Append(componentNames[sizeY]);
        nameBuilder.Append(componentNames[sizeX]);

        // Get the offset into the matrix structure for the current member (by offsetting from 0)
        size_t offset = (size_t)IndexIntoMatrix((byte*)nullptr, sizeX, sizeY, matrixUserData.SizeX, matrixUserData.SizeY, elementType->Size);
        builder.AddBoundField(type, nameBuilder.ToString(), elementType, offset, MemberOptions::None);
      }
    }
  }
  
  //***************************************************************************
  void CreateMatrixTypes(LibraryBuilder& builder)
  {
    Core& core = Core::GetInstance();
    // For now don't make 1xN or Nx1 matrices

    // Setup functions needed for Transform that'll tell us
    // how to perform the madd intrinsic on a matrix element
    core.TypeMultiplyAddFunctions[0] = MultiplyAddReal;
    core.TypeMultiplyAddFunctions[1] = MultiplyAddInteger;
    core.TypeMultiplyAddFunctions[2] = MultiplyAddBoolean;

    // Some later operations need to operate on different dimensions/typed
    // matrices so store them all locally here for a second pass
    BoundType* matrixTypes[Core::MaxMatrixElementTypes][Core::MaxMatrixComponents][Core::MaxMatrixComponents];

    for (size_t typeIndex = 0; typeIndex < Core::MaxMatrixElementTypes; ++typeIndex)
    {
      for (size_t sizeY = Core::MinMatrixComponents; sizeY <= Core::MaxMatrixComponents; ++sizeY)
      {
        for (size_t sizeX = Core::MinMatrixComponents; sizeX <= Core::MaxMatrixComponents; ++sizeX)
        {
          // The indices into the matrix types 3d array
          size_t indexX = sizeX - 1;
          size_t indexY = sizeY - 1;

          BoundType* elementType = core.MatrixElementTypes[typeIndex];

          // Build up the matrices's names (Real3x3, Integer3x3, etc...)
          StringBuilder typeNameBuilder;
          typeNameBuilder.Append(elementType->ToString());
          typeNameBuilder << sizeY;
          typeNameBuilder.Append('x');
          typeNameBuilder << sizeX;

          // Add the bound type for the matrix and store it for later use
          String fullyQualifiedName = typeNameBuilder.ToString();
          size_t matrixSize = elementType->Size * sizeX * sizeY;
          BoundType* matrixType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ValueType, matrixSize);
          matrixTypes[typeIndex][indexY][indexX] = matrixType;

          // Create complex user data to store information needed to
          // generically handle matrix operations independently of size and type
          MatrixUserData matrixUserData(sizeX, sizeY, typeIndex);
          matrixType->ComplexUserData.WriteObject(matrixUserData);

          matrixType->ToStringFunction = MatrixToString;

          // Bind all of the functions that are only for the matrix with its own type
          Function* f = builder.AddBoundDefaultConstructor(matrixType, MatrixDefaultConstructor);
          f->ComplexUserData.WriteObject(matrixUserData);
          ParameterArray constructorParameters;
          for (size_t y = 0; y < sizeY; ++y)
          {
            for (size_t x = 0; x < sizeX; ++x)
            {
              DelegateParameter& param = constructorParameters.push_back();
              param.Name = String::Format("m%d%d", y, x);
              param.ParameterType = elementType;
            }
          }
          f = builder.AddBoundConstructor(matrixType, MatrixConstructor, constructorParameters);
          f->ComplexUserData.WriteObject(matrixUserData);

          f = builder.AddBoundFunction(matrixType, OperatorGet, MatrixGet, TwoParameters(core.IntegerType, "y", "x"), elementType, FunctionOptions::None);
          f->ComplexUserData.WriteObject(matrixUserData);
          f = builder.AddBoundFunction(matrixType, "GetByIndex", MatrixGetByIndex, OneParameter(core.IntegerType, "index"), elementType, FunctionOptions::None);
          f->ComplexUserData.WriteObject(matrixUserData);
          
          f = builder.AddBoundFunction(matrixType, OperatorSet, MatrixSet, ThreeParameters(core.IntegerType, "y", core.IntegerType, "x", elementType, "value"), core.VoidType, FunctionOptions::None);
          f->ComplexUserData.WriteObject(matrixUserData);
          f = builder.AddBoundFunction(matrixType, "SetByIndex", MatrixSetByIndex, TwoParameters(core.IntegerType, "index", elementType, "value"), core.VoidType, FunctionOptions::None);
          f->ComplexUserData.WriteObject(matrixUserData);
          f = builder.AddBoundFunction(matrixType, OperatorGet, MatrixGetVector, OneParameter(core.IntegerType, "y"), core.VectorTypes[typeIndex][indexX], FunctionOptions::None);
          f->ComplexUserData.WriteObject(matrixUserData);
          f = builder.AddBoundFunction(matrixType, OperatorSet, MatrixSetVector, TwoParameters(core.IntegerType, "y", core.VectorTypes[typeIndex][indexX], "value"), core.VoidType, FunctionOptions::None);
          f->ComplexUserData.WriteObject(matrixUserData);
          // Don't actually want to have this equal function bound, but for unit testing it can be nice
          //f = builder.AddBoundFunction(matrixType, "Equal", MatrixEqual, OneParameter(matrixType), core.BooleanType, FunctionOptions::None);
          //f->ComplexUserData.WriteObject(matrixUserData);

          // Bind properties
          Property* p = builder.AddBoundProperty(matrixType, "Count", core.IntegerType, nullptr, MatrixCount, FunctionOptions::None);
          p->Get->ComplexUserData.WriteObject(matrixUserData);
          p = builder.AddBoundProperty(matrixType, "Count", core.IntegerType, nullptr, MatrixCount, FunctionOptions::Static);
          p->Get->ComplexUserData.WriteObject(matrixUserData);
          p = builder.AddBoundProperty(matrixType, "CountX", core.IntegerType, nullptr, MatrixCountX, FunctionOptions::None);
          p->Get->ComplexUserData.WriteObject(matrixUserData);
          p = builder.AddBoundProperty(matrixType, "CountX", core.IntegerType, nullptr, MatrixCountX, FunctionOptions::Static);
          p->Get->ComplexUserData.WriteObject(matrixUserData);
          p = builder.AddBoundProperty(matrixType, "CountY", core.IntegerType, nullptr, MatrixCountY, FunctionOptions::None);
          p->Get->ComplexUserData.WriteObject(matrixUserData);
          p = builder.AddBoundProperty(matrixType, "CountY", core.IntegerType, nullptr, MatrixCountY, FunctionOptions::Static);
          p->Get->ComplexUserData.WriteObject(matrixUserData);

          // Generate all of the M00, M01, etc... members
          GenerateMatrixMembers(builder, matrixType, matrixUserData);
        }
      }
    }

    // Add the Real and Integer matrix types to an array of all of those types
    for (size_t sizeY = Core::MinMatrixComponents; sizeY <= Core::MaxMatrixComponents; ++sizeY)
    {
      for (size_t sizeX = Core::MinMatrixComponents; sizeX <= Core::MaxMatrixComponents; ++sizeX)
      {
        // Get the two matrix types (as a transpose can have different dimensions)
        BoundType* realMatrixType = matrixTypes[0][sizeY - 1][sizeX - 1];
        BoundType* integerMatrixType = matrixTypes[1][sizeY - 1][sizeX - 1];
        BoundType* booleanMatrixType = matrixTypes[2][sizeY - 1][sizeX - 1];

        core.AllRealTypes.push_back(realMatrixType);
        core.AllIntegerTypes.push_back(integerMatrixType);
        core.AllBooleanTypes.push_back(booleanMatrixType);
      }
    }

    // Add the determinant functions (only for real because that's all hlsl has)
    Function* fn = builder.AddBoundFunction(core.MathType, "Determinant", RealMatrixDeterminant<Math::Matrix2>, OneParameter(matrixTypes[0][1][1]), core.RealType, FunctionOptions::Static);
    fn = builder.AddBoundFunction(core.MathType, "Determinant", RealMatrixDeterminant<Math::Matrix3>, OneParameter(matrixTypes[0][2][2]), core.RealType, FunctionOptions::Static);
    fn = builder.AddBoundFunction(core.MathType, "Determinant", RealMatrixDeterminant<Math::Matrix4>, OneParameter(matrixTypes[0][3][3]), core.RealType, FunctionOptions::Static);
    // Add the inverse functions for only square real matrices
    fn = builder.AddBoundFunction(core.MathType, "Invert", RealMatrixInverse<Math::Matrix2>, OneParameter(matrixTypes[0][1][1]), matrixTypes[0][1][1], FunctionOptions::Static);
    fn = builder.AddBoundFunction(core.MathType, "Invert", RealMatrixInverse<Math::Matrix3>, OneParameter(matrixTypes[0][2][2]), matrixTypes[0][2][2], FunctionOptions::Static);
    fn = builder.AddBoundFunction(core.MathType, "Invert", RealMatrixInverse<Math::Matrix4>, OneParameter(matrixTypes[0][3][3]), matrixTypes[0][3][3], FunctionOptions::Static);

    // Operations on one matrix that need to reference different matrix
    // types (only need a loop over x and y dimensions plus types)
    for (size_t typeIndex = 0; typeIndex < Core::MaxMatrixElementTypes; ++typeIndex)
    {
      for (size_t sizeY = Core::MinMatrixComponents; sizeY <= Core::MaxMatrixComponents; ++sizeY)
      {
        for (size_t sizeX = Core::MinMatrixComponents; sizeX <= Core::MaxMatrixComponents; ++sizeX)
        {
          // Get the two matrix types (as a transpose can have different dimensions)
          BoundType* matrixType = matrixTypes[typeIndex][sizeY - 1][sizeX - 1];
          BoundType* resultType = matrixTypes[typeIndex][sizeX - 1][sizeY - 1];

          MatrixUserData matrixUserData(sizeX, sizeY, typeIndex);
          Function* f = builder.AddBoundFunction(core.MathType, "Transpose", MatrixTranspose, OneParameter(matrixType), resultType, FunctionOptions::Static);
          f->ComplexUserData.WriteObject(matrixUserData);
        }
      }
    }

    // Iterate over matrices that share one common dimension for multiplication
    // (but skip bools because boolean matrix multiplication is weird...)
    for (size_t typeIndex = 0; typeIndex < Core::MaxMatrixElementTypes - 1; ++typeIndex)
    {
      for (size_t matrixASizeY = Core::MinMatrixComponents; matrixASizeY <= Core::MaxMatrixComponents; ++matrixASizeY)
      {
        for (size_t matrixASizeX = Core::MinMatrixComponents; matrixASizeX <= Core::MaxMatrixComponents; ++matrixASizeX)
        {
          BoundType* matrixA = matrixTypes[typeIndex][matrixASizeY - 1][matrixASizeX - 1];

          for (size_t matrixBSizeX = Core::MinMatrixComponents; matrixBSizeX <= Core::MaxMatrixComponents; ++matrixBSizeX)
          {
            size_t matrixBSizeY = matrixASizeX;
            BoundType* matrixB = matrixTypes[typeIndex][matrixBSizeY - 1][matrixBSizeX - 1];
            BoundType* resultMatrix = matrixTypes[typeIndex][matrixASizeY - 1][matrixBSizeX - 1];

            MatrixTransformUserData transformUserData(matrixASizeX, matrixASizeY, matrixBSizeX, matrixBSizeY, typeIndex);
            Function* f = builder.AddBoundFunction(core.MathType, "Multiply", MatrixTransform, TwoParameters(matrixA, "by", matrixB, "the"), resultMatrix, FunctionOptions::Static);
            f->ComplexUserData.WriteObject(transformUserData);
          }

          // Also generate the matrix * vector versions
          MatrixTransformUserData transformUserData(matrixASizeX, matrixASizeY, 1, matrixASizeX, typeIndex);
          BoundType* inVectorType = core.RealTypes[matrixASizeX - 1];
          BoundType* resultVectorType = core.RealTypes[matrixASizeY - 1];
          Function* f = builder.AddBoundFunction(core.MathType, "Multiply", MatrixTransform, TwoParameters(matrixA, "by", inVectorType, "the"), resultVectorType, FunctionOptions::Static);
          f->ComplexUserData.WriteObject(transformUserData);
        }
      }
    }

    // Square matrix operations on Reals
    for (size_t matrixSize = Core::MinMatrixComponents; matrixSize <= Core::MaxMatrixComponents; ++matrixSize)
    {
      BoundType* matrixType = matrixTypes[VectorScalarTypes::Real][matrixSize - 1][matrixSize - 1];

      // Generate the MultiplyPoint (with the vector Real(N-1) version that assumes 1 as the last element)
      MatrixTransformUserData transformUserData = MatrixTransformUserData(matrixSize, matrixSize, 1, matrixSize - 1, VectorScalarTypes::Real);
      BoundType* inVectorType = core.RealTypes[matrixSize - 2];
      BoundType* resultVectorType = core.RealTypes[matrixSize - 2];
      Function* f = builder.AddBoundFunction(core.MathType, "MultiplyPoint", MatrixTransformPoint, TwoParameters(matrixType, "by", inVectorType, "the"), resultVectorType, FunctionOptions::Static);
      f->ComplexUserData.WriteObject(transformUserData);

      // Also generate the MultiplyNormal (with the vector Real(N-1) version that assumes 0 as the last element)
      transformUserData = MatrixTransformUserData(matrixSize, matrixSize, 1, matrixSize - 1, VectorScalarTypes::Real);
      inVectorType = core.RealTypes[matrixSize - 2];
      resultVectorType = core.RealTypes[matrixSize - 2];
      f = builder.AddBoundFunction(core.MathType, "MultiplyNormal", MatrixTransform, TwoParameters(matrixType, "by", inVectorType, "the"), resultVectorType, FunctionOptions::Static);
      f->ComplexUserData.WriteObject(transformUserData);
    }
  }

}//namespace Zilch
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes




namespace Zilch
{
  //***************************************************************************
  ZilchDefineType(Property, "Property", Core, builder, type)
  {
  }

  //***************************************************************************
  ZilchDefineType(Field, "Field", Core, builder, type)
  {
  }

  //***************************************************************************
  ZilchDefineType(Variable, "Variable", Core, builder, type)
  {
  }

  //***************************************************************************
  AttributeParameter::AttributeParameter() :
    Type(AttributeType::Null),
    NumberValue(0.0),
    BooleanValue(false)
  {
  }

  //***************************************************************************
  DocumentedObject::DocumentedObject() :
    IsHidden(false)
  {
  }

  //***************************************************************************
  bool DocumentedObject::HasAttribute(StringParam name)
  {
    // Walk through the array of attributes (usually small)
    for (size_t i = 0; i < this->Attributes.size(); ++i)
    {
      // If we found a matching name, then we do have that attribue
      if (this->Attributes[i].Name == name)
        return true;
    }

    // If we got here, we didn't find the attribute
    return false;
  }
  
  //***************************************************************************
  Type* DocumentedObject::GetTypeOrNull()
  {
    return nullptr;
  }

  //***************************************************************************
  Member::Member() :
    Owner(nullptr)
  {
  }
  
  //***************************************************************************
  Library* Member::GetOwningLibrary()
  {
    return this->Owner->SourceLibrary;
  }

  //***************************************************************************
  Property::Property() :
    PropertyType(nullptr),
    IsStatic(false),
    Get(nullptr),
    Set(nullptr),
    IsHiddenWhenNull(false)
  {
  }
  
  //***************************************************************************
  Type* Property::GetTypeOrNull()
  {
    return this->PropertyType;
  }

  //***************************************************************************
  Field::Field() :
    Offset(0),
    Initializer(nullptr)
  {
  }

  //***************************************************************************
  Variable::Variable() :
    Local(0),
    ResultType(Core::GetInstance().ErrorType),
    Owner(nullptr)
  {
  }

  //***************************************************************************
  Library* Variable::GetOwningLibrary()
  {
    return this->Owner->Owner->SourceLibrary;
  }

  //***************************************************************************
  Type* Variable::GetTypeOrNull()
  {
    return this->ResultType;
  }

  //***************************************************************************
  SendsEvent::SendsEvent() :
    ResultType(Core::GetInstance().ErrorType)
  {
  }
}/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes



namespace Zilch
{
  //***************************************************************************
  const char* Instruction::Names[] =
  {
    #define ZilchEnumValue(value) #value,
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Note: These macros mirror those inside of Shared and VirtualMachine (for generation of instructions)

// Copy
#define ZilchCopyInstructions(Type)               \
  ZilchEnumValue(Copy##Type)

// Equality and inequality
#define ZilchEqualityInstructions(Type)           \
  ZilchEnumValue(TestInequality##Type)            \
  ZilchEnumValue(TestEquality##Type)

// Less and greater comparison
#define ZilchComparisonInstructions(Type)         \
  ZilchEnumValue(TestLessThan##Type)              \
  ZilchEnumValue(TestLessThanOrEqualTo##Type)     \
  ZilchEnumValue(TestGreaterThan##Type)           \
  ZilchEnumValue(TestGreaterThanOrEqualTo##Type)

// Generic numeric operators, copy, equality
#define ZilchNumericInstructions(Type)            \
  ZilchCopyInstructions(Type)                     \
  ZilchEqualityInstructions(Type)                 \
  /* No instruction for unary plus */             \
  ZilchEnumValue(Negate##Type)                    \
  ZilchEnumValue(Increment##Type)                 \
  ZilchEnumValue(Decrement##Type)                 \
  ZilchEnumValue(Add##Type)                       \
  ZilchEnumValue(Subtract##Type)                  \
  ZilchEnumValue(Multiply##Type)                  \
  ZilchEnumValue(Divide##Type)                    \
  ZilchEnumValue(Modulo##Type)                    \
  ZilchEnumValue(Pow##Type)                       \
  ZilchEnumValue(AssignmentAdd##Type)             \
  ZilchEnumValue(AssignmentSubtract##Type)        \
  ZilchEnumValue(AssignmentMultiply##Type)        \
  ZilchEnumValue(AssignmentDivide##Type)          \
  ZilchEnumValue(AssignmentModulo##Type)          \
  ZilchEnumValue(AssignmentPow##Type)

// Generic numeric operators, copy, equality, comparison
#define ZilchScalarInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)

// Vector operations, generic numeric operators, copy, equality
#define ZilchVectorInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)               \
  ZilchEnumValue(ScalarMultiply##Type)            \
  ZilchEnumValue(ScalarDivide##Type)              \
  ZilchEnumValue(ScalarModulo##Type)              \
  ZilchEnumValue(ScalarPow##Type)                 \
  ZilchEnumValue(AssignmentScalarMultiply##Type)  \
  ZilchEnumValue(AssignmentScalarDivide##Type)    \
  ZilchEnumValue(AssignmentScalarModulo##Type)    \
  ZilchEnumValue(AssignmentScalarPow##Type)

// Special integral operators, generic numeric operators, copy, equality, and comparison
#define ZilchIntegralInstructions(Type)           \
  ZilchEnumValue(BitwiseNot##Type)                \
  ZilchEnumValue(BitshiftLeft##Type)              \
  ZilchEnumValue(BitshiftRight##Type)             \
  ZilchEnumValue(BitwiseOr##Type)                 \
  ZilchEnumValue(BitwiseXor##Type)                \
  ZilchEnumValue(BitwiseAnd##Type)                \
  ZilchEnumValue(AssignmentBitshiftLeft##Type)    \
  ZilchEnumValue(AssignmentBitshiftRight##Type)   \
  ZilchEnumValue(AssignmentBitwiseOr##Type)       \
  ZilchEnumValue(AssignmentBitwiseXor##Type)      \
  ZilchEnumValue(AssignmentBitwiseAnd##Type)


// Core instructions
ZilchEnumValue(InvalidInstruction)

ZilchEnumValue(InternalDebugBreakpoint)
ZilchEnumValue(ThrowException)
ZilchEnumValue(PropertyDelegate)

ZilchEnumValue(TypeId)

ZilchEnumValue(BeginTimeout)
ZilchEnumValue(EndTimeout)

ZilchEnumValue(BeginScope)
ZilchEnumValue(EndScope)

ZilchEnumValue(ToHandle)

ZilchEnumValue(BeginStringBuilder)
ZilchEnumValue(EndStringBuilder)
ZilchEnumValue(AddToStringBuilder)

ZilchEnumValue(CreateInstanceDelegate)
ZilchEnumValue(CreateStaticDelegate)

ZilchEnumValue(IfFalseRelativeGoTo)
ZilchEnumValue(IfTrueRelativeGoTo)
ZilchEnumValue(RelativeGoTo)

ZilchEnumValue(Return)
ZilchEnumValue(PrepForFunctionCall)
ZilchEnumValue(FunctionCall)

ZilchEnumValue(NewObject)
ZilchEnumValue(LocalObject)
ZilchEnumValue(DeleteObject)

// Primitive type instructions
ZilchIntegralInstructions(Byte)
ZilchScalarInstructions(Byte)
ZilchIntegralInstructions(Integer)
ZilchScalarInstructions(Integer)
ZilchVectorInstructions(Integer2)
ZilchVectorInstructions(Integer3)
ZilchVectorInstructions(Integer4)
ZilchIntegralInstructions(Integer2)
ZilchIntegralInstructions(Integer3)
ZilchIntegralInstructions(Integer4)
ZilchScalarInstructions(Real)
ZilchVectorInstructions(Real2)
ZilchVectorInstructions(Real3)
ZilchVectorInstructions(Real4)
ZilchScalarInstructions(DoubleReal)
ZilchIntegralInstructions(DoubleInteger)
ZilchScalarInstructions(DoubleInteger)

ZilchEqualityInstructions(Boolean)
ZilchEqualityInstructions(Handle)
ZilchEqualityInstructions(Delegate)
ZilchEqualityInstructions(Any)
ZilchEqualityInstructions(Value)

ZilchCopyInstructions(Boolean)
ZilchCopyInstructions(Any)
ZilchCopyInstructions(Handle)
ZilchCopyInstructions(Delegate)
ZilchCopyInstructions(Value)

ZilchEnumValue(LogicalNotBoolean)

ZilchEnumValue(ConvertByteToReal)
ZilchEnumValue(ConvertByteToBoolean)
ZilchEnumValue(ConvertByteToInteger)
ZilchEnumValue(ConvertByteToDoubleInteger)
ZilchEnumValue(ConvertByteToDoubleReal)
ZilchEnumValue(ConvertIntegerToReal)
ZilchEnumValue(ConvertIntegerToBoolean)
ZilchEnumValue(ConvertIntegerToByte)
ZilchEnumValue(ConvertIntegerToDoubleInteger)
ZilchEnumValue(ConvertIntegerToDoubleReal)
ZilchEnumValue(ConvertRealToInteger)
ZilchEnumValue(ConvertRealToBoolean)
ZilchEnumValue(ConvertRealToByte)
ZilchEnumValue(ConvertRealToDoubleInteger)
ZilchEnumValue(ConvertRealToDoubleReal)
ZilchEnumValue(ConvertBooleanToInteger)
ZilchEnumValue(ConvertBooleanToReal)
ZilchEnumValue(ConvertBooleanToByte)
ZilchEnumValue(ConvertBooleanToDoubleInteger)
ZilchEnumValue(ConvertBooleanToDoubleReal)
ZilchEnumValue(ConvertDoubleIntegerToReal)
ZilchEnumValue(ConvertDoubleIntegerToBoolean)
ZilchEnumValue(ConvertDoubleIntegerToByte)
ZilchEnumValue(ConvertDoubleIntegerToInteger)
ZilchEnumValue(ConvertDoubleIntegerToDoubleReal)
ZilchEnumValue(ConvertDoubleRealToReal)
ZilchEnumValue(ConvertDoubleRealToBoolean)
ZilchEnumValue(ConvertDoubleRealToByte)
ZilchEnumValue(ConvertDoubleRealToInteger)
ZilchEnumValue(ConvertDoubleRealToDoubleInteger)

ZilchEnumValue(ConvertInteger2ToReal2)
ZilchEnumValue(ConvertInteger2ToBoolean2)
ZilchEnumValue(ConvertReal2ToInteger2)
ZilchEnumValue(ConvertReal2ToBoolean2)
ZilchEnumValue(ConvertBoolean2ToInteger2)
ZilchEnumValue(ConvertBoolean2ToReal2)

ZilchEnumValue(ConvertInteger3ToReal3)
ZilchEnumValue(ConvertInteger3ToBoolean3)
ZilchEnumValue(ConvertReal3ToInteger3)
ZilchEnumValue(ConvertReal3ToBoolean3)
ZilchEnumValue(ConvertBoolean3ToInteger3)
ZilchEnumValue(ConvertBoolean3ToReal3)

ZilchEnumValue(ConvertInteger4ToReal4)
ZilchEnumValue(ConvertInteger4ToBoolean4)
ZilchEnumValue(ConvertReal4ToInteger4)
ZilchEnumValue(ConvertReal4ToBoolean4)
ZilchEnumValue(ConvertBoolean4ToInteger4)
ZilchEnumValue(ConvertBoolean4ToReal4)

ZilchEnumValue(ConvertStringToStringRangeExtended)

ZilchEnumValue(ConvertDowncast)
ZilchEnumValue(ConvertToAny)
ZilchEnumValue(ConvertFromAny)
ZilchEnumValue(AnyDynamicMemberGet)
ZilchEnumValue(AnyDynamicMemberSet)

    #undef ZilchEnumValue
  };

  //***************************************************************************
  Operand::Operand() :
    HandleConstantLocal(0),
    FieldOffset(0),
    Type(OperandType::NotSet)
  {
  }

  //***************************************************************************
  Operand::Operand(OperandIndex local) :
    HandleConstantLocal(local),
    FieldOffset(0),
    Type(OperandType::Local)
  {
  }

  //***************************************************************************
  Operand::Operand(OperandIndex handleConstantLocal, size_t field, OperandType::Enum type) :
    HandleConstantLocal(handleConstantLocal),
    FieldOffset(field),
    Type(type)
  {
  }

  //***************************************************************************
  DebugOperand::DebugOperand()
  {
    this->OperandOffset = (size_t)-1;
    this->Primitive = DebugPrimitive::Memory;
    this->IsLocalOnly = false;
  }

  //***************************************************************************
  DebugOperand::DebugOperand(size_t offset, DebugPrimitive::Enum primitive, bool isLocal, StringParam name)
  {
    this->OperandOffset = offset;
    this->Primitive = primitive;
    this->IsLocalOnly = isLocal;
    this->Name = name;
  }

  //***************************************************************************
  DebugInstruction::DebugInstruction() :
    IsCopy(false)
  {
  }

#define ZilchOperand(array, type, member, primitive, isLocal) \
  array.push_back(DebugOperand(offsetof(type, member), primitive, isLocal, #member));



  //***************************************************************************
  void GenerateDebugInstructionInfo(Array<DebugInstruction>& debugOut)
  {
    debugOut.resize(Instruction::Count);

    // ToHandle
    {
      DebugInstruction& info = debugOut[Instruction::ToHandle];
      ZilchOperand(info.ReadOperands, ToHandleOpcode, ToHandle, DebugPrimitive::Memory, false);
      ZilchOperand(info.WriteOperands, ToHandleOpcode, SaveLocal, DebugPrimitive::Memory, true);
    }

    // CreateStaticDelegate
    {
      DebugInstruction& info = debugOut[Instruction::CreateStaticDelegate];
      info.FunctionPointers.push_back(offsetof(CreateStaticDelegateOpcode, BoundFunction));
      ZilchOperand(info.WriteOperands, CreateStaticDelegateOpcode, SaveLocal, DebugPrimitive::Delegate, true);
    }

    // CreateInstanceDelegate
    {
      DebugInstruction& info = debugOut[Instruction::CreateInstanceDelegate];
      info.FunctionPointers.push_back(offsetof(CreateInstanceDelegateOpcode, BoundFunction));
      ZilchOperand(info.ReadOperands, CreateInstanceDelegateOpcode, ThisHandle, DebugPrimitive::Handle, false);
      ZilchOperand(info.WriteOperands, CreateInstanceDelegateOpcode, SaveLocal, DebugPrimitive::Delegate, true);
    }

    
    // IfFalseRelativeGoTo / IfTrueRelativeGoTo
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::IfFalseRelativeGoTo,
        Instruction::IfTrueRelativeGoTo
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.ReadOperands, IfOpcode, Condition, DebugPrimitive::Boolean, false);
        info.OpcodeOffsets.push_back(offsetof(IfOpcode, JumpOffset));
      }
    }

    // IfTrueRelativeGoTo
    {
      DebugInstruction& info = debugOut[Instruction::IfTrueRelativeGoTo];
      ZilchOperand(info.ReadOperands, IfOpcode, Condition, DebugPrimitive::Boolean, false);
      info.OpcodeOffsets.push_back(offsetof(IfOpcode, JumpOffset));
    }
    
    
    // RelativeGoTo
    {
      DebugInstruction& info = debugOut[Instruction::RelativeGoTo];
      info.OpcodeOffsets.push_back(offsetof(RelativeJumpOpcode, JumpOffset));
    }
    
    // PrepForFunctionCall
    {
      DebugInstruction& info = debugOut[Instruction::PrepForFunctionCall];
      ZilchOperand(info.ReadOperands, PrepForFunctionCallOpcode, Delegate, DebugPrimitive::Delegate, false);
      info.OpcodeOffsets.push_back(offsetof(PrepForFunctionCallOpcode, JumpOffsetIfStatic));
    }
    
    // NewObject
    {
      DebugInstruction& info = debugOut[Instruction::NewObject];
      info.TypePointers.push_back(offsetof(CreateTypeOpcode, CreatedType));
      ZilchOperand(info.WriteOperands, CreateTypeOpcode, SaveHandleLocal, DebugPrimitive::Handle, true);
    }

    // LocalObject
    {
      DebugInstruction& info = debugOut[Instruction::LocalObject];
      info.TypePointers.push_back(offsetof(CreateLocalTypeOpcode, CreatedType));
      ZilchOperand(info.WriteOperands, CreateLocalTypeOpcode, SaveHandleLocal, DebugPrimitive::Handle, true);
      ZilchOperand(info.WriteOperands, CreateLocalTypeOpcode, StackLocal, DebugPrimitive::Memory, true);
    }
    
    // DeleteObject
    {
      DebugInstruction& info = debugOut[Instruction::DeleteObject];
      ZilchOperand(info.WriteOperands, DeleteObjectOpcode, Object, DebugPrimitive::Handle, false);
    }
    

    // [UnaryRValueOpcode]
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::NegateInteger,
        Instruction::NegateReal,
        Instruction::NegateReal2,
        Instruction::NegateReal3,
        Instruction::NegateReal4,
        Instruction::LogicalNotBoolean,
        Instruction::BitwiseNotInteger
      };

      DebugPrimitive::Enum types[] =
      {
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Boolean,
        DebugPrimitive::Integer
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum primitive = types[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.ReadOperands, UnaryRValueOpcode, SingleOperand, primitive, false);
        ZilchOperand(info.WriteOperands, UnaryRValueOpcode, Output, primitive, true);
      }
    }

    // [UnaryLValueOpcode]
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::IncrementInteger,
        Instruction::IncrementReal,
        Instruction::DecrementInteger,
        Instruction::DecrementReal,
      };

      DebugPrimitive::Enum types[] =
      {
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Integer,
        DebugPrimitive::Real
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum primitive = types[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.WriteOperands, UnaryLValueOpcode, SingleOperand, primitive, false);
      }
    }

    // [BinaryRValueOpcode] (Result + Operands all the same type)
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::BitshiftLeftInteger,
        Instruction::BitshiftRightInteger,
        Instruction::BitwiseOrInteger,
        Instruction::BitwiseXorInteger,
        Instruction::BitwiseAndInteger,
        Instruction::AddInteger,
        Instruction::AddReal,
        Instruction::AddReal2,
        Instruction::AddReal3,
        Instruction::AddReal4,
        Instruction::SubtractInteger,
        Instruction::SubtractReal,
        Instruction::SubtractReal2,
        Instruction::SubtractReal3,
        Instruction::SubtractReal4,
        Instruction::MultiplyInteger,
        Instruction::MultiplyReal,
        Instruction::MultiplyReal2,
        Instruction::MultiplyReal3,
        Instruction::MultiplyReal4,
        Instruction::DivideInteger,
        Instruction::DivideReal,
        Instruction::DivideReal2,
        Instruction::DivideReal3,
        Instruction::DivideReal4,
        Instruction::ModuloInteger,
        Instruction::ModuloReal,
        Instruction::ModuloReal2,
        Instruction::ModuloReal3,
        Instruction::ModuloReal4,
        Instruction::PowInteger,
        Instruction::PowReal,
        Instruction::PowReal2,
        Instruction::PowReal3,
        Instruction::PowReal4
      };

      DebugPrimitive::Enum types[] =
      {
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Boolean,
        DebugPrimitive::Boolean,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum primitive = types[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Left, primitive, false);
        ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Right, primitive, false);
        ZilchOperand(info.WriteOperands, BinaryRValueOpcode, Output, primitive, true);
      }
    }

    // [BinaryRValueOpcode] (Operands all the same type, Result is a Boolean)
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::TestLessThanInteger,
        Instruction::TestLessThanReal,
        Instruction::TestLessThanOrEqualToInteger,
        Instruction::TestLessThanOrEqualToReal,
        Instruction::TestGreaterThanInteger,
        Instruction::TestGreaterThanReal,
        Instruction::TestGreaterThanOrEqualToInteger,
        Instruction::TestGreaterThanOrEqualToReal,
        Instruction::TestInequalityInteger,
        Instruction::TestInequalityReal,
        Instruction::TestInequalityBoolean,
        Instruction::TestInequalityHandle,
        Instruction::TestInequalityReal2,
        Instruction::TestInequalityReal3,
        Instruction::TestInequalityReal4,
        Instruction::TestEqualityInteger,
        Instruction::TestEqualityReal,
        Instruction::TestEqualityBoolean,
        Instruction::TestEqualityHandle,
        Instruction::TestEqualityReal2,
        Instruction::TestEqualityReal3,
        Instruction::TestEqualityReal4
      };

      DebugPrimitive::Enum types[] =
      {
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Boolean,
        DebugPrimitive::Handle,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Boolean,
        DebugPrimitive::Handle,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum primitive = types[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Left, primitive, false);
        ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Right, primitive, false);
        ZilchOperand(info.WriteOperands, BinaryRValueOpcode, Output, DebugPrimitive::Boolean, true);
      }
    }

    // [BinaryRValueOpcode] (Scalar + Vector operations)
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::ScalarMultiplyReal2,
        Instruction::ScalarMultiplyReal3,
        Instruction::ScalarMultiplyReal4,
        Instruction::ScalarDivideReal2,
        Instruction::ScalarDivideReal3,
        Instruction::ScalarDivideReal4,
        Instruction::ScalarModuloReal2,
        Instruction::ScalarModuloReal3,
        Instruction::ScalarModuloReal4,
        Instruction::ScalarPowReal2,
        Instruction::ScalarPowReal3,
        Instruction::ScalarPowReal4
      };

      DebugPrimitive::Enum types[] =
      {
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum primitive = types[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Left, primitive, false);
        ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Right, DebugPrimitive::Real, false);
        ZilchOperand(info.WriteOperands, BinaryRValueOpcode, Output, primitive, true);
      }
    }

    // [BinaryLValueOpcode] (Operands all the same type)
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::AssignmentBitshiftLeftInteger,
        Instruction::AssignmentBitshiftRightInteger,
        Instruction::AssignmentBitwiseOrInteger,
        Instruction::AssignmentBitwiseXorInteger,
        Instruction::AssignmentBitwiseAndInteger,
        Instruction::AssignmentAddInteger,
        Instruction::AssignmentAddReal,
        Instruction::AssignmentAddReal2,
        Instruction::AssignmentAddReal3,
        Instruction::AssignmentAddReal4,
        Instruction::AssignmentSubtractInteger,
        Instruction::AssignmentSubtractReal,
        Instruction::AssignmentSubtractReal2,
        Instruction::AssignmentSubtractReal3,
        Instruction::AssignmentSubtractReal4,
        Instruction::AssignmentMultiplyInteger,
        Instruction::AssignmentMultiplyReal,
        Instruction::AssignmentMultiplyReal2,
        Instruction::AssignmentMultiplyReal3,
        Instruction::AssignmentMultiplyReal4,
        Instruction::AssignmentDivideInteger,
        Instruction::AssignmentDivideReal,
        Instruction::AssignmentDivideReal2,
        Instruction::AssignmentDivideReal3,
        Instruction::AssignmentDivideReal4,
        Instruction::AssignmentModuloInteger,
        Instruction::AssignmentModuloReal,
        Instruction::AssignmentModuloReal2,
        Instruction::AssignmentModuloReal3,
        Instruction::AssignmentModuloReal4,
        Instruction::AssignmentPowInteger,
        Instruction::AssignmentPowReal,
        Instruction::AssignmentPowReal2,
        Instruction::AssignmentPowReal3,
        Instruction::AssignmentPowReal4
      };

      DebugPrimitive::Enum types[] =
      {
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum primitive = types[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.ReadOperands, BinaryLValueOpcode, Right, primitive, false);
        ZilchOperand(info.WriteOperands, BinaryLValueOpcode, Output, primitive, false);
      }
    }

    // [BinaryLValueOpcode] (Scalar + Vector assignment operations)
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::AssignmentScalarMultiplyReal2,
        Instruction::AssignmentScalarMultiplyReal3,
        Instruction::AssignmentScalarMultiplyReal4,
        Instruction::AssignmentScalarDivideReal2,
        Instruction::AssignmentScalarDivideReal3,
        Instruction::AssignmentScalarDivideReal4,
        Instruction::AssignmentScalarModuloReal2,
        Instruction::AssignmentScalarModuloReal3,
        Instruction::AssignmentScalarModuloReal4,
        Instruction::AssignmentScalarPowReal2,
        Instruction::AssignmentScalarPowReal3,
        Instruction::AssignmentScalarPowReal4
      };

      DebugPrimitive::Enum types[] =
      {
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum primitive = types[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.ReadOperands, BinaryLValueOpcode, Right, DebugPrimitive::Real, false);
        ZilchOperand(info.WriteOperands, BinaryLValueOpcode, Output, primitive, false);
      }
    }

    // [ConversionOpcode]
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::ConvertIntegerToReal,
        Instruction::ConvertIntegerToBoolean,
        Instruction::ConvertRealToInteger,
        Instruction::ConvertRealToBoolean,
        Instruction::ConvertBooleanToInteger,
        Instruction::ConvertBooleanToReal
      };

      DebugPrimitive::Enum fromTypes[] =
      {
        DebugPrimitive::Integer,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real,
        DebugPrimitive::Boolean,
        DebugPrimitive::Boolean,
      };

      DebugPrimitive::Enum toTypes[] =
      {
        DebugPrimitive::Real,
        DebugPrimitive::Boolean,
        DebugPrimitive::Integer,
        DebugPrimitive::Boolean,
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum fromPrimitive = fromTypes[i];
        DebugPrimitive::Enum toPrimitive = toTypes[i];
        DebugInstruction& info = debugOut[instruction];
        ZilchOperand(info.ReadOperands, ConversionOpcode, ToConvert, fromPrimitive, false);
        ZilchOperand(info.WriteOperands, ConversionOpcode, Output, toPrimitive, true);
      }
    }

    // String to StringRange conversion
    {
      Instruction::Enum instruction = Instruction::ConvertStringToStringRangeExtended;
      DebugPrimitive::Enum fromPrimitive = DebugPrimitive::Handle;
      DebugPrimitive::Enum toPrimitive = DebugPrimitive::Handle;
      DebugInstruction& info = debugOut[instruction];
      ZilchOperand(info.ReadOperands, ConversionOpcode, ToConvert, fromPrimitive, false);
      ZilchOperand(info.WriteOperands, ConversionOpcode, Output, toPrimitive, true);
    }

    // [CopyOpcode]
    {
      Instruction::Enum instructions[] = 
      {
        Instruction::CopyInteger,
        Instruction::CopyReal,
        Instruction::CopyReal2,
        Instruction::CopyReal3,
        Instruction::CopyReal4,
        Instruction::CopyBoolean,
        Instruction::CopyHandle,
        Instruction::CopyDelegate,
        Instruction::CopyValue
      };

      DebugPrimitive::Enum types[] =
      {
        DebugPrimitive::Integer,
        DebugPrimitive::Real,
        DebugPrimitive::Real2,
        DebugPrimitive::Real3,
        DebugPrimitive::Real4,
        DebugPrimitive::Boolean,
        DebugPrimitive::Handle,
        DebugPrimitive::Delegate,
        DebugPrimitive::Memory,
      };

      for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
      {
        Instruction::Enum instruction = instructions[i];
        DebugPrimitive::Enum primitive = types[i];
        DebugInstruction& info = debugOut[instruction];
        info.IsCopy = true;
        ZilchOperand(info.ReadOperands, CopyOpcode, Source, primitive, false);
        ZilchOperand(info.WriteOperands, CopyOpcode, Destination, primitive, false);
        info.Sizes.push_back(offsetof(CopyOpcode, Size));
        info.Options.push_back(offsetof(CopyOpcode, Mode));
      }
    }
  }
}

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes








namespace Zilch
{
  //***************************************************************************
  bool Overload::ResolveAndImplicitConvert
  (
    const FunctionArray* functions,
    Function*& resolvedFunction,
    FunctionCallNode& functionCallNode
  )
  {
    // Loop through all the overload passes
    for (size_t passIndex = OverloadPass::NoImplicitConversion; passIndex <= OverloadPass::AnyImplicitConversion; ++passIndex)
    {
      // Get the current pass as an enum
      OverloadPass::Enum pass = (OverloadPass::Enum)passIndex;

      // Loop through all the function overloads that we have to choose from
      for (size_t i = 0; i < functions->size(); ++i)
      {
        // Get the current function
        Function* function = (*functions)[i];

        // Check the current function type against the call
        if (TestDelegateTypeVsCall(function->FunctionType, functionCallNode, pass))
        {
          // If we're on the last pass, then we need to generate implicit conversion code
          if (pass == OverloadPass::AnyImplicitConversion)
            GenerateImplicitCasts(function->FunctionType, functionCallNode);

          // Set the resolved function, and return a success
          resolvedFunction = function;
          return true;
        }
      }
    }

    // Since we got here, the overload was not resolved
    return false;
  }

  //***************************************************************************
  void Overload::GetFunctionCallSignatureString(StringBuilder& builder, const FunctionCallNode& functionCallNode)
  {
    // Add on the beginning call parentheses
    builder.Append("(");

    // Store the number of arguments we need to print
    size_t count = functionCallNode.Arguments.size();

    // Loop through all the arguments
    for (size_t i = 0; i < count; ++i)
    {
      // If the call uses named arguments...
      if (functionCallNode.IsNamed)
      {
        // Write the name of the argument
        builder.Append(functionCallNode.ArgumentNames[i]);
        builder.Append(" : ");
      }

      // Grab the current type
      Type* type = functionCallNode.Arguments[i]->ResultType;

      // Always make sure the type is valid / resolved
      if (type != nullptr)
      {
        // Write the type of the argument
        builder.Append(type->ToString());
      }
      else
      {
        Error("Attempting to print a signature where one of the argument types is invalid!");
      }

      // If we're not at the end
      if (i != count - 1)
      {
        // Add commas to separate out the arguments
        builder.Append(", ");
      }
    }

    // Add on the ending call parentheses
    builder.Append(")");
  }

  //***************************************************************************
  void Overload::ReportSingleError
  (
    CompilationErrors& errors,
    const CodeLocation& location,
    const DelegateType* type,
    const FunctionCallNode& functionCallNode
  )
  {
    // Get the calling signature
    StringBuilder call;
    call.Append("\n\n  delegate");
    GetFunctionCallSignatureString(call, functionCallNode);
    call.Append("\n\n");

    // Build a string to enumerate all possible overloads
    StringBuilder options;
    options.Append("\n\n  delegate");
    type->BuildSignatureString(options, functionCallNode.IsNamed);

    // Now report the error
    return errors.Raise(location, ErrorCode::UnableToResolveFunction,
      "delegate",
      call.ToString().c_str(),
      options.ToString().c_str());
  }

  //***************************************************************************
  void Overload::ReportError
  (
    CompilationErrors& errors,
    const CodeLocation& location,
    const FunctionArray* functions,
    const FunctionCallNode& functionCallNode
  )
  {
    // Error checking
    ErrorIf(functions == nullptr || functions->empty(),
      "We cannot report overloading errors when no functions were provided");

    // Get the name of one of the functions (we know there is at least one function in this array)
    String name = (*functions)[0]->Name;

    // Get the calling signature
    StringBuilder call;
    call.Append("\n\n  ");
    call.Append(name);
    GetFunctionCallSignatureString(call, functionCallNode);
    call.Append("\n\n");

    // Build a string to enumerate all possible overloads
    StringBuilder options;
    options.Append("\n");

    // Loop through all the function choices we have
    for (size_t i = 0; i < functions->size(); ++i)
    {
      // Get the current function
      Function* function = (*functions)[i];

      // Add each function signature to the output
      options.Append("\n  ");
      options.Append(name);
      function->FunctionType->BuildSignatureString(options, functionCallNode.IsNamed);
    }

    // Now report the error
    return errors.Raise(location, ErrorCode::UnableToResolveFunction,
      name.c_str(),
      call.ToString().c_str(),
      options.ToString().c_str());
  }

  //***************************************************************************
  bool Overload::TestCallAndImplicitConvert(DelegateType* delegateType, FunctionCallNode& functionCallNode)
  {
    // Perform each pass one at a time (early out as soon as we get a hit)
    if (TestDelegateTypeVsCall(delegateType, functionCallNode, OverloadPass::NoImplicitConversion))
      return true;
    if (TestDelegateTypeVsCall(delegateType, functionCallNode, OverloadPass::RawImplicitConversion))
      return true;
    if (TestDelegateTypeVsCall(delegateType, functionCallNode, OverloadPass::AnyImplicitConversion))
    {
      // In the last phase, we need to actually generate implicit casts (TypeCastNodes)
      GenerateImplicitCasts(delegateType, functionCallNode);
      return true;
    }

    // If we got here, the signature did not match at all
    return false;
  }

  //***************************************************************************
  void Overload::GenerateImplicitCasts(DelegateType* delegateType, FunctionCallNode& functionCallNode)
  {
    // Grab the list of arguments and parameters for convenience
    NodeList<ExpressionNode>& arguments = functionCallNode.Arguments;
    ParameterArray& parameters = delegateType->Parameters;

    // Get the number of arguments
    size_t argumentCount = functionCallNode.Arguments.size();
    ErrorIf(parameters.size() != argumentCount, "We should have already verified that that the parameter count matched");

    // First check to see that the overload has all the same argument names
    for (size_t i = 0; i < argumentCount; ++i)
    {
      // Get the current delegate parameter and expression argument
      const DelegateParameter& delegateParameter = parameters[i];
      ExpressionNode* argument = arguments[i];

      // Store the types in a more human readable format
      Type* fromType = argument->ResultType;
      Type* toType = delegateParameter.ParameterType;

      // Generate the implicit conversion
      Syntaxer::ImplicitConvertAfterWalkAndIo(arguments[i], toType);
    }
  }

  //***************************************************************************
  bool Overload::TestDelegateTypeVsCall(DelegateType* delegateType, FunctionCallNode& functionCallNode, OverloadPass::Enum pass)
  {
    // Get the number of arguments
    size_t argumentCount = functionCallNode.Arguments.size();

    // Get the arguments for the function call
    NodeList<ExpressionNode>::range arguments = functionCallNode.Arguments.all();

    // First, check that the call has the same number of arguments as the type's parameters
    // NOTE: This is important that we do this first, since the positional check below
    // test is there are no parameters (and assumes both have the same number)
    if (delegateType->Parameters.size() != argumentCount)
      return false;

    // First check to see that the overload has all the same argument names
    for (size_t i = 0; i < delegateType->Parameters.size(); ++i)
    {
      // Get the current delegate parameter
      const DelegateParameter& delegateParameter = delegateType->Parameters[i];

      // In a positional call, the argument index is just the current index (they must match exactly)
      size_t index = i;

      // If we are calling with named arguments...
      if (functionCallNode.IsNamed)
      {
        // Attempt to find the argument by name (it's a non positional call!)
        index = functionCallNode.ArgumentNames.findIndex(delegateParameter.Name);

        // If we didn't find anything...
        if (index == (size_t) -1)
        {
          // The overload did not match...
          return false;
        }
      }

      // Grab the current argument
      ExpressionNode* argument = arguments.front();

      // We really need to make sure that all argument types are resolved
      ReturnIf
      (
        argument->ResultType == nullptr,
        false,
        "Failed to find a type for a given argument"
      );

      // Store the types in a more human readable format
      Type* fromType = argument->ResultType;
      Type* toType = delegateParameter.ParameterType;

      // Figure out what type of cast this is...
      Shared& shared = Shared::GetInstance();
      switch (pass)
      {
        case OverloadPass::NoImplicitConversion:
        {
          // In this phase, the types must match *exactly*
          if (Type::IsSame(fromType, toType) == false)
            return false;
          break;
        }

        case OverloadPass::RawImplicitConversion:
        {
          // In this phase the types can be different but must be implicitly raw convertable
          // Ex: Conversion from NullType to Animal (does no work because NullType is also a handle)
          CastOperator cast = shared.GetCastOperator(fromType, toType);
          if (cast.IsValid == false || cast.CanBeImplicit == false || cast.RequiresCodeGeneration)
            return false;
          break;
        }

        case OverloadPass::AnyImplicitConversion:
        {
          // In this phase the types can be different but must be implicitly convertable (code generation may occur)
          // Ex: Conversion from an Integer to a Real
          CastOperator cast = shared.GetCastOperator(fromType, toType);
          if (cast.IsValid == false || cast.CanBeImplicit == false)
            return false;
          break;
        }

        default:
          Error("Invalid overload pass!");
          break;
      }

      // Move the argument forward
      arguments.popFront();
    }

    // We must have matched if we got here!
    return true;
  }

  ////***************************************************************************
  //void Overload::DetectAmbiguities(FunctionArray& functions, Function* function)
  //{
  //}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes









// Defines
#define ZilchSaveAndVerifyTokenPosition()                   \
  TokenPositionVerifier __verifier(&this->TokenPositions);  \
  this->SaveTokenPosition();

namespace Zilch
{
  //***************************************************************************
  // Structure that helps us to verify that our parser is working properly
  class TokenPositionVerifier
  {
  public:
    PodArray<size_t>* Positions;
    size_t Count;

    TokenPositionVerifier(PodArray<size_t>* positions) :
      Positions(positions),
      Count(positions->size())
    {
    }

    ~TokenPositionVerifier()
    {
      ErrorIf(this->Count != this->Positions->size(),
        "Token count was not equal when we left the stack as when we started");
    }
  };

  //***************************************************************************
  Parser::Parser(Project& project) :
    TokenIndex(0),
    Errors(*(CompilationErrors*)&project),
    ParentProject(&project)
  {
    ZilchErrorIfNotStarted(Parser);
  }
  
  //***************************************************************************
  void Parser::ParseIntoTree(const Array<UserToken>& tokens, SyntaxTree& syntaxTree, EvaluationMode::Enum evaluation)
  {
    // If we have no tokens, don't do anything
    if (IsTokenStreamEmpty(tokens))
      return;

    // Clear all token positions, just incase we reuse this parser
    this->TokenIndex = 0;
    this->TokenPositions.clear();

    // Store the tokenizer
    this->TokenStream = &tokens;

    // If we're evaluating an entire project, parse all the classes
    if (evaluation == EvaluationMode::Project)
    {
      // Get the root node for convenience
      RootNode* root = syntaxTree.Root;
      
      // Specifies if we parsed anything inside the script
      bool parsedSomething;
      
      // Parse the things that can show up inside a script (the outer most scope)
      do
      {
        // We haven't parsed anything yet this iteration...
        parsedSomething = false;

        // Attempt to parse a class definition
        parsedSomething |= root->NonTraversedNonOwnedNodesInOrder.Add(root->Classes.Add(this->Class())) != nullptr;

        // Attempt to parse an enum definition
        parsedSomething |= root->NonTraversedNonOwnedNodesInOrder.Add(root->Enums.Add(this->Enum())) != nullptr;
      }
      while (parsedSomething == true);
    }
    // Otherwise, we're just evaluating a single expression
    else
    {
      // Get the location where the expression is occuring
      CodeLocation location = tokens.front().Location;

      // We create a fake class node to hold the expression, since all expressions
      // must be inside functions, and all functions must be inside classes
      ClassNode* classNode = new ClassNode();
      classNode->Location = location;

      // All static classes are by choice a reference class (even if it cannot be allocated0
      classNode->CopyMode = TypeCopyMode::ReferenceType;

      // The class has a special generated name that cannot be accessed from within code
      classNode->Name.Location = location;
      classNode->Name.Token = ExpressionProgram;

      // Now we need to generate a special function to put the expression within
      FunctionNode* functionNode = new FunctionNode();
      functionNode->Location = location;

      // The function will have a special name that cannot be accessed from within code
      functionNode->Name.Location = location;
      functionNode->Name.Token = ExpressionMain;

      // Let the return type be an any type...
      functionNode->ReturnType = new AnySyntaxType();

      // The function is going to be static so that it can be invoked without a context
      functionNode->IsStatic = true;

      // Parse just one expression from the tokens (this may fail and return null!)
      syntaxTree.SingleExpressionScope = functionNode;
      syntaxTree.SingleExpressionIndex = functionNode->Statements.size();
      StatementNode* singleStatement = this->Statement(true);

      // If the statement is an expression, then we want to add an automatic return
      ExpressionNode* singleExpression = TypeBinding::DynamicCast<ExpressionNode*>(singleStatement);
      if (singleExpression != nullptr)
      {
        // Create the return statement to return the expression
        ReturnNode* returnNode = new ReturnNode();
        returnNode->ReturnValue = singleExpression;
        returnNode->Location = location;

        // Our statement is now just the parent return node
        singleStatement = returnNode;
      }

      // Add the expression as a single statement to the function
      functionNode->Statements.Add(singleStatement);

      // If this was not an expression, then always insert an implicit return at the end
      // Technically we could have issues if all code paths of their statement returned (but we're going to remove that error)
      if (singleExpression == nullptr)
      {
        // Always insert an implicit 'return null' at the end
        ValueNode* nullNode = new ValueNode();
        nullNode->Value = UserToken(Grammar::Null, &location);
        nullNode->Location = location;
        ReturnNode* returnNode = new ReturnNode();
        returnNode->ReturnValue = nullNode;
        returnNode->Location = location;
        functionNode->Statements.Add(returnNode);
      }

      // Add the psuedo function to the class
      classNode->Functions.Add(functionNode);
      classNode->NonTraversedNonOwnedNodesInOrder.Add(functionNode);

      // Finally, attach the class (and therefore function / expression) to the root
      syntaxTree.Root->Classes.Add(classNode);
      syntaxTree.Root->NonTraversedNonOwnedNodesInOrder.Add(classNode);
    }

    // If we somehow parsed everything, but didn't get to the end, we should throw an error
    if (this->TokenIndex != this->TokenStream->size() - 1)
    {
      // Grab the last token we hit
      UserToken token = (*this->TokenStream)[this->TokenIndex];

      // Show an error message that prints out the token we hit
      return this->Errors.Raise(token.Location, ErrorCode::ParsingNotComplete, token.Token.c_str(), Grammar::GetName(token.TokenId).c_str());
    }

    // If we parsed everything but there were attributes that never got attached to anything...
    if (this->LastAttributes.empty() == false)
    {
      // Show an error message to tell the user that attributes never got attached
      this->Errors.Raise(this->LastAttributes.back()->Location, ErrorCode::AttributesNotAttached);

      // Delete the leftover attributes and clear the last attribute list
      ZilchForEach(AttributeNode* node, this->LastAttributes.all())
        delete node;
      this->LastAttributes.clear();
      return;
    }
  }

  //***************************************************************************
  bool Parser::IsTokenStreamEmpty(const Array<UserToken>& tokens)
  {
    // If it's strictly empty, just return
    if (tokens.empty())
      return true;

    // Otherwise, check if the size is one and the front element is end
    if (tokens.size() == 1 && tokens.front().TokenId == Grammar::End)
      return true;

    // If we got here, it must not be empty
    return false;
  }

  //***************************************************************************
  void Parser::ParseExpressionInFunctionAndClass(const Array<UserToken>& expression, const Array<UserToken>& function, const Array<UserToken>& classTokensWithoutFunction, SyntaxTree& syntaxTree)
  {
    // If we have no expression tokens, don't do anything
    if (IsTokenStreamEmpty(expression))
      return;

    // Get the location where the expression is occuring
    CodeLocation location = expression.front().Location;

    // The resulting class node (either partially parsed or generaed)
    ClassNode* classNode = nullptr;

    // If we have the ability to parse a class...
    if (IsTokenStreamEmpty(function) == false)
    {
      // Clear all token positions and set the token stream to the class tokens
      this->TokenIndex = 0;
      this->TokenPositions.clear();
      this->TokenStream = &classTokensWithoutFunction;

      // Attempt to parse the class (remember, this class is guaranteed to not have the function within it)
      classNode = this->Class();
    }

    // If we either didn't have the ability to parse a class, or we failed on every attempt...
    if (classNode == nullptr)
    {
      // We create a fake class node to hold the expression, since all expressions
      // must be inside functions, and all functions must be inside classes
      classNode = new ClassNode();
      classNode->Location = location;

      // All static classes are by choice a reference class (even if it cannot be allocated0
      classNode->CopyMode = TypeCopyMode::ReferenceType;

      // The class has a special generated name that cannot be accessed from within code
      classNode->Name.Location = location;
      classNode->Name.Token = ExpressionProgram;
    }

    // Parse the given tokens as a function
    GenericFunctionNode* functionNode = nullptr;

    // If we have the ability to parse a function...
    if (IsTokenStreamEmpty(function) == false)
    {
      // To figure out what to do, just read the first token
      const UserToken& firstToken = function.front();

      // Clear all token positions and set the token stream to the function tokens
      this->TokenIndex = 0;
      this->TokenPositions.clear();
      this->TokenStream = &function;

      // Is this a function?
      {
        FunctionNode* node = this->Function();
        if (node != nullptr)
        {
          functionNode = node;

          // Add the psuedo function to the class
          classNode->Functions.Add(node);
          classNode->NonTraversedNonOwnedNodesInOrder.Add(node);
        }
      }
      
      // Is this a constructor?
      {
        ConstructorNode* node = this->Constructor();
        if (node != nullptr)
        {
          functionNode = node;

          // Add the psuedo function to the class
          classNode->Constructors.Add(node);
          classNode->NonTraversedNonOwnedNodesInOrder.Add(node);
        }
      }

      // Is this a destructor?
      {
        DestructorNode* node = this->Destructor();
        if (node != nullptr)
        {
          functionNode = node;

          // Add the psuedo function to the class
          classNode->Destructor = node;
          classNode->NonTraversedNonOwnedNodesInOrder.Add(node);
        }
      }

      switch (firstToken.TokenId)
      {
        case Grammar::Get:
        {
          // We're supposed to have read the get/set token, so advance by 1
          ++this->TokenIndex;
          BoundSyntaxType* type = new BoundSyntaxType();
          type->TypeName = "Integer";
          MemberVariableNode* memberVariable = new MemberVariableNode();
          memberVariable->IsProperty = true;
          memberVariable->Name.Token = "[Generated]";
          memberVariable->ResultSyntaxType = type;
          FunctionNode* node = this->GetSetFunctionBody(memberVariable, true);
          if (node != nullptr)
          {
            functionNode = node;
            memberVariable->Get = node;

            // Add the psuedo function to the class via member variable
            classNode->Variables.Add(memberVariable);
            classNode->NonTraversedNonOwnedNodesInOrder.Add(memberVariable);
          }
          break;
        }
        
        case Grammar::Set:
        {
          // We're supposed to have read the get/set token, so advance by 1
          ++this->TokenIndex;
          BoundSyntaxType* type = new BoundSyntaxType();
          type->TypeName = "Integer";
          MemberVariableNode* memberVariable = new MemberVariableNode();
          memberVariable->IsProperty = true;
          memberVariable->Name.Token = "[Generated]";
          memberVariable->ResultSyntaxType = type;
          FunctionNode* node = this->GetSetFunctionBody(memberVariable, false);
          if (node != nullptr)
          {
            functionNode = node;
            memberVariable->Set = node;

            // Add the psuedo function to the class via member variable
            classNode->Variables.Add(memberVariable);
            classNode->NonTraversedNonOwnedNodesInOrder.Add(memberVariable);
          }
          break;
        }
      }
    }

    // If we either didn't have the ability to parse a function, or we failed on every attempt...
    if (functionNode == nullptr)
    {
      // Now we need to generate a special function to put the expression within
      FunctionNode* node = new FunctionNode();
      functionNode = node;
      node->Location = location;

      // The function will have a special name that cannot be accessed from within code
      node->Name.Location = location;
      node->Name.Token = ExpressionMain;

      // The function is going to be static so that it can be invoked without a context
      node->IsStatic = true;

      // Add the psuedo function to the class
      classNode->Functions.Add(node);
      classNode->NonTraversedNonOwnedNodesInOrder.Add(node);
    }

    // Again, clear all token positions and set the token stream to the expression tokens
    this->TokenIndex = 0;
    this->TokenPositions.clear();
    this->TokenStream = &expression;

    // Parse just one expression from the tokens (this may fail and return null!)
    ExpressionNode* singleExpression = this->Expression();

    // As long as we got a valid single expression...
    if (singleExpression != nullptr)
    {
      // Find the scope that the expression probably exists within
      // (the latest scope before the expression's location)
      // Even if this cannot find a scope, it should always return the function node itself
      ScopeNode* latestScope = FindNearestScope(functionNode, singleExpression->Location);
      
      // We really don't want to crash doing auto-complete, but this is a serious error
      if (latestScope == nullptr)
      {
        // For now, just attach the expression to the class node
        // This will make sure everything gets deleted as expected, and we'll attempt to do some sort of auto-complete
        // Warning: This is not at all correct!
        syntaxTree.SingleExpressionScope = classNode;
        syntaxTree.SingleExpressionIndex = classNode->Statements.size();
        classNode->Statements.Add(singleExpression);
      }
      else
      {
        // Add the expression as a single statement to the latest scope (at the end of it)
        // so it will be evaluated in the context of that scope
        // Note that the found scope could just be the function itself
        syntaxTree.SingleExpressionScope = latestScope;
        syntaxTree.SingleExpressionIndex = latestScope->Statements.size();
        latestScope->Statements.Add(singleExpression);
      }
    }

    // Finally, attach the class (and therefore function / expression) to the root
    syntaxTree.Root->Classes.Add(classNode);
    syntaxTree.Root->NonTraversedNonOwnedNodesInOrder.Add(classNode);
  }

  //***************************************************************************
  ScopeNode* Parser::FindNearestScope(SyntaxNode* node, const CodeLocation& location)
  {
    // If this node that we're testing happens to come before the location...
    // Technically we should be testing if the location's end is within the node's end,
    // however it's slightly more tolerant to just check if the location's start is before the end
    // This should never happen, but we'll handle it anyways
    bool isLocationInsideNode =
      location.StartLine >= node->Location.StartLine &&
      (location.StartLine != node->Location.StartLine || location.StartCharacter >= node->Location.StartCharacter) &&
      location.StartLine <= node->Location.EndLine &&
      (location.StartLine != node->Location.EndLine || location.StartCharacter <= node->Location.EndCharacter);

    // We only want to consider nodes that we're inside of
    if (isLocationInsideNode == false)
    {
      return nullptr;
    }

    // We know that child nodes always come after our own node in a script
    // Therefore, we test ourself first, and then test children (to get the latest scope)
    ScopeNode* lastScope = TypeBinding::DynamicCast<ScopeNode*>(node);

    // Get all the children of this current node, as they could also be scopes
    NodeChildren children;
    node->PopulateChildren(children);

    // Loop through all the child nodes, some of which could be scopes
    for (size_t i = 0; i < children.size(); ++i)
    {
      // Grab the current child
      SyntaxNode* child = (*children[i]);

      // Recursively find any scopes in that node
      ScopeNode* found = FindNearestScope(child, location);

      // If we found anything....
      if (found != nullptr)
      {
        // We know here that the found scope must come after any previously found scopes, so replace it!
        lastScope = found;
      }
    }

    // Return whatever we found (this could be null!)
    return lastScope;
  }

  //***************************************************************************
  SyntaxType* Parser::ParseType(const Array<UserToken>& type)
  {
    // Clear all token positions and set the token stream to the type tokens
    this->TokenIndex = 0;
    this->TokenPositions.clear();
    this->TokenStream = &type;

    // Now attempt to read the type and see what we find
    return this->ReadTypeInfo();
  }

  //***************************************************************************
  void Parser::ErrorHere(ErrorCode::Enum errorCode, ...)
  {
    // Start a variadic argument list
    va_list argList;
    va_start(argList, errorCode);

    // Call the other error function
    ErrorHereArgs(errorCode, argList);

    // End the argument list
    va_end(argList);
  }

  //***************************************************************************
  void Parser::ErrorHereArgs(ErrorCode::Enum errorCode, StringParam extra, va_list argList)
  {
    // When raising an error 'here', we don't actually want the current token,
    // but rather the last token since our token index always points at the next token
    int previousIndex = (int)this->TokenIndex;
    --previousIndex;

    // Make sure we weren't at the first token, and if so cap our index at 0
    if (previousIndex < 0)
    {
      previousIndex = 0;
    }

    // Get the previous token
    const UserToken& previousToken = (*this->TokenStream)[(size_t)previousIndex];
    const UserToken& nextToken = (*this->TokenStream)[this->TokenIndex];

    // If we have a difference in lines...
    if (nextToken.Location.PrimaryLine != previousToken.Location.PrimaryLine)
    {
      // Invoke the error as if it was on the previous one
      this->Errors.RaiseArgs(previousToken.Location, extra, LocationArray(), errorCode, argList);
    }
    else
    {
      // Since it's on the same line, show the error at the next token
      this->Errors.RaiseArgs(nextToken.Location, extra, LocationArray(), errorCode, argList);
    }
  }

  //***************************************************************************
  void Parser::ErrorHereArgs(ErrorCode::Enum errorCode, va_list argList)
  {
    return ErrorHereArgs(errorCode, String(), argList);
  }
  
  //***************************************************************************
  void Parser::SetNodeLocationStartHere(SyntaxNode* node)
  {
    // Get the token where the last saved position was
    SetNodeLocationStartToToken(node, (*this->TokenStream)[this->TokenIndex]);
  }

  //***************************************************************************
  void Parser::SetNodeLocationPrimaryHere(SyntaxNode* node)
  {
    // Get the token where the last saved position was
    SetNodeLocationPrimaryToToken(node, (*this->TokenStream)[this->TokenIndex]);
  }

  //***************************************************************************
  void Parser::SetNodeLocationEndHere(SyntaxNode* node)
  {
    // When setting the end, we don't actually want the current token, but rather the last token
    // since our token index always points at the next token (which would be correct if we were starting)
    int previousIndex = (int)this->TokenIndex;
    --previousIndex;

    // Make sure we weren't at the first token, and if so cap our index at 0
    if (previousIndex < 0)
    {
      previousIndex = 0;
    }

    // Get the token where the last saved position was
    SetNodeLocationEndToToken(node, (*this->TokenStream)[(size_t)previousIndex]);
  }

  //***************************************************************************
  void Parser::SetNodeLocationStartToLastSave(SyntaxNode* node)
  {
    // Get the token where the last saved position was
    SetNodeLocationStartToToken(node, (*this->TokenStream)[this->TokenPositions.back()]);
  }

  //***************************************************************************
  void Parser::SetNodeLocationPrimaryToLastSave(SyntaxNode* node)
  {
    // Get the token where the last saved position was
    SetNodeLocationPrimaryToToken(node, (*this->TokenStream)[this->TokenPositions.back()]);
  }

  //***************************************************************************
  void Parser::SetNodeLocationEndToLastSave(SyntaxNode* node)
  {
    // Get the token where the last saved position was
    SetNodeLocationEndToToken(node, (*this->TokenStream)[this->TokenPositions.back()]);
  }

  //***************************************************************************
  void Parser::SetNodeLocationStartToToken(SyntaxNode* node, const UserToken& token)
  {
    // Set the line and character
    // Note that here we set the entire token, not just the start
    node->Location = token.Location;
  }

  //***************************************************************************
  void Parser::SetNodeLocationPrimaryToToken(SyntaxNode* node, const UserToken& token)
  {
    // Set the line and character
    node->Location.PrimaryCharacter = token.Location.PrimaryCharacter;
    node->Location.PrimaryLine = token.Location.PrimaryLine;
    node->Location.PrimaryPosition = token.Location.PrimaryPosition;
  }

  //***************************************************************************
  void Parser::SetNodeLocationEndToToken(SyntaxNode* node, const UserToken& token)
  {
    // Set the line and character
    node->Location.EndCharacter = token.Location.EndCharacter;
    node->Location.EndLine = token.Location.EndLine;
    node->Location.EndPosition = token.Location.EndPosition;
  }

  //***************************************************************************
  void Parser::SaveTokenPosition()
  {
    // Push the current token index onto the stack
    this->TokenPositions.push_back(this->TokenIndex);
  }

  //***************************************************************************
  void Parser::RecallTokenPosition()
  {
    // Pop the token index and revert the current one
    this->TokenIndex = this->TokenPositions.back();
    this->TokenPositions.pop_back();
  }

  //***************************************************************************
  void Parser::AcceptTokenPosition()
  {
    // Simply just pop the token position from the stack
    this->TokenPositions.pop_back();
  }

  //***************************************************************************
  bool Parser::AcceptAnyArgs(size_t parameters, const UserToken** out_token, va_list vl)
  {
    // Loop through all the extra arguments
    for (size_t i = 0; i < parameters; ++i)
    {
      // Retreive the symbol argument
      // We use int here because technically an enum can have any size (1, 2, etc)
      // but the va-args list will auto-promote the enum to int
      Grammar::Enum symbol = (Grammar::Enum)va_arg(vl, int /*Grammar::Enum*/);

      // Retreive the current token
      const UserToken* token = &(*this->TokenStream)[this->TokenIndex];

      // If the next token in the token stream was that same symbol...
      if (token->TokenId == symbol)
      {
        // We found one of them! Close the args list, increment the token index, output the value, and return success
        ++this->TokenIndex;
        *out_token = token;
        return true;
      }
    }

    // Otherwise, if we got here we didn't find it :<
    return false;
  }

  //***************************************************************************
  bool Parser::AcceptAny(size_t parameters, const UserToken** out_token, ...)
  {
    // Create a variadic argument list to read the extra arguments
    va_list vl;
    va_start(vl, out_token);

    // Run the accept any that takes a va_list
    bool result = AcceptAnyArgs(parameters, out_token, vl);

    // Close the va_list and return the result
    va_end(vl);
    return result;
  }

  //***************************************************************************
  bool Parser::Expect(Grammar::Enum grammarConstant, ErrorCode::Enum errorCode, ...)
  {
    // Create a variadic argument list to read the extra arguments
    va_list vl;
    va_start(vl, errorCode);
    
    // Invoke the argument list version
    const UserToken* ignoredToken = nullptr;
    bool result = this->ExpectAndRetrieveArgs(grammarConstant, ignoredToken, errorCode, vl);
      
    // Finalize the argument list and return what we got back
    va_end(vl);
    return result;
  }

  //***************************************************************************
  bool Parser::ExpectAndRetrieveArgs(Grammar::Enum grammarConstant, const UserToken*& outToken, ErrorCode::Enum errorCode, va_list vl)
  {
    // Retreive the next token from the stream and store it
    const UserToken* userToken = &(*this->TokenStream)[this->TokenIndex];

    // If the next token in the token stream was not the same symbol...
    if (userToken->TokenId != grammarConstant)
    {
      // Anything extra we decide to append to the error
      String extra;

      bool foundWasKeyword = (userToken->TokenId >= Grammar::Abstract && userToken->TokenId <= Grammar::While);

      if (grammarConstant == Grammar::LowerIdentifier || grammarConstant == Grammar::UpperIdentifier)
      {
        if (foundWasKeyword)
        {
          extra = String::Format(" Note: '%s' is a keyword and cannot be used as a name.",
            userToken->Token.c_str());
        }
        // If we expected an upper identifier, but we got a lower one...
        else if (userToken->TokenId == Grammar::LowerIdentifier)
        {
          String expectedIdentifier = ToUpperCamelCase(userToken->Token);
          extra = String::Format(" Upper-camel case names are required here (use '%s' instead of '%s').",
            expectedIdentifier.c_str(), userToken->Token.c_str());
        }
        // If we expected a lower identifier, but we got an upper one...
        else if (userToken->TokenId == Grammar::UpperIdentifier)
        {
          String expectedIdentifier = ToLowerCamelCase(userToken->Token);
          extra = String::Format(" Lower-camel case names are required here (use '%s' instead of '%s').",
            expectedIdentifier.c_str(), userToken->Token.c_str());
        }
      }
      else
      {
        // Get string representations of the two tokens so we can display info to the user
        String foundSymbol    = Grammar::GetKeywordOrSymbol(userToken->TokenId);
        String expectedSymbol = Grammar::GetKeywordOrSymbol(grammarConstant);

        // Because we are expecting a particular token, format extra information so
        // that the error always says what we found and what we expected to find
        extra = String::Format(" We found '%s' but we expected to find '%s'.",
          foundSymbol.c_str(), expectedSymbol.c_str());
      }

      // Report an error here
      ErrorHereArgs(errorCode, extra, vl);

      // We found a token that wasn't what we were looking for, return failure
      va_end(vl);
      return false;
    }

    // Otherwise, if the out-token is not null, output the found token
    outToken = userToken;

    // We found all the given tokens! Push the token index out to the end of the list and return success
    ++this->TokenIndex;
    return true;
  }

  //***************************************************************************
  bool Parser::ExpectAndRetrieve(Grammar::Enum grammarConstant, const UserToken*& outToken, ErrorCode::Enum errorCode, ...)
  {
    // Create a variadic argument list to read the extra arguments
    va_list vl;
    va_start(vl, errorCode);

    // Invoke the argument list version
    bool result = this->ExpectAndRetrieveArgs(grammarConstant, outToken, errorCode, vl);

    // Finalize the argument list and return what we got back
    va_end(vl);
    return result;
  }

  //***************************************************************************
  bool Parser::Accept(size_t parameters, ...)
  {
    // Create a variadic argument list to read the extra arguments
    va_list vl;
    va_start(vl, parameters);

    // Compute the end token that we'll stop at
    const size_t end = parameters + this->TokenIndex;

    // Loop through all the tokens we were given (and loop over the tokens in the tokenizer)
    for (size_t i = this->TokenIndex; i < end; ++i)
    {
      // Retreive the symbol argument
      // We use int here because technically an enum can have any size (1, 2, etc)
      // but the va-args list will auto-promote the enum to int
      Grammar::Enum symbol = (Grammar::Enum)va_arg(vl, int /*Grammar::Enum*/);

      // If the next token in the token stream was not the same symbol...
      if ((*this->TokenStream)[i].TokenId != symbol)
      {
        // We found a token that wasn't what we were looking for, return failure
        va_end(vl);
        return false;
      }
    }

    // We found all the given tokens! Push the token index out to the end of the list and return success
    va_end(vl);
    this->TokenIndex = end;
    return true;
  }

  //***************************************************************************
  bool Parser::AcceptAndRetrieve(size_t parameters, ...)
  {
    // Create a variadic argument list to read the extra arguments
    va_list vl;
    va_start(vl, parameters);

    // Compute the end token that we'll stop at
    const size_t end = parameters + this->TokenIndex;

    // Loop through all the tokens we were given (and loop over the tokens in the tokenizer)
    for (size_t i = this->TokenIndex; i < end; ++i)
    {
      // Retreive the symbol argument and a pointer to the out token pointer
      // We use int here because technically an enum can have any size (1, 2, etc)
      // but the va-args list will auto-promote the enum to int
      Grammar::Enum symbol = (Grammar::Enum)va_arg(vl, int /*Grammar::Enum*/);

      // A pointer to a constant user token
      const UserToken** out_token = va_arg(vl, const UserToken**);

      // Retreive the next token from the stream and store it
      const UserToken* user_token = &(*this->TokenStream)[i];

      // If the next token in the token stream was not the same symbol...
      if (user_token->TokenId != symbol)
      {
        // We found a token that wasn't what we were looking for, return failure
        va_end(vl);
        return false;
      }

      // Otherwise, if the out-token is not null, output the found token
      if (out_token != nullptr)        
        *out_token = user_token;
    }

    // We found all the given tokens! Push the token index out to the end of the list and return success
    va_end(vl);
    this->TokenIndex = end;
    return true;
  }

  //***************************************************************************
  bool Parser::ReadDelegateTypeContents(DelegateSyntaxType* delegateSyntaxType)
  {
    //// Is this a template type?
    //if (Accept(1, Grammar::BeginTemplate))
    //{
    //  // Parse arguments to the indexer until there are no more
    //  ZilchLoop
    //  {
    //    // Attempt to read another type
    //    SyntaxType* argumentType = this->ReadTypeInfo();

    //    // If the argument was valid...
    //    if (argumentType == nullptr)
    //    {
    //      // The argument was not found!
    //      ErrorHere(ErrorCode::TemplateArgumentNotFound);
    //    }
    //    else
    //    {
    //      // Add it to the arguments list
    //      dataSyntaxType->TemplateArguments.Add(argumentType);
    //    }

    //    // Attempt to read an argument separator, and if we don't find one, break out
    //    if (Accept(1, Grammar::ArgumentSeparator) == false)
    //    {
    //      break;
    //    }
    //  }

    //  // We now expect to close the template argument
    //  if (Expect(Grammar::EndTemplate, ErrorCode::TemplateTypeArgumentsNotComplete) == false)
    //  {
    //    // We didn't successfully parse a the type definition, so return a failure
    //    delete dataSyntaxType;
    //    RecallTokenPosition();
    //    return nullptr;
    //  }
    //}

    // Get the name of the function
    if (Expect(Grammar::BeginFunctionParameters, ErrorCode::FunctionArgumentListNotFound, "delegate"))
    {
      // Get all the parameters for the delegate
      do
      {
        // Store a temporary copy of the current parameter that we're reading in
        DelegateSyntaxParameter parameter;

        // Look for an identifier
        if (AcceptAndRetrieve(1, Grammar::LowerIdentifier, &parameter.Name))
        {
          // Look for a type specifier (followed by the parameter's type)
          if (Expect(Grammar::TypeSpecifier, ErrorCode::ParameterTypeSpecifierNotFound, parameter.Name->Token.c_str()))
          {
            // Attempt to read the type after the parameter
            if ((parameter.Type = this->ReadTypeInfo()) != nullptr)
            {
              // Add this parameter to the list of parameters
              delegateSyntaxType->Parameters.push_back(parameter);
            }
            else
            {
              // Show an error
              ErrorHere(ErrorCode::ParameterTypeNotFound, parameter.Name->Token.c_str());
              return false;
            }
          }
          else
          {
            // We didn't read the type specifier
            return false;
          }
        }
      }
      while (Accept(1, Grammar::ArgumentSeparator));

      // Look for the end parenthasis
      if (Expect(Grammar::EndFunctionParameters, ErrorCode::FunctionArgumentListNotComplete, "delegate"))
      {
        // Return if we successfully parsed the type at the end or not
        return AcceptOptionalTypeSpecifier(delegateSyntaxType->Return, ErrorCode::DelegateReturnTypeNotFound);
      }
    }

    // If we got down here, we must have failed...
    return false;
  }

  //***************************************************************************
  BoundSyntaxType* Parser::ReadBoundTypeInfo()
  {
    ZilchSaveAndVerifyTokenPosition();

    // Grab the user token for the identifier
    const UserToken* typeToken;

    // Look for the type identifier
    if (AcceptAndRetrieve(1, Grammar::UpperIdentifier, &typeToken) == true)
    {
      // Create a new data syntax type
      BoundSyntaxType* boundSyntaxType = new BoundSyntaxType();
      this->SetNodeLocationStartToLastSave(boundSyntaxType);

      // Store away the type string
      boundSyntaxType->TypeName = typeToken->Token;

      // Is this a template type?
      if (Accept(1, Grammar::BeginTemplate))
      {
        // Parse arguments to the template there are no more
        ZilchLoop
        {
          // Attempt to read another type
          SyntaxType* argumentType = this->ReadTypeInfo();

          // If the argument was valid...
          if (argumentType == nullptr)
          {
            // The argument was not found!
            ErrorHere(ErrorCode::TemplateArgumentNotFound);

            // We didn't successfully parse a the type definition, so return a failure
            delete boundSyntaxType;
            RecallTokenPosition();
            return nullptr;
          }
          else
          {
            // Add it to the arguments list
            boundSyntaxType->TemplateArguments.Add(argumentType);
          }

          // Attempt to read an argument separator, and if we don't find one, break out
          if (Accept(1, Grammar::ArgumentSeparator) == false)
          {
            break;
          }
        }

        // We now expect to close the template argument
        if (Expect(Grammar::EndTemplate, ErrorCode::TemplateTypeArgumentsNotComplete) == false)
        {
          // We didn't successfully parse a the type definition, so return a failure
          delete boundSyntaxType;
          RecallTokenPosition();
          return nullptr;
        }
      }

      // Accept the token position and return the data type
      AcceptTokenPosition();

      // We'll return the data syntax type
      return boundSyntaxType;
    }

    // Return nothing since we failed to parse
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  SyntaxType* Parser::ReadTypeInfo()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // If this type represents the any type...
    if (this->Accept(1, Grammar::Any))
    {
      // There's nothing else to read about the any type, just return a new one
      this->AcceptTokenPosition();
      SyntaxType* anySyntaxType = new AnySyntaxType();
      this->SetNodeLocationStartToLastSave(anySyntaxType);
      return anySyntaxType;
    }
    // If this type represents a delegate type...
    else if (this->Accept(1, Grammar::Delegate))
    {
      // Create a new delegate syntax type
      DelegateSyntaxType* delegateSyntaxType = new DelegateSyntaxType();

      // Read the delegate type
      if (this->ReadDelegateTypeContents(delegateSyntaxType))
      {
        // Accept the token position and return the delegate type
        this->AcceptTokenPosition();
        this->SetNodeLocationStartToLastSave(delegateSyntaxType);

        // We'll return the delegate syntax type
        return delegateSyntaxType;
      }
      else
      {
        // We didn't successfully parse a the deligate definition, so return a failure
        delete delegateSyntaxType;
        this->RecallTokenPosition();
        return nullptr;
      }
    }
    else
    {
      // Store whether or not this type is a reference (uses the ref keyword)
      bool isIndirectionRef = false;
      if (Accept(1, Grammar::Ref))
      {
        // This is an indirection
        isIndirectionRef = true;
      }

      // Attempt to read a named type...
      BoundSyntaxType* boundSyntaxType = this->ReadBoundTypeInfo();

      // If we failed to read the named syntax type, return nothing
      if (boundSyntaxType == nullptr)
      {
        this->RecallTokenPosition();
        return nullptr;
      }

      // If this is an indirection of a type (ref)
      if (isIndirectionRef)
      {
        // Create a qualified syntax type
        IndirectionSyntaxType* indirectionSyntaxType = new IndirectionSyntaxType();
        this->SetNodeLocationStartToLastSave(indirectionSyntaxType);

        // Set the true type for the qualified type...
        indirectionSyntaxType->ReferencedType = boundSyntaxType;

        // Return the qualified syntax type
        this->AcceptTokenPosition();
        return indirectionSyntaxType;
      }
      else
      {
        // Return the true syntax type that we parsed
        this->AcceptTokenPosition();
        return boundSyntaxType;
      }
    }
  }

  //***************************************************************************
  LocalVariableNode* Parser::LocalVariable(bool initialized)
  {
    // Parse any optional attribute
    this->ParseAllOptionalAttributes();

    // If any errors occurred in parsing attributes, error here
    if (this->Errors.WasError)
      return nullptr;

    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // First look for the "var" keyword
    if (Accept(1, Grammar::Variable))
    {
      // Create a variable node
      LocalVariableNode* node = new LocalVariableNode();
      this->SetNodeLocationStartToLastSave(node);

      // Attach any attributes we parsed for this member variable
      this->AttachLastAttributeToNode(node->Attributes);
      
      // If this is a static variable...
      if (GetAttribute(node->Attributes, StaticAttribute) != nullptr)
          node->IsStatic = true;

      // Get the name of the variable
      const UserToken* variableName = nullptr;
      if (ExpectAndRetrieve(Grammar::LowerIdentifier, variableName, ErrorCode::VariableNameNotFound))
      {
        // Store the name of the node
        node->Name = *variableName;
        this->SetNodeLocationPrimaryToToken(node, *variableName);

        // Return if we successfully parsed the type at the end or not
        if (AcceptOptionalTypeSpecifier(node->ResultSyntaxType, ErrorCode::VariableTypeNotFound, node->Name.c_str()))
        {
          // If we don't need to be initialized, skip this next part
          if (initialized == false)
          {
            // Accept the token position, and return the variable node
            this->SetNodeLocationEndHere(node);
            this->AcceptTokenPosition();
            return node;
          }

          // Now make sure we are assigning to the variable
          if (Expect(Grammar::Assignment, ErrorCode::VariableMustBeInitialized, node->Name.c_str()))
          {
            // Now attempt to read an expression in
            node->InitialValue = Expression();

            // If we parsed an initial value...
            if (node->InitialValue != nullptr)
            {
              // Accept the token position, and return the variable node
              this->SetNodeLocationEndHere(node);
              this->AcceptTokenPosition();
              return node;
            }
            else
            {
              // Show an error message
              this->ErrorHere(ErrorCode::VariableInitialValueNotFound, node->Name.c_str());
            }
          }
        }
      }

      // We must have failed, so delete the node
      delete node;
    }

    // We didn't successfully parse a variable definition, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  template <typename Node>
  void Parser::ApplyVirtualStaticExtensionAttributes(Node* node)
  {
    // If this is a static function...
    if (GetAttribute(node->Attributes, StaticAttribute) != nullptr)
        node->IsStatic = true;

    // If this is a virtual function...
    if (GetAttribute(node->Attributes, VirtualAttribute) != nullptr)
    {
      // If the node is static, then we cannot be marked as virtual
      if (node->IsStatic)
      {
        this->ErrorHere(ErrorCode::StaticCannotBeVirtual, node->Name.c_str());
        return;
      }

      // Mark the node as being virtual
      node->Virtualized = VirtualMode::Virtual;
    }

    // If this is an extension function...
    AttributeNode* extensionAttribute = GetAttribute(node->Attributes, ExtensionAttribute);
    if (extensionAttribute != nullptr)
    {
      // We emit this error message over and over for all cases of failure
      CodeLocation& location = extensionAttribute->Location;
      cstr attributeName = extensionAttribute->TypeName->Token.c_str();
      cstr errorMessage = " The attribute must take the form of [Extension(typeid(OtherType))] and the OtherType must be a class/struct type.";

      // Make sure the attribute has a call node that only takes one argument
      FunctionCallNode* callNode = extensionAttribute->AttributeCall;
      if (callNode == nullptr || callNode->Arguments.size() != 1)
        return this->Errors.Raise(location, ErrorCode::InvalidAttribute, attributeName, errorMessage);

      // Make sure the only argument to the attribute call is a typeid node with a compile time type
      TypeIdNode* typeIdNode = TypeBinding::DynamicCast<TypeIdNode*>(callNode->Arguments[0]);
      if (typeIdNode == nullptr || typeIdNode->CompileTimeSyntaxType == nullptr)
        return this->Errors.Raise(location, ErrorCode::InvalidAttribute, attributeName, errorMessage);

      // Make sure the typeid's compile time type is a bound type (class/struct) not a delegate or indirect type
      BoundSyntaxType* extensionOwner = TypeBinding::DynamicCast<BoundSyntaxType*>(typeIdNode->CompileTimeSyntaxType);
      if (extensionOwner == nullptr)
        return this->Errors.Raise(location, ErrorCode::InvalidAttribute, attributeName, errorMessage);

      // We successfully parsed an extension owner
      node->ExtensionOwner = extensionOwner->Clone();
    }

    // If this is a virtual function...
    if (GetAttribute(node->Attributes, OverrideAttribute) != nullptr)
    {
      ErrorIf(node->Virtualized == VirtualMode::Overriding,
        "It is not possible to already be overriding");

      // If the node is non-virtual, then mark it as overriding
      if (node->Virtualized == VirtualMode::NonVirtual)
      {
        // If the node is static, then we cannot be marked as virtual or overriding
        if (node->IsStatic)
        {
          this->ErrorHere(ErrorCode::StaticCannotBeOverriding, node->Name.c_str());
          return;
        }

        // Mark the node as being overriding
        node->Virtualized = VirtualMode::Overriding;
      }
      else
      {
        // The node is both overriding and virtual, this is unnecessary
        this->ErrorHere(ErrorCode::UnnecessaryVirtualAndOverride, node->Name.c_str());
        return;
      }
    }
  }

  //***************************************************************************
  MemberVariableNode* Parser::MemberVariable()
  {
    // Parse any optional attribute
    this->ParseAllOptionalAttributes();

    // If any errors occurred in parsing attributes, error here
    if (this->Errors.WasError)
      return nullptr;

    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // First look for the "var" keyword
    if (this->Accept(1, Grammar::Variable))
    {
      // Create a variable node
      MemberVariableNode* node = new MemberVariableNode();
      this->SetNodeLocationStartToLastSave(node);

      // Attach any attributes we parsed for this member variable
      this->AttachLastAttributeToNode(node->Attributes);

      // The name token we attempt to read
      const UserToken* nameToken = nullptr;

      // Get the name of the variable
      if (this->ExpectAndRetrieve(Grammar::UpperIdentifier, nameToken, ErrorCode::VariableNameNotFound))
      {
        // Store the name of the node
        node->Name = *nameToken;

        // Look for any virtual and static attributes
        this->ApplyVirtualStaticExtensionAttributes(node);

        // If any errors occurred from the virtual/static parsing
        if (this->Errors.WasError)
        {
          // We didn't successfully parse the static/virtual/override attributes
          this->RecallTokenPosition();
          delete node;
          return nullptr;
        }

        // Look for a type after the member variable
        if (this->AcceptOptionalTypeSpecifier(node->ResultSyntaxType, ErrorCode::VariableTypeNotFound, node->Name.c_str()))
        {
          // As long as we got a valid type...
          if (node->ResultSyntaxType != nullptr)
          {
            // Accept the beginning scope
            if (this->Accept(1, Grammar::BeginScope))
            {
              // This is a property, thus we expect to find a get or a set, or both
              // They must always come in the order of 'get' first, then set
              node->IsProperty = true;

              // Check if we have a getter
              if (this->Accept(1, Grammar::Get))
              {
                // Read in the get function body
                node->Get = this->GetSetFunctionBody(node, true);
              }

              // Check if we have a setter
              if (this->Accept(1, Grammar::Set))
              {
                // Read in the set function body
                node->Set = this->GetSetFunctionBody(node, false);
              }

              // Error checking, we don't want to find a get after a set
              if (this->Accept(1, Grammar::Get))
              {
                // Show an error message
                this->ErrorHere(ErrorCode::GetFoundAfterSet, node->Name.c_str());
              }
              // We expect to see the end of the scope
              else if (this->Expect(Grammar::EndScope, ErrorCode::PropertyDeclarationNotComplete, node->Name.c_str()))
              {
                // Accept the token position, and return the variable node
                this->SetNodeLocationEndHere(node);
                this->AcceptTokenPosition();
                return node;
              }
              // If we're doing auto-complete or something like it...
              else if (this->Errors.TolerantMode)
              {
                // Since we're being tolerant, just eat tokens until we hit the end of our scope
                // This is just an approximation, as there may be actual scope errors
                // This will return true if it finds the scope and will advance the token forward automatically
                if (this->MoveToScopeEnd())
                {
                  // Accept the token position, and return the variable node
                  this->SetNodeLocationEndHere(node);
                  this->AcceptTokenPosition();
                  return node;
                }
              }
            }
            // We are not a property, so make sure the user is initializing the variable
            else
            {
              if (this->Accept(1, Grammar::Assignment))
              {
                // Note: It is actually legal for a member variable to Overriding or Virtual
                // In the case that we're overriding, we'll still be a raw member when directly accessed, but
                // if we're accessed through an interface it will use the generated get/set
                // In the case that we're virtual, the member itself basically becomes a property
                // This needs to be handled specially, because in the PreInitialize we still wan't to assign
                // a value to the raw field data, but then anyone who accessing the member after that goes
                // through a property get/set

                // Now attempt to read the initialization expression in
                node->InitialValue = Expression();
              
                // If we failed to parsed an initial value...
                if (node->InitialValue == nullptr)
                {
                  // Show an error message
                  this->ErrorHere(ErrorCode::VariableInitialValueNotFound, node->Name.c_str());

                  // We didn't successfully parse a variable definition, so just recall the token position and return null
                  RecallTokenPosition();
                  delete node;
                  return nullptr;
                }
              }

              // Attempt to read the statement separator
              if (this->Expect(Grammar::StatementSeparator, ErrorCode::VariableInitializationNotComplete, node->Name.c_str()))
              {
                // Accept the token position, and return the variable node
                this->SetNodeLocationEndHere(node);
                this->AcceptTokenPosition();
                return node;
              }
            }
          }
          else
          {
            // Show an error message
            this->ErrorHere(ErrorCode::MemberVariableTypesCannotBeInferred, node->Name.c_str());
          }
        }
      }

      // We must have failed, so delete the node
      delete node;
    }

    // We didn't successfully parse a variable definition, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  void Parser::ParseAllOptionalAttributes()
  {
    // Parse all the optional atrtibutes
    while (ParseOneOptionalAttribute());
  }

  //***************************************************************************
  bool Parser::ParseOneOptionalAttribute()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting an attribute
    if (Accept(1, Grammar::BeginAttribute))
    {
      // Every attribute starts with a type name
      const UserToken* typeName;

      // Read the attribute name
      if (ExpectAndRetrieve(Grammar::UpperIdentifier, typeName, ErrorCode::AttributeTypeNotFound))
      {
        // Create an attribute node that we'll fill in below
        AttributeNode* node = new AttributeNode();
        this->SetNodeLocationStartToLastSave(node);

        // Save the type name on the node
        node->TypeName = typeName;

        // Read an optional function call after the attribute node
        node->AttributeCall = this->FunctionCall(nullptr);

        // If there was any sort of error, bail out
        if (this->Errors.WasError)
        {
          // We didn't successfully parse the function call, so just recall the token position and return false
          delete node;
          RecallTokenPosition();
          return false;
        }

        // Look for the ending of the attribute
        if (Expect(Grammar::EndAttribute, ErrorCode::AttributeNotComplete, typeName->Token.c_str()))
        {
          // Add this node to the list of attributes which
          // we will attach to the next valid node we find
          this->LastAttributes.Add(node);

          // Accept the token position, and return the attributes
          this->SetNodeLocationEndHere(node);
          AcceptTokenPosition();
          return true;
        }
        else
        {
          delete node;
        }
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return false;
  }
  
  //***************************************************************************
  void Parser::AttachLastAttributeToNode(NodeList<AttributeNode>& attributes)
  {
    // Output the list of attributes
    attributes = this->LastAttributes;

    // Clear out the last attributes
    this->LastAttributes.clear();
  }

  //***************************************************************************
  EnumValueNode* Parser::EnumValue()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Stores the initializer type (reused variable)
    const UserToken* valueName;

    // Attempt to read the enum value name
    if (this->AcceptAndRetrieve(1, Grammar::UpperIdentifier, &valueName))
    {
      // Create a return node since this is a valid return statement
      EnumValueNode* node = new EnumValueNode();
      this->SetNodeLocationStartToLastSave(node);

      // Set the name of the enum
      node->Name = *valueName;
      
      // It's optional to set a specific integral value
      if (this->Accept(1, Grammar::Assignment))
      {
        // Read the custom value we want to give this enum entry
        if (this->ExpectAndRetrieve(Grammar::IntegerLiteral, node->Value, ErrorCode::EnumValueRequiresIntegerLiteral, node->Name.c_str()) == false)
        {
          // We didn't successfully parse an enum, so just recall the token position and return null
          this->RecallTokenPosition();
          delete node;
          return nullptr;
        }
      }

      // Accept the token position, and return the "return node"
      this->AcceptTokenPosition();
      this->SetNodeLocationEndHere(node);
      return node;
    }

    // We didn't successfully parse en enum, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  EnumNode* Parser::Enum()
  {
    // Parse any optional attribute
    this->ParseAllOptionalAttributes();
    
    // If any errors occurred in parsing attributes, error here
    if (this->Errors.WasError)
      return nullptr;

    // Save the token position
    ZilchSaveAndVerifyTokenPosition();
    
    // This will store the keyword we used to star this object (class or struct)
    const UserToken* enumType;

    // First look for the "enum" or "flags" keyword
    if (this->AcceptAny(2, &enumType, Grammar::Enumeration, Grammar::Flags))
    {
      // We must be inside a class, so allocate a node for it
      EnumNode* node = new EnumNode();
      this->SetNodeLocationStartToLastSave(node);

      // We read the class or struct keyword, it's safe to assume no other node type could be here
      // Attach the attributes we read above to the class node
      this->AttachLastAttributeToNode(node->Attributes);

      // Mark if this is considered a flags enum or not...
      node->IsFlags = (enumType->TokenId == Grammar::Flags);
      
      // Get the name of the enum
      const UserToken* name;
      if (this->ExpectAndRetrieve(Grammar::UpperIdentifier, name, ErrorCode::EnumNameNotFound))
      {
        // Set the name of the class node
        node->Name = *name;
        
        // Are we inheriting from a type (or implementing an interface?)
        if (this->Accept(1, Grammar::Inheritance))
        {
          // Attempt to read a parent type for this enum
          node->Inheritance = this->ReadTypeInfo();

          // If we had an error reading a type...
          if (this->Errors.WasError)
          {
            // We didn't successfully parse a class definition, so just recall the token position and return null
            delete node;
            RecallTokenPosition();
            return nullptr;
          }
        }

        // Now dive into the scope...
        if (this->Expect(Grammar::BeginScope, ErrorCode::EnumBodyNotFound, node->Name.c_str()))
        {
          // Parse the things that can show up inside a class until we run out of those
          ZilchLoop
          {
            // Attempt to add an enum value
            if (node->Values.Add(this->EnumValue()))
            {
              // If we don't find a comma, break out since there should be nothing more
              // Note that we allow a trailing comma after the last enum value
              if (this->Accept(1, Grammar::ArgumentSeparator) == false)
              {
                break;
              }
            }
            // We didn't parse an enum value, so break out
            else
            {
              break;
            }
          }

          // If we hit the end of the class scope...
          bool finishedNode = Expect(Grammar::EndScope, ErrorCode::EnumBodyNotComplete, node->Name.c_str());

          // As long as we finished this node (either via correct parsing or tolerance)
          if (finishedNode == false && this->Errors.TolerantMode)
          {
            // Since we're being tolerant, just eat tokens until we hit the end of our scope
            // This is just an approximation, as there may be actual scope errors
            // This will return true if it finds the scope and will advance the token forward automatically
            finishedNode = this->MoveToScopeEnd();
          }

          // As long as we finished this node (either via correct parsing or tolerance)
          if (finishedNode)
          {
            // We read the entire class defintion
            // Accept the token position, and return the class node
            this->AcceptTokenPosition();
            this->SetNodeLocationEndHere(node);
            return node;
          }
        }
      }

      // We must have failed, so delete the node
      delete node;
    }

    // We didn't successfully parse a class definition, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ClassNode* Parser::Class()
  {
    // Parse any optional attribute
    this->ParseAllOptionalAttributes();

    // If any errors occurred in parsing attributes, error here
    if (this->Errors.WasError)
      return nullptr;

    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // This will store the keyword we used to star this object (class or struct)
    const UserToken* objectType;

    // First look for the "class" or "struct" keyword
    if (AcceptAny(2, &objectType, Grammar::Class, Grammar::Struct))
    {
      // We must be inside a class, so allocate a node for it
      ClassNode* node = new ClassNode();
      this->SetNodeLocationStartToLastSave(node);

      // We read the class or struct keyword, it's safe to assume no other node type could be here
      // Attach the attributes we read above to the class node
      this->AttachLastAttributeToNode(node->Attributes);

      // Set if we are a value type or not
      if (objectType->TokenId == Grammar::Struct)
      {
        // It was declared as a struct, therefore it is a value type!
        node->CopyMode = TypeCopyMode::ValueType;
      }
      else
      {
        node->CopyMode = TypeCopyMode::ReferenceType;
      }

      // Get the name of the class
      const UserToken* name;
      if (ExpectAndRetrieve(Grammar::UpperIdentifier, name, ErrorCode::ClassNameNotFound))
      {
        // Set the name of the class node
        node->Name = *name;

        // Is this a template type?
        if (Accept(1, Grammar::BeginTemplate))
        {
          // Parse arguments to the template until there are no more
          ZilchLoop
          {
            // Get the name of the argument
            const UserToken* argumentName;

            // Look for an identifier...
            if (ExpectAndRetrieve(Grammar::UpperIdentifier, argumentName, ErrorCode::TemplateArgumentNotFound))
            {
              // Add it to the arguments list
              node->TemplateArguments.push_back(argumentName);
            }
            else
            {
              // We didn't successfully parse a class definition, so just recall the token position and return null
              delete node;
              this->RecallTokenPosition();
              return nullptr;
            }

            // Attempt to read an argument separator, and if we don't find one, break out
            if (Accept(1, Grammar::ArgumentSeparator) == false)
            {
              break;
            }
          }

          // We now expect to close the template argument
          if (Expect(Grammar::EndTemplate, ErrorCode::TemplateTypeArgumentsNotComplete) == false)
          {
            // We didn't successfully parse a class definition, so just recall the token position and return null
            delete node;
            RecallTokenPosition();
            return nullptr;
          }
        }

        // Are we inheriting from a type (or implementing an interface?)
        if (Accept(1, Grammar::Inheritance))
        {
          // Parse all the interfaces / base class
          ZilchLoop
          {
            // Look for an identifier...
            if (SyntaxType* argumentType = this->ReadTypeInfo())
            {
              // Add it to the arguments list
              node->Inheritance.Add(argumentType);
            }
            else
            {
              // We didn't successfully parse a class definition, so just recall the token position and return null
              delete node;
              RecallTokenPosition();
              return nullptr;
            }

            // Attempt to read an argument separator, and if we don't find one, break out
            if (Accept(1, Grammar::ArgumentSeparator) == false)
            {
              break;
            }
          }
        }

        // Now dive into the scope...
        if (Expect(Grammar::BeginScope, ErrorCode::ClassBodyNotFound, node->Name.c_str()))
        {
          // Specifies if we parsed anything inside the current scope
          bool parsedSomething;

          // Clear the destructor first
          node->Destructor = nullptr;

          // Parse the things that can show up inside a class until we run out of those
          do
          {
            // We haven't parsed anything yet this iteration...
            parsedSomething = false;

            // Attempt to parse a variable
            parsedSomething |= node->NonTraversedNonOwnedNodesInOrder.Add(node->Variables.Add(this->MemberVariable())) != nullptr;

            // Attempt to parse a function definition
            parsedSomething |= node->NonTraversedNonOwnedNodesInOrder.Add(node->Functions.Add(this->Function())) != nullptr;

            // Attempt to parse a constructor definition
            parsedSomething |= node->NonTraversedNonOwnedNodesInOrder.Add(node->Constructors.Add(this->Constructor())) != nullptr;

            // Attempt to parse a 'sends' statement
            parsedSomething |= node->NonTraversedNonOwnedNodesInOrder.Add(node->SendsEvents.Add(this->SendsEvent())) != nullptr;

            // Attempt to parse a destructor definition
            DestructorNode* destructor = this->Destructor();
            if (destructor != nullptr)
            {
              if (node->Destructor == nullptr)
              {
                // Set the destructor
                node->NonTraversedNonOwnedNodesInOrder.Add(destructor);
                node->Destructor = destructor;
                parsedSomething = true;
              }
              else
              {
                // Show an error
                ErrorHere(ErrorCode::OnlyOneDestructorAllowed);

                // We didn't successfully parse a class definition, so just recall the token position and return null
                delete node;
                delete destructor;
                RecallTokenPosition();
                return nullptr;
              }
            }
          }
          while (parsedSomething == true);

          // If we hit the end of the class scope...
          bool finishedNode = Expect(Grammar::EndScope, ErrorCode::ClassBodyNotComplete, node->Name.c_str());

          // As long as we finished this node (either via correct parsing or tolerance)
          if (finishedNode == false && this->Errors.TolerantMode)
          {
            // Since we're being tolerant, just eat tokens until we hit the end of our scope
            // This is just an approximation, as there may be actual scope errors
            // This will return true if it finds the scope and will advance the token forward automatically
            finishedNode = this->MoveToScopeEnd();
          }

          // As long as we finished this node (either via correct parsing or tolerance)
          if (finishedNode)
          {
            // We read the entire class defintion
            // Accept the token position, and return the class node
            AcceptTokenPosition();
            this->SetNodeLocationEndHere(node);
            return node;
          }
        }
      }

      // We must have failed, so delete the node
      delete node;
    }

    // We didn't successfully parse a class definition, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  bool Parser::AcceptOptionalTypeSpecifier(SyntaxType*& outSyntaxType, ErrorCode::Enum notFound, ...)
  {
    // Start a variadic argument list
    va_list vl;
    va_start(vl, notFound);
    
    // Forward the arguments to the accept function
    bool result = this->AcceptOptionalTypeSpecifierArgs(outSyntaxType, notFound, vl);

    // We're done with the variadic list
    va_end(vl);
    return result;
  }

  //***************************************************************************
  bool Parser::AcceptOptionalTypeSpecifierArgs(SyntaxType*& outSyntaxType, ErrorCode::Enum notFound, va_list args)
  {
    // Look for the type specifier for the return types
    if (Accept(1, Grammar::TypeSpecifier))
    {
      // This will store the return types in a function
      outSyntaxType = this->ReadTypeInfo();

      // Check if we did not parse a return type (but we were expecting one)
      if (outSyntaxType == nullptr)
      {
        // Throw an error
        this->ErrorHereArgs(notFound, args);
        return false;
      }
    }
    else
    {
      // We have no return type
      outSyntaxType = nullptr;
    }

    // We got here, successfull!
    return true;
  }

  //***************************************************************************
  bool Parser::ExpectArgumentList(GenericFunctionNode* node, StringParam functionName, bool mustBeEmpty)
  {
    // Get the name of the function
    if (Expect(Grammar::BeginFunctionParameters, ErrorCode::FunctionArgumentListNotFound, functionName.c_str()))
    {
      // Store the parameter index
      size_t parameterIndex = 0;

      // Some special argument lists (such as the destructor) must be empty
      // Technically we could parse those as a separate function, but just to reuse code we put this here
      if (mustBeEmpty == false)
      {
        // Get all the arguments for the function
        do
        {
          // Parse a parameter node
          ParameterNode* parameter = Parameter();

          // If the parameter is null
          if (parameter == nullptr)
          {
            // If we've already parsed one argument (meaning we have a comma)
            if (parameterIndex > 0)
            {
              // Throw an error
              ErrorHere(ErrorCode::FunctionParameterNotFound);
              return false;
            }
          }
          else
          {
            // Fill in which parameter this is
            parameter->ParameterIndex = parameterIndex;
          }

          // Add the parameter parameter to the parameter list, and pass in its index
          node->Parameters.Add(parameter);

          // Increment the parameter index
          ++parameterIndex;
        }
        while (Accept(1, Grammar::ArgumentSeparator));
      }

      // Look for the end parenthasis
      if (Expect(Grammar::EndFunctionParameters, ErrorCode::FunctionArgumentListNotComplete, functionName.c_str()))
      {
        // We succeeded at parsing
        return true;
      }
    }

    // Otherwise, we failed at parsing
    return false;
  }

  //***************************************************************************
  bool Parser::ExpectScopeBody(GenericFunctionNode* node, StringParam functionName)
  {
    // Now look for the start scope
    if (Expect(Grammar::BeginScope, ErrorCode::FunctionBodyNotFound, functionName.c_str()))
    {
      // Parse all the statements in the function
      while (node->Statements.Add(Statement()));

      // Now look for the end scope.
      if (Expect(Grammar::EndScope, ErrorCode::FunctionBodyNotComplete, functionName.c_str()))
      {
        // We succeeded in parsing the body
        this->SetNodeLocationEndHere(node);
        return true;
      }
      // If we're in tolerant mode...
      else if (this->Errors.TolerantMode)
      {
        // Since we're being tolerant, just eat tokens until we hit the end of our scope
        // This is just an approximation, as there may be actual scope errors
        // This will return true if it finds the scope and will advance the token forward automatically
        bool result = this->MoveToScopeEnd();
        this->SetNodeLocationEndHere(node);
        return result;
      }
    }

    // Otherwise, we failed at parsing
    return false;
  }
  
  //***************************************************************************
  bool Parser::MoveToScopeEnd()
  {
    // We probably failed to parse a statement, and therefore we didn't hit the end of the scope
    // Alternatively, the scope could just be missing

    // We're going to parse until we hit a scope (skipping all remaining statements)
    // We could try to parse the rest of the statements, but generally they don't affect code completion
    // Note: This could be entirely incorrect in the case that the end scope is missing!
    // For example, in parsing a scope for a function if the end scope is missing, it will not stop until
    // it reaches the end scope for the class!

    // We're currently in a scope (we started above)
    // When this hits zero, we'll know we reached the end of our scope
    size_t scopeCounter = 1;

    // Loop through all the rest of the tokens
    for (size_t index = this->TokenIndex; index < this->TokenStream->size(); ++index)
    {
      // Retreive the current token
      const UserToken* token = &(*this->TokenStream)[index];
          
      // Based on the current token type...
      switch (token->TokenId)
      {
        // If we reach the end of a file, or another function, or another class...
        // In the future, this may break if we add sub-classes or anonymous/nested functions
        case Grammar::End:
        case Grammar::Function:
        case Grammar::Class:
        {
          // Leave the token index right at this position so this token will be the next thing parsed
          this->TokenIndex = index;
          return true;
        }

        case Grammar::BeginScope:
        {
          // Increment the scope counter since we just encountered another scope
          ++scopeCounter;
          break;
        }
        case Grammar::EndScope:
        {
          // Decrement the scope counter until it reaches 0
          --scopeCounter;

          // If we hit the end of our current scope
          if (scopeCounter == 0)
          {
            // Move the token forward so that the next token is whatever is after the end scope
            this->TokenIndex = index + 1;

            // Return that we accepted this entire scope!
            return true;
          }
          break;
        }
      }
    }

    // If we got here, we were unable to find the ending scope!
    return false;
  }

  //***************************************************************************
  FunctionNode* Parser::GenerateGetSetFunctionNode(MemberVariableNode* variable, bool isGet)
  {
    // Create a function node
    FunctionNode* node = new FunctionNode();
    this->SetNodeLocationStartToLastSave(node);

    // We create a clone of the type because, in both get/set cases
    // the node is responsible for cleaning up syntax types, and we
    // want to avoid any double delete situations
    SyntaxType* typeClone = (SyntaxType*)variable->ResultSyntaxType->Clone();

    // If this is a getter...
    if (isGet)
    {
      // Generate the name for the getter
      node->Name = variable->Name;
      node->Name.Token = BuildGetterName(variable->Name.Token);

      // Getters don't take any parameters, but return the type of the property
      node->ReturnType = typeClone;
    }
    // Otherwise it's a setter!
    else
    {
      // Generate the name for the setter
      node->Name = variable->Name;
      node->Name.Token = BuildSetterName(variable->Name.Token);

      // Create a parameter node since all setters take in the value being set
      ParameterNode* value = new ParameterNode();
      this->SetNodeLocationStartToLastSave(value);

      // The parameter is never defaulted
      value->InitialValue = nullptr;

      // The value's type is the same as the variable's type
      value->ResultSyntaxType = typeClone;

      // The name of the parameter is simply just 'value'
      value->Name.Location = value->Location;
      value->Name.Token = ValueKeyword;

      // Add the parameter to our get function
      node->Parameters.Add(value);
    }

    // The function is static based entirely off whether the member is static
    node->IsStatic = variable->IsStatic;
    node->Virtualized = variable->Virtualized;

    // Return the function node we created
    return node;
  }

  //***************************************************************************
  FunctionNode* Parser::GetSetFunctionBody(MemberVariableNode* variable, bool isGet)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Generate the function node
    FunctionNode* node = GenerateGetSetFunctionNode(variable, isGet);

    // Now look for the start scope
    if (this->ExpectScopeBody(node, node->Name.Token))
    {
      // Accept the token position, and return the variable node
      this->AcceptTokenPosition();
      return node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    delete node;
    return nullptr;
  }

  //***************************************************************************
  FunctionNode* Parser::Function()
  {
    // Parse any optional attribute
    this->ParseAllOptionalAttributes();

    // If any errors occurred in parsing attributes, error here
    if (this->Errors.WasError)
      return nullptr;

    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Look for the function keyword
    if (Accept(1, Grammar::Function))
    {
      // Create a function node
      FunctionNode* node = new FunctionNode();
      this->SetNodeLocationStartToLastSave(node);

      // Attach any attributes to this function node
      this->AttachLastAttributeToNode(node->Attributes);

      // Get the name of the function
      const UserToken* functionName;
      if (this->ExpectAndRetrieve(Grammar::UpperIdentifier, functionName, ErrorCode::FunctionNameNotFound))
      {
        // Store the name on the function
        node->Name = *functionName;

        // Look for any virtual and static attributes
        this->ApplyVirtualStaticExtensionAttributes(node);

        // If any errors occurred from the virtual/static parsing
        if (this->Errors.WasError)
        {
          // We didn't successfully parse the static/virtual/override attributes
          this->RecallTokenPosition();
          delete node;
          return nullptr;
        }

        // Parse the argument list
        bool argumentsMustBeEmpty = false;
        if (this->ExpectArgumentList(node, node->Name.Token, argumentsMustBeEmpty))
        {
          // Attempt to read the type specifier
          this->AcceptOptionalTypeSpecifier(node->ReturnType, ErrorCode::FunctionReturnTypeNotFound, node->Name.c_str());

          // If an error occurred reading the type specifier
          if (this->Errors.WasError)
          {
            // We didn't successfully parse the return type, so just recall the token position and return null
            this->RecallTokenPosition();
            delete node;
            return nullptr;
          }

          // Now look for the start scope
          if (this->ExpectScopeBody(node, node->Name.Token))
          {
            // Accept the token position, and return the variable node
            this->SetNodeLocationEndHere(node);
            this->AcceptTokenPosition();

            // Return the node now that we've parsed it
            return node;
          }
        }
      }

      // We failed if we got here
      delete node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  AttributeNode* Parser::GetAttribute(NodeList<AttributeNode>& attributes, StringParam name)
  {
    // Loop through all the attributes
    for (size_t i = 0; i < attributes.size(); ++i)
    {
      // Grab the current attribute
      AttributeNode* attribute = attributes[i];

      // If this is a the attribute we were looking for...
      if (attribute->TypeName->Token == name)
        return attribute;
    }

    // Otherwise, we didn't find it
    return nullptr;
  }

  //***************************************************************************
  template <typename FunctionNodeType>
  FunctionNodeType* Parser::SpecializedFunction
  (
    Grammar::Enum type,
    String functionName,
    bool (Parser::*postArgs)(FunctionNodeType* node)
  )
  {
    // Parse any optional attribute
    this->ParseAllOptionalAttributes();

    // If any errors occurred in parsing attributes, error here
    if (this->Errors.WasError)
      return nullptr;

    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Look for the given grammar keyword
    if (Accept(1, type))
    {
      // Create a specialized function node
      FunctionNodeType* node = new FunctionNodeType();
      this->SetNodeLocationStartToLastSave(node);

      // Parse the argument list
      bool argumentsMustBeEmpty = (type == Grammar::Destructor);
      if (this->ExpectArgumentList(node, functionName, argumentsMustBeEmpty))
      {
        // If we have a post arguments parser function...
        if (postArgs != nullptr)
        {
          // Apply the post arguments function
          if ((this->*postArgs)(node) == false)
          {
            // We failed the post arguments function, so recall and free the node
            delete node;
            RecallTokenPosition();
            return nullptr;
          }
        }

        // Now look for the start scope
        if (this->ExpectScopeBody(node, functionName))
        {
          // Accept the token position, and return the variable node
          this->SetNodeLocationEndHere(node);
          this->AcceptTokenPosition();

          // Attach any attributes to this function node
          this->AttachLastAttributeToNode(node->Attributes);
          return node;
        }
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ConstructorNode* Parser::Constructor()
  {
    return SpecializedFunction<ConstructorNode>(Grammar::Constructor, "Constructor", &Parser::ConstructorInitializerList);
  }

  //***************************************************************************
  bool Parser::ConstructorInitializerList(ConstructorNode* node)
  {
    // If we have an initializer list...
    if (this->Accept(1, Grammar::InitializerList))
    {
      // Stores the initializer type (reused variable)
      const UserToken* initializerType;

      // The first thing we expect is a base class initializer
      if (this->AcceptAndRetrieve(1, Grammar::Base, &initializerType))
      {
        // Create an initializer node to represent the base class
        InitializerNode* initializer = new InitializerNode();
        initializer->InitializerType = initializerType;
        this->SetNodeLocationStartHere(initializer);

        // Let the constructor know that it actually has a base initializer
        node->BaseInitializer = initializer;

        // Parse the function call for the current initializer
        FunctionCallNode* call = this->FunctionCall(nullptr);

        // If we did not parse the base initializer function call...
        if (call == nullptr)
        {
          // We can't just have 'base' or 'this' sitting there
          this->ErrorHere(ErrorCode::FunctionCallExpectedAfterInitializer);
          delete initializer;
          return false;
        }
        else
        {
          // The left hand operand is the base class initializer
          call->LeftOperand = initializer;

          // Add the call to the statements
          node->Statements.Add(call);
        }
      }
      
      // Look for a comma delimiter
      if (this->Accept(1, Grammar::ArgumentSeparator))
      {
        // Grab the 'this' token (we don't parse it as a special keyword!)
        const UserToken* thisToken;
        
        // Look for a local base class initializer
        if (this->AcceptAndRetrieve(1, Grammar::LowerIdentifier, &thisToken))
        {
          // If we found the 'this' keyword...
          if (thisToken->Token == ThisKeyword)
          {
            // Create an initializer node to represent the base class
            InitializerNode* initializer = new InitializerNode();
            initializer->InitializerType = thisToken;
            node->ThisInitializer = initializer;
            this->SetNodeLocationStartHere(initializer);

            // Parse the function call for the current initializer
            FunctionCallNode* call = this->FunctionCall(nullptr);

            // If we did not parse the base initializer function call...
            if (call == nullptr)
            {
              // We can't just have 'base' or 'this' sitting there
              this->ErrorHere(ErrorCode::FunctionCallExpectedAfterInitializer);
              delete initializer;
              return false;
            }
            else
            {
              // The left hand operand is the base class initializer
              call->LeftOperand = initializer;

              // Add the call to the statements
              node->Statements.Add(call);
            }
          }
        }
      }

      // Check for a late base initializer...
      if (this->Accept(2, Grammar::ArgumentSeparator, Grammar::Base))
      {
        this->ErrorHere(ErrorCode::BaseClassInitializerMustComeFirst);
        return false;
      }
    }

    // If we got here, either we did not have an initializer 
    // list or we did have one and parsed it properly
    return true;
  }

  //***************************************************************************
  DestructorNode* Parser::Destructor()
  {
    return SpecializedFunction<DestructorNode>(Grammar::Destructor, "Destructor", nullptr);
  }

  //***************************************************************************
  SendsEventNode* Parser::SendsEvent()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // First look for the "sends" keyword
    if (Accept(1, Grammar::Sends))
    {
      // Create a sends statement node
      SendsEventNode* node = new SendsEventNode();
      this->SetNodeLocationStartToLastSave(node);

      // Get the name of the variable
      if (ExpectAndRetrieve(Grammar::UpperIdentifier, node->Name, ErrorCode::SendsEventStatementNameNotFound))
      {
        // Grab the string name for convenience
        String name = node->Name->Token;

        // Look for a type after the member variable
        if (AcceptOptionalTypeSpecifier(node->EventType, ErrorCode::SendsEventStatementTypeNotFound, name.c_str()))
        {
          // As long as we got a valid type...
          if (node->EventType != nullptr)
          {
            // Attempt to read the statement separator
            if (Expect(Grammar::StatementSeparator, ErrorCode::SendsEventStatementNotComplete, name.c_str()))
            {
              // Accept the token position, and return the variable node
              this->SetNodeLocationEndHere(node);
              AcceptTokenPosition();
              return node;
            }
          }
          else
          {
            // Show an error message
            ErrorHere(ErrorCode::SendsEventStatementTypeSpecifierNotFound, name.c_str());
          }
        }
      }

      // We must have failed, so delete the node
      delete node;
    }

    // We didn't successfully parse a variable definition, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ParameterNode* Parser::Parameter()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Attempt to read the name before continuing...
    const UserToken* name;

    // Look for an identifier
    if (AcceptAndRetrieve(1, Grammar::LowerIdentifier, &name))
    {
      // Look for a type specifier (followed by the parameter's type)
      if (Expect(Grammar::TypeSpecifier, ErrorCode::ParameterTypeSpecifierNotFound, name->Token.c_str()))
      {
        // Create a parameter node
        ParameterNode* node = new ParameterNode();
        this->SetNodeLocationStartToLastSave(node);

        // Assume the parameter is not yet defaulted
        node->InitialValue = nullptr;

        // Attempt to read the type after the parameter
        if ((node->ResultSyntaxType = this->ReadTypeInfo()) != nullptr)
        {
          // Store the name and type on the parameter node
          node->Name = *name;

          // Accept the token position, and return the variable node
          AcceptTokenPosition();
          this->SetNodeLocationEndHere(node);
          return node;
        }
        else
        {
          // Delete the node and show an error
          delete node;
          ErrorHere(ErrorCode::ParameterTypeNotFound, name->Token.c_str());
        }
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ExpressionNode* Parser::BinaryOperatorRightToLeftAssociative(ExpressionFn currentPrecedence, ExpressionFn nextPrecedence, int parameters, ...)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Attempt to parse the left operand (look for a higher precedence expression)
    ExpressionNode* leftOperand = (this->*nextPrecedence)();

    // As long as we parced a left operand...
    if (leftOperand != nullptr)
    {
      // This will hold the operator that we parse below
      const UserToken* acceptedOperator;

      // Start a variadic argument list
      va_list vl;
      va_start(vl, parameters);

      // If we found the operator...
      if (AcceptAnyArgs(parameters, &acceptedOperator, vl))
      {
        // Attempt to parse the right operand as if it was another expression of the same precedence
        ExpressionNode* rightOperand = (this->*currentPrecedence)();

        // If we properly parsed the right operand...
        if (rightOperand != nullptr)
        {
          // Allocate an expression node that encapsulates the operator and operands
          BinaryOperatorNode* node = new BinaryOperatorNode();
          node->Location = leftOperand->Location;
          SetNodeLocationPrimaryToToken(node, *acceptedOperator);

          // Initialize the node
          node->Operator = acceptedOperator;

          // Add the left and right operands explicitly to the node
          node->LeftOperand   = leftOperand;
          node->RightOperand  = rightOperand;

          // Accept the token position, close the va_list, and return the expression node
          this->AcceptTokenPosition();
          this->SetNodeLocationEndHere(node);
          va_end(vl);
          return node;
        }
        else
        {
          // We have an improper right operand to an expression, so delete the left argument and close the va_list
          delete leftOperand;
          va_end(vl);

          // Show an error message
          this->ErrorHere
          (
            ErrorCode::BinaryOperatorRightOperandNotFound,
            Grammar::GetName(acceptedOperator->TokenId).c_str(),
            acceptedOperator->Token.c_str()
          );
          RecallTokenPosition();
          return nullptr;
        }
      }
      else
      {
        // Otherwise, we didn't find an operator, but the left-argument could still be a valid expression
        AcceptTokenPosition();
        return leftOperand;
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ExpressionNode* Parser::BinaryOperatorLeftToRightAssociative(ExpressionFn nextPrecedence, int parameters, ...)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Attempt to parse the left operand (look for a higher precedence expression)
    ExpressionNode* leftOperand = (this->*nextPrecedence)();

    // As long as we parced a left operand...
    if (leftOperand != nullptr)
    {
      ZilchLoop
      {
        // This will hold the operator that we parse below
        const UserToken* acceptedOperator;

        // Start a variadic argument list
        va_list vl;
        va_start(vl, parameters);

        // If we found the operator...
        if (AcceptAnyArgs(parameters, &acceptedOperator, vl))
        {
          // Attempt to parse the right operand as if it was another expression of lower precedence
          ExpressionNode* rightOperand =  (this->*nextPrecedence)();

          // If we properly parsed the right operand...
          if (rightOperand != nullptr)
          {
            // Allocate an expression node that encapsulates the operator and operands
            BinaryOperatorNode* node = new BinaryOperatorNode();
            node->Location = leftOperand->Location;
            SetNodeLocationPrimaryToToken(node, *acceptedOperator);

            // Initialize the node
            node->Operator = acceptedOperator;

            // Add the left and right operands explicitly to the node
            node->LeftOperand   = leftOperand;
            node->RightOperand  = rightOperand;

            // Close the va_list and continue the iteration to find more operands
            va_end(vl);
            leftOperand = node;
            this->SetNodeLocationEndHere(node);
          }
          else
          {
            // We have an improper right operand to an expression, so delete the left argument and close the va_list
            delete leftOperand;
            va_end(vl);

            // Show an error message
            this->ErrorHere
            (
              ErrorCode::BinaryOperatorRightOperandNotFound,
              Grammar::GetName(acceptedOperator->TokenId).c_str(),
              acceptedOperator->Token.c_str()
            );

            // We didn't successfully parse an expression, so just recall the token position and return null
            RecallTokenPosition();
            return nullptr;
          }
        }
        else
        {
          // Otherwise, we didn't find an operator, but the left-argument could still be a valid expression
          AcceptTokenPosition();
          return leftOperand;
        }
      }
      
      // Technically unreachable (all paths above handled properly)
      // If we somehow got here, we failed
      //delete leftOperand;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression()
  {
    // Note: See the top of 'Shared.cpp' for a reference on precedence
    return Expression00();
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression00()
  {
    // Parse the assignment and compound assignment operators
    return BinaryOperatorRightToLeftAssociative(&Parser::Expression00, &Parser::Expression01, 12, Grammar::Assignment, Grammar::AssignmentAdd, Grammar::AssignmentSubtract, Grammar::AssignmentMultiply, Grammar::AssignmentDivide, Grammar::AssignmentModulo, Grammar::AssignmentExponent, Grammar::AssignmentLeftShift, Grammar::AssignmentRightShift, Grammar::AssignmentBitwiseAnd, Grammar::AssignmentBitwiseXor, Grammar::AssignmentBitwiseOr);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression01()
  {
    // Parse the logical or operator
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression02, 1, Grammar::LogicalOr);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression02()
  {
    // Parse the logical and operator
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression03, 1, Grammar::LogicalAnd);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression03()
  {
    // Parse the bitwise or operator
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression04, 1, Grammar::BitwiseOr);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression04()
  {
    // Parse the bitwise xor operator
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression05, 1, Grammar::BitwiseXor);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression05()
  {
    // Parse the bitwise and operator
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression06, 1, Grammar::BitwiseAnd);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression06()
  {
    // Parse the equality and inequality operators
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression07, 2, Grammar::Equality, Grammar::Inequality);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression07()
  {
    // Parse the comparison operators
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression08, 4, Grammar::LessThan, Grammar::LessThanOrEqualTo, Grammar::GreaterThan, Grammar::GreaterThanOrEqualTo);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression08()
  {
    // Parse the bitshift operators
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression09, 2, Grammar::BitshiftLeft, Grammar::BitshiftRight);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression09()
  {
    // Parse the additive operators
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression10, 2, Grammar::Add, Grammar::Subtract);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression10()
  {
    // Parse the multaplicative operators and the modulo operator
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression11, 3, Grammar::Multiply, Grammar::Divide, Grammar::Modulo);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression11()
  {
    // Parse the exponent operator
    return BinaryOperatorLeftToRightAssociative(&Parser::Expression12, 1, Grammar::Exponent);
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression12()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // This will store the unary left hand operator
    const UserToken* acceptedOperator;

    // Attempt to parse the unary left hand operator
    if (AcceptAny(7, &acceptedOperator, Grammar::Positive, Grammar::Negative, Grammar::Increment, Grammar::Decrement, Grammar::LogicalNot, Grammar::BitwiseNot, Grammar::PropertyDelegate))
    {
      // Attempt to read in the unary operand
      ExpressionNode* operand = Expression13();

      // If we found an operand...
      if (operand != nullptr)
      {
        // The node we're creating...
        UnaryOperatorNode* node = nullptr;

        // If this is a property delegate node, then this operator is slightly different
        if (acceptedOperator->TokenId == Grammar::PropertyDelegate)
        {
          // Create a unary node (property delegate operator) to represent the operation
          node = new PropertyDelegateOperatorNode();
        }
        else
        {
          // Create a unary node to represent the operation
          node = new UnaryOperatorNode();
        }

        // Initialize the node so we know it's location
        this->SetNodeLocationStartToToken(node, *acceptedOperator);

        // Setup the node
        node->Operator = acceptedOperator;

        // Add the operand expression explicitly to the node
        node->Operand = operand;

        // Accept the token position, and return the expression node
        AcceptTokenPosition();
        this->SetNodeLocationEndHere(node);
        return node;
      }
      else
      {
        // Show an error message
        this->ErrorHere
        (
          ErrorCode::UnaryOperatorOperandNotFound,
          Grammar::GetName(acceptedOperator->TokenId).c_str(),
          acceptedOperator->Token.c_str()
        );
      }
    }
    else
    {
      // Just attempt to read the next level of precedence
      ExpressionNode* nextLevel = Expression13();

      // If the next precedence level returned us a node, we'll use that one
      if (nextLevel != nullptr)
      {
        // Accept the token position, and return the next-level expression node
        AcceptTokenPosition();
        return nextLevel;
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }
  
  //***************************************************************************
  ExpressionNode* Parser::Expression13()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Attempt to parse the left operand (look for a higher precedence expression)
    ExpressionNode* leftOperand = Expression14();

    // As long as we parced a left operand...
    if (leftOperand != nullptr)
    {
      ZilchLoop
      {
        // If we found the "as" operator...
        if (Accept(1, Grammar::As))
        {
          // Allocate a type-cast node that represents the casting operation
          TypeCastNode* node = new TypeCastNode();
          this->SetNodeLocationStartToLastSave(node);
          this->SetNodeLocationPrimaryHere(node);

          // Now attempt to grab the type that we're casting to
          if ((node->Type = this->ReadTypeInfo()) != nullptr)
          {
            // Add the left operand explicitly to the node
            node->Operand = leftOperand;

            // Close the va_list and continue the iteration to find more operands
            leftOperand = node;
            this->SetNodeLocationEndHere(node);
          }
          else
          {
            // We have an improper right operand to an expression, so delete the left argument and close the va_list
            delete node;
            delete leftOperand;
            ErrorHere(ErrorCode::CastTypeNotFound);

            // We didn't successfully parse an expression, so just recall the token position and return null
            RecallTokenPosition();
            return nullptr;
          }
        }
        else
        {
          // Otherwise, we didn't find an operator, but the left-argument could still be a valid expression
          AcceptTokenPosition();
          return leftOperand;
        }
      }
      
      // Technically unreachable (all paths above handled properly)
      // If we got down here, we failed
      //delete leftOperand;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ExpressionNode* Parser::Expression14()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Attempt to read a value node
    ExpressionNode* value = Value();

    // If the value node parsed successfully...
    if (value != nullptr)
    {
      // This node will store any nodes we get from the post-expression call
      ExpressionNode* node = this->PostExpression(value);

      // If we found a valid post-expression node...
      if (node != nullptr)
      {
        // Collect all the post-expressions
        ZilchLoop
        {
          // To chain post expressions, make the node we found into the "value"
          value = node;

          // Attempt to read another post expression node
          ExpressionNode* nextNode = this->PostExpression(value);

          // If we successfully parsed the next expression node...
          if (nextNode != nullptr)
          {
            // Store it away to be used in the next iteration...
            node = nextNode;
          }
          else
          {
            // Exit since we no longer have a node
            break;
          }
        }

        // Accept the token position, and return the special operator node
        AcceptTokenPosition();
        return node;
      }

      // Accept the token position, and return the value node
      AcceptTokenPosition();
      return value;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ExpressionNode* Parser::PostExpression(ExpressionNode* leftOperand)
  {
    // First, check if we're at an indexer call
    ExpressionNode* node = this->IndexerCall(leftOperand);

    // If so, return the node
    if (node != nullptr)
      return node;

    // Now check to see if we're at a function call
    node = this->FunctionCall(leftOperand);

    // If so, return the node
    if (node != nullptr)
      return node;

    // Now check to see if we're at a member access
    node = this->MemberAccess(leftOperand);

    // If so, return the node
    if (node != nullptr)
      return node;

    // Now check to see if this is an expression initializer
    node = this->ExpressionInitializer(leftOperand);

    // If so, return the node
    if (node != nullptr)
      return node;

    // We failed to find anything...
    return nullptr;
  }

  //***************************************************************************
  IndexerCallNode* Parser::IndexerCall(ExpressionNode* leftOperand)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting an index
    if (this->Accept(1, Grammar::BeginIndex))
    {
      // We started an index, so allocate an indexer node
      IndexerCallNode* node = new IndexerCallNode();
      this->SetNodeLocationStartToLastSave(node);

      // Parse arguments to the indexer until there are no more
      ZilchLoop
      {
        // Attempt to parse an argument to the indexer
        if (node->Arguments.Add(this->Expression()) == nullptr)
        {
          // Show an error
          this->ErrorHere(ErrorCode::IndexerIndicesNotFound);

          // We didn't successfully parse an expression, so just recall the token position and return null
          this->RecallTokenPosition();
          delete node;
          return nullptr;
        }

        // Attempt to read an argument separator, and if we don't find one, break out
        if (this->Accept(1, Grammar::ArgumentSeparator) == false)
          break;
      }

      // Now that we parsed all the arguments, we need to parse the end of the index call
      if (this->Accept(1, Grammar::EndIndex))
      {
        // Accept the token position, and return the indexer node
        this->AcceptTokenPosition();
        this->SetNodeLocationEndHere(node);
        node->LeftOperand = leftOperand;
        return node;
      }
      else
      {
        // Show an error message
        this->ErrorHere(ErrorCode::IndexerNotComplete);
        delete node;
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  FunctionCallNode* Parser::FunctionCall(ExpressionNode* leftOperand)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a function call
    if (this->Accept(1, Grammar::BeginFunctionCall))
    {
      // We started a function call, so allocate an function call node
      FunctionCallNode* node = new FunctionCallNode();
      this->SetNodeLocationStartToLastSave(node);

      // Assume by default that we will not use named arguments
      // Note that if the function call has no arguments, it will not matter
      node->IsNamed = false;

      // Did we already parse the first argument
      bool parsedFirstArgument = false;

      // Parse arguments to the function call until there are no more
      ZilchLoop
      {
        // This will hold the argument name as we parse it
        const UserToken* argumentName = nullptr;

        // Look for an identifier and the named argument symbol
        if (this->AcceptAndRetrieve(2, Grammar::LowerIdentifier, &argumentName, Grammar::NameSpecifier, (void*)nullptr))
        {
          // Add the name to the list of function call names
          node->ArgumentNames.push_back(argumentName->Token);

          // Attempt to parse an argument to the indexer
          if (node->Arguments.Add(Expression()) == nullptr)
          {
            // Show an error message
            this->ErrorHere(ErrorCode::FunctionCallNamedArgumentNotFound, argumentName->Token.c_str());

            // We didn't successfully parse an expression, so just recall the token position and return null
            this->RecallTokenPosition();
            delete node;
            return nullptr;
          }

          // We parsed the first argument
          parsedFirstArgument = true;

          // Since we parsed the named argument we must be using named calling
          node->IsNamed = true;

          // Attempt to read an argument separator, and if we don't find one, break out
          if (this->Accept(1, Grammar::ArgumentSeparator) == false)
          {
            break;
          }
        }
        // As long as we didn't yet parse the first argument...
        else if (parsedFirstArgument == false)
        {
          break;
        }
        else
        {
          // Show an error message
          this->ErrorHere(ErrorCode::FunctionCallNotComplete);

          // We didn't successfully parse an expression, so just recall the token position and return null
          this->RecallTokenPosition();
          delete node;
          return nullptr;
        }
      }

      // If we did not parse any arguments (which could be ok...)
      // We need to try parsing as if they were positional arguments
      if (parsedFirstArgument == false)
      {
        // Parse arguments to the function call until there are no more
        ZilchLoop
        {
          // Attempt to parse an argument to the indexer
          if (node->Arguments.Add(Expression()))
          {
            // We parsed the first argument
            parsedFirstArgument = true;

            // Attempt to read an argument separator, and if we don't find one, break out
            if (this->Accept(1, Grammar::ArgumentSeparator) == false)
            {
              break;
            }
          }
          // As long as we didn't yet parse the first argument...
          else if (parsedFirstArgument == false)
          {
            break;
          }
          else
          {
            // Show an error message
            this->ErrorHere(ErrorCode::FunctionCallNotComplete);

            // We didn't successfully parse an expression, so just recall the token position and return null
            this->RecallTokenPosition();
            delete node;
            return nullptr;
          }
        }
      }

      // Now that we parsed all the arguments, we need to parse the end of the function call
      if (this->Accept(1, Grammar::EndFunctionCall))
      {
        // Accept the token position, and return the function call node
        this->AcceptTokenPosition();
        this->SetNodeLocationEndHere(node);
        node->LeftOperand = leftOperand;
        return node;
      }
      else
      {
        // Show an error message
        this->ErrorHere(ErrorCode::FunctionCallNotComplete);
        delete node;
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  MemberAccessNode* Parser::MemberAccess(ExpressionNode* leftOperand)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Hold the access operator type
    const UserToken* accessOperator;

    // Check to see if we're starting a member access
    if (this->AcceptAny(2, &accessOperator, Grammar::Access, Grammar::NonVirtualAccess))
    {
      // Hold the member we attempted to access
      const UserToken* member;

      // Get the member name that we're trying to access
      if (this->ExpectAndRetrieve(Grammar::UpperIdentifier, member, ErrorCode::MemberAccessNameNotFound))
      {
        // We started a member access, so allocate the corresponding node
        MemberAccessNode* node = new MemberAccessNode();
        node->LeftOperand = leftOperand;
        this->SetNodeLocationStartToLastSave(node);

        // Set the operator
        node->Operator = accessOperator->TokenId;

        // Set the name
        node->Name = member->Token;

        // Accept the token position, and return the function call node
        this->AcceptTokenPosition();
        this->SetNodeLocationEndHere(node);
        return node;
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::Delete()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a delete statement
    if (Accept(1, Grammar::Delete))
    {
      // Parse the expression which we are deleting
      ExpressionNode* deletedObject = Expression();

      // If we parsed an expression
      if (deletedObject != nullptr)
      {
        // Create a delete node since this is a valid return statement
        DeleteNode* node = new DeleteNode();
        this->SetNodeLocationStartToLastSave(node);

        // Set the deleted object, then add the expression as a child
        node->DeletedObject = deletedObject;

        // Accept the token position, and return the "return node"
        AcceptTokenPosition();
        this->SetNodeLocationEndHere(node);
        return node;
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::Return()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Checks whether this return ignores flow control errors
    bool isDebugReturn = false;

    // Check to see if we're starting a debug statement (could be other debug statements)
    if (Accept(1, Grammar::Debug))
    {
      // This is a debug return, which means it ignores flow control
      isDebugReturn = true;
    }

    // Check to see if we're starting a return statement
    if (Accept(1, Grammar::Return))
    {
      // Create a return node since this is a valid return statement
      ReturnNode* node = new ReturnNode();
      this->SetNodeLocationStartToLastSave(node);

      // Set the debug return flag depending upon what we read above
      node->IsDebugReturn = isDebugReturn;

      // Attempt to parse an expression (this expression can be missing, that is OK!)
      node->ReturnValue = Expression();

      // Accept the token position, and return the "return node"
      AcceptTokenPosition();
      this->SetNodeLocationEndHere(node);
      return node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::Break()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a break statement
    if (Accept(1, Grammar::Break))
    {
      // Create a break node since this is a valid break statement
      BreakNode* node = new BreakNode();
      this->SetNodeLocationStartToLastSave(node);

      // Grab the user token for the identifier
      const UserToken* scopeCount = nullptr;

      // Read an optional integer that tells us how many loop scopes to break out of
      if (AcceptAndRetrieve(1, Grammar::IntegerLiteral, &scopeCount))
      {
        // Read the break count
        node->ScopeCount = atoi(scopeCount->Token.c_str());

        // If the scope count is not valid
        if (node->ScopeCount <= 0)
        {
          // Throw an error
          ErrorHere(ErrorCode::BreakCountMustBeGreaterThanZero);

          // We didn't successfully parse an expression, so just recall the token position and return null
          RecallTokenPosition();
          delete node;
          return nullptr;
        }
      }
      else
      {
        // Otherwise, the scope count is assumed to be 1
        node->ScopeCount = 1;
      }

      // Accept the token position, and return the "break node"
      AcceptTokenPosition();
      this->SetNodeLocationEndHere(node);
      return node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }
  
  //***************************************************************************
  StatementNode* Parser::DebugBreak()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a debug break statement
    if (Accept(2, Grammar::Debug, Grammar::Break))
    {
      // Create a break node since this is a valid break statement
      DebugBreakNode* node = new DebugBreakNode();
      this->SetNodeLocationStartToLastSave(node);

      // Accept the token position, and return the "debug break node"
      AcceptTokenPosition();
      this->SetNodeLocationEndHere(node);
      return node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::Continue()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a continue statement
    if (Accept(1, Grammar::Continue))
    {
      // Create a continue node since this is a valid continue statement
      ContinueNode* node = new ContinueNode();
      this->SetNodeLocationStartToLastSave(node);

      // Accept the token position, and return the "return node"
      AcceptTokenPosition();
      this->SetNodeLocationEndHere(node);
      return node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::Throw()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a continue statement
    if (this->Accept(1, Grammar::Throw))
    {
      // Read the expression (we'll validate that it's an exception type in the syntaxer)
      ExpressionNode* exception = this->Expression();

      // As long as we read the exception expression (typically new Exception...)
      if (exception != nullptr)
      {
        // Create a throw node since we know everything we need
        ThrowNode* node = new ThrowNode();
        this->SetNodeLocationStartToLastSave(node);

        // Set the exception expression on the node
        node->Exception = exception;

        // Accept the token position, and return the "throw node"
        this->AcceptTokenPosition();
        this->SetNodeLocationEndHere(node);
        return node;
      }
      else
      {
        // Show an error and let us be recalled below
        this->ErrorHere(ErrorCode::ThrowExceptionExpressionNotFound);
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::Statement(bool optionalDelimiter)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // First parse to see if we found a delimited statement
    if (StatementNode* node = DelimitedStatement())
    {
      // When parsing single expressions and statements, we allow the delimiter to be optional (because we know its singular)
      if (optionalDelimiter)
      {
        // Just eat the statement separator if there is one
        this->Accept(1, Grammar::StatementSeparator);

        // Accept the token position, and return the node
        AcceptTokenPosition();
        return node;
      }
      else
      {
        // Check to see that the statement was properly delimited
        if (this->Expect(Grammar::StatementSeparator, ErrorCode::StatementSeparatorNotFound))
        {
          // Accept the token position, and return the node
          AcceptTokenPosition();
          return node;
        }
        else
        {
          // We failed to find the ending semicolon, delete the node and unroll
          delete node;
        }
      }
    }
    else if (StatementNode* node = FreeStatement())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }

    // Otherwise, recall the old token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::DelimitedStatement()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Look for a variable (don't check for delimiting because it will be automatically checked for later)
    if (LocalVariableNode* node = this->LocalVariable())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      node->IsUsedAsStatement = true;
      return node;
    }
    // Look for a return statement
    else if (StatementNode* node = this->Return())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    // Look for a delete statement
    else if (StatementNode* node = this->Delete())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    // Look for a break statement
    else if (StatementNode* node = this->Break())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    // Look for a debug break statement
    else if (StatementNode* node = this->DebugBreak())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    // Look for a continue statement
    else if (StatementNode* node = this->Continue())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    // Look for a throw exception statement
    else if (StatementNode* node = this->Throw())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    // Look for an expression
    else if (ExpressionNode* node = this->Expression())
    {
      // Mark that this expression is being used as a statement
      node->IsUsedAsStatement = true;

      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }

    // Otherwise, recall the old token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::FreeStatement()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Look for an if statement
    if (StatementNode* node = If())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    else if (StatementNode* node = For())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    else if (StatementNode* node = ForEach())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    else if (StatementNode* node = While())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    else if (StatementNode* node = DoWhile())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    else if (StatementNode* node = Loop())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    else if (StatementNode* node = Scope())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }
    else if (StatementNode* node = Timeout())
    {
      // Accept the token position, and return the node
      AcceptTokenPosition();
      return node;
    }

    // Otherwise, recall the old token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  void Parser::IfBody(ExpressionNode*& condition, IfRootNode* root)
  {
    // Create an if node since this is a valid if statement
    IfNode* node = new IfNode();
    this->SetNodeLocationStartToLastSave(node);
    
    // Parse all the statements inside the if-statement
    if (this->ExpectScopedStatements(node->Statements, Grammar::If))
    {
      // Set the conditional expression on the if-node
      node->Condition = condition;

      // End the node here and attach it to the if parts
      this->SetNodeLocationEndHere(node);
      root->IfParts.Add(node);

      // As long as we have a condition, we can continue parsing else statements
      if (condition != nullptr)
      {
        // Parse the else statement (if it exists)
        this->Else(root);
      }

      // We're done by this point
      condition = nullptr;
      return;
    }

    // Delete the if-node if we got here
    delete node;
  }

  //***************************************************************************
  ExpressionNode* Parser::IfCondition()
  {
    // Check to see if we're starting an if statement
    if (this->Accept(1, Grammar::If))
    {
      // Look for the beginning parenthasis
      if (this->Expect(Grammar::BeginGroup, ErrorCode::IfConditionalExpressionNotFound))
      {
        // Attempt to parse the conditional expression
        ExpressionNode* condition = Expression();

        // If we properly parsed the conditional expression...
        if (condition != nullptr)
        {
          // Look for the end parenthasis and beginning of the if-statement scope
          if (this->Expect(Grammar::EndGroup, ErrorCode::IfConditionalExpressionNotComplete))
          {
            return condition;
          }

          // Delete the conditional expression node if we got here
          delete condition;
        }
        else
        {
          // We couldn't read the conditional expression
          this->ErrorHere(ErrorCode::IfConditionalExpressionNotFound);
        }
      }
    }

    // Otherwise, no condition was parsed
    return nullptr;
  }

  //***************************************************************************
  void Parser::Else(IfRootNode* root)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting an else statement
    if (this->Accept(1, Grammar::Else))
    {
      // Parse the condition (it's ok if this is null)
      ExpressionNode* condition = this->IfCondition();

      // Now parse the body of the else statement
      this->IfBody(condition, root);

      // As long as we got a valid node back
      if (this->Errors.WasError == false)
      {
        // Return the node
        this->AcceptTokenPosition();
        return;
      }
    }

    // Otherwise, no else was parsed (that's ok!)
    this->RecallTokenPosition();
  }

  //***************************************************************************
  StatementNode* Parser::Timeout()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a timeout statement
    if (this->Accept(1, Grammar::Timeout))
    {
      // Look for the beginning of a conditional expression
      if (this->Expect(Grammar::BeginGroup, ErrorCode::TimeoutSecondsNotFound))
      {
        // The timeout always takes an integer, just to ensure that users don't try to go to
        // a precision that's lower than our timer (typically the standard C clock function)
        const UserToken* secondsToken = nullptr;
        if (this->ExpectAndRetrieve(Grammar::IntegerLiteral, secondsToken, ErrorCode::TimeoutSecondsExpectedIntegerLiteral))
        {
          // Look for the end parenthasis
          if (this->Expect(Grammar::EndGroup, ErrorCode::TimeoutSecondsNotComplete))
          {
            // Set the number of seconds on the node
            int seconds = atoi(secondsToken->Token.c_str());

            // If the user specified a zero or negative time...
            if (seconds <= 0)
            {
              // Inform the user, recall the token position back and return out
              this->ErrorHere(ErrorCode::TimeoutSecondsMustBeNonZeroPositive);
              this->RecallTokenPosition();
              return nullptr;
            }

            // We've parsed everything we need to ensure this is a timeout statement, so create it
            TimeoutNode* node = new TimeoutNode();
            this->SetNodeLocationStartToLastSave(node);

            // We've verified it can't be negative, so cast it to an unsigned and store it on the node
            node->Seconds = (size_t)seconds;
            
            // Parse all the statements inside the timeout-statement
            if (this->ExpectScopedStatements(node->Statements, Grammar::Timeout))
            {
              // Accept the token position, and return the "return node"
              this->AcceptTokenPosition();
              this->SetNodeLocationEndHere(node);
              return node;
            }

            // Delete the timeout-node if we got here
            delete node;
          }
        }
        else
        {
          // Show an error message
          this->ErrorHere(ErrorCode::TimeoutSecondsNotFound);
        }
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::Scope()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a scope statement
    if (this->Accept(1, Grammar::Scope))
    {
      // Create a loop node since this is a valid loop statement
      ScopeNode* node = new ScopeNode();
      this->SetNodeLocationStartToLastSave(node);

      // Parse all the statements inside the while-statement
      if (this->ExpectScopedStatements(node->Statements, Grammar::Scope))
      {
        // Accept the token position, and return the "return node"
        this->AcceptTokenPosition();
        this->SetNodeLocationEndHere(node);
        return node;
      }

      // Delete the while-node
      delete node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  IfRootNode* Parser::If()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Parse the if condition (including the if keyword)
    ExpressionNode* condition = IfCondition();

    // If a condition and keyword was read...
    if (condition != nullptr)
    {
      // The root of the if statement, which makes traversing the parts of the if statement more straightforward
      IfRootNode* ifRoot = new IfRootNode();
      this->SetNodeLocationStartToLastSave(ifRoot);

      // Parse the body of the if statement, from { to }
      this->IfBody(condition, ifRoot);

      // As long as the body was properly read...
      if (this->Errors.WasError == false)
      {
        // We didn't have an error, so we should have one child
        if (ifRoot->IfParts.empty() == false)
        {
          // The first part of the if statement is the 
          ifRoot->IfParts.front()->IsFirstPart = true;
        }

        // Accept the token position, and return the "return node"
        this->AcceptTokenPosition();
        this->SetNodeLocationEndHere(ifRoot);
        return ifRoot;
      }

      // If we got here, we failed
      delete ifRoot;

      // This condition could be nulled by the 'IfBody' call
      delete condition;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::ForEach()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // This is effectively what this below code is translating a foreach loop to:
    //*
    //* foreach (var animal in farm.All)
    //* {
    //*   animal.Speak();
    //* }
    //* 
    //* for (var [animalRange] = farm.All.All; [animalRange].IsNotEmpty; [animalRange].MoveNext())
    //* {
    //*   var animal = [animalRange].Current;
    //*   animal.Speak();
    //* }
    //*

    // Check to see if we're starting a foreach statement
    if (this->Accept(1, Grammar::ForEach))
    {
      // Look for the beginning of the for loop declaration
      if (this->Expect(Grammar::BeginGroup, ErrorCode::ForLoopExpressionsNotFound))
      {
        // Attempt to parse the variable
        LocalVariableNode* valueVariable = this->LocalVariable(false);

        // If we didn't parse a variable...
        if (valueVariable == nullptr)
        {
          // Show an error since we failed to parse the condition
          this->ErrorHere(ErrorCode::ForEachVariableDeclarationNotFound);

          // We didn't successfully parse an expression, so just recall the token position and return null
          this->RecallTokenPosition();
          return nullptr;
        }

        // Look for the 'in' keyword
        if (this->Expect(Grammar::In, ErrorCode::ForEachInKeywordNotFound))
        {
          // Attempt to parse the range expression
          ExpressionNode* range = this->Expression();

          // If we parsed an expression...
          if (range != nullptr)
          {
            // Look for the end parenthasis
            if (this->Expect(Grammar::EndGroup, ErrorCode::ForLoopExpressionsNotComplete))
            {
              // Create a for node since this is a valid for statement
              ForEachNode* node = new ForEachNode();
              this->SetNodeLocationStartToLastSave(node);

              // Let any users know the original variable/range that came from the foreach
              node->NonTraversedVariable = valueVariable->Clone();
              node->NonTraversedRange = (ExpressionNode*)range->Clone();

              // Access the 'All' element of the range expression
              // Note that even ranges have a subsequent 'All' which returns itself
              MemberAccessNode* allAccessNode = new MemberAccessNode();
              allAccessNode->Location = range->Location;
              allAccessNode->Name = "All";
              allAccessNode->Operator = Grammar::Access;
              allAccessNode->LeftOperand = range;

              // Create a variable that will store the range
              LocalVariableNode* rangeVariable = new LocalVariableNode();
              rangeVariable->Location = range->Location;
              rangeVariable->Name.Location = range->Location;
              rangeVariable->Name.Token = BuildString("[", valueVariable->Name.Token, "Range]");
              rangeVariable->InitialValue = allAccessNode;
              node->RangeVariable = rangeVariable;

              // Create a local variable reference to the range variable
              LocalVariableReferenceNode* rangeLocal = new LocalVariableReferenceNode();
              rangeLocal->Value = rangeVariable->Name;

              // We need to access the 'MoveNext' function on the range
              MemberAccessNode* moveNextAccessNode = new MemberAccessNode();
              moveNextAccessNode->Location = range->Location;
              moveNextAccessNode->Name = "MoveNext";
              moveNextAccessNode->Operator = Grammar::Access;
              moveNextAccessNode->LeftOperand = rangeLocal;

              // We want to call the 'MoveNext' function
              FunctionCallNode* moveNextCallNode = new FunctionCallNode();
              moveNextCallNode->Location = range->Location;
              moveNextCallNode->LeftOperand = moveNextAccessNode;

              // For iteration, we call the 'MoveNext' functoin on the range
              node->Iterator = moveNextCallNode;

              // Access the 'IsNotEmpty' element of the range expression
              MemberAccessNode* isNotEmptyAccessNode = new MemberAccessNode();
              isNotEmptyAccessNode->Location = range->Location;
              isNotEmptyAccessNode->Name = "IsNotEmpty";
              isNotEmptyAccessNode->Operator = Grammar::Access;
              isNotEmptyAccessNode->LeftOperand = rangeLocal->Clone();

              // Our condition is if we're empty
              node->Condition = isNotEmptyAccessNode;

              // Access the 'Current' element of the range expression
              MemberAccessNode* currentAccessNode = new MemberAccessNode();
              currentAccessNode->Location = range->Location;
              currentAccessNode->Name = "Current";
              currentAccessNode->Operator = Grammar::Access;
              currentAccessNode->LeftOperand = rangeLocal->Clone();

              // We create this variable and initialize it as the first statement in the for loop
              valueVariable->InitialValue = currentAccessNode;
              node->Statements.Add(valueVariable);

              // Parse all the statements inside the foreach-statement
              if (this->ExpectScopedStatements(node->Statements, Grammar::ForEach))
              {
                // Accept the token position, and return the "return node"
                this->AcceptTokenPosition();
                this->SetNodeLocationEndHere(node);
                return node;
              }

              // We didn't successfully parse an expression, so just recall the token position and return null
              this->RecallTokenPosition();
              delete node;
              return nullptr;
            }

            // We failed, so delete anything we've created up to this point
            delete range;
          }
          else
          {
            // Show an error since we failed to parse the condition
            this->ErrorHere(ErrorCode::ForEachRangeExpressionNotFound);
          }

          // We failed, so delete anything we've created up to this point
          delete valueVariable;
        }
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }
  
  //***************************************************************************
  bool Parser::ExpectScopedStatements(NodeList<StatementNode>& statements, Grammar::Enum parentKeyword)
  {
    // Grab the keyword in case an error occurs
    const String& keyword = Grammar::GetKeywordOrSymbol(parentKeyword);

    // Look for the beginning of the if-statement scope
    if (this->Accept(1, Grammar::BeginScope))
    {
      // Parse all the statements inside the if-statement
      while (statements.Add(this->Statement()));

      // Now look for the end scope
      if (this->Expect(Grammar::EndScope, ErrorCode::ScopeBodyNotComplete, keyword.c_str()))
      {
        return true;
      }
      // If we didn't find the end of the scope, but we're in tolerant mode...
      else if (this->Errors.TolerantMode)
      {
        // Since we're being tolerant, just eat tokens until we hit the end of our scope
        // This is just an approximation, as there may be actual scope errors
        // This will return true if it finds the scope and will advance the token forward automatically
        return this->MoveToScopeEnd();
      }
    }
    // Try and parse a single statement, if that fails, then throw an error
    else if (statements.Add(this->Statement()))
    {
      return true;
    }
    // Otherwise, we failed to parse either {} or a single statement...
    else
    {
      this->ErrorHere(ErrorCode::ScopeBodyNotFound, keyword.c_str());
    }

    return false;
  }

  //***************************************************************************
  StatementNode* Parser::For()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a for statement
    if (Accept(1, Grammar::For))
    {
      // Look for the beginning of the for loop declaration
      if (Expect(Grammar::BeginGroup, ErrorCode::ForLoopExpressionsNotFound))
      {
        // Attempt to parse the variable
        LocalVariableNode* variable = this->LocalVariable();

        // Alternatively, we could have an initialization expression (assume we don't for now)
        ExpressionNode* initialization = nullptr;

        // If we didn't parse a variable...
        if (variable == nullptr)
        {
          // Attempt to parse the initialization expression
          initialization = Expression();

          // If we do not have an initialization expression...
          if (initialization == nullptr)
          {
            // Show an error since we failed to parse the condition
            ErrorHere(ErrorCode::ForLoopExpressionsNotFound);

            // We didn't successfully parse an expression, so just recall the token position and return null
            RecallTokenPosition();
            return nullptr;
          }
        }

        // Look for the semicolon that separates initialization and condition
        if (Expect(Grammar::StatementSeparator, ErrorCode::ForLoopExpressionsNotComplete))
        {
          // Attempt to parse the condition expression
          ExpressionNode* condition = Expression();

          // If we parsed an expression...
          if (condition != nullptr)
          {
            // Look for the semicolon that separates initialization and condition
            if (Expect(Grammar::StatementSeparator, ErrorCode::ForLoopExpressionsNotComplete))
            {
              // Attempt to parse the iterator expression
              ExpressionNode* iterator = Expression();

              // If we parsed an expression...
              if (iterator != nullptr)
              {
                // Look for the end parenthasis
                if (Expect(Grammar::EndGroup, ErrorCode::ForLoopExpressionsNotComplete))
                {
                  // Create a for node since this is a valid for statement
                  ForNode* node = new ForNode();
                  this->SetNodeLocationStartToLastSave(node);

                  // Parse all the statements inside the for-statement
                  if (this->ExpectScopedStatements(node->Statements, Grammar::For))
                  {
                    // Set the variable (it could be null)
                    node->ValueVariable = variable;

                    // Set the initialization expression (it could be null)
                    node->Initialization = initialization;

                    // Set the conditional expression
                    node->Condition = condition;

                    // Set the iterator expression
                    node->Iterator = iterator;

                    // Accept the token position, and return the "return node"
                    AcceptTokenPosition();
                    this->SetNodeLocationEndHere(node);
                    return node;
                  }

                  // Delete the node since we failed
                  delete node;
                }
              }
              else
              {
                // Show an error since we failed to parse the iterator
                ErrorHere(ErrorCode::ForLoopExpressionsNotFound);
              }

              // We failed, so delete anything we've created up to this point
              delete iterator;
            }

            // We failed, so delete anything we've created up to this point
            delete condition;
          }
          else
          {
            // Show an error since we failed to parse the condition
            ErrorHere(ErrorCode::ForLoopExpressionsNotFound);
          }

          // We failed, so delete anything we've created up to this point
          delete variable;
          delete initialization;
        }
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::While()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a while statement
    if (this->Accept(1, Grammar::While))
    {
      // Look for the beginning of a conditional expression
      if (this->Expect(Grammar::BeginGroup, ErrorCode::WhileConditionalExpressionNotFound))
      {
        // Attempt to parse the conditional expression
        ExpressionNode* condition = this->Expression();

        // If we properly parsed the conditional expression...
        if (condition != nullptr)
        {
          // Look for the end parenthasis
          if (this->Expect(Grammar::EndGroup, ErrorCode::WhileConditionalExpressionNotComplete))
          {
            // Create a while node since this is a valid while statement
            WhileNode* node = new WhileNode();
            this->SetNodeLocationStartToLastSave(node);

            // Parse all the statements inside the while-statement
            if (this->ExpectScopedStatements(node->Statements, Grammar::While))
            {
              // Set the conditional expression on the if-node
              node->Condition = condition;

              // Accept the token position, and return the "return node"
              AcceptTokenPosition();
              this->SetNodeLocationEndHere(node);
              return node;
            }

            // Delete the while-node
            delete node;
          }

          // Delete the conditional expression node
          delete condition;
        }
        else
        {
          // Show an error message
          ErrorHere(ErrorCode::WhileConditionalExpressionNotFound);
        }
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::DoWhile()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a do while statement
    if (this->Accept(1, Grammar::Do))
    {
      // Create a do-while node since this is a valid while statement
      DoWhileNode* node = new DoWhileNode();
      this->SetNodeLocationStartToLastSave(node);

      // Parse all the statements inside the while-statement
      if (this->ExpectScopedStatements(node->Statements, Grammar::Do))
      {
        // Now parse the while statement
        if (Accept(1, Grammar::While))
        {
          // Look for the beginning of a conditional expression
          if (Expect(Grammar::BeginGroup, ErrorCode::DoWhileConditionalExpressionNotFound))
          {
            // Attempt to parse the conditional expression
            ExpressionNode* condition = Expression();

            // If we properly parsed the conditional expression...
            if (condition != nullptr)
            {
              // Look for the end parenthasis
              if (Expect(Grammar::EndGroup, ErrorCode::DoWhileConditionalExpressionNotComplete))
              {
                // Set the conditional expression on the if-node
                node->Condition = condition;

                // Accept the token position, and return the "return node"
                AcceptTokenPosition();
                this->SetNodeLocationEndHere(node);
                return node;
              }

              // Delete the conditional expression node
              delete condition;
            }
            else
            {
              // We failed to find the conditional expression
              ErrorHere(ErrorCode::DoWhileConditionalExpressionNotFound);
            }
          }
        }
      }

      // Delete the while-node
      delete node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StatementNode* Parser::Loop()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Check to see if we're starting a loop statement
    if (this->Accept(1, Grammar::Loop))
    {
      // Create a loop node since this is a valid loop statement
      LoopNode* node = new LoopNode();
      this->SetNodeLocationStartToLastSave(node);

      // Parse all the statements inside the while-statement
      if (this->ExpectScopedStatements(node->Statements, Grammar::Loop))
      {
        // Accept the token position, and return the "return node"
        AcceptTokenPosition();
        this->SetNodeLocationEndHere(node);
        return node;
      }

      // Delete the while-node
      delete node;
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  StaticTypeNode* Parser::StaticTypeOrCreationCall()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // We don't know if this node is going to be used as a constructor yet
    CreationMode::Enum creationMode = CreationMode::Invalid;

    // Lets see if it's a new creation call
    if (this->Accept(1, Grammar::New))
      creationMode = CreationMode::New;
    // Lets see if it's a local creation call
    else if (this->Accept(1, Grammar::Local))
      creationMode = CreationMode::Local;

    // Now lets attempt to get the type used in the new-call
    BoundSyntaxType* type = this->ReadBoundTypeInfo();
    if (type != nullptr)
    {
      // Create the node that we'll attach to the tree
      StaticTypeNode* node = new StaticTypeNode();
      node->Mode = creationMode;
      node->ReferencedSyntaxType = type;

      // Let the node know where it was started
      this->SetNodeLocationStartToLastSave(node);

      // Return the parsed constructor call (every new/local requires a constructor call)
      this->SetNodeLocationEndHere(node);
      this->AcceptTokenPosition();
      return node;
    }
    // If we didn't read a type, but we did have a new/local...
    else if (creationMode != CreationMode::Invalid)
    {
      // Show an error message
      this->ErrorHere(ErrorCode::CreatedTypeNotFound);
    }

    // Return null since we didn't parse anything
    this->RecallTokenPosition();
    return nullptr;
  }
  
  //***************************************************************************
  ExpressionNode* Parser::ExpressionInitializer(ExpressionNode* leftOperand)
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // Let the user know that the syntax has changed
    ZilchTodo("This can be removed once a considerable time period has passed or when we give it a new meaning");
    if (this->Accept(1, Grammar::OldBeginInitializer))
    {
      // Show an error and recall back to the saved position
      this->ErrorHere(ErrorCode::GenericError, "The expression initializer syntax has changed from using [] to using {}.");
      this->RecallTokenPosition();
      return nullptr;
    }

    // Attempt to parse the initializer now (initializes members and adds values to containers AFTER construction)
    if (this->Accept(1, Grammar::BeginInitializer))
    {
      // Wrap the left operand in a uniquely generated local variable
      // (so we can refer to it in special syntactical sugar cases)
      // For example, when we do member initializers or container initializers, we call .Add on this variable
      // We explicitly use this as an expression
      LocalVariableNode* leftVar = new LocalVariableNode(ExpressionInitializerLocal, this->ParentProject, nullptr);
      this->SetNodeLocationStartToLastSave(leftVar);
    
      // Create and setup the expression initializer node
      ExpressionInitializerNode* initializer = new ExpressionInitializerNode();
      this->SetNodeLocationStartHere(initializer);
    
      // Our initializer points at the unique local variable we created, and in tern that points at the actual left expression
      initializer->LeftOperand = leftVar;

      // Because we may allow a trailing comma (or empty initializers) then we may accept an initializer early
      bool acceptedOuterEndInitializer = false;

      // Loop until we have no more expressions to parse
      do
      {
        // First check to see if this is an entirely empty list or if we just have a trailing comma...
        if (this->Accept(1, Grammar::EndInitializer))
        {
          acceptedOuterEndInitializer = true;
          break;
        }

        // If we read in an add node (two forms, just an expression, and also a block [expressions])
        ExpressionInitializerAddNode* addNode = nullptr;

        // Save the name of the member we're initializing
        const UserToken* memberName = nullptr;

        // If we're initializing a member...
        if (this->AcceptAndRetrieve(2, Grammar::UpperIdentifier, &memberName, Grammar::Assignment, nullptr))
        {
          // Create the member initializer node
          ExpressionInitializerMemberNode* memberNode = new ExpressionInitializerMemberNode();
          this->SetNodeLocationStartHere(memberNode);
          initializer->InitailizeMembers.Add(memberNode);

          // Set the name of the member we're accessing
          memberNode->MemberName = *memberName;

          // Now read the value we want to initialize this member to
          if (ExpressionNode* initialValue = this->Expression())
          {
            // Store the initial value, we've read the entire member initializer!
            memberNode->Value = initialValue;
            
            // End the member node here
            this->SetNodeLocationEndHere(memberNode);

            // We previously generated a local variable so we could look up the variable by name
            LocalVariableReferenceNode* accessLeftVar = new LocalVariableReferenceNode();
            accessLeftVar->Location = memberNode->Location;
            accessLeftVar->Value = leftVar->Name;

            // Access the 'Add' method on the container
            MemberAccessNode* memberAccess = new MemberAccessNode();
            memberAccess->Location = memberNode->Location;
            memberAccess->Name = memberName->Token;
            memberAccess->Operator = Grammar::Access;
            memberAccess->LeftOperand = accessLeftVar;

            // Call the add method with the arguments we parsed
            BinaryOperatorNode* assignment = new BinaryOperatorNode();
            assignment->Location = memberNode->Location;
            assignment->LeftOperand = memberAccess;
            assignment->Operator = Tokenizer::GetAssignmentToken();
            assignment->RightOperand = (ExpressionNode*)memberNode->Value->Clone();

            // Lastly, add the assignment to the initialization statements
            initializer->InitializerStatements.Add(assignment);
          }
          else
          {
            // Show an error and recall back to the saved position
            this->ErrorHere(ErrorCode::CreationInitializeMemberExpectedInitialValue,
              memberName->Token.c_str(), memberName->Token.c_str());
            this->RecallTokenPosition();

            // Deleting the initializer should delete the constructor call and the creation node, and the type we parsed
            delete initializer;
            return nullptr;
          }
        }
        // Look for another 'add' element initializer
        else if (this->Accept(1, Grammar::BeginInitializer))
        {
          // We're reading another value (could be an argument list)
          addNode = new ExpressionInitializerAddNode();
          this->SetNodeLocationStartHere(addNode);
          initializer->AddValues.Add(addNode);
        
          // Because we may allow a trailing comma (or empty initializers) then we may accept an initializer early
          bool acceptedInnerEndInitializer = false;

          // Loop until we have no more expressions to parse
          do
          {
            // First check to see if this is an entirely empty list or if we just have a trailing comma...
            if (this->Accept(1, Grammar::EndInitializer))
            {
              acceptedInnerEndInitializer = true;
              break;
            }

            // Parse each expression and add it
            ExpressionNode* addValue = this->Expression();

            // We got in here, but we didn't expect another expression
            // We make an exception for the first expression
            if (addValue == nullptr)
            {
              // Show an error and recall back to the saved position
              this->ErrorHere(ErrorCode::CreationInitializerNotComplete);
              this->RecallTokenPosition();

              // Deleting the initializer should delete the constructor call and the creation node, and the type we parsed
              delete initializer;
              return nullptr;
            }

            // Add the next expression to our arguments list...
            addNode->Arguments.Add(addValue);
          }
          // While we read comma separators (which means we read the next expression)
          while (this->Accept(1, Grammar::ArgumentSeparator));

          // If we expect another expression...
          if (acceptedInnerEndInitializer == false && this->Expect(Grammar::EndInitializer, ErrorCode::CreationInitializerNotComplete) == false)
          {
            // Deleting the initializer should delete the constructor call and the creation node, and the type we parsed
            delete initializer;
            this->RecallTokenPosition();
            return nullptr;
          }
        }
        // If we're adding just one expression...
        else if (ExpressionNode* singleAddValue = this->Expression())
        {
          // We're reading another value (could be an argument list)
          addNode = new ExpressionInitializerAddNode();
          this->SetNodeLocationStartHere(addNode);
          initializer->AddValues.Add(addNode);
        
          // Add the expression we read to the add node
          addNode->Arguments.Add(singleAddValue);
        }
        else
        {
          // Show an error and recall back to the saved position
          this->ErrorHere(ErrorCode::CreationInitializerExpectedSubElement);
          this->RecallTokenPosition();

          // Deleting the initializer should delete the constructor call and the creation node, and the type we parsed
          delete initializer;
          return nullptr;
        }

        // If we read in an add node, then generate an actual 'Add' statement
        if (addNode != nullptr)
        {
          // End the add node here
          this->SetNodeLocationEndHere(addNode);
          
          // We previously generated a local variable so we could look up the creation node by name
          LocalVariableReferenceNode* accessLeftVar = new LocalVariableReferenceNode();
          accessLeftVar->Location = addNode->Location;
          accessLeftVar->Value = leftVar->Name;

          // Access the 'OperatorInsert' method on the container
          MemberAccessNode* addMember = new MemberAccessNode();
          addMember->Location = addNode->Location;
          addMember->Name = OperatorInsert;
          addMember->Operator = Grammar::Access;
          addMember->LeftOperand = accessLeftVar;

          // Call the add method with the arguments we parsed
          FunctionCallNode* addCall = new FunctionCallNode();
          addCall->Location = addNode->Location;
          addCall->LeftOperand = addMember;

          // Copy over the arguments to the function call
          for (size_t i = 0; i < addNode->Arguments.size(); ++i)
          {
            // Clone the same expression arguments to appear in the add call arguments
            addCall->Arguments.Add((ExpressionNode*)addNode->Arguments[i]->Clone());
          }

          // Lastly, add the call to the initialization statements
          initializer->InitializerStatements.Add(addCall);
        }
      }
      // While we read comma separators (which means we read the next expression)
      while (this->Accept(1, Grammar::ArgumentSeparator));

      // If we expect another expression...
      if (acceptedOuterEndInitializer == false && this->Expect(Grammar::EndInitializer, ErrorCode::CreationInitializerNotComplete) == false)
      {
        // Deleting the constructor call should delete the creation node, all initializers, and the type we parsed
        delete initializer;
        this->RecallTokenPosition();
        return nullptr;
      }

      // The initializer ends here
      this->SetNodeLocationEndHere(initializer);
      this->AcceptTokenPosition();
      leftVar->InitialValue = leftOperand;
      return initializer;
    }

    // We didn't parse anything
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ExpressionNode* Parser::TypeId()
  {
    // We only need to get the type-id token because we need to know its location
    // so that we can tell the node where it started from
    const UserToken* typeIdToken;

    // Lets see if it's a type-id
    if (this->AcceptAndRetrieve(1, Grammar::Typeid, &typeIdToken))
    {
      // Check for the first parenthesis
      if (this->Expect(Grammar::BeginGroup, ErrorCode::TypeIdExpressionNotFound))
      {
        // Below is a little bit of a wonky piece of logic
        // We may want to introduce a 'static type id' instead
        // Basically we need to attempt to read a type, and then if that fails
        // we need to recall back and read an expression
        // We know that we properly read the type when it parses and we also read
        // an ending parenthesis ')'. Note that the user could be inputting
        // an expression, but the expression could start with a type (TypeMemberAccess...)
        this->SaveTokenPosition();

        // We may alternatively try to get the typeid of a type
        ZilchTodo("Investigate changing typeid(Type) to just parsing an expression because now we have "
                  "StaticTypeNode (Decorate StaticTypeNode would need to allow typeid as a parent)");
        SyntaxType* type = this->ReadTypeInfo();

        // Read the value we want to get the type of
        ExpressionNode* value = nullptr;

        // If we read the type, and we know it's the whole type because we hit the ending parentheses...
        if (type != nullptr && this->Accept(1, Grammar::EndGroup))
        {
          // Accept the read so we can move on
          this->AcceptTokenPosition();
        }
        // If no type was read, or we didn't read the end parentheses
        // then attempt to read a value expression...
        else
        {
          // First attempt to delete the type that was read (nullptr safe to delete)
          delete type;
          type = nullptr;

          // Recall the position back so we can read the expression
          this->RecallTokenPosition();
          
          // Read the value expression that we want to get rtti for
          value = this->Expression();
        }

        // As long as we read the type-id expression / type
        if (type != nullptr || value != nullptr)
        {
          // Make sure we read the ending parenthesis (note, if we read a type, then that already happened!)
          if (type != nullptr || this->Expect(Grammar::EndGroup, ErrorCode::TypeIdExpressionNotComplete))
          {
            // Create a new call node
            TypeIdNode* node = new TypeIdNode();
            this->SetNodeLocationStartToToken(node, *typeIdToken);

            // Set the value expression or type that we want to get rtti for
            node->CompileTimeSyntaxType = type;
            node->Value = value;

            // Return the node we just parsed
            this->SetNodeLocationEndHere(node);
            return node;
          }
        }
        else
        {
          // Show an error since we didn't parse the expression
          this->ErrorHere(ErrorCode::TypeIdExpressionNotFound);
        }
      }
    }

    // Return null since we didn't parse anything
    return nullptr;
  }

  //***************************************************************************
  ValueNode* Parser::CreateStringLiteral(const UserToken* token)
  {
    // Just allocate a standard value-node
    ValueNode* node = new ValueNode();

    // Let the node know where it started and ended (line / character, etc)
    this->SetNodeLocationStartHere(node);

    // Point the node's value to the parsed value
    node->Value = *token;
    node->Value.TokenId = Grammar::StringLiteral;

    // Return the value node
    return node;
  }

  //***************************************************************************
  StringInterpolantNode* Parser::StringInterpolant()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // This will hold the token that we try and parse
    const UserToken* interpolantStart;
    
    // Check to see if we're starting a string interpolant
    if (this->AcceptAny(1, &interpolantStart, Grammar::BeginStringInterpolate))
    {
      // Create a string interpolant node
      StringInterpolantNode* node = new StringInterpolantNode();
      this->SetNodeLocationStartToLastSave(node);

      // Add the string value node
      node->Elements.Add(this->CreateStringLiteral(interpolantStart));

      ZilchLoop
      {
        // Now we should be able to parse an expression, since we started an interpolation
        if (node->Elements.Add(this->Expression()) == nullptr)
        {
          // Show an error and recall back to the saved position
          this->ErrorHere(ErrorCode::StringInterpolantExpectedExpression);
          this->RecallTokenPosition();
          delete node;
          return nullptr;
        }

        // Attempt to read the end of the interpolant
        const UserToken* interpolantEnd;
        if (this->AcceptAny(2, &interpolantEnd, Grammar::EndStringInterpolate, Grammar::EndBeginStringInterpolate))
        {
          // Add the string value node
          node->Elements.Add(this->CreateStringLiteral(interpolantEnd));

          // If we reached the true end of the interpolant
          if (interpolantEnd->TokenId == Grammar::EndStringInterpolate)
          {
            // Accept the token position, and return the node
            this->AcceptTokenPosition();
            this->SetNodeLocationEndHere(node);
            return node;
          }
        }
        else
        {
          // Show an error and recall back to the saved position
          this->ErrorHere(ErrorCode::StringInterpolantNotComplete);
          this->RecallTokenPosition();
          delete node;
          return nullptr;
        }
      }
    }

    // We didn't successfully parse an expression, so just recall the token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }

  //***************************************************************************
  ExpressionNode* Parser::Value()
  {
    // Save the token position
    ZilchSaveAndVerifyTokenPosition();

    // This will hold the token that we try and parse
    const UserToken* value;

    // Attempt to parse any value (including literals and identifiers) and retreive the associated token
    if (this->AcceptAny(10, &value, Grammar::LowerIdentifier, Grammar::IntegerLiteral, Grammar::DoubleIntegerLiteral, Grammar::RealLiteral, Grammar::DoubleRealLiteral, Grammar::StringLiteral, Grammar::CharacterLiteral, Grammar::Null, Grammar::True, Grammar::False))
    {
      // We found a value, so make room for it
      ValueNode* node;
      
      // If the value is an lower-case identifier, then it must be a variable reference
      if (value->TokenId == Grammar::LowerIdentifier)
      {
        // Allocate an identifier node (which is also a value node)
        node = new LocalVariableReferenceNode();
      }
      // Otherwise, it's just a standard value
      else
      {
        // Just allocate a standard value-node
        node = new ValueNode();
      }

      // Let the node know where it started (line / character, etc)
      this->SetNodeLocationStartToLastSave(node);

      // Point the node's value to the parsed value
      node->Value = *value;

      // Accept the token position, and return the value node
      AcceptTokenPosition();
      this->SetNodeLocationEndHere(node);
      return node;
    }
    // Lets see if it's a string interpolant
    else if (StringInterpolantNode* node = this->StringInterpolant())
    {
      // Accept the token position, and return the value node
      AcceptTokenPosition();
      return node;
    }
    // Read a type (a constructor call or static member access could follow)
    // We also parse the new/local keywords here (in that case, we know it MUST be a constructor call)
    else if (StaticTypeNode* node = this->StaticTypeOrCreationCall())
    {
      // Accept the token position, and return the value node
      AcceptTokenPosition();
      return node;
    }
    // It might be a type-id, lets check that
    else if (ExpressionNode* node = this->TypeId())
    {
      // Accept the token position, and return the value node
      AcceptTokenPosition();
      return node;
    }
    // Lastly, try and see if we're just in a grouping operator
    else if (Accept(1, Grammar::BeginGroup))
    {
      // Attempt to read the expression inside the grouping
      ExpressionNode* expression = this->Expression();

      // If the expression was found...
      if (expression != nullptr)
      {
        // Look for the closing parenthasis
        if (Expect(Grammar::EndGroup, ErrorCode::GroupingOperatorNotComplete))
        {
          // Accept the token position, and return the expression node
          this->AcceptTokenPosition();
          return expression;
        }

        // If we got here, we failed to finish the grouping operator
        delete expression;
      }
    }

    // Otherwise, recall the old token position and return null
    this->RecallTokenPosition();
    return nullptr;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes




namespace Zilch
{
  //***************************************************************************
  namespace Events
  {
    ZilchDefineEvent(PreBuild);
  }
  
  //***************************************************************************
  BuildEvent::BuildEvent() :
    BuildingProject(nullptr),
    Dependencies(nullptr),
    Builder(nullptr)
  {
  }
  
  //***************************************************************************
  LibraryRef BuildEvent::FindLibrary(StringParam name)
  {
    ZilchForEach(LibraryRef library, this->Dependencies->all())
    {
      if (library->Name == name)
        return library;
    }

    return nullptr;
  }

  //***************************************************************************
  Plugin::~Plugin()
  {
  }
  
  //***************************************************************************
  PluginStubLibrary& PluginStubLibrary::GetInstance()
  {
    static PluginStubLibrary instance;
    return instance;
  }
  
  //***************************************************************************
  PluginStubLibrary::PluginStubLibrary() :
    StaticLibrary("PluginStubLibrary")
  {
  }
  
  //***************************************************************************
  PluginStubLibrary::~PluginStubLibrary()
  {
  }
  
  //***************************************************************************
  bool PluginStubLibrary::CanBuildTypes()
  {
    return true;
  }
  
  //***************************************************************************
  void NameMangler::MangleLibrary(LibraryRef library)
  {
    Array<BoundType*> orderedTypes;
    library->GetTypesInDependencyOrder(orderedTypes);

    for (size_t i = 0; i < orderedTypes.size(); ++i)
    {
      BoundType* type = orderedTypes[i];
      for (size_t j = 0; j < type->AllFunctions.size(); ++j)
      {
        Function* function = type->AllFunctions[j];
        String mangledName = this->MangleFunction(function);
        this->MangledNameToFunction.insert(mangledName, function);
      }
    }
  }
  
  //***************************************************************************
  Function* NameMangler::FindFunction(StringParam mangledName, const char* functionName, StringParam typeName)
  {
    Function* function = this->MangledNameToFunction.findValue(mangledName, nullptr);
    ErrorIf
    (
      function == nullptr,
      "Unable to find function/overload %s on type %s (with mangling %s)",
      functionName,
      typeName,
      mangledName.c_str()
    );
    return function;
  }

  //***************************************************************************
  String NameMangler::MangleFunction(Function* function)
  {
    String& mangledName = this->FunctionToMangledName[function];

    if (mangledName.empty())
    {
      DelegateType* type = function->FunctionType;

      StringBuilder builder;
      builder.Append(LibraryBuilder::FixIdentifier(function->Owner->Name, TokenCheck::NoMultipleInvalidCharacters));
      builder.Append("_");
      builder.Append(LibraryBuilder::FixIdentifier(function->Name, TokenCheck::RemoveOuterBrackets | TokenCheck::NoMultipleInvalidCharacters));
      builder.Append("_");
      String fixedName = LibraryBuilder::FixIdentifier(type->ToString(), TokenCheck::NoMultipleInvalidCharacters);
      builder.Append(fixedName);
      mangledName = builder.ToString();
    }

    return mangledName;
  }
  
  //***************************************************************************
  BoundType* FindLibraryType(LibraryRef library, const char* name, BoundType*& outputType)
  {
    BoundType* type = library->BoundTypes.findValue(name, nullptr);
    outputType = type;
    ErrorIf(type == nullptr, "Unable to find the %s type", name);
    return type;
  }

  //***************************************************************************
  NativeName::NativeName()
  {
  }
  
  //***************************************************************************
  NativeName::NativeName(StringParam className, StringParam parameterName, StringParam returnName) :
    Class(className),
    Parameter(parameterName),
    Return(returnName)
  {
  }
  
  //***************************************************************************
  NativeStubCode::NativeStubCode()
  {
    this->TypeToCppName.insert(ZilchTypeId(Delegate), NativeName("Zilch::Delegate", "const Zilch::Delegate&", "Zilch::Delegate"));

    this->TypeToCppName.insert(ZilchTypeId(void), NativeName("void", "void", "void"));
    
    this->TypeToCppName.insert(ZilchTypeId(Boolean), NativeName("bool", "bool", "bool"));
    this->TypeToCppName.insert(ZilchTypeId(Boolean2), NativeName("Zilch::Boolean2", "const Zilch::Boolean2&", "Zilch::Boolean2"));
    this->TypeToCppName.insert(ZilchTypeId(Boolean3), NativeName("Zilch::Boolean3", "const Zilch::Boolean3&", "Zilch::Boolean3"));
    this->TypeToCppName.insert(ZilchTypeId(Boolean4), NativeName("Zilch::Boolean4", "const Zilch::Boolean4&", "Zilch::Boolean4"));

    this->TypeToCppName.insert(ZilchTypeId(Byte), NativeName("unsigned char", "unsigned char", "unsigned char"));

    this->TypeToCppName.insert(ZilchTypeId(Integer), NativeName("int", "int", "int"));
    this->TypeToCppName.insert(ZilchTypeId(Integer2), NativeName("Zilch::Integer2", "const Zilch::Integer2&", "Zilch::Integer2"));
    this->TypeToCppName.insert(ZilchTypeId(Integer3), NativeName("Zilch::Integer3", "const Zilch::Integer3&", "Zilch::Integer3"));
    this->TypeToCppName.insert(ZilchTypeId(Integer4), NativeName("Zilch::Integer4", "const Zilch::Integer4&", "Zilch::Integer4"));

    this->TypeToCppName.insert(ZilchTypeId(Real), NativeName("float", "float", "float"));
    this->TypeToCppName.insert(ZilchTypeId(Real2), NativeName("Zilch::Real2", "const Zilch::Real2&", "Zilch::Real2"));
    this->TypeToCppName.insert(ZilchTypeId(Real3), NativeName("Zilch::Real3", "const Zilch::Real3&", "Zilch::Real3"));
    this->TypeToCppName.insert(ZilchTypeId(Real4), NativeName("Zilch::Real4", "const Zilch::Real4&", "Zilch::Real4"));
    
    this->TypeToCppName.insert(ZilchTypeId(Quaternion), NativeName("Zilch::Quaternion", "const Zilch::Quaternion&", "Zilch::Quaternion"));
      
    this->TypeToCppName.insert(ZilchTypeId(String), NativeName("Zilch::String", "const Zilch::String&", "Zilch::String"));

    this->TypeToCppName.insert(ZilchTypeId(DoubleReal), NativeName("double", "double", "double"));
    this->TypeToCppName.insert(ZilchTypeId(DoubleInteger), NativeName("long long", "long long", "long long"));
  }

  //***************************************************************************
  NativeName NativeStubCode::GetCppTypeName(Type* type, Library* generatingLibrary)
  {
    if (Type::IsDelegateType(type))
      type = ZilchTypeId(Delegate);

    NativeName* nativeName = this->TypeToCppName.findPointer(type);
    if (nativeName != nullptr)
      return *nativeName;

    String name = LibraryBuilder::FixIdentifier(type->ToString(), TokenCheck::None, '\0');

    if (generatingLibrary->Name != type->SourceLibrary->Name)
      name = BuildString(type->SourceLibrary->Name, "::", name);

    NativeName nativeNameResult;
    nativeNameResult.Class = name;
    
    if (Type::IsHandleType(type))
    {
      nativeNameResult.Parameter = BuildString(name, "*");
      nativeNameResult.Return = nativeNameResult.Parameter;
    }
    else
    {
      nativeNameResult.Parameter = name;
      nativeNameResult.Return = name;
    }

    this->TypeToCppName.insert(type, nativeNameResult);

    return nativeNameResult;
  }
  
  //***************************************************************************
  String NativeStubCode::GenerateHpp(Library* library, Array<BoundType*>& orderedTypes)
  {
    String nameSpace = library->Name;
    String nameDefine = nameSpace.ToUpper();

    ZilchCodeBuilder builder;
    builder.Write(this->HppHeader);
    builder.WriteLineIndented("#pragma once");
    builder.Write("#ifndef ");
    builder.Write(nameDefine);
    builder.WriteLineIndented("_HPP");
    builder.Write("#define ");
    builder.Write(nameDefine);
    builder.WriteLineIndented("_HPP");
    builder.WriteLineIndented();

    builder.WriteLineIndented();
    builder.Write("namespace ");
    builder.Write(nameSpace);
    builder.BeginScope(ScopeType::Block);
    builder.WriteLineIndented();
    
    for (size_t i = 0; i < orderedTypes.size(); ++i)
    {
      BoundType* type = orderedTypes[i];

      String typeName = this->GetCppTypeName(type, library).Class;

      builder.Write("class ");
      builder.Write(typeName);
      builder.WriteLineIndented(";");
    }

    builder.WriteLineIndented();

    for (size_t i = 0; i < orderedTypes.size(); ++i)
    {
      BoundType* type = orderedTypes[i];
      
      if (type->Description.empty() == false)
      {
        builder.WriteSingleLineComment(type->Description);
        builder.WriteLineIndented();
      }

      static const String GenericBase = "Zilch::Base";

      String typeName = this->GetCppTypeName(type, library).Class;
      String baseName = GenericBase;
      
      BoundType* base = type->BaseType;
      if (base != nullptr)
        baseName = this->GetCppTypeName(base, library).Class;
      
      builder.Write("class ");
      builder.Write(typeName);
      builder.Write(" : public ");
      builder.Write(baseName);

      builder.BeginScope(ScopeType::Class);

      // We generally put 'public' on the same line as the scope
      --builder.Indentation;
      builder.WriteLineIndented();
      builder.Write("public:");
      ++builder.Indentation;
      
      builder.WriteLineIndented();

      for (size_t j = 0; j < type->AllFunctions.size(); ++j)
      {
        Function* function = type->AllFunctions[j];

        String functionName = LibraryBuilder::FixIdentifier(function->Name, TokenCheck::RemoveOuterBrackets);

        DelegateType* delegateType = function->FunctionType;
        
        if (function->Description.empty() == false)
        {
          builder.WriteSingleLineComment(function->Description);
          builder.WriteLineIndented();
        }

        if (function->This == nullptr)
          builder.Write("static ");

        Type* returnType = delegateType->Return;
        NativeName returnTypeName = GetCppTypeName(returnType, library);
        builder.Write(returnTypeName.Return);

        builder.WriteSpace();
        builder.Write(functionName);
        builder.Write("(");

        size_t lastIndex = delegateType->Parameters.size() - 1;
        for (size_t k = 0; k < delegateType->Parameters.size(); ++k)
        {
          DelegateParameter& parameter = delegateType->Parameters[k];
          builder.Write(GetCppTypeName(parameter.ParameterType, library).Parameter);
          if (parameter.IsNameGenerated == false)
          {
            builder.WriteSpace();
            builder.Write(parameter.Name);
          }

          if (k != lastIndex)
            builder.Write(", ");
        }

        builder.Write(");");
        builder.WriteLineIndented();
        builder.WriteLineIndented();
      }
      
      if (Type::IsEnumOrFlagsType(type))
      {
        builder.WriteLineIndented("int mValue;");
      }
      else
      {
        builder.Write("unsigned char mValue[");
        builder.Write((Integer)type->GetCopyableSize());
        builder.WriteLineIndented("];");
      }
      
      builder.EndScope();
      builder.WriteLineIndented(";");
      builder.WriteLineIndented();
    }

    builder.EndScope();
    builder.WriteLineIndented();
    builder.WriteLineIndented();
    
    builder.Write("namespace Zilch");
    builder.BeginScope(ScopeType::Block);
    builder.WriteLineIndented();
    
    for (size_t i = 0; i < orderedTypes.size(); ++i)
    {
      BoundType* type = orderedTypes[i];
      String typeName = this->GetCppTypeName(type, library).Class;
      String baseName = type->BaseType ? this->GetCppTypeName(type->BaseType, library).Class : String();
    
      static const String TypeCopyReference = "Zilch::TypeCopyMode::ReferenceType";
      static const String TypeCopyValue = "Zilch::TypeCopyMode::ValueType";
      
      String typeCopyMode = TypeCopyReference;
      if (type->CopyMode == TypeCopyMode::ValueType)
        typeCopyMode = TypeCopyValue;

      if (type->BaseType == nullptr)
      {
        builder.Write("ZilchDeclareExternalBaseType(");
        builder.Write(library->Name);
        builder.Write("::");
        builder.Write(typeName);
        builder.Write(", ");
        builder.Write(typeCopyMode);
        builder.WriteLineIndented(");");
      }
      else
      {
        builder.Write("ZilchDeclareExternalDerivedType(");
        builder.Write(library->Name);
        builder.Write("::");
        builder.Write(typeName);
        builder.Write(", ");
        builder.Write(type->BaseType->SourceLibrary->Name);
        builder.Write("::");
        builder.Write(baseName);
        builder.Write(", ");
        builder.Write(typeCopyMode);
        builder.WriteLineIndented(");");
      }
    }

    builder.EndScope();
    builder.WriteLineIndented();
    builder.WriteLineIndented();
    
    builder.Write("bool HookUp");
    builder.Write(library->Name);
    builder.WriteLineIndented("(Zilch::BuildEvent* event);");
    builder.WriteLineIndented();

    builder.WriteLineIndented("#endif");

    String result = builder.ToString();
    return result;
  }
  
  //***************************************************************************
  String NativeStubCode::GenerateCpp(Library* library, Array<BoundType*>& orderedTypes)
  {
    String nameSpace = library->Name;
    String nameDefine = nameSpace.ToUpper();

    ZilchCodeBuilder builder;
    builder.Write(this->CppHeader);
    builder.WriteLineIndented("#include \"Zilch.hpp\"");
    builder.Write("#include \"");
    builder.Write(library->Name);
    builder.WriteLineIndented(".hpp\"");
    builder.WriteLineIndented();

    builder.Write("namespace ");
    builder.Write(nameSpace);
    builder.BeginScope(ScopeType::Block);
    builder.WriteLineIndented();
    
    for (size_t i = 0; i < orderedTypes.size(); ++i)
    {
      BoundType* type = orderedTypes[i];
      String typeName = this->GetCppTypeName(type, library).Class;

      builder.WriteLineIndented("//***************************************************************************");
      builder.Write("static Zilch::BoundType* ");
      String cachedTypeName = String::Format("%s_Type", typeName.c_str());
      builder.Write(cachedTypeName);
      builder.WriteLineIndented(" = nullptr;");

      for (size_t j = 0; j < type->AllFunctions.size(); ++j)
      {
        Function* function = type->AllFunctions[j];

        String functionName = function->Name;
        if (function->IsPropertyGetOrSet)
          functionName = functionName.sub_string(1, functionName.size() - 2);

        DelegateType* delegateType = function->FunctionType;

        builder.WriteLineIndented("//***************************************************************************");
        builder.Write("static Zilch::Function* ");
        String cachedFunctionName = this->Mangler.MangleFunction(function);
        builder.Write(cachedFunctionName);
        builder.WriteLineIndented(" = nullptr;");

        Type* returnType = delegateType->Return;
        NativeName returnTypeName = GetCppTypeName(returnType, library);

        bool isReturnVoid = (delegateType->Return == ZilchTypeId(void));
        String defaultReturn;
        if (isReturnVoid == false)
          defaultReturn = String::Format(" Zilch::Default<%s>()", returnTypeName.Return.c_str());

        builder.Write(returnTypeName.Return);
        builder.WriteSpace();
        builder.Write(typeName);
        builder.Write("::");
        builder.Write(functionName);
        builder.Write("(");

        size_t lastIndex = delegateType->Parameters.size() - 1;
        for (size_t k = 0; k < delegateType->Parameters.size(); ++k)
        {
          DelegateParameter& parameter = delegateType->Parameters[k];
          builder.Write(GetCppTypeName(parameter.ParameterType, library).Parameter);
          builder.WriteSpace();
          builder.Write(parameter.Name);

          if (k != lastIndex)
            builder.Write(", ");
        }

        builder.Write(")");
        builder.BeginScope(ScopeType::Function);
        builder.WriteLineIndented();

        builder.Write("ReturnIf(");
        builder.Write(cachedFunctionName);
        builder.Write(" == nullptr,");
        builder.Write(defaultReturn);
        builder.WriteLineIndented(", \"The function does not exist (it may have been removed)\");");

        builder.WriteLineIndented("Zilch::ExecutableState* __state = Zilch::ExecutableState::GetCallingState();");
        builder.Write("ReturnIf(__state == nullptr,");
        builder.Write(defaultReturn);
        builder.WriteLineIndented(", \"You can only invoke this function when your code is called from Zilch\");");
        builder.WriteLineIndented();

        builder.Write("Zilch::Call __call(");
        builder.Write(cachedFunctionName);
        builder.WriteLineIndented(", __state);");

        if (function->This != nullptr)
        {
          builder.Write("__call.Set<Zilch::Handle>(Zilch::Call::This, Zilch::Handle(__state, ZilchTypeId(");
          builder.Write(typeName);
          builder.WriteLineIndented("), (unsigned char*)this));");
        }

        for (size_t k = 0; k < delegateType->Parameters.size(); ++k)
        {
          DelegateParameter& parameter = delegateType->Parameters[k];

          builder.Write("__call.Set<");
          builder.Write(GetCppTypeName(parameter.ParameterType, library).Parameter);
          builder.Write(">(");
          builder.Write((Integer)k);
          builder.Write(", ");
          builder.Write(parameter.Name);
          builder.WriteLineIndented(");");
        }
        builder.WriteLineIndented();

        builder.WriteLineIndented("Zilch::ExceptionReport& __report = __state->GetCallingReport();");
        builder.WriteLineIndented("__call.Invoke(__report);");
        builder.WriteLineIndented();
        
        if (isReturnVoid)
        {
          builder.WriteLineIndented("return;");
        }
        else
        {
          builder.WriteLineIndented("if (__report.HasThrownExceptions())");
          builder.WriteIndent();
          builder.Write("return");
          builder.Write(defaultReturn);
          builder.WriteLineIndented(";");
          builder.WriteLineIndented();

          builder.Write("return __call.Get<");
          builder.Write(returnTypeName.Return);
          builder.WriteLineIndented(">(Zilch::Call::Return);");
        }

        builder.EndScope();
        builder.WriteLineIndented();
        builder.WriteLineIndented();
      }
    }
    builder.EndScope();
    builder.WriteLineIndented();
    builder.WriteLineIndented();
    
    builder.Write("namespace Zilch");
    builder.BeginScope(ScopeType::Block);
    builder.WriteLineIndented();
    
    for (size_t i = 0; i < orderedTypes.size(); ++i)
    {
      BoundType* type = orderedTypes[i];
      String typeName = this->GetCppTypeName(type, library).Class;
      String cachedTypeName = String::Format("%s::%s_Type", library->Name.c_str(), typeName.c_str());

      builder.Write("ZilchDefineExternalGiven(");
      builder.Write(library->Name);
      builder.Write("::");
      builder.Write(typeName);
      builder.Write(", \"");
      builder.Write(typeName);
      builder.Write("\", ");
      builder.Write(cachedTypeName);
      builder.WriteLineIndented(", PluginStubLibrary, builder, type) {}");
    }

    builder.EndScope();
    builder.WriteLineIndented();
    builder.WriteLineIndented();
    
    builder.Write("bool HookUp");
    builder.Write(library->Name);
    builder.Write("(Zilch::BuildEvent* event)");
    builder.BeginScope(ScopeType::Function);
    
    builder.Write("const char* libraryName = \"");
    builder.Write(library->Name);
    builder.WriteLineIndented("\";");

    builder.WriteLineIndented("Zilch::BoundType* type = nullptr;");
    
    builder.WriteLineIndented("Zilch::LibraryRef library = event->FindLibrary(libraryName);");
    builder.WriteLineIndented("ReturnIf(library == nullptr, false, \"Unable to find the library %s in the list of dependencies\", libraryName);");

    builder.WriteLineIndented("Zilch::NameMangler mangler;");
    builder.WriteLineIndented("mangler.MangleLibrary(library);");

    for (size_t i = 0; i < orderedTypes.size(); ++i)
    {
      BoundType* type = orderedTypes[i];
      String typeName = this->GetCppTypeName(type, library).Class;
      
      String cachedTypeName = String::Format("%s::%s_Type", library->Name.c_str(), typeName.c_str());

      builder.Write("type = FindLibraryType(library, \"");
      builder.Write(type->Name);
      builder.Write("\", ");
      builder.Write(cachedTypeName);
      builder.WriteLineIndented(");");

      builder.WriteLineIndented("ErrorIf(type == nullptr, \"Unable to find the %s type\", type->Name);");
      builder.Write("if (type != nullptr)");
      builder.BeginScope(ScopeType::Block);
      builder.WriteLineIndented();
      
      for (size_t j = 0; j < type->AllFunctions.size(); ++j)
      {
        Function* function = type->AllFunctions[j];
        String cachedFunctionName = this->Mangler.MangleFunction(function);
        
        builder.Write(library->Name);
        builder.Write("::");
        builder.Write(cachedFunctionName);
        builder.Write(" = mangler.FindFunction(\"");
        builder.Write(cachedFunctionName);
        builder.Write("\", \"");
        builder.Write(function->Name);
        builder.WriteLineIndented("\", type->Name);");
      }

      builder.EndScope();
      builder.WriteLineIndented();
      builder.WriteLineIndented();
    }

    builder.WriteLineIndented();
    builder.WriteLineIndented("return true;");
    builder.EndScope();
    builder.WriteLineIndented();

    String result = builder.ToString();
    return result;
  }

  //***************************************************************************
  void NativeStubCode::Generate(LibraryRef library)
  {
    Array<BoundType*> orderedTypes;
    library->GetTypesInDependencyOrder(orderedTypes);

    this->Hpp = this->GenerateHpp(library.Object, orderedTypes);
    this->Cpp = this->GenerateCpp(library.Object, orderedTypes);
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes
















namespace Zilch
{
  //***************************************************************************
  namespace Events
  {
    ZilchDefineEvent(PreParser);
    ZilchDefineEvent(TypeParsed);
    ZilchDefineEvent(PostSyntaxer);
  }

  //***************************************************************************
  ParseEvent::ParseEvent() :
    Builder(nullptr),
    Type(nullptr),
    Location(nullptr)
  {
  }
    
  //***************************************************************************
  bool CompletionEntry::operator<(const CompletionEntry& rhs) const
  {
    // We want names to be alphabetical starting with A
    if (this->Name < rhs.Name)
      return true;
    if (this->Name > rhs.Name)
      return false;
    
    // We want types to be alphabetical starting with A
    if (this->Type < rhs.Type)
      return true;
    if (this->Type > rhs.Type)
      return false;

    // We actually use > to compare descriptions because we want the longest first
    if (this->Description.size() > rhs.Description.size())
      return true;
    if (this->Description.size() < rhs.Description.size())
      return false;

    // Finally, the descriptions had the same length, so compare their contents (may be equal!)
    return this->Description < rhs.Description;
  }
  
  //***************************************************************************
  CompletionParameter::CompletionParameter() :
    IsNameGenerated(false)
  {
  }

  //***************************************************************************
  AutoCompleteInfo::AutoCompleteInfo() :
    IsStatic(false),
    NearestType(nullptr),
    IsLiteral(false),
    RemoveDuplicateNameEntries(true),
    BestCompletionOverload(-1),
    Success(false)
  {
  }
  
  //***************************************************************************
  String AutoCompleteInfo::GetShortTypeName(StringParam fullTypeName)
  {
    // Empty strings should still return an entry when splitting (at least I think that would make sense), but just to be safe...
    if (fullTypeName.empty())
      return String();

    // Get the first word from the full type name
    String shortName = fullTypeName.Split(" ").front();

    // If the name is still too long, then trim it down and add an elipsis
    static const String Elipsis("...");
    if (shortName.size() > ShortTypeNameMaxLength)
      shortName = BuildString(shortName.sub_string(0, ShortTypeNameMaxLength - Elipsis.size()), Elipsis);

    return shortName;
  }
  
  //***************************************************************************
  String AutoCompleteInfo::GetJson()
  {
    JsonBuilder builder;
    builder.Begin(JsonType::Object);
    {
      builder.Key("Success");
      builder.Value(this->Success);

      builder.Key("NearestType");
      if (this->NearestType != nullptr)
        builder.Value(this->NearestType->ToString());
      else
        builder.Value(String());
      
      builder.Key("IsLiteral");
      builder.Value(this->IsLiteral);
      
      builder.Key("IsStatic");
      builder.Value(this->IsStatic);

      builder.Key("CompletionEntries");
      builder.Begin(JsonType::ArrayMultiLine);
      {
        for (size_t i = 0; i < this->CompletionEntries.size(); ++i)
        {
          CompletionEntry& entry = this->CompletionEntries[i];
          builder.Begin(JsonType::Object);
          {
            builder.Key("Name");
            builder.Value(entry.Name);

            builder.Key("Description");
            builder.Value(entry.Description);

            builder.Key("Type");
            builder.Value(entry.Type);

            builder.Key("ShortType");
            builder.Value(entry.ShortType);
          }
          builder.End();
        }
      }
      builder.End();
      
      builder.Key("FunctionName");
      builder.Value(this->FunctionName);

      builder.Key("BestCompletionOverload");
      builder.Value(this->BestCompletionOverload);

      builder.Key("CompletionOverloads");
      builder.Begin(JsonType::ArrayMultiLine);
      {
        for (size_t i = 0; i < this->CompletionOverloads.size(); ++i)
        {
          CompletionOverload& overload = this->CompletionOverloads[i];
          builder.Begin(JsonType::Object);
          {
            builder.Key("Description");
            builder.Value(overload.Description);
            
            builder.Key("ReturnType");
            builder.Value(overload.ReturnType);
            
            builder.Key("ReturnShortType");
            builder.Value(overload.ReturnType);
            
            builder.Key("Signature");
            builder.Value(overload.Signature);

            builder.Key("Parameters");
            builder.Begin(JsonType::ArrayMultiLine);
            {
              for (size_t i = 0; i < overload.Parameters.size(); ++i)
              {
                CompletionParameter& parameter = overload.Parameters[i];
                builder.Begin(JsonType::Object);
                {
                  builder.Key("Name");
                  builder.Value(parameter.Name);
                  
                  builder.Key("Description");
                  builder.Value(parameter.Description);
                  
                  builder.Key("Type");
                  builder.Value(parameter.Type);
                  
                  builder.Key("ShortType");
                  builder.Value(parameter.ShortType);
                  
                  builder.Key("IsNameGenerated");
                  builder.Value(parameter.IsNameGenerated);
                }
                builder.End();
              }
            }
            builder.End();
          }
          builder.End();
        }
      }
      builder.End();
    }
    builder.End();

    String result = builder.ToString();
    return result;
  }
  
  //***************************************************************************
  DefinitionInfo::DefinitionInfo() :
    DefinedVariable(nullptr),
    DefinedFunction(nullptr),
    DefinedProperty(nullptr),
    DefinedField(nullptr),
    ResolvedType(nullptr)
  {
  }

  //***************************************************************************
  Project::Project() :
    CursorPosition(NoCursor),
    UserData(nullptr),
    VariableUniqueIdCounter(0)
  {
    ZilchErrorIfNotStarted(Project);
  }

  //***************************************************************************
  void Project::AddCodeFromString(StringParam code, StringParam origin, void* codeUserData)
  {
    // Add an entry to the list of all entries
    CodeEntry& entry = this->Entries.push_back();
    entry.Code = code;
    entry.Origin = origin;
    entry.CodeUserData = codeUserData;
  }

  //***************************************************************************
  bool Project::ReadTextFile(StringParam fileName, String& textOut)
  {
    // Attempt to open the file for text reading
    FILE* fp = fopen(fileName.c_str(), "r");

    // If the file pointer is valid...
    if (fp)
    {
      // Create a string builder to concatenate all read in chunks together
      StringBuilder builder;

      // While we haven't reached the end of the file and have no errors...
      while (!feof(fp))
      {
        // Create a temporary buffer to store read in chunks
        const size_t BufferSize = 1024;
        char buffer[BufferSize];

        // Read a chunk of the file into the buffer
        size_t amountRead = fread(buffer, 1, BufferSize, fp);

        // If we had any kind of error, early out...
        if (ferror(fp))
        {
          // Return that we failed to read the file
          return false;
        }

        // Add the amount read into the string range
        builder.Append(StringRange(buffer, amountRead));
      }

      // Close the file handle
      fclose(fp);

      // Output the string that we read and return a success
      textOut = builder.ToString();
      return true;
    }

    // Otherwise, we failed to open the file
    return false;
  }

  //***************************************************************************
  bool Project::AddCodeFromFile(StringParam fileName, void* codeUserData)
  {
    // Read all the file into a string
    String code;
    bool result = ReadTextFile(fileName, code);

    // If we successfully read in the file...
    if (result)
    {
      // Add the code to the project
      this->AddCodeFromString(code, fileName, codeUserData);
    }

    // Return whether or not we successfully read the file
    return result;
  }

  //***************************************************************************
  void Project::Clear()
  {
    this->Entries.clear();
    this->PluginDirectories.clear();
    this->PluginFiles.clear();
  }

  //***************************************************************************
  bool Project::Tokenize(Array<UserToken>& tokensOut, Array<UserToken>& commentsOut)
  {
    // Reset whether there was an error or not
    this->WasError = false;

    // The tokenizer that parses the input stream into a list of tokens
    Tokenizer tokenizer(*this);

    // Loop through all the project entries
    for (size_t i = 0; i < this->Entries.size(); ++i)
    {
      // Grab the current project entry
      CodeEntry& entry = this->Entries[i];

      // Keep parsing all code into the same token stream
      tokenizer.Parse(entry, tokensOut, commentsOut);
    }

    // Finalize the token stream
    tokenizer.Finalize(tokensOut);

    // Return true if it succeeded, or false if there was an error in tokenizing
    return !this->WasError;
  }

  //***************************************************************************
  // This simple struct is used to define information about which syntax nodes came from which lines
  class ZeroShared OriginInfo
  {
  public:
    // Constructor
    OriginInfo() :
      MaxLine(0)
    {
    }

    // The max line reachable in the file (actually it's the last node we saw)
    size_t MaxLine;

    // The lines that map to a syntax node (some lines will be empty)
    HashMap<size_t, SyntaxNode*> LineToNode;
  };

  //***************************************************************************
  // Maps the line that a node occurs on to the node itself
  void MapLinesToNodes(HashMap<String, OriginInfo>& info, SyntaxNode* node)
  {
    // Skip attribute nodes, they are attached in a similar fashion to comments
    if (TypeBinding::DynamicCast<AttributeNode*>(node) != nullptr)
      return;

    // Populate all the children of the current node
    NodeChildren children;
    node->PopulateChildren(children);
    
    // Get the origin information by name
    OriginInfo& origin = info[node->Location.Origin];

    // Map the current node's line to the node itself
    // If another node exists under that same line, keep the first one
    // This is so that comments get attached to the highest parent node occuring on that line
    // (eg for 'var i = 5;' to the 'var' statement instead of the '5' expression);
    origin.LineToNode.insertNoOverwrite(node->Location.StartLine, node);

    // If this is the furthest node we've encountered in the file...
    if (node->Location.StartLine > origin.MaxLine)
    {
      // Push out the max line so we know how far to look when attaching comments
      origin.MaxLine = node->Location.StartLine;
    }

    // Loop through the children and map the lines again
    for (size_t i = 0; i < children.size(); ++i)
    {
      // Recursively invoke the map lines function
      MapLinesToNodes(info, (*children[i]));
    }
  }

  //***************************************************************************
  void Project::AttachCommentsToNodes(SyntaxTree& syntaxTree, Array<UserToken>& comments)
  {
    // Setup the map that we use to associate lines with nodes
    HashMap<String, OriginInfo> info;

    // Perform the actual line to node association, starting at the root going down
    MapLinesToNodes(info, syntaxTree.Root);

    // Loop through all the comments we parsed
    for (size_t i = 0; i < comments.size(); ++i)
    {
      // Get the current comment
      UserToken& comment = comments[i];

      // We need to start by looking in the file/origin where the comment existed
      OriginInfo& origin = info[comment.Location.Origin];

      // Now start at the comment line and loop downward until we find a node to attach it to (stop at the last line)
      for (size_t j = comment.Location.StartLine; j <= origin.MaxLine; ++j)
      {
        // Attempt to find a node at the current line
        SyntaxNode* node = origin.LineToNode.findValue(j, nullptr);

        // If we found a node...
        if (node != nullptr)
        {
          // Append the comment to the node and move on to the next comment!
          node->Comments.push_back(comment.Token);
          break;
        }
      }
    }
  }

  //***************************************************************************
  bool Project::CompileUncheckedSyntaxTree(SyntaxTree& syntaxTreeOut, Array<UserToken>& tokensOut, EvaluationMode::Enum evaluation)
  {
    // Reset the unique variable-id counter (ensures determanistic behavior)
    this->VariableUniqueIdCounter = 0;

    // Store all the parsed comment tokens
    Array<UserToken> comments;

    // Start by tokenizing the stream
    if (this->Tokenize(tokensOut, comments) == false)
      return false;

    // The parser parses the list of tokens into a syntax tree
    Parser parser(*this);
    
    // Apply the parser to the token stream, which should output a syntax tree!
    parser.ParseIntoTree(tokensOut, syntaxTreeOut, evaluation);

    // Make sure to attach all the comments we parsed to
    // any nodes, so we can collect them for documentation
    this->AttachCommentsToNodes(syntaxTreeOut, comments);

    // Fix up any parent pointers
    SyntaxNode::FixParentPointers(syntaxTreeOut.Root, nullptr);

    // Return true if it succeeded, or false if there was an error in parsing
    return !this->WasError;
  }

  //***************************************************************************
  bool Project::CompileCheckedSyntaxTree
  (
    SyntaxTree& syntaxTreeOut,
    LibraryBuilder& builder,
    Array<UserToken>& tokensOut,
    const Module& dependencies,
    EvaluationMode::Enum evaluation
  )
  {
    // The syntaxer holds information about all the internal and parsed types
    // It is also responsible for checking syntax for things like scope, etc
    Syntaxer syntaxer(*this);

    // Start by compiling the code into an unchecked tree
    if (this->CompileUncheckedSyntaxTree(syntaxTreeOut, tokensOut, evaluation) == false)
      return false;

    // Collect all the types, assign types where they are needed, and perform syntax checking
    syntaxer.ApplyToTree(syntaxTreeOut, builder, *this, dependencies);

    // Fix up any parent pointers (in case anything gets moved around)
    // This may be unnecessary... but we'd still like to do it
    SyntaxNode::FixParentPointers(syntaxTreeOut.Root, nullptr);

    // Return true if it succeeded, or false if there was a syntax error
    return !this->WasError;
  }

  void Project::LoadPlugins(LibraryBuilder& builder, Module& dependencies)
  {
    Array<Plugin*> loadedPlugins;

    // Load all individual plugins
    ZilchForEach(String& pluginFile, this->PluginFiles.all())
    {
      Status status;
      Plugin* plugin = builder.LoadPlugin(status, pluginFile);
      if (plugin != nullptr)
        loadedPlugins.append(plugin);
    }
    
    // Load all plugins found within these directories
    ZilchForEach(String& pluginDirectory, this->PluginDirectories.all())
    {
      builder.LoadPlugins(pluginDirectory, loadedPlugins);
    }

    BuildEvent buildEvent;
    buildEvent.BuildingProject = this;
    buildEvent.Dependencies = &dependencies;
    buildEvent.Builder = &builder;

    ZilchForEach(Plugin* loadedPlugin, loadedPlugins.all())
    {
      EventSend(loadedPlugin, Events::PreBuild, &buildEvent);
    }
  }
  
  //***************************************************************************
  LibraryRef Project::Compile(StringParam libraryName, Module& dependencies, EvaluationMode::Enum evaluation, SyntaxTree& treeOut)
  {
    // We're about to generate a library so we need a builder
    LibraryBuilder builder(libraryName);
    builder.BuiltLibrary->TolerantMode = this->TolerantMode;

    // Let the user know the library finished running the syntaxer (the user may add types here)
    ParseEvent preEvent;
    preEvent.Builder = &builder;
    EventSend(this, Events::PreParser, &preEvent);

    // Loads plugins into the library builder
    this->LoadPlugins(builder, dependencies);

    // Let the library know what source was used to build it
    builder.SetEntries(this->Entries);

    // Store the array of tokens that we generate
    Array<UserToken> tokens;

    // Compile the code into a checked syntax tree
    if (this->CompileCheckedSyntaxTree(treeOut, builder, tokens, dependencies, evaluation) == false)
      return nullptr;

    // Let the user know the library finished running the syntaxer (the user may add types here)
    ParseEvent postEvent;
    postEvent.Builder = &builder;
    EventSend(this, Events::PostSyntaxer, &postEvent);

    // Only generate code if we're not in tolerant mode (otherwise it would probably be seriously messed up...)
    if (this->TolerantMode == false)
    {
      // The code generator uses the syntax tree to generate opcode for each function
      CodeGenerator codeGenerator;
      LibraryRef library = codeGenerator.Generate(treeOut, builder);

      // Check that the library was valid
      ErrorIf(library == nullptr, "Somehow the library returned from code generation was not valid!");
      return library;
    }
    else
    {
      // Create the library without code generation
      return builder.CreateLibrary();
    }
  }

  //***************************************************************************
  LibraryRef Project::Compile(StringParam libraryName, Module& dependencies, EvaluationMode::Enum evaluation)
  {
    // The syntax tree holds a more intuitive representation of the parsed program and is easy to traverse
    SyntaxTree syntaxTree;
    return this->Compile(libraryName, dependencies, evaluation, syntaxTree);
  }
  
  //***************************************************************************
  CompletionOverload& Project::AddAutoCompleteOverload(AutoCompleteInfo& info, DelegateType* delegateType)
  {
    // Create a new overload that we'll return to the user
    CompletionOverload& overload = info.CompletionOverloads.push_back();

    // First, output the entire signature of the delegate
    overload.Signature = delegateType->ToString();

    // Fill out the return type of the delegate if its not void
    if (Zilch::Type::IsSame(ZilchTypeId(void), delegateType->Return) == false)
    {
      overload.ReturnType = delegateType->Return->ToString();
      overload.ReturnShortType = AutoCompleteInfo::GetShortTypeName(overload.ReturnType);
    }

    // Walk through all the delegate parameters and add them as completion parameters
    for (size_t i = 0; i < delegateType->Parameters.size(); ++i)
    {
      // Grab the current delegate parameter and make a completion parameter for it
      DelegateParameter& delegateParam = delegateType->Parameters[i];
      CompletionParameter& completionParam = overload.Parameters.push_back();
      completionParam.Type = delegateParam.ParameterType->ToString();
      completionParam.ShortType = AutoCompleteInfo::GetShortTypeName(completionParam.Type);
      completionParam.Name = delegateParam.Name;
      completionParam.IsNameGenerated = delegateParam.IsNameGenerated;
    }

    return overload;
  }

  //***************************************************************************
  // This is a functor entirely used for the below function (should be a local to the function, but some compilers don't support that...)
  class AutoCompletePropertyFunctionQuery
  {
  public:
    AutoCompleteInfo* Info;

    // Every time we encounter an extension property...
    bool operator()(Property* property)
    {
      // Fill out the entry with information about the property name, description, and stringified type
      CompletionEntry& entry = this->Info->CompletionEntries.push_back();
      entry.Name = property->Name;
      entry.Description = property->Description;
      entry.Type = property->PropertyType->ToString();
      entry.ShortType = AutoCompleteInfo::GetShortTypeName(entry.Type);
      return false;
    }
    
    // Every time we encounter an extension function...
    bool operator()(Function* function)
    {
      // Fill out the entry with information about the property name, description, and stringified type
      CompletionEntry& entry = this->Info->CompletionEntries.push_back();
      entry.Name = function->Name;
      entry.Description = function->Description;
      entry.Type = function->FunctionType->ToString();
      entry.ShortType = AutoCompleteInfo::GetShortTypeName(entry.Type);
      return false;
    }
  };
  
  //***************************************************************************
  void Project::InitializeDefinitionInfo(DefinitionInfo& resultOut, DocumentedObject* object)
  {
    // Get the type of the documented object (could be a property type, function type, class/struct type, etc)
    resultOut.ResolvedType = object->GetTypeOrNull();

    // If this is a native location, we need to generate stub code
    if (object->NameLocation.IsNative)
    {
      // Generate stub code for the library (if its already generated, this will do nothing)
      Library* library = object->GetOwningLibrary();
      library->GenerateDefinitionStubCode();
    }

    // Set the element and the name of the location
    resultOut.ElementLocation = object->Location;
    resultOut.NameLocation = object->NameLocation;
  }
  
  //***************************************************************************
  void Project::GetDefinitionInfo(Module& dependencies, size_t cursorPosition, StringParam cursorOrigin, DefinitionInfo& resultOut)
  {
    // Temporary set tolerant mode to true (recall it on any exiting of this function)
    Zero::SetAndRecallOnDestruction<bool> changeTolerantMode(&this->TolerantMode, true);

    // Compile the entirety of the project and get the syntax tree out of it
    // We MUST store the library or all the resources will be released
    SyntaxTree syntaxTree;
    resultOut.IncompleteLibrary = this->Compile(DefaultLibraryName, dependencies, EvaluationMode::Project, syntaxTree);

    // Get all the syntax nodes under the cursor
    Array<SyntaxNode*> nodes;
    syntaxTree.GetNodesAtCursor(cursorPosition, cursorOrigin, nodes);

    // If we received no nodes, then return nothing (DefinitionInfo will remain empty)
    if (nodes.empty())
      return;

    // Walk through the nodes backwards (since the more leaf nodes end up at the back)
    for (int i = (int)nodes.size() - 1; i >= 0; --i)
    {
      // Grab the current node
      SyntaxNode* node = nodes[i];
      
      if (SyntaxType* typedNode = TypeBinding::DynamicCast<SyntaxType*>(node))
      {
        Type* resolvedType = typedNode->ResolvedType;
        if (resolvedType != nullptr)
        {
          this->InitializeDefinitionInfo(resultOut, resolvedType);
          return;
        }
      }
      else if (LocalVariableReferenceNode* typedNode = TypeBinding::DynamicCast<LocalVariableReferenceNode*>(node))
      {
        Variable* variable = typedNode->AccessedVariable;
        if (variable != nullptr)
        {
          this->InitializeDefinitionInfo(resultOut, variable);
          resultOut.DefinedVariable = variable;
          return;
        }
      }
      else if (MemberAccessNode* typedNode = TypeBinding::DynamicCast<MemberAccessNode*>(node))
      {
        Field* field = typedNode->AccessedField;
        Property* property = typedNode->AccessedProperty;
        Function* function = typedNode->AccessedFunction;

        if (field != nullptr)
        {
          this->InitializeDefinitionInfo(resultOut, field);
          resultOut.DefinedField = field;
          return;
        }

        if (property != nullptr)
        {
          this->InitializeDefinitionInfo(resultOut, property);
          resultOut.DefinedProperty = property;
          return;
        }

        if (function != nullptr)
        {
          this->InitializeDefinitionInfo(resultOut, function);
          resultOut.DefinedFunction = function;
          return;
        }
        
        if (typedNode->OverloadedFunctions != nullptr && typedNode->OverloadedFunctions->empty() == false)
        {
          function = typedNode->OverloadedFunctions->front();
          this->InitializeDefinitionInfo(resultOut, function);
          resultOut.DefinedFunction = function;
          return;
        }
      }
    }
  }

  //***************************************************************************
  void Project::GetAutoCompleteInfo(Module& dependencies, size_t cursorPosition, StringParam cursorOrigin, AutoCompleteInfo& resultOut)
  {
    // First query auto complete type and function information
    this->GetAutoCompleteInfoInternal(dependencies, cursorPosition, cursorOrigin, resultOut);

    // We basically consider the auto complete a success if it found anything that wasn't the error type (and not null)
    resultOut.Success = (resultOut.NearestType != nullptr && resultOut.NearestType != Core::GetInstance().ErrorType);

    // If we're trying to access a bound type...
    Zilch::BoundType* boundType = Zilch::TypeBinding::DynamicCast<Zilch::BoundType*>(resultOut.NearestType);

    // If this wasn't a bound type, check first if its an indirect type
    if (boundType == nullptr)
    {
      // In general we can access indirect types exactly like how we access bound types...
      Zilch::IndirectionType* indirectType = Zilch::TypeBinding::DynamicCast<Zilch::IndirectionType*>(resultOut.NearestType);

      // Just set the bound type to be the reference type and continue on
      if (indirectType != nullptr)
        boundType = indirectType->ReferencedType;
    }

    // Make sure we have a valid type, but ignore integer literals
    if (boundType != nullptr)
    {
      // Query the dependencies for all extension functions and properties for the bound type
      // These functors also walk up base types and find any of their properties
      AutoCompletePropertyFunctionQuery queryFunctor;
      queryFunctor.Info = &resultOut;
      ForEachProperty(resultOut.IsStatic, dependencies, boundType, queryFunctor);
      ForEachFunction(resultOut.IsStatic, dependencies, boundType, queryFunctor);
    }

    // If we have no actual function overloads (we still may be performing a call on a delegate or functor of some sort)...
    if (resultOut.FunctionOverloads.empty())
    {
      // If the expression is a delegate type then generate an overload for the delegate
      // call (we technically won't know descriptions or, in the future, parameter names...)
      DelegateType* delegateType = TypeBinding::DynamicCast<DelegateType*>(resultOut.NearestType);
      if (delegateType != nullptr)
        this->AddAutoCompleteOverload(resultOut, delegateType);
      
      // We always set the name to be "delegate" when we don't know where the actual function came from
      resultOut.FunctionName = Grammar::GetKeywordOrSymbol(Grammar::Delegate);
    }
    else
    {
      // Now we handle any real overloads that we might have found (only when accessing a member on a type can we deal with overloads)
      for (size_t i = 0; i < resultOut.FunctionOverloads.size(); ++i)
      {
        // Grab the current overloaded function
        Function* function = resultOut.FunctionOverloads[i];

        // Create a completion overload for it (filling out return type and parameters/names)
        CompletionOverload& overload = this->AddAutoCompleteOverload(resultOut, function->FunctionType);

        // Set the description (this could be an inherited description)
        overload.Description = function->Description;
      
        // If we haven't gotten a function name yet, get it from this overload
        if (resultOut.FunctionName.empty())
        {
          // Show a special name for constructors
          if (function->Name == ConstructorName)
            resultOut.FunctionName = Grammar::GetKeywordOrSymbol(Grammar::Constructor);
          else
            resultOut.FunctionName = function->Name;
        }
      
        ErrorIf(function->Name != resultOut.FunctionName && function->Name != ConstructorName,
          "All function names in the overload list should match");
      }
    }

    // If we have completion overloads, then try to find some sort of 'best' overload to show the user, in
    // the event that the IDE does not have good support for an overload list or 'call-tips'
    if (resultOut.CompletionOverloads.empty() == false)
    {
      // Right now, we're only considering overloads that have descrptions (looking for the one with the most parameters)
      int bestParameterCount = -1;

      // Walk through all the completion overloads and look for the first with a description
      for (size_t i = 0; i < resultOut.CompletionOverloads.size(); ++i)
      {
        // Grab the current overload for convenience
        CompletionOverload& overload = resultOut.CompletionOverloads[i];

        // We only consider overloads tha have a description, then we look for the one with the most parameters
        int parameterCount = (int)overload.Parameters.size();
        if (overload.Description.empty() == false && parameterCount > bestParameterCount)
        {
          // This one is now the 'best', but we need to keep looking
          bestParameterCount = parameterCount;
          resultOut.BestCompletionOverload = (int)i;
        }
      }
      
      // If we still didn't find a good overload with a description...
      if (resultOut.BestCompletionOverload == -1)
      {
        // Just find the one with the most parameters, this should always get at least one
        // because all overloads have 0 or more parameters (and we start at -1)
        bestParameterCount = -1;
        
        // Walk through all the completion overloads and look for the first with a description
        for (size_t i = 0; i < resultOut.CompletionOverloads.size(); ++i)
        {
          // Grab the current overload for convenience
          CompletionOverload& overload = resultOut.CompletionOverloads[i];

          // We only consider overloads tha have a description, then we look for the one with the most parameters
          int parameterCount = (int)overload.Parameters.size();
          if (parameterCount > bestParameterCount)
          {
            // This one is now the 'best', but we need to keep looking
            bestParameterCount = parameterCount;
            resultOut.BestCompletionOverload = (int)i;
          }
        }
      }
    }

    // Finally, sort all completions and remove redundant entries
    sort(resultOut.CompletionEntries.all());

    // If the user wants us to remove duplicate entries...
    if (resultOut.RemoveDuplicateNameEntries)
    {
      // The last entry name that we hit (so we can compare the next one and see if its the same)
      String lastName;

      // Walk through all entries and only keep the first one for any duplicates (should already be sorted with longest descriptions first)
      for (size_t i = 0; i < resultOut.CompletionEntries.size();)
      {
        // If the current entry has the same name as the last...
        CompletionEntry& entry = resultOut.CompletionEntries[i];
        if (entry.Name == lastName)
        {
          // Note: We don't need to update 'lastName' because we know its the same!
          // Remove this entry from the completions (this will iterate us forward since it moves all entries in front back by one)
          resultOut.CompletionEntries.eraseAt(i);
        }
        else
        {
          // This is a new name, so store it so we can compare next time
          lastName = entry.Name;
          ++i;
        }
      }
    }
  }

  //***************************************************************************
  void Project::GetAutoCompleteInfoInternal(Module& dependencies, size_t cursorPosition, StringParam cursorOrigin, AutoCompleteInfo& resultOut)
  {
    // Temporary set tolerant mode to true (recall it on any exiting of this function)
    Zero::SetAndRecallOnDestruction<bool> changeTolerantMode(&this->TolerantMode, true);

    // Always assume we're parsing an instance/expression
    // Later on if we fail, we'll try to parse a type and therefore it may be a static
    resultOut.IsStatic = false;

    // Store the array of tokens that we generate
    Array<UserToken> tokens;
    Array<UserToken> comments;
    this->Tokenize(tokens, comments);

    const size_t InvalidIndex = (size_t) -1;
    size_t closestTokenIndex = InvalidIndex;

    for (size_t i = 0; i < tokens.size(); ++i)
    {
      UserToken& token = tokens[i];

      if (token.Location.Origin == cursorOrigin)
      {
        if (token.Start >= cursorPosition)
        {
          break;
        }

        closestTokenIndex = i;
      }
    }

    // If there's a dot right where the cursor is, backup until we hit no dots or function calls
    if (closestTokenIndex != InvalidIndex)
    {
      while (closestTokenIndex != InvalidIndex)
      {
        Grammar::Enum tokenId = tokens[closestTokenIndex].TokenId;
        if (tokenId != Grammar::Access && tokenId != Grammar::BeginFunctionCall)
        {
          break;
        }

        --closestTokenIndex;
      }
    }

    // If we still have a valid cursor token
    if (closestTokenIndex == InvalidIndex)
    {
      return;
    }
    
    Array<UserToken> expressionTokens;

    int parenthesesCount = 0;
    int bracketsCount = 0;
    bool done = false;

    size_t end = closestTokenIndex;
    size_t i = end;
    while (i != InvalidIndex)
    {
      UserToken& token = tokens[i];

      switch (token.TokenId)
      {
        case Grammar::New:
        case Grammar::Local:
        case Grammar::LowerIdentifier:
        case Grammar::RealLiteral:
        case Grammar::DoubleRealLiteral:
        case Grammar::IntegerLiteral:
        case Grammar::DoubleIntegerLiteral:
        case Grammar::StringLiteral:
        case Grammar::True:
        case Grammar::False:
        case Grammar::Typeid:
          if (parenthesesCount == 0 && bracketsCount == 0)
          {
            --i;
            done = true;
          }
          break;
          
        case Grammar::UpperIdentifier:
        case Grammar::Access:
        case Grammar::As:
          break;

        case Grammar::EndGroup: /* also EndFunctionCall */
          ++parenthesesCount;
          break;

        case Grammar::BeginGroup: /* also BeginFunctionCall */
          --parenthesesCount;

          if (parenthesesCount == -1)
            done = true;
          break;

        case Grammar::EndIndex:
          ++bracketsCount;
          break;

        case Grammar::BeginIndex:
          --bracketsCount;

          if (bracketsCount == -1)
            done = true;
          break;

        default:
          if (parenthesesCount == 0 && bracketsCount == 0)
          {
            done = true;
          }
          break;
      }

      if (done)
        break;

      --i;
    }

    size_t start = i + 1;

    for (size_t j = start; j <= end; ++j)
    {
      expressionTokens.push_back(tokens[j]);
    }
    
    if (expressionTokens.empty())
    {
      return;
    }
    
    
    Array<UserToken> functionTokens;
    Array<UserToken> classTokensWithoutFunction;
    {
      int functionStart = -1;
      int functionKeywordStart = -1;
      int functionEnd = -1;
      for (int j = (int)closestTokenIndex; j >= 0 && functionStart == -1; --j)
      {
        UserToken& token = tokens[j];

        switch (token.TokenId)
        {
          case Grammar::Get:
          case Grammar::Set:
          case Grammar::Function:
          case Grammar::Constructor:
          case Grammar::Destructor:
            functionStart = j;
            functionKeywordStart = j;
            break;
        }
      }

      if (functionStart != -1)
      {
        size_t attributeBracketCount = 0;
        
        // Parse backwards and look for attributes above the function
        int attributeStart = functionStart - 1;
        if (attributeStart >= 0 && tokens[attributeStart].TokenId == Grammar::EndAttribute)
        {
          for (int j = attributeStart; j >= 0; --j)
          {
            UserToken& token = tokens[j];
            if (token.TokenId == Grammar::EndAttribute)
            {
              ++attributeBracketCount;
            }
            else if (token.TokenId == Grammar::BeginAttribute)
            {
              --attributeBracketCount;
            }

            if (attributeBracketCount <= 0)
            {
              functionStart = j;
              break;
            }
          }
        }

        size_t scopeCount = 0;

        for (int j = functionKeywordStart; j < (int)tokens.size(); ++j)
        {
          UserToken& token = tokens[j];

          if (token.TokenId == Grammar::BeginScope)
          {
            ++scopeCount;
          }
          else if (token.TokenId == Grammar::EndScope)
          {
            --scopeCount;

            if (scopeCount == 0)
            {
              functionEnd = j;
              break;
            }
          }
          else if (j != functionKeywordStart && 
                   (token.TokenId == Grammar::Function    ||
                    token.TokenId == Grammar::Constructor ||
                    token.TokenId == Grammar::Destructor  ||
                    token.TokenId == Grammar::Get         ||
                    token.TokenId == Grammar::Set         ||
                    token.TokenId == Grammar::Class       ||
                    token.TokenId == Grammar::Struct))
          {
            functionEnd = j - 1;
            break;
          }
        }
      }

      if (functionEnd != -1 && functionEnd > functionStart)
      {
        for (int j = functionStart; j <= functionEnd; ++j)
        {
          UserToken& token = tokens[j];
          functionTokens.push_back(token);
        }

        // Lets handle getting all the class tokens (without this function inside)
        {
          int classStart = -1;
          int classEnd = -1;

          for (int j = functionStart; j >= 0; --j)
          {
            UserToken& token = tokens[j];

            if (token.TokenId == Grammar::Class || token.TokenId == Grammar::Struct)
            {
              classStart = j;
              break;
            }
          }

          if (classStart != -1)
          {
            size_t scopeCount = 0;

            for (int j = classStart; j < (int)tokens.size(); ++j)
            {
              UserToken& token = tokens[j];

              if (token.TokenId == Grammar::BeginScope)
              {
                ++scopeCount;
              }
              else if (token.TokenId == Grammar::EndScope)
              {
                --scopeCount;

                if (scopeCount == 0)
                {
                  classEnd = j;
                  break;
                }
              }
              else if (j != classStart && (token.TokenId == Grammar::Class || token.TokenId == Grammar::Struct))
              {
                functionEnd = j - 1;
                break;
              }
            }
          }

          if (classEnd != -1 && classEnd > classStart)
          {
            for (int j = classStart; j <= classEnd; ++j)
            {
              // If we're not within the function...
              if (j < functionStart || j > functionEnd)
              {
                UserToken& token = tokens[j];
                classTokensWithoutFunction.push_back(token);
              }
            }
          }
        }
      }
    }

    Tokenizer tokenizer(*this);
    tokenizer.Finalize(expressionTokens);
    tokenizer.Finalize(functionTokens);
    tokenizer.Finalize(classTokensWithoutFunction);

    // The syntax tree holds a more intuitive representation of the parsed program and is easy to traverse
    SyntaxTree syntaxTree;

    // We're about to generate a library so we need a builder
    LibraryBuilder builder("CodeCompletion");

    // Loads plugins into the library builder
    this->LoadPlugins(builder, dependencies);

    // The parser parses the list of tokens into a syntax tree
    Parser parser(*this);
    
    // Apply the parser to the token stream, which should output a syntax tree!
    parser.ParseExpressionInFunctionAndClass(expressionTokens, functionTokens, classTokensWithoutFunction, syntaxTree);

    // The syntaxer holds information about all the internal and parsed types
    // It is also responsible for checking syntax for things like scope, etc
    Syntaxer syntaxer(*this);

    // We need to check if we actually parsed an expression
    ScopeNode* singleExpressionScope = syntaxTree.SingleExpressionScope;
    size_t singleExpressionIndex = syntaxTree.SingleExpressionIndex;
    if (singleExpressionScope != nullptr && singleExpressionIndex != (size_t)-1)
    {
      // Make sure to attach all the comments we parsed to
      // any nodes, so we can collect them for documentation
      this->AttachCommentsToNodes(syntaxTree, comments);

      // After the tree is generated, the child to parent pointers are not set so do that now
      // These can get used if anyone wants to traverse the tree upward
      SyntaxNode::FixParentPointers(syntaxTree.Root, nullptr);

      // Collect all the types, assign types where they are needed, and perform syntax checking
      syntaxer.ApplyToTree(syntaxTree, builder, *this, dependencies);

      // Fix up any parent pointers (in case anything gets moved around)
      // This may be unnecessary... but we'd still like to do it
      SyntaxNode::FixParentPointers(syntaxTree.Root, nullptr);

      if (singleExpressionIndex < singleExpressionScope->Statements.size())
      {
        // Grab the statements from the scope (it should be an expression...)
        StatementNode* singleStatement = singleExpressionScope->Statements[singleExpressionIndex];

        // Cast the statement into the expression that we're looking for, it should be the right one
        ExpressionNode* singleExpression = TypeBinding::DynamicCast<ExpressionNode*>(singleStatement);
        if (singleExpression != nullptr)
        {
          // The result type may be null if it was unable to resolve... return whatever we found
          resultOut.NearestType = singleExpression->ResultType;

          // Create the library so it will keep references to types
          resultOut.IncompleteLibrary = builder.CreateLibrary();

          // If the value we're accessing is a value node, then it's a literal
          resultOut.IsLiteral = (TypeBinding::DynamicCast<ValueNode*>(singleExpression) != nullptr);

          // Look to see if we're accessing a single function or a bunch of overloads
          const FunctionArray* overloads = nullptr;
          Function* singleFunction = nullptr;

          // If the expression is a member access...
          if (MemberAccessNode* memberAccess = TypeBinding::DynamicCast<MemberAccessNode*>(singleExpression))
          {
            overloads = memberAccess->OverloadedFunctions;
            singleFunction = memberAccess->AccessedFunction;
          }
          // If this is a creation call, we also want to pull out constructor overloads
          else if (StaticTypeNode* staticType = TypeBinding::DynamicCast<StaticTypeNode*>(singleExpression))
          {
            resultOut.IsStatic = true;
            overloads = staticType->OverloadedConstructors;
            singleFunction = staticType->ConstructorFunction;
          }

          // If we resolved to an overload group... (but did not pick one yet)
          if (overloads != nullptr)
          {
            // Also let the user know what the overloads are
            resultOut.FunctionOverloads = *overloads;
          }
          // If we just resolved a single function...
          else if (singleFunction != nullptr)
          {
            // Add the single function (so that the user can get more documentation from it)
            resultOut.FunctionOverloads.push_back(singleFunction);
          }
        }
      }
    }
    else
    {
      // We might have been trying to access a static property/function/variable on a class
      SyntaxType* syntaxType = parser.ParseType(expressionTokens);
      
      // We may have parsed a syntax type, but we still need to resolve it into a real type
      if (syntaxType != nullptr)
      {
        resultOut.IsStatic = true;
        resultOut.NearestType = syntaxer.RetrieveType(syntaxType, expressionTokens.front().Location, dependencies);
        delete syntaxType;
      }
    }
  }
}
/**************************************************************\
* Author: Joshua Davis
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/






namespace Zilch
{
  //***************************************************************************
  ZilchDefineType(Random, "Random", Core, builder, type)
  {
    ZilchBindConstructor(builder, type, Random, nullptr, uint);
    ZilchBindConstructor(builder, type, Random, nullptr);
    ZilchBindDestructor(builder, type, Random);

    // Change to a property later
    ZilchBindProperty(builder, type, &Random::GetSeed, &Random::SetSeed, "Seed");
    ZilchBindProperty(builder, type, &Random::GetMaxInteger, nullptr, "MaxInteger");

    // Basic type randoms
    ZilchBindMethod(builder, type, &Random::Boolean,    ZilchNoOverload, "Boolean",    nullptr);
    ZilchBindMethod(builder, type, &Random::Integer,    ZilchNoOverload, "Integer",    nullptr);
    ZilchBindMethod(builder, type, &Random::Real,       ZilchNoOverload, "Real",       nullptr);
    ZilchBindMethod(builder, type, &Random::UnitReal2,  ZilchNoOverload, "UnitReal2",  nullptr);
    ZilchBindMethod(builder, type, &Random::Real2,      ZilchNoOverload, "Real2",      "minLength, maxLength");
    ZilchBindMethod(builder, type, &Random::UnitReal3,  ZilchNoOverload, "UnitReal3",  nullptr);
    ZilchBindMethod(builder, type, &Random::Real3,      ZilchNoOverload, "Real3",      "minLength, maxLength");
    ZilchBindMethod(builder, type, &Random::Quaternion, ZilchNoOverload, "Quaternion", nullptr);

    // Range/variance helpers
    ZilchBindMethod(builder, type, &Random::RangeInclusiveMax, ZilchNoOverload, "RangeInclusiveMax", "min, max");
    ZilchBindMethod(builder, type, &Random::RangeExclusiveMax, ZilchNoOverload, "RangeExclusiveMax", "min, max");
    ZilchBindMethod(builder, type, &Random::Range, ZilchNoOverload, "Range", "min, max");
    ZilchBindMethod(builder, type, &Random::Variance, (int   (Random::*)(int,   int)),   "Variance", "baseValue, variance");
    ZilchBindMethod(builder, type, &Random::Variance, (float (Random::*)(float, float)), "Variance", "baseValue, variance");

    // Some more "user friendly" functions for designers
    ZilchBindMethod(builder, type, &Random::DieRoll,     ZilchNoOverload, "DieRoll",      nullptr);
    ZilchBindMethod(builder, type, &Random::Probability, ZilchNoOverload, "Probability",  "probabilityOfTrue");
    ZilchBindMethod(builder, type, &Random::CoinFlip,    ZilchNoOverload, "CoinFlip",     nullptr);
    ZilchBindMethod(builder, type, &Random::Rotation,    ZilchNoOverload, "Rotation",     nullptr);

    // Bell curve (Gaussian) distribution
    ZilchBindMethod(builder, type, &Random::BellCurve, (float (Random::*)()),                    "BellCurve", nullptr);
    ZilchBindMethod(builder, type, &Random::BellCurve, (float (Random::*)(float, float)),        "BellCurve", "center, range");
    ZilchBindMethod(builder, type, &Random::BellCurve, (float (Random::*)(float, float, float)), "BellCurve", "center, range, standardDeviation");
  }

  //***************************************************************************
  Random::Random()
  {
    this->OriginalSeed = this->Generator.mSeed;
  }
  
  //***************************************************************************
  Random::Random(uint seed) :
    Generator(seed)
  {
    this->OriginalSeed = seed;
  }
  
  //***************************************************************************
  void Random::SetSeed(uint seed)
  {
    this->Generator = Math::Random(seed);
    this->OriginalSeed = seed;
  }
  
  //***************************************************************************
  uint Random::GetSeed()
  {
    return this->OriginalSeed;
  }
  
  //***************************************************************************
  int Random::GetMaxInteger()
  {
    return Math::Random::cRandMax;
  }
  
  //***************************************************************************
  bool Random::Boolean()
  {
    return this->Generator.IntRangeInIn(0, 1) == 1;
  }
  
  //***************************************************************************
  int Random::Integer()
  {
    return this->Generator.Next();
  }
  
  //***************************************************************************
  float Random::Real()
  {
    return this->Generator.Float();
  }
  
  //***************************************************************************
  Math::Vector2 Random::UnitReal2()
  {
    return this->Generator.PointOnUnitCircle();
  }
  
  //***************************************************************************
  Math::Vector2 Random::Real2(float minLength, float maxLength)
  {
    return this->Generator.ScaledVector2(minLength, maxLength);
  }
  
  //***************************************************************************
  Math::Vector3 Random::UnitReal3()
  {
    return this->Generator.PointOnUnitSphere();
  }
  
  //***************************************************************************
  Math::Vector3 Random::Real3(float minLength, float maxLength)
  {
    return this->Generator.ScaledVector3(minLength, maxLength);
  }
  
  //***************************************************************************
  Zilch::Quaternion Random::Quaternion()
  {
    return this->Generator.RotationQuaternion();
  }
  
  //***************************************************************************
  int Random::RangeInclusiveMax(int min, int max)
  {
    return this->Generator.IntRangeInIn(min, max);
  }
  
  //***************************************************************************
  int Random::RangeExclusiveMax(int min, int max)
  {
    return this->Generator.IntRangeInEx(min, max);
  }
  
  //***************************************************************************
  int Random::Variance(int base, int variance)
  {
    return this->Generator.IntVariance(base, variance);
  }
  
  //***************************************************************************
  float Random::Range(float min, float max)
  {
    return this->Generator.FloatRange(min, max);
  }
  
  //***************************************************************************
  float Random::Variance(float base, float variance)
  {
    return this->Generator.FloatVariance(base, variance);
  }
  
  //***************************************************************************
  uint Random::DieRoll(uint sides)
  {
    return this->Generator.DieRoll(sides);
  }
  
  //***************************************************************************
  bool Random::Probability(float probOfTrue)
  {
    return this->Generator.Float() < probOfTrue;
  }
  
  //***************************************************************************
  bool Random::CoinFlip()
  {
    return this->Generator.IntRangeInIn(0, 1) == 1;
  }
  
  //***************************************************************************
  Zilch::Quaternion Random::Rotation()
  {
    return this->Generator.RotationQuaternion();
  }
  
  //***************************************************************************
  float Random::BellCurve()
  {
    return this->Generator.BellCurve(0.5f, 0.5f, 1.0f);
  }
  
  //***************************************************************************
  float Random::BellCurve(float center, float range)
  {
    return this->Generator.BellCurve(center, range, 1.0f);
  }
  
  //***************************************************************************
  float Random::BellCurve(float center, float range, float standardDeviation)
  {
    return this->Generator.BellCurve(center, range, standardDeviation);
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Note: This code is based on Steve Reid's 100% Public Domain Sha1 implementation (thank you Steve!)

// Includes



namespace Zilch
{
  //***************************************************************************
  Sha1Builder::Sha1Builder()
  {
    // SHA1 initialization constants
    this->State[0] = 0x67452301;
    this->State[1] = 0xEFCDAB89;
    this->State[2] = 0x98BADCFE;
    this->State[3] = 0x10325476;
    this->State[4] = 0xC3D2E1F0;
    this->Count[0] = 0;
    this->Count[1] = 0;
  }

  //***************************************************************************
  void Sha1Builder::RunUnitTests()
  {
    const char* inputs[] =
    {
      "abc",
      "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
      "A million repetitions of 'a'"
    };

    const char* outputs[] =
    {
      "A9993E364706816ABA3E25717850C26C9CD0D89D",
      "84983E441C3BD26EBAAE4AA1F95129E5E54670F1",
      "34AA973CD4C4DAA4F61EEB2BDBAD27316534016F"
    };

    const size_t NumTests = sizeof(inputs) / sizeof(const char*);

    for (size_t i = 0; i < NumTests; ++i)
    {
      const char* input = inputs[i];
      const char* expectedOutput = outputs[i];

      Sha1Builder builder;

      // Special case test for test #3 (which is index 2)
      if (i == 2)
      {
        for (size_t i = 0; i < 1000000; ++i)
          builder.Append("a");
      }
      else
      {
        builder.Append(input);
      }
      String result = builder.OutputHashString();

      ErrorIf(result != expectedOutput, "The Sha1Builder returned an incorrect hash");
    }
  }

  //***************************************************************************
  #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

  /* blk0() and blk() perform the initial expand. */
  /* I got the idea of expanding during the round function from SSLeay */
  /* FIXME: can we do this in an endian-proof way? */
  #ifdef WORDS_BIGENDIAN
  #define blk0(i) block->l[i]
  #else
  #define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
      |(rol(block->l[i],8)&0x00FF00FF))
  #endif
  #define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
      ^block->l[(i+2)&15]^block->l[i&15],1))

  /* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
  #define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
  #define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
  #define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
  #define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
  #define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);

  //***************************************************************************
  // Hash a single 512-bit block (this is the core of the algorithm)
  void Sha1BuilderTransform(u32 state[5], const byte buffer[64])
  {
    u32 a, b, c, d, e;
    typedef union
    {
      byte c[64];
      u32 l[16];
    }
    CHAR64LONG16;
    CHAR64LONG16* block;

    block = (CHAR64LONG16*)buffer;

    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];

    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);

    /* Add the working vars back into context.state[] */
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;

    /* Wipe variables */
    a = b = c = d = e = 0;
  }
  
  //***************************************************************************
  void Sha1Builder::Append(const byte* data, size_t length)
  {
    size_t i, j;

    j = (this->Count[0] >> 3) & 63;
    if ((this->Count[0] += (u32)(length << 3)) < (length << 3))
      this->Count[1]++;
    this->Count[1] += (u32)(length >> 29);

    if ((j + length) > 63)
    {
      memcpy(&this->Buffer[j], data, (i = 64-j));
      Sha1BuilderTransform(this->State, this->Buffer);
      for (; i + 63 < length; i += 64)
      {
        Sha1BuilderTransform(this->State, data + i);
      }

      j = 0;
    }
    else
    {
      i = 0;
    }

    memcpy(&this->Buffer[j], &data[i], length - i);
  }
  
  //***************************************************************************
  void Sha1Builder::Append(StringRange data)
  {
    this->Append((byte*)data.begin, data.size());
  }
  
  //***************************************************************************
  bool Sha1Builder::Append(File& file)
  {
    // If the file isn't valid, early out
    if (file.IsOpen() == false)
      return false;

    // Read all the contents of the file chunk by chunk, running Sha1 on each chunk
    byte buffer[4096] = {0};
    ZilchLoop
    {
      size_t dataRead = file.Read(buffer, sizeof(buffer));
      this->Append(buffer, dataRead);

      if (dataRead != sizeof(buffer))
        break;
    }

    return true;
  }
  
  //***************************************************************************
  void Sha1Builder::OutputHash(byte* hashOut)
  {
    // Make a temporary copy of the builder
    Sha1Builder copy = *this;

    u32 i;
    byte finalcount[8];

    for (i = 0; i < 8; i++)
    {
      // Endian independent
      finalcount[i] = (unsigned char)((this->Count[(i >= 4 ? 0 : 1)] >> ((3-(i & 3)) * 8) ) & 255);
    }

    this->Append((const byte*)"\200", 1);

    while ((this->Count[0] & 504) != 448)
    {
      this->Append((const byte*)"\0", 1);
    }

    // Should cause a Sha1BuilderTransform()
    this->Append(finalcount, 8);

    for (i = 0; i < Sha1Builder::Sha1ByteSize; i++)
    {
      hashOut[i] = (byte)((this->State[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
    }

    // Return everything to its original state
    *this = copy;
  }
  
  //***************************************************************************
  void Sha1Builder::OutputHash(Array<byte>& hashOut)
  {
    hashOut.resize(Sha1Builder::Sha1ByteSize);
    this->OutputHash(hashOut.data());
  }
  
  //***************************************************************************
  String Sha1Builder::OutputHashString()
  {
    byte hash[Sha1ByteSize] = {0};
    this->OutputHash(hash);

    // Turn the SHA1 into a hex string
    char hexedSha1[Sha1ByteSize * 2 + 1] = {0};
    for (size_t i = 0; i < Sha1ByteSize; ++i)
    {
      ZeroSPrintf(hexedSha1 + 2 * i, 3, "%02X", hash[i]);
    }

    return String(hexedSha1, sizeof(hexedSha1) - 1);
  }
  
  //***************************************************************************
  String Sha1Builder::GetHashString(StringRange data)
  {
    Sha1Builder builder;
    builder.Append(data);
    return builder.OutputHashString();
  }
  
  //***************************************************************************
  String Sha1Builder::GetHashString(File& file)
  {
    Sha1Builder builder;
    builder.Append(file);
    return builder.OutputHashString();
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes






namespace Zilch
{
  //***************************************************************************
  // Operator Precedence:
  // Left to right:
  //  0. As
  //     BeginFunctionCall & EndFunctionCall
  //     BeginIndex & EndIndex
  //     Access
  // Right to left:
  //  1. Positive
  //     Negative
  //     Increment
  //     Decrement
  //     LogicalNot
  //     BitwiseNot
  //     PropertyDelegate
  // Left to right:
  //  2. Exponent
  //  3. Multiply
  //     Divide
  //     Modulo
  //  4. Add
  //     Subtract
  //  5. BitshiftLeft
  //     BitshiftRight
  //  6. LessThan
  //     LessThanOrEqualTo
  //     GreaterThan
  //     GreaterThanOrEqualTo
  //  7. Equality
  //     Inequality
  //  8. BitwiseAnd
  //  9. BitwiseXor
  // 10. BitwiseOr
  // 11. LogicalAnd
  // 12. LogicalOr
  // Right to left:
  // 13. Assignment
  //     AssignmentAdd
  //     AssignmentSubtract
  //     AssignmentMultiply
  //     AssignmentDivide
  //     AssignmentModulo
  //     AssignmentExponent
  //     AssignmentLeftShift
  //     AssignmentRightShift
  //     AssignmentBitwiseAnd
  //     AssignmentBitwiseXor
  //     AssignmentBitwiseOr

  //***************************************************************************
  BinaryOperator::BinaryOperator() :
    IsValid(false),
    Lhs(nullptr),
    Rhs(nullptr),
    Result(nullptr),
    Operator(Grammar::Invalid),
    Instruction(Instruction::InvalidInstruction),
    FlipArguments(false),
    Io(IoMode::NotSet),
    CastLhsTo(nullptr),
    CastRhsTo(nullptr)
  {
  }

  //***************************************************************************
  size_t BinaryOperator::Hash() const
  {
    // Start off with a cleared out hash
    size_t result = 0;

    // Hash both the left and right (add a random prime because they could be the same)
    result ^= (size_t)(this->Lhs->Hash());
    result ^= (size_t)(this->Rhs->Hash() * 1276478784635841471);

    // Now hash the operator and include that 
    result ^= (size_t)(this->Operator * 5463458053);

    // Return the resulting hash
    return result;
  }

  //***************************************************************************
  bool BinaryOperator::operator==(const BinaryOperator& rhs) const
  {
    // Compare the operators
    if (this->Operator != rhs.Operator)
      return false;

    // Compare the left and right operands
    return (this->Lhs == rhs.Lhs) && (this->Rhs == rhs.Rhs);
  }


  //***************************************************************************
  UnaryOperator::UnaryOperator() :
    IsValid(false),
    Operand(nullptr),
    Result(nullptr),
    Operator(Grammar::Invalid),
    Instruction(Instruction::InvalidInstruction),
    Io(IoMode::NotSet)
  {
  }

  //***************************************************************************
  size_t UnaryOperator::Hash() const
  {
    // Start off with a cleared out hash
    size_t result = 0;

    // Hash the operand and add that to the result
    result ^= (size_t)this->Operand->Hash();

    // Now hash the operator and include that 
    result ^= (size_t)(this->Operator * 5463458053);

    // Return the resulting hash
    return result;
  }

  //***************************************************************************
  bool UnaryOperator::operator==(const UnaryOperator& rhs) const
  {
    // Compare the operators
    if (this->Operator != rhs.Operator)
      return false;

    // Compare the operands
    return this->Operand == rhs.Operand;
  }

  //***************************************************************************
  UntypedOperator::UntypedOperator() :
    IsValid(false),
    Operator(Grammar::Invalid),
    Precedence(0),
    Associativity(OperatorAssociativity::LeftToRight)
  {
  }

  //***************************************************************************
  CastOperator::CastOperator() :
    IsValid(false),
    From(nullptr),
    To(nullptr),
    Operation(CastOperation::Invalid),
    PrimitiveInstruction(Instruction::InvalidInstruction),
    CanBeImplicit(false),
    RequiresCodeGeneration(false)
  {
  }

  //***************************************************************************
  size_t CastOperator::Hash() const
  {
    return (size_t)(this->From->Hash() ^ this->To->Hash() * 33679033);
  }

  //***************************************************************************
  bool CastOperator::operator==(const CastOperator& rhs) const
  {
    return this->From == rhs.From && this->To == rhs.To;
  }

  //***************************************************************************
  Shared::Shared()
  {
    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // Reserve room for operators
    this->PrecedenceToOperators.reserve(32);
    
    // Add all generic information about operator precedence and associativity
    size_t precedence = 1;
    OperatorAssociativity::Enum associativity = OperatorAssociativity::LeftToRight;
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::BeginFunctionCall);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::EndFunctionCall);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::BeginIndex);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::EndIndex);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Access);
    precedence = 2;
    associativity = OperatorAssociativity::RightToLeft;
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::Positive);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::Negative);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::Increment);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::Decrement);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::LogicalNot);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::BitwiseNot);
    this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::PropertyDelegate);
    precedence = 3;
    associativity = OperatorAssociativity::LeftToRight;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Exponent);
    precedence = 4;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Multiply);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Divide);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Modulo);
    precedence = 5;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Add);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Subtract);
    precedence = 6;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitshiftLeft);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitshiftRight);
    precedence = 7;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::LessThan);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::LessThanOrEqualTo);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::GreaterThan);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::GreaterThanOrEqualTo);
    precedence = 8;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Equality);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Inequality);
    precedence = 9;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitwiseAnd);
    precedence = 10;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitwiseXor);
    precedence = 11;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitwiseOr);
    precedence = 12;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::LogicalAnd);
    precedence = 13;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::LogicalOr);
    precedence = 14;
    associativity = OperatorAssociativity::RightToLeft;
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Assignment);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentAdd);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentSubtract);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentMultiply);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentDivide);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentModulo);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentExponent);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentLeftShift);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentRightShift);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentBitwiseAnd);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentBitwiseXor);
    this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentBitwiseOr);

    // HandleAssignment
    {
      BinaryOperator& info = this->HandleAssignment;
      info.Result = core.VoidType;
      info.Operator = Grammar::Assignment;
      info.Instruction = Instruction::CopyHandle;
      info.Io = IoMode::WriteLValue;
      info.IsValid = true;
    }
    // HandleEquality
    {
      BinaryOperator& info = this->HandleEquality;
      info.Result = core.BooleanType;
      info.Operator = Grammar::Equality;
      info.Instruction = Instruction::TestEqualityHandle;
      info.Io = IoMode::ReadRValue;
      info.IsValid = true;
    }
    // HandleInequality
    {
      BinaryOperator& info = this->HandleInequality;
      info.Result = core.BooleanType;
      info.Operator = Grammar::Inequality;
      info.Instruction = Instruction::TestInequalityHandle;
      info.Io = IoMode::ReadRValue;
      info.IsValid = true;
    }
    // DelegateAssignment
    {
      BinaryOperator& info = this->DelegateAssignment;
      info.Result = core.VoidType;
      info.Operator = Grammar::Assignment;
      info.Instruction = Instruction::CopyDelegate;
      info.Io = IoMode::WriteLValue;
      info.IsValid = true;
    }
    // DelegateEquality
    {
      BinaryOperator& info = this->DelegateEquality;
      info.Result = core.BooleanType;
      info.Operator = Grammar::Equality;
      info.Instruction = Instruction::TestEqualityDelegate;
      info.Io = IoMode::ReadRValue;
      info.IsValid = true;
    }
    // DelegateInequality
    {
      BinaryOperator& info = this->DelegateInequality;
      info.Result = core.BooleanType;
      info.Operator = Grammar::Inequality;
      info.Instruction = Instruction::TestInequalityDelegate;
      info.Io = IoMode::ReadRValue;
      info.IsValid = true;
    }
    // AnyAssignment
    {
      BinaryOperator& info = this->AnyAssignment;
      info.Result = core.VoidType;
      info.Operator = Grammar::Assignment;
      info.Instruction = Instruction::CopyAny;
      info.Io = IoMode::WriteLValue;
      info.IsValid = true;
    }
    // AnyEquality
    {
      BinaryOperator& info = this->AnyEquality;
      info.Result = core.BooleanType;
      info.Operator = Grammar::Equality;
      info.Instruction = Instruction::TestEqualityAny;
      info.Io = IoMode::ReadRValue;
      info.IsValid = true;
    }
    // AnyInequality
    {
      BinaryOperator& info = this->AnyInequality;
      info.Result = core.BooleanType;
      info.Operator = Grammar::Inequality;
      info.Instruction = Instruction::TestInequalityAny;
      info.Io = IoMode::ReadRValue;
      info.IsValid = true;
    }
    // ValueAssignment
    {
      BinaryOperator& info = this->ValueAssignment;
      info.Result = core.VoidType;
      info.Operator = Grammar::Assignment;
      info.Instruction = Instruction::CopyValue;
      info.Io = IoMode::WriteLValue;
      info.IsValid = true;
    }
    // ValueEquality
    {
      BinaryOperator& info = this->ValueEquality;
      info.Result = core.BooleanType;
      info.Operator = Grammar::Equality;
      info.Instruction = Instruction::TestEqualityValue;
      info.Io = IoMode::ReadRValue;
      info.IsValid = true;
    }
    // ValueInequality
    {
      BinaryOperator& info = this->ValueInequality;
      info.Result = core.BooleanType;
      info.Operator = Grammar::Inequality;
      info.Instruction = Instruction::TestInequalityValue;
      info.Io = IoMode::ReadRValue;
      info.IsValid = true;
    }
    
    // RawImplicitCast, (same-cast, up-cast, null-cast, any-delegate-cast)
    {
      CastOperator& info = this->RawImplicitCast;
      info.Operation = CastOperation::Raw;
      info.CanBeImplicit = true;
      info.RequiresCodeGeneration = false;
      info.IsValid = true;
    }
    // DynamicDownCast
    {
      CastOperator& info = this->DynamicDownCast;
      info.Operation = CastOperation::DynamicDown;
      info.CanBeImplicit = false;
      info.RequiresCodeGeneration = true;
      info.IsValid = true;
    }
    // ToAnyCast
    {
      CastOperator& info = this->ToAnyCast;
      info.Operation = CastOperation::ToAny;
      info.CanBeImplicit = true;
      info.RequiresCodeGeneration = true;
      info.IsValid = true;
    }
    // FromAnyCast
    {
      CastOperator& info = this->FromAnyCast;
      info.Operation = CastOperation::FromAny;
      info.CanBeImplicit = true;
      info.RequiresCodeGeneration = true;
      info.IsValid = true;
    }
    // EnumIntegerCast
    {
      CastOperator& info = this->EnumIntegerCast;
      info.Operation = CastOperation::Raw;
      info.CanBeImplicit = true;
      info.RequiresCodeGeneration = false;
      info.IsValid = true;
    }
    // IntegerEnumCast
    {
      CastOperator& info = this->IntegerEnumCast;
      info.Operation = CastOperation::Raw;
      info.CanBeImplicit = false;
      info.RequiresCodeGeneration = false;
      info.IsValid = true;
    }
    // NullToDelegate
    {
      CastOperator& info = this->NullToDelegate;
      info.Operation = CastOperation::NullToDelegate;
      info.CanBeImplicit = true;
      info.RequiresCodeGeneration = false;
      info.IsValid = true;
      //this->CastOperatorsFrom[core.NullType].push_back(info);
    }

    // Handle our built in primitive casts
    // The 1-dimensional cases
    this->AddPrimitiveCast(core.ByteType,           core.RealType,          Instruction::ConvertByteToReal,                 true );
    this->AddPrimitiveCast(core.ByteType,           core.BooleanType,       Instruction::ConvertByteToBoolean,              false);
    this->AddPrimitiveCast(core.ByteType,           core.IntegerType,       Instruction::ConvertByteToInteger,              true );
    this->AddPrimitiveCast(core.ByteType,           core.DoubleIntegerType, Instruction::ConvertByteToDoubleInteger,        true );
    this->AddPrimitiveCast(core.ByteType,           core.DoubleRealType,    Instruction::ConvertByteToDoubleReal,           true );

    this->AddPrimitiveCast(core.IntegerType,        core.RealType,          Instruction::ConvertIntegerToReal,              true );
    this->AddPrimitiveCast(core.IntegerType,        core.BooleanType,       Instruction::ConvertIntegerToBoolean,           false);
    this->AddPrimitiveCast(core.IntegerType,        core.ByteType,          Instruction::ConvertIntegerToByte,              false);
    this->AddPrimitiveCast(core.IntegerType,        core.DoubleIntegerType, Instruction::ConvertIntegerToDoubleInteger,     true );
    this->AddPrimitiveCast(core.IntegerType,        core.DoubleRealType,    Instruction::ConvertIntegerToDoubleReal,        true );
    this->AddPrimitiveCast(core.RealType,           core.IntegerType,       Instruction::ConvertRealToInteger,              false);
    this->AddPrimitiveCast(core.RealType,           core.BooleanType,       Instruction::ConvertRealToBoolean,              false);
    this->AddPrimitiveCast(core.RealType,           core.ByteType,          Instruction::ConvertRealToByte,                 false);
    this->AddPrimitiveCast(core.RealType,           core.DoubleIntegerType, Instruction::ConvertRealToDoubleInteger,        false);
    this->AddPrimitiveCast(core.RealType,           core.DoubleRealType,    Instruction::ConvertRealToDoubleReal,           true );
    this->AddPrimitiveCast(core.BooleanType,        core.IntegerType,       Instruction::ConvertBooleanToInteger,           false);
    this->AddPrimitiveCast(core.BooleanType,        core.RealType,          Instruction::ConvertBooleanToReal,              false);
    this->AddPrimitiveCast(core.BooleanType,        core.ByteType,          Instruction::ConvertBooleanToByte,              false);
    this->AddPrimitiveCast(core.BooleanType,        core.DoubleIntegerType, Instruction::ConvertBooleanToDoubleInteger,     false);
    this->AddPrimitiveCast(core.BooleanType,        core.DoubleRealType,    Instruction::ConvertBooleanToDoubleReal,        false);
    this->AddPrimitiveCast(core.DoubleIntegerType,  core.RealType,          Instruction::ConvertDoubleIntegerToReal,        false);
    this->AddPrimitiveCast(core.DoubleIntegerType,  core.BooleanType,       Instruction::ConvertDoubleIntegerToBoolean,     false);
    this->AddPrimitiveCast(core.DoubleIntegerType,  core.ByteType,          Instruction::ConvertDoubleIntegerToByte,        false);
    this->AddPrimitiveCast(core.DoubleIntegerType,  core.IntegerType,       Instruction::ConvertDoubleIntegerToInteger,     false);
    this->AddPrimitiveCast(core.DoubleIntegerType,  core.DoubleRealType,    Instruction::ConvertDoubleIntegerToDoubleReal,  true );
    this->AddPrimitiveCast(core.DoubleRealType,     core.RealType,          Instruction::ConvertDoubleRealToReal,           false);
    this->AddPrimitiveCast(core.DoubleRealType,     core.BooleanType,       Instruction::ConvertDoubleRealToBoolean,        false);
    this->AddPrimitiveCast(core.DoubleRealType,     core.ByteType,          Instruction::ConvertDoubleRealToByte,           false);
    this->AddPrimitiveCast(core.DoubleRealType,     core.IntegerType,       Instruction::ConvertDoubleRealToInteger,        false);
    this->AddPrimitiveCast(core.DoubleRealType,     core.DoubleIntegerType, Instruction::ConvertDoubleRealToDoubleInteger,  false);

    // The 2-dimensional cases
    this->AddPrimitiveCast(core.Integer2Type,  core.Real2Type,    Instruction::ConvertInteger2ToReal2,    true);
    this->AddPrimitiveCast(core.Integer2Type,  core.Boolean2Type, Instruction::ConvertInteger2ToBoolean2, false);
    this->AddPrimitiveCast(core.Real2Type,     core.Integer2Type, Instruction::ConvertReal2ToInteger2,    false);
    this->AddPrimitiveCast(core.Real2Type,     core.Boolean2Type, Instruction::ConvertReal2ToBoolean2,    false);
    this->AddPrimitiveCast(core.Boolean2Type,  core.Integer2Type, Instruction::ConvertBoolean2ToInteger2, false);
    this->AddPrimitiveCast(core.Boolean2Type,  core.Real2Type,    Instruction::ConvertBoolean2ToReal2,    false);

    // The 3-dimensional cases
    this->AddPrimitiveCast(core.Integer3Type,  core.Real3Type,    Instruction::ConvertInteger3ToReal3,    true);
    this->AddPrimitiveCast(core.Integer3Type,  core.Boolean3Type, Instruction::ConvertInteger3ToBoolean3, false);
    this->AddPrimitiveCast(core.Real3Type,     core.Integer3Type, Instruction::ConvertReal3ToInteger3,    false);
    this->AddPrimitiveCast(core.Real3Type,     core.Boolean3Type, Instruction::ConvertReal3ToBoolean3,    false);
    this->AddPrimitiveCast(core.Boolean3Type,  core.Integer3Type, Instruction::ConvertBoolean3ToInteger3, false);
    this->AddPrimitiveCast(core.Boolean3Type,  core.Real3Type,    Instruction::ConvertBoolean3ToReal3,    false);

    // The 4-dimensional cases
    this->AddPrimitiveCast(core.Integer4Type,  core.Real4Type,    Instruction::ConvertInteger4ToReal4,    true);
    this->AddPrimitiveCast(core.Integer4Type,  core.Boolean4Type, Instruction::ConvertInteger4ToBoolean4, false);
    this->AddPrimitiveCast(core.Real4Type,     core.Integer4Type, Instruction::ConvertReal4ToInteger4,    false);
    this->AddPrimitiveCast(core.Real4Type,     core.Boolean4Type, Instruction::ConvertReal4ToBoolean4,    false);
    this->AddPrimitiveCast(core.Boolean4Type,  core.Integer4Type, Instruction::ConvertBoolean4ToInteger4, false);
    this->AddPrimitiveCast(core.Boolean4Type,  core.Real4Type,    Instruction::ConvertBoolean4ToReal4,    false);

    // String to StringRange
    this->AddPrimitiveCast(core.StringType,  core.StringRangeType,    Instruction::ConvertStringToStringRangeExtended, true);

    // Note: These macros mirror those inside of InstructionEnum and VirtualMachine (for generation of instructions)

    // Copy
    #define ZilchCopyOperators(WithType)                                                                                                                                                                                \
      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddBinary(type, core.VoidType, Grammar::Assignment, Instruction::Copy##WithType, IoMode::WriteLValue);                                                                                                    \
      }

    // Equality and inequality
    #define ZilchEqualityOperators(WithType, ResultType)                                                                                                                                                                            \
      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddBinary(type, core.ResultType##Type, Grammar::Inequality, Instruction::TestInequality##WithType, IoMode::ReadRValue);                                                                                        \
        this->AddBinary(type, core.ResultType##Type, Grammar::Equality, Instruction::TestEquality##WithType, IoMode::ReadRValue);                                                                                            \
      }

    // Less and greater comparison
    #define ZilchComparisonOperators(WithType, ResultType)                                                                                                                                                              \
      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddBinary(type, core.ResultType##Type, Grammar::LessThan, Instruction::TestLessThan##WithType, IoMode::ReadRValue);                                                                                       \
        this->AddBinary(type, core.ResultType##Type, Grammar::LessThanOrEqualTo, Instruction::TestLessThanOrEqualTo##WithType, IoMode::ReadRValue);                                                                     \
        this->AddBinary(type, core.ResultType##Type, Grammar::GreaterThan, Instruction::TestGreaterThan##WithType, IoMode::ReadRValue);                                                                                 \
        this->AddBinary(type, core.ResultType##Type, Grammar::GreaterThanOrEqualTo, Instruction::TestGreaterThanOrEqualTo##WithType, IoMode::ReadRValue);                                                               \
      }

    // Generic numeric operators, copy, equality
    #define ZilchNumericOperators(WithType, ComparisonType)                                                                                                                                                                             \
      ZilchCopyOperators(WithType)                                                                                                                                                                                      \
      ZilchEqualityOperators(WithType, ComparisonType)                                                                                                                                                                                  \
      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddUnary(type, type, Grammar::Positive, Instruction::InvalidInstruction, IoMode::ReadRValue);                                                                                                             \
        this->AddUnary(type, type, Grammar::Negative, Instruction::Negate##WithType, IoMode::ReadRValue);                                                                                                               \
        this->AddUnary(type, core.VoidType, Grammar::Increment, Instruction::Increment##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                                            \
        this->AddUnary(type, core.VoidType, Grammar::Decrement, Instruction::Decrement##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                                            \
        this->AddBinary(type, type, Grammar::Add, Instruction::Add##WithType, IoMode::ReadRValue);                                                                                                                      \
        this->AddBinary(type, type, Grammar::Subtract, Instruction::Subtract##WithType, IoMode::ReadRValue);                                                                                                            \
        this->AddBinary(type, type, Grammar::Multiply, Instruction::Multiply##WithType, IoMode::ReadRValue);                                                                                                            \
        this->AddBinary(type, type, Grammar::Divide, Instruction::Divide##WithType, IoMode::ReadRValue);                                                                                                                \
        this->AddBinary(type, type, Grammar::Modulo, Instruction::Modulo##WithType, IoMode::ReadRValue);                                                                                                                \
        this->AddBinary(type, type, Grammar::Exponent, Instruction::Pow##WithType, IoMode::ReadRValue);                                                                                                                 \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentAdd, Instruction::AssignmentAdd##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                                   \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentSubtract, Instruction::AssignmentSubtract##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                         \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentMultiply, Instruction::AssignmentMultiply##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                         \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentDivide, Instruction::AssignmentDivide##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                             \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentModulo, Instruction::AssignmentModulo##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                             \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentExponent, Instruction::AssignmentPow##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                              \
      }

    // Generic numeric operators, copy, equality, comparison
    #define ZilchScalarOperators(WithType)                                                                                                                                                                              \
      ZilchNumericOperators(WithType, Boolean)                                                                                                                                                                          \
      ZilchComparisonOperators(WithType, Boolean)

    // Vector operations, generic numeric operators, copy, equality
    #define ZilchVectorOperators(VectorType, ScalarType, ComparisonType)                                                                                                                                                \
      ZilchNumericOperators(VectorType, Boolean)                                                                                                                                                                 \
      ZilchComparisonOperators(VectorType, ComparisonType)                                                                                                                                                              \
      {                                                                                                                                                                                                                 \
        BoundType* vectorType = core.VectorType##Type;                                                                                                                                                                  \
        BoundType* scalarType = core.ScalarType##Type;                                                                                                                                                                  \
        this->AddBinaryCommunative(vectorType, scalarType, vectorType, Grammar::Multiply, Instruction::ScalarMultiply##VectorType, IoMode::ReadRValue);                                                                 \
        this->AddBinaryNonCommunative(vectorType, scalarType, vectorType, Grammar::Divide, Instruction::ScalarDivide##VectorType, IoMode::ReadRValue);                                                                  \
        this->AddBinaryNonCommunative(vectorType, scalarType, vectorType, Grammar::Modulo, Instruction::ScalarModulo##VectorType, IoMode::ReadRValue);                                                                  \
        this->AddBinaryNonCommunative(vectorType, scalarType, vectorType, Grammar::Exponent, Instruction::ScalarPow##VectorType, IoMode::ReadRValue);                                                                   \
        this->AddBinaryNonCommunative(vectorType, scalarType, core.VoidType, Grammar::AssignmentMultiply, Instruction::AssignmentScalarMultiply##VectorType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue)); \
        this->AddBinaryNonCommunative(vectorType, scalarType, core.VoidType, Grammar::AssignmentDivide, Instruction::AssignmentScalarDivide##VectorType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));     \
        this->AddBinaryNonCommunative(vectorType, scalarType, core.VoidType, Grammar::AssignmentModulo, Instruction::AssignmentScalarModulo##VectorType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));     \
        this->AddBinaryNonCommunative(vectorType, scalarType, core.VoidType, Grammar::AssignmentExponent, Instruction::AssignmentScalarPow##VectorType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));      \
      }

    // Special integral operators, generic numeric operators, copy, equality, and comparison
    #define ZilchIntegralOperators(WithType)                                                                                                                                                                            \
      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddUnary(type, type, Grammar::BitwiseNot, Instruction::BitwiseNot##WithType, IoMode::ReadRValue);                                                                                                         \
        this->AddBinary(type, type, Grammar::BitshiftLeft, Instruction::BitshiftLeft##WithType, IoMode::ReadRValue);                                                                                                    \
        this->AddBinary(type, type, Grammar::BitshiftRight, Instruction::BitshiftRight##WithType, IoMode::ReadRValue);                                                                                                  \
        this->AddBinary(type, type, Grammar::BitwiseOr, Instruction::BitwiseOr##WithType, IoMode::ReadRValue);                                                                                                          \
        this->AddBinary(type, type, Grammar::BitwiseXor, Instruction::BitwiseXor##WithType, IoMode::ReadRValue);                                                                                                        \
        this->AddBinary(type, type, Grammar::BitwiseAnd, Instruction::BitwiseAnd##WithType, IoMode::ReadRValue);                                                                                                        \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentLeftShift, Instruction::AssignmentBitshiftLeft##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                    \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentRightShift, Instruction::AssignmentBitshiftRight##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                  \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentBitwiseOr, Instruction::AssignmentBitwiseOr##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                       \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentBitwiseXor, Instruction::AssignmentBitwiseXor##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                     \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentBitwiseAnd, Instruction::AssignmentBitwiseAnd##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                     \
      }
    
    ZilchIntegralOperators(Byte);
    ZilchScalarOperators(Byte);
    ZilchIntegralOperators(Integer);
    ZilchScalarOperators(Integer);
    ZilchVectorOperators(Integer2, Integer, Boolean2);
    ZilchVectorOperators(Integer3, Integer, Boolean3);
    ZilchVectorOperators(Integer4, Integer, Boolean4);
    ZilchIntegralOperators(Integer2);
    ZilchIntegralOperators(Integer3);
    ZilchIntegralOperators(Integer4);
    ZilchScalarOperators(Real);
    ZilchVectorOperators(Real2, Real, Boolean2);
    ZilchVectorOperators(Real3, Real, Boolean3);
    ZilchVectorOperators(Real4, Real, Boolean4);
    ZilchScalarOperators(DoubleReal);
    ZilchIntegralOperators(DoubleInteger);
    ZilchScalarOperators(DoubleInteger);

    ZilchEqualityOperators(Boolean, Boolean);
    // Handle, Delegate, and Value equality operators are handled specially above

    ZilchCopyOperators(Boolean);
    // Handle, Delegate, and Value copy (assignment) operators are handled specially above

    // Boolean operators
    this->AddUnary(core.BooleanType, core.BooleanType, Grammar::LogicalNot, Instruction::LogicalNotBoolean, IoMode::ReadRValue);

    // Note: These operators have instructions marked as invalid because short circuit is handled specially
    // There is not actually an opcode/instruction that performs logical or/and
    this->AddBinary(core.BooleanType, core.BooleanType, Grammar::LogicalAnd, Instruction::InvalidInstruction, IoMode::ReadRValue);
    this->AddBinary(core.BooleanType, core.BooleanType, Grammar::LogicalOr, Instruction::InvalidInstruction, IoMode::ReadRValue);
  }

  //***************************************************************************
  void Shared::AddBinary(Type* lhs, Type* rhs, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io, bool flip)
  {
    // Generate the operator information
    BinaryOperator info;
    info.Lhs = lhs;
    info.Rhs = rhs;
    info.Result = result;
    info.Operator = oper;
    info.Instruction = instruction;
    info.Io = io;
    info.FlipArguments = flip;
    info.IsValid = true;

    // Insert it into the set
    this->BinaryOperators.insertOrError(info, "Two unary operators inserted with the same types and operator");
  }

  //***************************************************************************
  void Shared::AddBinaryCommunative(Type* type1, Type* type2, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io)
  {
    // The arguments only need flipping if they're not of the same type
    bool needsFlip = !Type::IsSame(type1, type2);

    // Since the order they added it was type1, type2, then it needs no flip
    this->AddBinary(type1, type2, result, oper, instruction, io, false);

    // When we reverse the types, a flip could be necessary for the opcode
    this->AddBinary(type2, type1, result, oper, instruction, io, needsFlip);
  }

  //***************************************************************************
  void Shared::AddBinaryNonCommunative(Type* lhs, Type* rhs, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io)
  {
    // Since the order they added it was type1, type2, then it needs no flip
    this->AddBinary(lhs, rhs, result, oper, instruction, io, false);
  }
  
  //***************************************************************************
  void Shared::AddBinary(Type* sameType, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io)
  {
    this->AddBinary(sameType, sameType, result, oper, instruction, io, false);
  }

  //***************************************************************************
  void Shared::AddUnary(Type* operand, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io)
  {
    // Generate the operator information
    UnaryOperator info;
    info.Operand = operand;
    info.Result = result;
    info.Operator = oper;
    info.Instruction = instruction;
    info.Io = io;
    info.IsValid = true;

    // Insert it into the set
    this->UnaryOperators.insertOrError(info, "Two binary operators inserted with the same types and operator");
  }

  //***************************************************************************
  void Shared::AddPrimitiveCast(Type* fromType, Type* toType, Instruction::Enum instruction, bool canBeImplicit)
  {
    CastOperator info;
    info.From = fromType;
    info.To = toType;
    info.Operation = CastOperation::Primitive;
    info.PrimitiveInstruction = instruction;
    info.CanBeImplicit = canBeImplicit;
    info.IsValid = true;

    // All primitive operations require code generation (an instruction)
    info.RequiresCodeGeneration = true;
    
    // Insert it into the set
    this->CastOperators.insertOrError(info, "Two cast operators inserted with the same from/to types");
    this->PrimitiveCastOperatorsFrom[fromType].push_back(info);
  }

  //***************************************************************************
  void Shared::AddPrecedence(size_t precedence, OperatorAssociativity::Enum associativity, OperatorArity::Enum arity, Grammar::Enum oper)
  {
    // Create a structure that describes everything we need to know generically about the operator
    UntypedOperator info;
    info.Associativity = associativity;
    info.Operator = oper;
    info.Precedence = precedence;
    info.Arity = arity;
    info.IsValid = true;

    // It turns out since sometimes we use the same symbol for an operator,
    // but in some cases it can be unary or binary, then we need to key off the 'arity'
    OperatorWithArity key;
    key.Operator = oper;
    key.Arity = arity;

    // Map the operator to its precedence level, which is useful for code formatters
    this->OperatorToPrecedence.insertOrError(key, info, "The operator was inserted twice");

    // Map the precedence level to any operators on that level, which is useful for documentation
    if (precedence >= this->PrecedenceToOperators.size())
    {
      // Make sure we can store the precedence up to this level
      this->PrecedenceToOperators.resize(precedence + 1);
    }

    // Get all the operators at the given precedence level (or create an empty array)
    Array<UntypedOperator>& operators = this->PrecedenceToOperators[precedence];

    // Add the operator to the precedence list, and we're done!
    operators.push_back(info);
  }

  //***************************************************************************
  bool Shared::OperatorWithArity::operator==(const OperatorWithArity& rhs) const
  {
    return this->Operator == rhs.Operator && this->Arity == rhs.Arity;
  }

  //***************************************************************************
  size_t Shared::OperatorWithArity::Hash() const
  {
    return (((size_t)this->Operator) * 234059) ^ (this->Arity * 98361);
  }

  //***************************************************************************
  Shared& Shared::GetInstance()
  {
    // Singleton pattern
    static Shared instance;
    return instance;
  }
  
  //***************************************************************************
  BinaryOperator Shared::GetBinaryOperator(Type* lhs, Type* rhs, Grammar::Enum oper, bool allowRecursiveLookup)
  {
    // First attempt to find the operator in the specialized place
    // This MUST be first, otherwise value assignment for primitives will be a slower memcpy
    BinaryOperator finder;
    finder.Lhs = lhs;
    finder.Rhs = rhs;
    finder.Operator = oper;

    // Look for the operator in the pre-defined operator set
    BinaryOperator* result = this->BinaryOperators.findPointer(finder);
    if (result != nullptr)
    {
      // We found it, so return it!
      return *result;
    }

    // Make sure at least one is an enum
    Type* integerType = ZilchTypeId(Integer);
    bool lhsIsEnum = Type::IsEnumOrFlagsType(lhs);
    bool rhsIsEnum = Type::IsEnumOrFlagsType(rhs);
    if (lhsIsEnum || rhsIsEnum)
    {
      // Check to see if the operation is between an enum and an integer
      // We assign to the left, meaning the type we're converting to would be on the left
      bool isEnumToInteger = Type::IsSame(lhs, integerType);
      bool isIntegerToEnum = Type::IsSame(rhs, integerType);

      // Check to see if the operation is between the enum and another enum of the same kind
      bool isSameEnumWithEnum = lhsIsEnum && rhsIsEnum && Type::IsSame(lhs, rhs);

      // Don't allow assignments with integer to enum (otheriwse if it's between enum/enum or enum to integer, let it through)
      if (isSameEnumWithEnum || isEnumToInteger || (isIntegerToEnum && oper != Grammar::Assignment))
      {
        // Treat both as integers, and see if the operation would have been valid
        BinaryOperator integerOperator = this->GetBinaryOperator(integerType, integerType, oper);

        // If the operator is valid
        if (integerOperator.IsValid)
        {
          // Modify the operator slightly to make the inputs the same, and also make the result the enum type
          if (Type::IsSame(integerOperator.Result, integerType))
          {
            // Set the result to the enum type
            if (lhsIsEnum)
              integerOperator.Result = lhs;
            else
              integerOperator.Result = rhs;
          }

          // Return the re-purposed integer operator
          return integerOperator;
        }
      }
    }

    // Are both types handle types?
    if (Type::IsHandleType(lhs) && Type::IsHandleType(rhs))
    {
      // If we can convert the right to the left hand side (or they are the same)
      CastOperator castRightToLeft = this->GetCastOperator(rhs, lhs);
      if (castRightToLeft.IsValid && castRightToLeft.CanBeImplicit && castRightToLeft.RequiresCodeGeneration == false)
      {
        // Based on the operation...
        switch (oper)
        {
          // It is only legal for us to do assignment here, since the right
          // hand side must convert to the left hand side (eg, upcasting or null)
          case Grammar::Assignment:
            return this->HandleAssignment;
          case Grammar::Equality:
            return this->HandleEquality;
          case Grammar::Inequality:
            return this->HandleInequality;
        }
      }
      
      // If we can convert the left to the right hand side (we already know they aren't the same from above)
      CastOperator castLeftToRight = this->GetCastOperator(lhs, rhs);
      if (castLeftToRight.IsValid && castLeftToRight.CanBeImplicit && castLeftToRight.RequiresCodeGeneration == false)
      {
        // Based on the operation...
        switch (oper)
        {
          case Grammar::Equality:
            return this->HandleEquality;
          case Grammar::Inequality:
            return this->HandleInequality;
        }
      }
    }
    // Are both types the same type?
    else if (Type::IsSame(lhs, rhs))
    {
      // Note: In all of these  checks below we only need to
      // check one of them because we know they are the same!

      // Are both types value types?
      if (Type::IsValueType(lhs))
      {
        // Based on the operation...
        switch (oper)
        {
          case Grammar::Assignment:
            return this->ValueAssignment;
          case Grammar::Equality:
            return this->ValueEquality;
          case Grammar::Inequality:
            return this->ValueInequality;
        }
      }

      // Are both types delegate types?
      if (Type::IsDelegateType(lhs))
      {
        // Based on the operation...
        switch (oper)
        {
          case Grammar::Assignment:
            return this->DelegateAssignment;
          case Grammar::Equality:
            return this->DelegateEquality;
          case Grammar::Inequality:
            return this->DelegateInequality;
        }
      }

      // Are both types any types?
      if (Type::IsAnyType(lhs))
      {
        // Based on the operation...
        switch (oper)
        {
          case Grammar::Assignment:
            return this->AnyAssignment;
          case Grammar::Equality:
            return this->AnyEquality;
          case Grammar::Inequality:
            return this->AnyInequality;
        }
      }
    }

    // We got to this point and didn't find any binary operators that worked without implicit casting
    // When testing for implicit casting, it is common for us to look into our own casts
    if (allowRecursiveLookup == false)
      return BinaryOperator();

    // Lets take a look and see if implicit casting can solve our problems!
    // First, attempt to cast the right argument into the left argument type
    {
      CastOperator rightCast = this->GetCastOperator(rhs, lhs);

      // Only accept valid implicit casts
      if (rightCast.IsValid && rightCast.CanBeImplicit)
      {
        // We only look for direct 'primitive' binary operators
        BinaryOperator binaryOperatorWithCast = this->GetBinaryOperator(lhs, lhs, oper, false);
        if (binaryOperatorWithCast.IsValid)
        {
          // Let the user know that they need to cast to make this operator work
          binaryOperatorWithCast.Rhs = rhs;
          binaryOperatorWithCast.CastRhsTo = lhs;
          return binaryOperatorWithCast;
        }
      }
    }

    // We enumerate all the values the right argument can be cast into
    Array<CastOperator> rightCasts = this->GetPrimitiveCastOperatorsFrom(rhs);
    for (size_t i = 0; i < rightCasts.size(); ++i)
    {
      CastOperator& rightCast = rightCasts[i];
      
      // We only consider implicit casts
      if (rightCast.CanBeImplicit == false)
        continue;

      // We only look for direct 'primitive' binary operators
      BinaryOperator binaryOperatorWithCast = this->GetBinaryOperator(lhs, rightCast.To, oper, false);
      if (binaryOperatorWithCast.IsValid)
      {
        // Let the user know that they need to cast to make this operator work
        binaryOperatorWithCast.Rhs = rhs;
        binaryOperatorWithCast.CastRhsTo = rightCast.To;
        return binaryOperatorWithCast;
      }
    }

    // We enumerate all the values the left argument can be cast into
    Array<CastOperator> leftCasts = this->GetPrimitiveCastOperatorsFrom(lhs);
    for (size_t i = 0; i < leftCasts.size(); ++i)
    {
      CastOperator& leftCast = leftCasts[i];
      
      // We only consider implicit casts
      if (leftCast.CanBeImplicit == false)
        continue;

      // We only look for direct 'primitive' binary operators
      BinaryOperator binaryOperatorWithCast = this->GetBinaryOperator(leftCast.To, rhs, oper, false);
      if (binaryOperatorWithCast.IsValid)
      {
        // We can't allow implicit casting of the left argument when the operator is an l-value operator
        // For example, we never want Integer = Real to attempt to cast Integer to Real to make it work
        // This is partially mitigated by attempting the right operand first
        if ((binaryOperatorWithCast.Io & IoMode::WriteLValue) != 0)
          continue;

        // Let the user know that they need to cast to make this operator work
        binaryOperatorWithCast.Lhs = lhs;
        binaryOperatorWithCast.CastLhsTo = leftCast.To;
        return binaryOperatorWithCast;
      }
    }

    // We were unable to find anything, return an invalid operator
    return BinaryOperator();
  }
  
  //***************************************************************************
  UnaryOperator Shared::GetUnaryOperator(Type* type, Grammar::Enum oper)
  {
    // Attempt to find the result in the pre-made set of instructions
    UnaryOperator finder;
    finder.Operand = type;
    finder.Operator = oper;
    UnaryOperator* result = this->UnaryOperators.findPointer(finder);

    // If we found any operator, return it
    if (result != nullptr)
      return *result;

    // Check to see if the type we're operating on is an enum...
    Type* integerType = ZilchTypeId(Integer);
    if (Type::IsEnumOrFlagsType(type))
    {
      // Check to see if we have an integer operator of the same kind...
      UnaryOperator integerOperator = this->GetUnaryOperator(integerType, oper);

      // If the operator is valid
      if (integerOperator.IsValid)
      {
        // Modify the operator slightly to make the inputs the same, and also make the result the enum type
        if (Type::IsSame(integerOperator.Result, integerType))
            integerOperator.Result = type;

        // Return the re-purposed integer operator
        return integerOperator;
      }
    }

    // Otherwise, we didn't find the unary operator for this type...
    return UnaryOperator();
  }

  //***************************************************************************
  Array<CastOperator> Shared::GetPrimitiveCastOperatorsFrom(Type* from)
  {
    return this->PrimitiveCastOperatorsFrom[from];
  }

  //***************************************************************************
  CastOperator Shared::GetCastOperator(Type* from, Type* to)
  {
    // Get the core library
    Core& core = Core::GetInstance();

    // If the types are the exact same, then we require no conversion at all!
    // Note: This check should always come first, to avoid situations like 'ToAny' when it's 'Any' to 'Any'
    if (Type::IsSame(from, to))
      return this->RawImplicitCast;

    // If we're attempting to convert to the 'any' type...
    if (Type::IsAnyType(to))
      return this->ToAnyCast;

    // If we're attempting to convert from the 'any' type...
    if (Type::IsAnyType(from))
      return this->FromAnyCast;

    // If we're casting from an Integer to an enum...
    if (Type::IsSame(from, ZilchTypeId(Integer)) && Type::IsEnumOrFlagsType(to))
      return this->IntegerEnumCast;

    // If we're casting from an enum to an Integer... (can be implicit)
    if (Type::IsEnumOrFlagsType(from) && Type::IsSame(to, ZilchTypeId(Integer)))
      return this->EnumIntegerCast;

    // First attempt to find the operator in the specialized place
    CastOperator finder;
    finder.From = from;
    finder.To = to;

    // Look for the operator in the pre-defined operator set
    CastOperator* result = this->CastOperators.findPointer(finder);
    if (result != nullptr)
      return *result;

    // If we're converting from null to any delegate type...
    if (Type::IsSame(ZilchTypeId(NullPointerType), from) && Type::IsDelegateType(to))
      return this->NullToDelegate;

    // If we're converting from null to any other handle type...
    if (Type::IsSame(ZilchTypeId(NullPointerType), from) && Type::IsHandleType(to))
      return this->RawImplicitCast;

    // If we are converting from a delegate to the 'any delegate'...
    if (Type::IsDelegateType(from) && to == core.AnyDelegateType)
      return this->RawImplicitCast;

    // If we are converting from a reference type (handle type) to the 'any handle'...
    if (Type::IsHandleType(from) && to == core.AnyHandleType)
      return this->RawImplicitCast;

    // Attempt to grab both types as reference types
    BoundType* fromBoundType = Type::GetHandleType(from);
    BoundType* toBoundType   = Type::GetHandleType(to);

    // If both types are reference types (only one level of indirection)...
    if (fromBoundType != nullptr && toBoundType != nullptr)
    {
      // If the 'from' type is a 'to' type, meaning 'from' is either the same or more derived...
      if (TypeBinding::IsA(fromBoundType, toBoundType))
        return this->RawImplicitCast;

      // If the 'to' type is a 'from' type, meaning 'from' is either the same or more base... ('to' is more derived)
      if (TypeBinding::IsA(toBoundType, fromBoundType))
        return this->DynamicDownCast;
    }

    // Otherwise I was not able to find the cast operator
    return CastOperator();
  }
  
  //***************************************************************************
  UntypedOperator Shared::GetOperatorPrecedence(Grammar::Enum oper, OperatorArity::Enum arity)
  {
    OperatorWithArity finder;
    finder.Operator = oper;
    finder.Arity = arity;
    return this->OperatorToPrecedence.findValue(finder, UntypedOperator());
  }
  
  //***************************************************************************
  const Array<Array<UntypedOperator> >& Shared::GetPrecedences()
  {
    return this->PrecedenceToOperators;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes





namespace Zilch
{
  //***************************************************************************
  StaticLibrary::StaticLibrary(String name) :
    Name(name),
    Build(BuildState::NotBuilt)
  {
    // Create a library builder
    this->Builder = new LibraryBuilder(name);
  }

  //***************************************************************************
  StaticLibrary::~StaticLibrary()
  {
    delete this->Builder;
  }

  //***************************************************************************
  BuildState::Enum StaticLibrary::GetBuildState()
  {
    return this->Build;
  }
  
  //***************************************************************************
  bool StaticLibrary::CanBuildTypes()
  {
    return this->Build == BuildState::Building;
  }

  //***************************************************************************
  LibraryRef StaticLibrary::GetLibrary()
  {
    // Attempt to build the library (it may already be building...)
    this->BuildLibrary();

    // If the library has not been built yet...
    ErrorIf
    (
      this->Library == nullptr,
      "The static library '%s' is currently in the process of being built and cannot be grabbed!",
      this->Name.c_str()
    );

    return this->Library;
  }

  //***************************************************************************
  LibraryBuilder* StaticLibrary::GetBuilder()
  {
    // If the library was already built (the builder is destroyed...)
    if (this->Builder == nullptr)
    {
      // Throw an error
      Error("The static library '%s' was already built, and therefore its builder cannot be accessed.",
        this->Library->Name.c_str());
      return nullptr;
    }

    return this->Builder;
  }

  //***************************************************************************
  void StaticLibrary::SetupBinding(LibraryBuilder& builder)
  {
    // The base class does nothing, this is just to allow users to do their own setup
  }

  //***************************************************************************
  void StaticLibrary::BuildLibrary()
  {
    // Don't bother doing anything if we're already building or built
    if (this->Build != BuildState::NotBuilt)
      return;

    // Let the library know it's in the process of building
    // This is generally used to provide clear error messages in ZilchTypeId
    this->Build = BuildState::Building;

    // Build all dependent libraries
    ZilchForEach(StaticLibrary* dependency, this->Dependencies.all())
    {
      // Its ok to call BuildLibrary more than once
      dependency->BuildLibrary();
    }

    // Before we run initializers, let the user setup anything they want
    this->SetupBinding(*this->Builder);

    // Create the library and store it for everyone to be able to access
    this->Library = this->Builder->CreateLibrary();

    // Destroy the library builder since it's no longer needed
    delete this->Builder;
    this->Builder = nullptr;

    // Let the library know it's done being built
    this->Build = BuildState::Built;
  }


  //***************************************************************************
  BoundType* StaticLibrary::MakeType
  (
    StringParam         name,
    size_t              size,
    TypeCopyMode::Enum  copyMode,
    BoundType*          parent,
    size_t              nativeVirtualCount
  )
  {
    // Get the library builder
    LibraryBuilder& builder = *this->GetBuilder();

    // Create the type info with the provided information
    BoundType* newType = builder.AddBoundType(name, copyMode, size, nativeVirtualCount);
    newType->BaseType = parent;

    // Return the new type
    return newType;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes








namespace Zilch
{
  //***************************************************************************
  ZilchDefineExternalType(StreamCapabilities::Enum, "StreamCapabilities", Core, builder, type)
  {
    ZilchBindEnum(builder, type, SpecialType::Flags);
    ZilchBindEnumValue(builder, type, StreamCapabilities::None,     "None");
    ZilchBindEnumValue(builder, type, StreamCapabilities::Read,     "Read");
    ZilchBindEnumValue(builder, type, StreamCapabilities::Write,    "Write");
    ZilchBindEnumValue(builder, type, StreamCapabilities::Seek,     "Seek");
    ZilchBindEnumValue(builder, type, StreamCapabilities::GetCount, "GetCount");
    ZilchBindEnumValue(builder, type, StreamCapabilities::SetCount, "SetCount");
  }

  //***************************************************************************
  ZilchDefineExternalType(StreamOrigin::Enum, "StreamOrigin", Core, builder, type)
  {
    ZilchBindEnum(builder, type, SpecialType::Enumeration);
    ZilchBindEnumValue(builder, type, StreamOrigin::Start,    "Start");
    ZilchBindEnumValue(builder, type, StreamOrigin::Current,  "Current");
    ZilchBindEnumValue(builder, type, StreamOrigin::End,      "End");
  }

  //***************************************************************************
  ZilchDefineType(IEncoding, "IEncoding", Core, builder, type)
  {
    type->HandleManager = ZilchManagerId(PointerManager);

    // Even though this is an interface, because it is native, it must have a constructor that can be implemented
    ZilchBindConstructor(builder, type, IEncoding, nullptr);
    ZilchBindDestructor(builder, type, IEncoding);

    ZilchBindMethod(builder, type, &IEncoding::Write, ZilchNoOverload, "Write", nullptr)->IsVirtual = true;
    ZilchBindMethod(builder, type, &IEncoding::Read,  ZilchNoOverload, "Read",  nullptr)->IsVirtual = true;

    ZilchBindProperty(builder, type, &IEncoding::GetAscii, nullptr, "Ascii");
    ZilchBindProperty(builder, type, &IEncoding::GetUtf8,  nullptr, "Utf8");
  }

  //***************************************************************************
  ZilchDefineType(IStreamClass, "IStream", Core, builder, type)
  {
    // Even though this is an interface, because it is native, it must have a constructor that can be implemented
    ZilchBindConstructor(builder, type, IStreamClass, nullptr);
    ZilchBindDestructor(builder, type, IStreamClass);

    ZilchBindProperty(builder, type, &IStreamClass::GetCapabilities, nullptr, "Capabilities");
    ZilchBindProperty(builder, type, &IStreamClass::GetPosition, &IStreamClass::SetPosition, "Position");
    ZilchBindProperty(builder, type, &IStreamClass::GetCount, &IStreamClass::SetCount, "Count");
    
    ZilchBindMethod(builder, type, &IStreamClass::Seek, ZilchNoOverload, "Seek", "position, origin")->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::Write, (Integer (IStreamClass::*)(ArrayClass<Byte>&, Integer, Integer)), "Write", "data, byteStart, byteCount")->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::WriteByte, ZilchNoOverload, "WriteByte", nullptr)->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::Read, (Integer (IStreamClass::*)(ArrayClass<Byte>&, Integer, Integer)), "Read", "data, byteStart, byteCount")->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::ReadByte, ZilchNoOverload, "ReadByte", nullptr)->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::Flush, ZilchNoOverload, "Flush", nullptr)->IsVirtual = true;

    // Extensions (these are not virtual)
    ZilchBindMethod(builder, type, &IStreamClass::Write, (Integer (IStreamClass::*)(ArrayClass<Byte>&)), "Write", "data");
    ZilchBindMethod(builder, type, &IStreamClass::WriteText, (Integer (IStreamClass::*)(StringParam, IEncoding&)), "WriteText", "text, sourceStreamEncoding")->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::WriteText, (Integer (IStreamClass::*)(StringParam)), "WriteText", "text")->IsVirtual = true;
    //ZilchBindMethod(builder, type, &IStreamClass::Read, (ArrayClass<Byte> (IStreamClass::*)(Integer)), "Read", "byteCount");
    ZilchBindMethod(builder, type, &IStreamClass::ReadLine, (String (IStreamClass::*)(IEncoding&)), "ReadLine", nullptr)->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::ReadLine, (String (IStreamClass::*)()), "ReadLine", nullptr)->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::ReadAllText, (String (IStreamClass::*)(IEncoding&)), "ReadAllText", nullptr)->IsVirtual = true;
    ZilchBindMethod(builder, type, &IStreamClass::ReadAllText, (String (IStreamClass::*)()), "ReadAllText", nullptr)->IsVirtual = true;
  }

  //***************************************************************************
  AsciiEncoding& IEncoding::GetAscii()
  {
    static AsciiEncoding encoding;
    return encoding;
  }
  
  //***************************************************************************
  Utf8Encoding& IEncoding::GetUtf8()
  {
    static Utf8Encoding encoding;
    return encoding;
  }
  
  //***************************************************************************
  Integer IEncoding::Write(Rune rune, IStreamClass& stream)
  {
    ExecutableState::CallingState->ThrowNotImplementedException();
    return 0;
  }
  
  //***************************************************************************
  Rune IEncoding::Read(IStreamClass& stream)
  {
    ExecutableState::CallingState->ThrowNotImplementedException();
    return Rune();
  }

  //***************************************************************************
  Integer AsciiEncoding::Write(Rune rune, IStreamClass& stream)
  {
    return stream.WriteByte((Byte)rune.mValue);
  }

  //***************************************************************************
  Rune AsciiEncoding::Read(IStreamClass& stream)
  {
    // Read a single byte from the stream, if its not valid, then return null
    Integer byte = stream.ReadByte();
    if (byte == -1)
      return Rune();
    return Rune(byte);
  }
  
  //***************************************************************************
  Integer Utf8Encoding::Write(Rune rune, IStreamClass& stream)
  {
    // At the moment this is not correct and must be updated to do proper Utf8 encoding
    ZilchTodo("Unicode");
    return stream.WriteByte((Byte)rune.mValue);
  }

  //***************************************************************************
  Rune Utf8Encoding::Read(IStreamClass& stream)
  {
    // At the moment this is not correct and must be updated to do proper Utf8 decoding
    // Read a single byte from the stream, if its not valid, then return null
    ZilchTodo("Unicode");
    Integer byte = stream.ReadByte();
    if (byte == -1)
      return Rune();
    return Rune(byte);
  }
  
  //***************************************************************************
  StreamCapabilities::Enum IStreamClass::GetCapabilities()
  {
    return StreamCapabilities::None;
  }
  
  //***************************************************************************
  DoubleInteger IStreamClass::GetPosition()
  {
    ExecutableState::CallingState->ThrowNotImplementedException();
    return 0;
  }

  //***************************************************************************
  void IStreamClass::SetPosition(DoubleInteger position)
  {
    // Attempt to seek to the given position relative to the start
    if (this->Seek(position, StreamOrigin::Start) == false)
    {
      // We failed the first seek, check if the position was negative (if so, seek to the start of the stream)
      if (position < 0)
      {
        this->Seek(0, StreamOrigin::Start);
      }
      // Also check if the position was beyond the size of the stream
      // This is valid for some streams, however we already know the above seek failed
      // Clamp to the end of the stream
      else if (position > this->GetCount())
      {
        this->Seek(0, StreamOrigin::End);
      }
    }
  }
  
  //***************************************************************************
  DoubleInteger IStreamClass::GetCount()
  {
    if ((this->GetCapabilities() & StreamCapabilities::GetCount) == 0)
      ExecutableState::CallingState->ThrowException("This stream does not support the GetCount capability");
    return 0;
  }

  //***************************************************************************
  void IStreamClass::SetCount(DoubleInteger count)
  {
    if ((this->GetCapabilities() & StreamCapabilities::SetCount) == 0)
      ExecutableState::CallingState->ThrowException("This stream does not support the SetCount capability");
  }
  
  //***************************************************************************
  bool IStreamClass::Seek(DoubleInteger position, StreamOrigin::Enum origin)
  {
    if ((this->GetCapabilities() & StreamCapabilities::Seek) == 0)
      ExecutableState::CallingState->ThrowException("This stream does not support the Seek capability");
    return false;
  }
  
  //***************************************************************************
  Integer IStreamClass::Write(ArrayClass<Byte>& data, Integer byteStart, Integer byteCount)
  {
    if ((this->GetCapabilities() & StreamCapabilities::Write) == 0)
    {
      ExecutableState::CallingState->ThrowException("This stream does not support the Write capability");
      return 0;
    }
    
    IStreamClass::ValidateArray(data, byteStart, byteCount, false);
    return 0;
  }
  
  //***************************************************************************
  Integer IStreamClass::WriteByte(Byte byte)
  {
    ExecutableState::CallingState->ThrowException("This stream does not support the Write capability");
    return 0;
  }
  
  //***************************************************************************
  Integer IStreamClass::Read(ArrayClass<Byte>& data, Integer byteStart, Integer byteCount)
  {
    if ((this->GetCapabilities() & StreamCapabilities::Read) == 0)
    {
      ExecutableState::CallingState->ThrowException("This stream does not support the Read capability");
      return 0;
    }

    IStreamClass::ValidateArray(data, byteStart, byteCount, true);
    return 0;
  }
  
  //***************************************************************************
  Integer IStreamClass::ReadByte()
  {
    if ((this->GetCapabilities() & StreamCapabilities::Read) == 0)
      ExecutableState::CallingState->ThrowException("This stream does not support the Read capability");
    return 0;
  }
  
  //***************************************************************************
  void IStreamClass::Flush()
  {
  }
  
  //***************************************************************************
  bool IStreamClass::ValidateArray(ArrayClass<Byte>& data, Integer byteStart, Integer byteCount, bool resizeArrayIfNeeded)
  {
    // We don't allow a negative starting value
    if (byteStart < 0)
    {
      ExecutableState::CallingState->ThrowException("The parameter 'byteStart' cannot be negative");
      return false;
    }

    // We don't allow a negative count value
    if (byteCount < 0)
    {
      ExecutableState::CallingState->ThrowException("The parameter 'byteCount' cannot be negative");
      return false;
    }
    
    // Compute the end in bytes and get the current size of the array
    Integer byteEnd = byteStart + byteCount;
    Integer currentCount = (Integer)data.NativeArray.size();

    // If the byte range goes outside the current array
    if (byteEnd > currentCount)
    {
      // If we allow resizing...
      if (resizeArrayIfNeeded)
      {
        // Resize the array to go all the way to the end, and then zero out the bytes
        data.NativeArray.resize(byteEnd);
        memset(data.NativeArray.data() + currentCount, 0, byteEnd - currentCount);
        data.Modified();
      }
      else
      {
        ExecutableState::CallingState->ThrowException("The byte range exceeds the size of the array");
        return false;
      }
    }

    // We didn't throw an exception, so it must be valid
    return true;
  }
  
  //***************************************************************************
  Integer IStreamClass::Write(ArrayClass<Byte>& data)
  {
    return this->Write(data, 0, data.NativeArray.size());
  }
  
  //***************************************************************************
  Integer IStreamClass::WriteText(StringParam text, IEncoding& destinationStreamEncoding)
  {
    Integer totalWritten = 0;

    // Techinically this should be iterating through runes
    ZilchTodo("Unicode");
    StringRange range = text.all();
    ZilchForEach(char c, range)
    {
      // Use whatever encoding they passed in to write out the rune (should be virtual)
      Integer amountWritten = destinationStreamEncoding.Write(Rune(c), *this);
      if (amountWritten == 0)
        break;

      // Accumulate how much was written (may be multiple bytes for each rune, depending on the encoding)
      totalWritten += amountWritten;
    }
    return totalWritten;
  }
  
  //***************************************************************************
  Integer IStreamClass::WriteText(StringParam text)
  {
    return this->WriteText(text, IEncoding::GetUtf8());
  }
  
  //***************************************************************************
  String IStreamClass::ReadLine(IEncoding& sourceStreamEncoding)
  {
    // Appends all the runes together
    StringBuilder builder;

    ZilchLoop
    {
      // The encoding will translate bytes from the stream into valid characters (runes)
      // If reading fails for any reason, encoding should always return the null character
      Rune rune = sourceStreamEncoding.Read(*this);
      int runeValue = rune.mValue;

      // We disregard carriage return. Maybe we shouldn't do this, but it simplifies
      // our logic and doesn't cause it to read ahead in the stream
      // Only very old systems use just the CR to mean newline
      // If this is specifically just the LF (newline character)
      if (runeValue == '\n')
      {
        builder.Append('\n');
        return builder.ToString();
      }

      // If this is the end of a the stream (or an error occurred)
      if (runeValue == '\0')
        return builder.ToString();

      // We concatenate all read runes together (should automatically encode Utf8 because our strings are Utf8)
      ZilchTodo("Unicode");
      builder.Append((char)runeValue);
    }
  }

  //***************************************************************************
  String IStreamClass::ReadLine()
  {
    return this->ReadLine(IEncoding::GetUtf8());
  }
  
  //***************************************************************************
  String IStreamClass::ReadAllText(IEncoding& sourceStreamEncoding)
  {
    // Appends all the runes together
    StringBuilder builder;

    ZilchLoop
    {
      // The encoding will translate bytes from the stream into valid characters (runes)
      // If reading fails for any reason, encoding should always return the null character
      Rune rune = sourceStreamEncoding.Read(*this);
      int runeValue = rune.mValue;

      // If this is the end of a the stream (or an error occurred)
      if (runeValue == '\0')
        return builder.ToString();

      // We concatenate all read runes together (should automatically encode Utf8 because our strings are Utf8)
      ZilchTodo("Unicode");
      builder.Append((char)runeValue);
    }
  }

  //***************************************************************************
  String IStreamClass::ReadAllText()
  {
    return this->ReadAllText(IEncoding::GetUtf8());
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes







namespace Zilch
{
  //***************************************************************************
  ZilchDefineType(StringBuilderExtended, "StringBuilder", Core, builder, type)
  {
    ZilchBindConstructor(builder, type, StringBuilderExtended, nullptr);
    ZilchBindDestructor(builder, type, StringBuilderExtended);

    ZilchBindMethod(builder, type, &StringBuilderExtended::ToString, ZilchNoOverload, "ToString", nullptr);

    ZilchBindMethod(builder, type, &StringBuilderExtended::Clear, ZilchNoOverload, "Clear", nullptr);
    
    ZilchBindMethod(builder, type, &StringBuilderExtended::Write, (void (StringBuilderExtended::*)(AnyParam)), "Write", nullptr);
    
    ZilchBindMethod(builder, type, &StringBuilderExtended::WriteLine, (void (StringBuilderExtended::*)()), "WriteLine", nullptr);
    ZilchBindMethod(builder, type, &StringBuilderExtended::WriteLine, (void (StringBuilderExtended::*)(AnyParam)), "WriteLine", nullptr);
  }
  
  //***************************************************************************
  void StringBuilderExtended::Write(AnyParam value)
  {
    this->Append(value.ToString());
  }
  
  //***************************************************************************
  void StringBuilderExtended::Write(StringParam value)
  {
    this->Append(value);
  }

  //***************************************************************************
  void StringBuilderExtended::Write(StringRange value)
  {
    this->Append(value);
  }

  //***************************************************************************
  void StringBuilderExtended::Write(cstr value)
  {
    this->Append(value);
  }

  //***************************************************************************
  void StringBuilderExtended::Write(char value)
  {
    this->Append(value);
  }

  //***************************************************************************
  void StringBuilderExtended::Write(Integer value)
  {
    this->Append(IntegerToString(value));
  }

  //***************************************************************************
  void StringBuilderExtended::Write(Integer2Param value)
  {
    this->Append(Integer2ToString(value));
  }

  //***************************************************************************
  void StringBuilderExtended::Write(Integer3Param value)
  {
    this->Append(Integer3ToString(value));
  }

  //***************************************************************************
  void StringBuilderExtended::Write(Integer4Param value)
  {
    this->Append(Integer4ToString(value));
  }

  //***************************************************************************
  void StringBuilderExtended::Write(DoubleInteger value)
  {
    this->Append(DoubleIntegerToString(value));
  }
  
  //***************************************************************************
  void StringBuilderExtended::Write(Boolean value)
  {
    this->Append(BooleanToString(value));
  }

  //***************************************************************************
  void StringBuilderExtended::Write(Boolean2Param value)
  {
    this->Append(Boolean2ToString(value));
  }

  //***************************************************************************
  void StringBuilderExtended::Write(Boolean3Param value)
  {
    this->Append(Boolean3ToString(value));
  }

  //***************************************************************************
  void StringBuilderExtended::Write(Boolean4Param value)
  {
    this->Append(Boolean4ToString(value));
  }
  
  //***************************************************************************
  void StringBuilderExtended::Write(Real value)
  {
    this->Append(RealToString(value));
  }

  //***************************************************************************
  void StringBuilderExtended::Write(DoubleReal value)
  {
    this->Append(DoubleRealToString(value));
  }
  
  //***************************************************************************
  void StringBuilderExtended::Write(Real2Param value)
  {
    this->Append(Real2ToString(value));
  }
  
  //***************************************************************************
  void StringBuilderExtended::Write(Real3Param value)
  {
    this->Append(Real3ToString(value));
  }
  
  //***************************************************************************
  void StringBuilderExtended::Write(Real4Param value)
  {
    this->Append(Real4ToString(value));
  }
  
  //***************************************************************************
  void StringBuilderExtended::Write(QuaternionParam value)
  {
    this->Append(QuaternionToString(value));
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine()
  {
    this->Append("\n");
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(AnyParam value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(StringParam value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(StringRange value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(cstr value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(char value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(Integer value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(Integer2Param value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(Integer3Param value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(Integer4Param value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(DoubleInteger value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(Boolean value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(Boolean2Param value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(Boolean3Param value)
  {
    this->Write(value);
    this->WriteLine();
  }

  //***************************************************************************
  void StringBuilderExtended::WriteLine(Boolean4Param value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(Real value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(DoubleReal value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(Real2Param value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(Real3Param value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(Real4Param value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::WriteLine(QuaternionParam value)
  {
    this->Write(value);
    this->WriteLine();
  }
  
  //***************************************************************************
  void StringBuilderExtended::Clear()
  {
    this->Deallocate();
  }

  //***************************************************************************
  String StringBuilderExtended::ToString() const
  {
    return StringBuilder::ToString();
  }

  //-------------------------------------------------------------------Rune
  //***************************************************************************
  ZilchDefineType(Rune, "Rune", Core, builder, type)
  {
    type->ToStringFunction = &Rune::ToString;

    ZilchBindConstructor(builder, type, Rune, nullptr);
    ZilchBindConstructor(builder, type, Rune, "value", int);
    ZilchBindField(builder, type, &Rune::mValue, "Value", PropertyBinding::GetSet);
  }

  //***************************************************************************
  Rune::Rune()
  {
    mValue = 0;
  }

  //***************************************************************************
  Rune::Rune(int value)
  {
    mValue = value;
  }
  
  //***************************************************************************
  String Rune::ToString(const BoundType* type, const byte* data)
  {
    Rune* rune = (Rune*)data;
    return String(rune->mValue);
  }

  //-------------------------------------------------------------------RuneIterator
  //***************************************************************************
  ZilchDefineType(RuneIterator, "RuneIterator", Core, builder, type)
  {
    ZilchBindConstructor(builder, type, RuneIterator, nullptr);
    ZilchBindDestructor(builder, type, RuneIterator);

    BoundType* boolType = ZilchTypeId(Boolean);
    BoundType* integerType = ZilchTypeId(int);
    BoundType* voidType = ZilchTypeId(void);
    BoundType* runeType = ZilchTypeId(Rune);
    BoundType* stringType = ZilchTypeId(String);
    type->ToStringFunction = &RuneIterator::ToString;

    // Range interface
    builder.AddBoundProperty(type, "All", type, nullptr, &RuneIterator::All, MemberOptions::None);
    builder.AddBoundFunction(type, "MoveNext", &RuneIterator::Increment, ParameterArray(), voidType, MemberOptions::None);
    builder.AddBoundProperty(type, "Current", runeType, nullptr, &RuneIterator::Current, MemberOptions::None);
    builder.AddBoundProperty(type, "IsNotEmpty", boolType, nullptr, &RuneIterator::IsNotEmpty, MemberOptions::None);

    // Iterator interface
    builder.AddBoundFunction(type, "Increment", &RuneIterator::Increment, ParameterArray(), voidType, MemberOptions::None);
    builder.AddBoundFunction(type, "Decrement", &RuneIterator::Decrement, ParameterArray(), voidType, MemberOptions::None);
    builder.AddBoundFunction(type, "Equals", &RuneIterator::Equals, OneParameter(type), boolType, MemberOptions::None);

    builder.AddBoundProperty(type, "ByteIndex", integerType, nullptr, &RuneIterator::GetByteIndex, MemberOptions::None);
    builder.AddBoundProperty(type, "OriginalString", stringType, nullptr, &StringRangeExtended::GetOriginalString, FunctionOptions::None);
  }

  //***************************************************************************
  String RuneIterator::ToString(const BoundType* type, const byte* data)
  {
    RuneIterator* iterator = (RuneIterator*)data;

    return String(iterator->mRange.front());
  }

  //***************************************************************************
  void RuneIterator::All(Call& call, ExceptionReport& report)
  {
    call.SetHandle(Call::Return, call.GetHandle(Call::This));
  }

  //***************************************************************************
  void RuneIterator::Current(Call& call, ExceptionReport& report)
  {
    RuneIterator* self = (RuneIterator*)call.GetHandle(Call::This).Dereference();
    if(self->mRange.empty())
    {
      // Throw an exception since the range was empty and we called Current
      call.GetState()->ThrowException(report, "The iterator reached the end and an attempt was made to get the current value");
      return;
    }

    Rune result(self->mRange.front());
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void RuneIterator::IsNotEmpty(Call& call, ExceptionReport& report)
  {
    RuneIterator* self = (RuneIterator*)call.GetHandle(Call::This).Dereference();

    call.Set(Call::Return, !self->mRange.empty());
  }

  //***************************************************************************
  void RuneIterator::Increment(Call& call, ExceptionReport& report)
  {
    RuneIterator* self = (RuneIterator*)call.GetHandle(Call::This).Dereference();

    if(self->mRange.empty())
    {
      call.GetState()->ThrowException(report, "Cannot increment an iterator past the end of the original string");
      return;
    }

    self->mRange.popFront();
  }

  //***************************************************************************
  void RuneIterator::Decrement(Call& call, ExceptionReport& report)
  {
    RuneIterator* self = (RuneIterator*)call.GetHandle(Call::This).Dereference();
    --self->mRange.begin;
    if(self->mRange.begin < self->mOriginalStringReference.begin())
    {
      call.GetState()->ThrowException(report, "Cannot decrement an iterator before the begin of the original string");
      return;
    }
  }

  //***************************************************************************
  void RuneIterator::Equals(Call& call, ExceptionReport& report)
  {
    RuneIterator* self = (RuneIterator*)call.GetHandle(Call::This).Dereference();
    RuneIterator* param0 = call.Get<RuneIterator*>(0);

    bool result = self->mRange.begin == param0->mRange.begin;
    call.Set(Call::Return, result);
  }

  //***************************************************************************
  void RuneIterator::GetByteIndex(Call& call, ExceptionReport& report)
  {
    RuneIterator* self = (RuneIterator*)call.GetHandle(Call::This).Dereference();
    int byteIndex = (int)(self->mRange.begin - self->mOriginalStringReference.begin());
    call.Set(Call::Return, byteIndex);
  }

  //***************************************************************************
  void RuneIterator::GetOriginalString(Call& call, ExceptionReport& report)
  {
    RuneIterator* self = (RuneIterator*)call.GetHandle(Call::This).Dereference();

    call.SetHandle(Call::Return, &self->mOriginalStringReference);
  }

  //***************************************************************************
  void RuneIterator::FindRuneIndexFromIterator(Call& call, ExceptionReport& report)
  {
    //for now, just assume the byte index is the same as the rune index
    GetByteIndex(call, report);
  }

  //-------------------------------------------------------------------StringRangeSafe
  //***************************************************************************
  ZilchDefineType(StringRangeExtended, "StringRange", Core, builder, type)
  {
    ZilchBindConstructor(builder, type, StringRangeExtended, nullptr);
    ZilchBindDestructor(builder, type, StringRangeExtended);

    BoundType* booleanType = ZilchTypeId(bool);
    BoundType* integerType = ZilchTypeId(Integer);
    BoundType* iteratorType = ZilchTypeId(RuneIterator);
    BoundType* stringType = ZilchTypeId(String);
    BoundType* splitRangeType = ZilchTypeId(StringSplitRangeExtended);
    type->ToStringFunction = &StringRangeExtended::ToString;

    // Range interface
    builder.AddBoundProperty(type, "All", type, nullptr, &StringRangeExtended::All, MemberOptions::None);
    ZilchBindMethod(builder, type, &StringRangeExtended::MoveNext, ZilchNoOverload, "MoveNext", nullptr);
    builder.AddBoundProperty(type, "Current", ZilchTypeId(Rune), nullptr, &StringRangeExtended::Current, MemberOptions::None); 
    builder.AddBoundProperty(type, "IsNotEmpty", booleanType, nullptr, &StringRangeExtended::IsNotEmpty, MemberOptions::None);

    builder.AddBoundProperty(type, "Begin", iteratorType, nullptr, Begin, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns the RuneIterator at the start of this range.");
    ZilchBindMethod(builder, type, &StringRangeExtended::CompareTo, ZilchNoOverload, "CompareTo", nullptr)
      ->Description = ZilchDocumentString("Returns if this string range is equal to the given range.");
    ZilchBindMethod(builder, type, &StringRangeExtended::Contains, ZilchNoOverload, "Contains", nullptr)
      ->Description = ZilchDocumentString("Returns if the string contains the specified substring.");
    builder.AddBoundProperty(type, "End", iteratorType, nullptr, End, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns the RuneIterator at the end (one past the last Rune) of this range.");
    ZilchBindMethod(builder, type, &StringRangeExtended::EndsWith, ZilchNoOverload, "EndsWith", nullptr)
      ->Description = ZilchDocumentString("Returns if the string ends with the specified substring.");
    builder.AddBoundFunction(type, "FindFirstOf", FindFirstOf, OneParameter(type), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns a StringRange that contains the first occurrence of given StringRange.");
    builder.AddBoundFunction(type, "FindLastOf", FindLastOf, OneParameter(type), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns a StringRange that contains the last occurrence of given StringRange.");
    builder.AddBoundFunction(type, "FindRangeInclusive", FindRangeInclusive, TwoParameters(type, "startRange", "endRange"), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Finds the first StringRange that starts with 'startRange' and ends with 'endRange'. This substring includes 'startRange' and 'endRange'.");
    builder.AddBoundFunction(type, "FindRangeExclusive", FindRangeExclusive, TwoParameters(type, "startRange", "endRange"), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Finds the first StringRange that starts with 'startRange' and ends with 'endRange'. This substring excludes 'startRange' and 'endRange'.");
    ZilchBindMethod(builder, type, &StringRangeExtended::Replace, ZilchNoOverload, "Replace", "oldValue newValue")
      ->Description = ZilchDocumentString("Returns a new string with all occurances of a substrings replaced with another substring.");
    builder.AddBoundFunction(type, "Split", StringRangeExtended::Split, OneParameter(type, "separator"), splitRangeType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Splits the string, according to the separator string, into a range of substrings.");
    builder.AddBoundFunction(type, "SubString", SubString, TwoParameters(iteratorType, "begin", "end"), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Constructs a StringRange from the given begin and end iterators.");
    builder.AddBoundFunction(type, "SubStringBytes", SubStringBytes, TwoParameters(integerType, "startByteIndex", "lengthInBytes"), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Constructs a substring based upon a number of bytes. WARNING: strings are UTF8 so indexing by bytes could produce unexpected results on non-ascii strings.");
    ZilchBindMethod(builder, type, &StringRangeExtended::StartsWith, ZilchNoOverload, "StartsWith", nullptr)
      ->Description = ZilchDocumentString("Returns if the string ends with the specified substring.");
    builder.AddBoundFunction(type, "Trim", Trim, ParameterArray(), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Trims all leading and trailing whitespace.");
    builder.AddBoundFunction(type, "TrimEnd", TrimEnd, ParameterArray(), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Trims all trailing whitespace.");
    builder.AddBoundFunction(type, "TrimStart", TrimStart, ParameterArray(), type, FunctionOptions::None)
      ->Description = ZilchDocumentString("Trims all leading whitespace.");
    ZilchBindMethod(builder, type, &StringRangeExtended::ToLower, ZilchNoOverload, "ToLower", nullptr)
      ->Description = ZilchDocumentString("Returns a copy of the string that has been converted to lowercase.");
    builder.AddBoundFunction(type, "ToString", ConvertToString, ParameterArray(), stringType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns a new string of the current range.");
    ZilchBindMethod(builder, type, &StringRangeExtended::ToUpper, ZilchNoOverload, "ToUpper", nullptr)
      ->Description = ZilchDocumentString("Returns a copy of the string that has been converted to uppercase.");

    builder.AddBoundProperty(type, "OriginalString", stringType, nullptr, &StringRangeExtended::GetOriginalString, FunctionOptions::None)
      ->Description = ZilchDocumentString("Returns the entire string that this range was constructed from.");
    builder.AddBoundFunction(type, "RuneIteratorFromByteIndex", RuneIteratorFromByteIndex, OneParameter(integerType, "byteIndex"), iteratorType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Finds the iterator from a byte index. WARNING: Strings are UTF8 and constructing an iterator from bytes indices can make an iterator in the middle of a rune.");
    builder.AddBoundFunction(type, "RuneIteratorFromRuneIndex", RuneIteratorFromRuneIndex, OneParameter(integerType, "runeIndex"), iteratorType, FunctionOptions::None)
      ->Description = ZilchDocumentString("Finds the iterator from a rune index (the 'character' index). WARNING: this may be slow as finding an iterator from rune index requires a linear search.");
  }

  //***************************************************************************
  String StringRangeExtended::ToString(const BoundType* type, const byte* data)
  {
    StringRangeExtended* range = (StringRangeExtended*)data;

    return range->mRange;
  }

  //***************************************************************************
  void StringRangeExtended::All(Call& call, ExceptionReport& report)
  {
    call.SetHandle(Call::Return, call.GetHandle(Call::This));
  }

  //***************************************************************************
  void StringRangeExtended::MoveNext()
  {
    mRange.popFront();
  }

  //***************************************************************************
  void StringRangeExtended::Current(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    Rune rune;
    if(!self->mRange.empty())
      rune = Rune(self->mRange.front());
    call.Set(Call::Return, rune);
  }

  //***************************************************************************
  void StringRangeExtended::IsNotEmpty(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    call.Set(Call::Return, !self->mRange.empty());
  }

  //***************************************************************************
  void StringRangeExtended::Begin(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    StringRange result = StringRange(self->mRange.begin, self->mOriginalStringReference.end());
    SetResultIterator(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  void StringRangeExtended::ConvertToString(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    String result = self->mRange;
    call.Set(Call::Return, &result);
  }

  //***************************************************************************
  int StringRangeExtended::CompareTo(StringRangeExtended range)
  {
    return mRange.CompareTo(range.mRange);
  }

  //***************************************************************************
  bool StringRangeExtended::Contains(StringRangeExtended string)
  {
    return mRange.Contains(string.mRange);
  }

  //***************************************************************************
  void StringRangeExtended::End(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    StringRange result = StringRange(self->mRange.end, self->mOriginalStringReference.end());
    SetResultIterator(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  bool StringRangeExtended::EndsWith(StringRangeExtended subString)
  {
    return mRange.EndsWith(subString.mRange);
  }

  //***************************************************************************
  void StringRangeExtended::FindFirstOf(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    StringRangeExtended* searchRange = call.Get<StringRangeExtended*>(0);

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    StringRange result = self->mRange.FindFirstRangeOf(searchRange->mRange);
    SetResultStringRange(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  void StringRangeExtended::FindLastOf(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    StringRangeExtended* searchRange = call.Get<StringRangeExtended*>(0);

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    StringRange result = self->mRange.FindLastRangeOf(searchRange->mRange);
    SetResultStringRange(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  void StringRangeExtended::FindRangeExclusive(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    StringRangeExtended* beginRange = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* endRange = call.Get<StringRangeExtended*>(1);

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    StringRange result = self->mRange.FindRangeExclusive(beginRange->mRange, endRange->mRange);
    SetResultStringRange(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  void StringRangeExtended::FindRangeInclusive(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    StringRangeExtended* beginRange = call.Get<StringRangeExtended*>(0);
    StringRangeExtended* endRange = call.Get<StringRangeExtended*>(1);

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    StringRange result = self->mRange.FindRangeInclusive(beginRange->mRange, endRange->mRange);
    SetResultStringRange(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  String StringRangeExtended::Replace(StringRangeExtended oldValue, StringRangeExtended newValue)
  {
    return mRange.Replace(oldValue.mRange, newValue.mRange);
  }

  //***************************************************************************
  void StringRangeExtended::RuneIteratorFromByteIndex(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    int byteIndex = call.Get<int>(0);

    RuneIteratorFromByteIndexInternal(call, report, self->mOriginalStringReference, self->mRange, byteIndex);
  }

  //***************************************************************************
  void StringRangeExtended::RuneIteratorFromByteIndexInternal(Call& call, ExceptionReport& report, StringParam strRef, StringRange range, int byteIndex)
  {
    int sizeInBytes = (int)range.sizeInBytes();

    if(byteIndex < 0)
    {
      call.GetState()->ThrowException(report, "A negative byte index is not supported");
      return;
    }

    if(byteIndex >= sizeInBytes)
    {
      call.GetState()->ThrowException(report, "Byte index is greater than the size of the range");
      return;
    }

    StringRange result = range.sub_string(byteIndex, sizeInBytes - byteIndex);
    SetResultIterator(call, report, strRef, result);
  }

  //***************************************************************************
  void StringRangeExtended::RuneIteratorFromRuneIndex(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    int byteIndex = call.Get<int>(0);

    RuneIteratorFromRuneIndexInternal(call, report, self->mOriginalStringReference, self->mRange, byteIndex);
  }

  //***************************************************************************
  void StringRangeExtended::RuneIteratorFromRuneIndexInternal(Call& call, ExceptionReport& report, StringParam strRef, StringRange range, int runeIndex)
  {
    RuneIteratorFromByteIndexInternal(call, report, strRef, range, runeIndex);
  }

  //***************************************************************************
  void StringRangeExtended::Split(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    StringRangeExtended* separatorStr = call.Get<StringRangeExtended*>(0);

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    SetResultStringSplitRange(call, report, self->mOriginalStringReference, self->mRange.Split(separatorStr->mRange));
  }

  //***************************************************************************
  bool StringRangeExtended::StartsWith(StringRangeExtended subString)
  {
    return mRange.StartsWith(subString.mRange);
  }

  //***************************************************************************
  void StringRangeExtended::SubString(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    RuneIterator* beginIterator = call.Get<RuneIterator*>(0);
    RuneIterator* endIterator = call.Get<RuneIterator*>(1);

    //make sure that the begin and end are within the valid range of the original string
    StringRange::iterator begin = Math::Clamp(beginIterator->mRange.begin, self->mOriginalStringReference.begin(), self->mOriginalStringReference.end());
    StringRange::iterator end = Math::Clamp(endIterator->mRange.begin, self->mOriginalStringReference.begin(), self->mOriginalStringReference.end());
    //make sure the end is equal to or after begin
    if(end < begin)
      end = begin;

    SetResultStringRange(call, report, self->mOriginalStringReference, StringRange(begin, end));
  }

  //***************************************************************************
  void StringRangeExtended::SubStringBytes(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();
    int bytesStart = call.Get<int>(0);
    int bytesLength = call.Get<int>(1);

    StringRange result = self->mRange.sub_string(bytesStart, bytesLength);
    SetResultStringRange(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  void StringRangeExtended::Trim(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    StringRange result = self->mRange.Trim();
    SetResultStringRange(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  void StringRangeExtended::TrimEnd(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    StringRange result = self->mRange.TrimEnd();
    SetResultStringRange(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  void StringRangeExtended::TrimStart(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    if(ValidateRange(self->mOriginalStringReference, self->mRange) == false)
      return;

    StringRange result = self->mRange.TrimStart();
    ValidateRange(self->mOriginalStringReference, result);
    SetResultStringRange(call, report, self->mOriginalStringReference, result);
  }

  //***************************************************************************
  String StringRangeExtended::ToLower()
  {
    return mRange.ToLower();
  }

  //***************************************************************************
  String StringRangeExtended::ToUpper()
  {
    return mRange.ToUpper();
  }

  //***************************************************************************
  void StringRangeExtended::SetResultStringRange(Call& call, ExceptionReport& report, const String& strRef, StringRange result)
  {
    Handle rangeHandle = call.GetState()->AllocateDefaultConstructedHeapObject(ZilchTypeId(StringRangeExtended), report, HeapFlags::ReferenceCounted);
    StringRangeExtended& stringRange = *(StringRangeExtended*)rangeHandle.Dereference();
    stringRange.mOriginalStringReference = strRef;
    stringRange.mRange = result;
    call.SetHandle(Call::Return, rangeHandle);
  }

  //***************************************************************************
  void StringRangeExtended::SetResultStringSplitRange(Call& call, ExceptionReport& report, StringParam strRef, const Zero::StringSplitRange& result)
  {
    Handle rangeHandle = call.GetState()->AllocateHeapObject(ZilchTypeId(StringSplitRangeExtended), report, HeapFlags::ReferenceCounted);
    StringSplitRangeExtended& stringRange = *(StringSplitRangeExtended*)rangeHandle.Dereference();
    stringRange.mOriginalStringReference = strRef;
    stringRange.mSplitRange = result;
    call.SetHandle(Call::Return, rangeHandle);
  }

  //***************************************************************************
  void StringRangeExtended::SetResultIterator(Call& call, ExceptionReport& report, StringParam strRef, StringRange result)
  {
    Handle rangeHandle = call.GetState()->AllocateDefaultConstructedHeapObject(ZilchTypeId(RuneIterator), report, HeapFlags::ReferenceCounted);
    RuneIterator& stringRange = *(RuneIterator*)rangeHandle.Dereference();
    stringRange.mOriginalStringReference = strRef;
    stringRange.mRange = result;
    call.SetHandle(Call::Return, rangeHandle);
  }

  //***************************************************************************
  void StringRangeExtended::GetOriginalString(Call& call, ExceptionReport& report)
  {
    StringRangeExtended* self = (StringRangeExtended*)call.GetHandle(Call::This).Dereference();

    call.SetHandle(Call::Return, &self->mOriginalStringReference);
  }

  bool StringRangeExtended::ValidateRange(StringParam strRef, const StringRange& range)
  {
    //the range is empty so it's always valid
    if(range.begin == range.end)
      return true;

    if(range.begin < strRef.begin() || range.begin > strRef.end() ||
       range.end < strRef.begin() || range.end > strRef.end() ||
       range.begin > range.end)
    {
      ExecutableState* state = ExecutableState::CallingState;
      ExceptionReport& report = *(state->StackFrames.back()->Report);
      state->ThrowException(report, "The range is invalid. Most likely the begin/end iterators were manually moved.");
      return false;
    }
    
    return true;
  }

  //-------------------------------------------------------------------StringSplitRangeSafe
  //***************************************************************************
  ZilchDefineType(StringSplitRangeExtended, "StringSplitRange", Core, builder, type)
  {
    ZilchBindDestructor(builder, type, StringRangeExtended);

    // Range interface
    builder.AddBoundProperty(type, "All", type, nullptr, &StringSplitRangeExtended::All, MemberOptions::None);
    builder.AddBoundFunction(type, "MoveNext", &StringSplitRangeExtended::MoveNext, ParameterArray(), ZilchTypeId(void), MemberOptions::None);
    builder.AddBoundProperty(type, "Current", ZilchTypeId(StringRangeExtended), nullptr, &StringSplitRangeExtended::Current, MemberOptions::None);
    builder.AddBoundProperty(type, "IsNotEmpty", ZilchTypeId(Boolean), nullptr, &StringSplitRangeExtended::IsNotEmpty, MemberOptions::None);
  }

  //***************************************************************************
  void StringSplitRangeExtended::All(Call& call, ExceptionReport& report)
  {
    call.SetHandle(Call::Return, call.GetHandle(Call::This));
  }

  //***************************************************************************
  void StringSplitRangeExtended::MoveNext(Call& call, ExceptionReport& report)
  {
    StringSplitRangeExtended* self = (StringSplitRangeExtended*)call.GetHandle(Call::This).Dereference();
    self->mSplitRange.popFront();
  }

  //***************************************************************************
  void StringSplitRangeExtended::Current(Call& call, ExceptionReport& report)
  {
    StringSplitRangeExtended* self = (StringSplitRangeExtended*)call.GetHandle(Call::This).Dereference();

    StringRangeExtended::SetResultStringRange(call, report, self->mOriginalStringReference, self->mSplitRange.front());
  }

  //***************************************************************************
  void StringSplitRangeExtended::IsNotEmpty(Call& call, ExceptionReport& report)
  {
    StringSplitRangeExtended* self = (StringSplitRangeExtended*)call.GetHandle(Call::This).Dereference();
    call.Set(Call::Return, !self->mSplitRange.empty());
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes



namespace Zilch
{
  const String ThisKeyword                ("this");
  const String ValueKeyword               ("value");
  const String PreConstructorName         ("[PreConstructor]");
  const String ConstructorName            ("[Constructor]");
  const String DestructorName             ("[Destructor]");
  const String FieldInitializerName       ("[FieldInitializer]");
  const String ExpressionLibrary          ("Expression");
  const String ExpressionProgram          ("Program");
  const String ExpressionMain             ("Main");
  const String PropertyDelegateName       ("Property");
  const String StaticAttribute            ("Static");
  const String OverrideAttribute          ("Override");
  const String VirtualAttribute           ("Virtual");
  const String HiddenAttribute            ("Hidden");
  const String ExtensionAttribute         ("Extension");
  const String CodeString                 ("CodeString");
  const String ExpressionInitializerLocal ("ExpressionInitializer");
  const String OperatorInsert             ("Add");
  const String OperatorGet                ("Get");
  const String OperatorSet                ("Set");
  const String UnknownOrigin              ("<Unknown>");
  const String EmptyLowerIdentifier       ("value");
  const String EmptyUpperIdentifier       ("Value");
  const String DefaultLibraryName         ("Library");
  

  //***************************************************************************
  String BuildGetterName(String name)
  {
    return BuildString("[Get", name, "]");
  }

  //***************************************************************************
  String BuildSetterName(String name)
  {
    return BuildString("[Set", name, "]");
  }

  //***************************************************************************
  String ReplaceStringEscapes(StringRange input)
  {
    StringBuilder builder;

    // Whether or not we hit the escape character '\'
    bool isEscape = false;

    // Walk through all the input characters
    for (size_t i = 0; i < input.size(); ++i)
    {
      // Grab the current character
      char c = input[i];

      // If we hit the escape character...
      if (isEscape)
      {
        // Based on the escaped character type...
        switch (c)
        {
          // All these characters just get directly inserted as themselves
          case '"':
          case '`':
          case '\\':
            builder.Append(c);
            break;

          // These characters have special meanings or ascii values
          case '0':
            builder.Append('\0');
            break;
          case 'a':
            builder.Append('\a');
            break;
          case 'b':
            builder.Append('\b');
            break;
          case 'f':
            builder.Append('\f');
            break;
          case 'n':
            builder.Append('\n');
            break;
          case 'r':
            builder.Append('\r');
            break;
          case 't':
            builder.Append('\t');
            break;
          case 'v':
            builder.Append('\v');
            break;
          default:
            builder.Append(c);
            Error("Hit a character that shouldn't have been escaped (should have been caught by the tokenizer)");
            break;
        }

        // No matter what, we've already handled the escape
        isEscape = false;
      }
      else if (c == '\\')
      {
        isEscape = true;
      }
      else
      {
        // Otherwise, we just hit a normal character
        builder.Append(c);
      }
    }

    // Return the resulting string
    return builder.ToString();
  }

  //***************************************************************************
  bool IsZilchQuoteCharacter(char c)
  {
    return c == '"' || c == '`';
  }

  //***************************************************************************
  StringRange StripStringQuotes(StringRange input)
  {
    // Error checking
    ErrorIf(input.size() < 2, "A string cannot contain quotes on both ends if it has a size less than 2");
    ErrorIf(IsZilchQuoteCharacter(input[0]) == false, "The starting character was not a Zilch quotation");
    ErrorIf(IsZilchQuoteCharacter(input[input.size() - 1]) == false, "The ending character was not a Zilch quotation");

    // Move the beginning inward and the end backwards by 1 to strip the quotes
    ++input.begin;
    --input.end;

    return input;
  }

  //***************************************************************************
  String ReplaceStringEscapesAndStripQuotes(StringRange input)
  {
    // Strip the quotes
    input = StripStringQuotes(input);

    // Now perform the string replacements
    return ReplaceStringEscapes(input);
  }

  //***************************************************************************
  String ToLowerCamelCase(StringRange input)
  {
    if (input.empty())
      return String();

    int firstCharacter = input[0];
    firstCharacter = tolower(firstCharacter);
    return BuildString(String((char)firstCharacter), input.sub_string(1, input.size() - 1));
  }

  //***************************************************************************
  String ToUpperCamelCase(StringRange input)
  {
    if (input.empty())
      return String();

    int firstCharacter = input[0];
    firstCharacter = toupper(firstCharacter);
    return BuildString(String((char)firstCharacter), input.sub_string(1, input.size() - 1));
  }
}
/**************************************************************\
* Author: Joshua Davis
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/






namespace Zilch
{
  //***************************************************************************
  StubCode::StubCode() :
    SetNativeLocations(false)
  {
  }
  
  //***************************************************************************
  String StubCode::Finalize()
  {
    // Stringify the builder
    String finalCode = this->Builder.ToString();

    // Walk through all native locations and set the code portion
    ZilchForEach(CodeLocation* location, this->NativeLocations.all())
      location->Code = finalCode;

    return finalCode;
  }
  
  //***************************************************************************
  bool SendsEventSorter(SendsEvent& lhs, SendsEvent& rhs)
  {
    // Sort from A to Z
    int compareName = lhs.Name.CompareTo(rhs.Name);
    if (compareName == -1)
      return true;
    if (compareName == 1)
      return false;

    // The names are equal, so now we need to compare the type names (this can be slow in some cases)
    if (lhs.ResultType->ToString() < rhs.ResultType->ToString())
      return true;
    return false;
  }

  //***************************************************************************
  bool PropertySorter(Property* lhs, Property* rhs)
  {
    // Sort from A to Z (properties should be unique, so no need to sort them by type)
    return lhs->Name < rhs->Name;
  }

  //***************************************************************************
  bool FunctionSorter(Function* lhs, Function* rhs)
  {
    // Sort the entire stringified function (this sorts the signature and the parameters)
    return lhs->ToString() < rhs->ToString();
  }
  
  //***************************************************************************
  void StubCode::Generate(BoundType* type)
  {
    ZilchCodeBuilder& codeBuilder = this->Builder;
    CodeFormat& format = codeBuilder.Format;
    
    this->StartNativeLocation(type->Location);
    this->GenerateHeader(type);

    ZilchTodo("We may want to handle attributes for GetEventHandlerFunction being non-null (may be an interface) / CreatableInScript / Native");


    if (type->CopyMode == TypeCopyMode::ReferenceType)
    {
      codeBuilder.WriteKeywordOrSymbol(Grammar::Class);
    }
    else
    {
      switch (type->SpecialType)
      {
        case SpecialType::Enumeration:
          codeBuilder.WriteKeywordOrSymbol(Grammar::Enumeration);
          break;
        case SpecialType::Flags:
          codeBuilder.WriteKeywordOrSymbol(Grammar::Flags);
          break;
        case SpecialType::Standard:
          codeBuilder.WriteKeywordOrSymbol(Grammar::Struct);
          break;
      }
    }

    codeBuilder.WriteSpace();

    this->StartNativeLocation(type->NameLocation);
    codeBuilder.Write(type->Name);
    this->EndNativeLocation(type->NameLocation);

    if (type->BaseType != nullptr)
    {
      codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::Inheritance, format.SpaceStyleInheritanceColon, format.SpaceStyleGlobalDefaultColon);
      codeBuilder.Write(type->BaseType->Name);

      ZilchForEach(BoundType* interfaceType, type->InterfaceTypes.all())
      {
        codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::ArgumentSeparator, format.SpaceStyleInheritanceComma, format.SpaceStyleGlobalDefaultComma);
        codeBuilder.Write(interfaceType->Name);
      }
    }

    codeBuilder.BeginScope(ScopeType::Class);
    codeBuilder.WriteLineIndented();

    SendsEventArray sendsEventsSorted = type->SendsEvents;
    sort(sendsEventsSorted.all(), SendsEventSorter);
    ZilchForEach(SendsEvent& sendsEvent, sendsEventsSorted.all())
    {
      this->Generate(&sendsEvent);
    }
  
    PropertyArray allPropertiesSorted = type->AllProperties;
    sort(allPropertiesSorted.all(), PropertySorter);
    ZilchForEach(Property* property, allPropertiesSorted.all())
    {
      this->Generate(property);
    }

    this->Generate(type->Constructors);
    if (type->Destructor != nullptr)
      this->Generate(type->Destructor);
    this->Generate(type->AllFunctions);

    codeBuilder.EndScope();
    this->EndNativeLocation(type->Location);
  }
  
  //***************************************************************************
  void StubCode::Generate(FunctionArray& functions)
  {
    ZilchCodeBuilder& codeBuilder = this->Builder;
    CodeFormat& format = codeBuilder.Format;

    // Loop through all the provided functions
    FunctionArray functionsSorted = functions;
    sort(functionsSorted.all(), FunctionSorter);
    ZilchForEach(Function* function, functionsSorted.all())
    {
      this->Generate(function);
    }
  }
  
  //***************************************************************************
  void StubCode::Generate(Function* function)
  {
    ZilchCodeBuilder& codeBuilder = this->Builder;
    CodeFormat& format = codeBuilder.Format;

    // If this is a property get or set, then skip it
    if (function->IsPropertyGetOrSet)
      return;
    
    this->StartNativeLocation(function->Location);
    this->GenerateHeader(function);
    ZilchTodo("IsStatic");

    // If this is a constructor...
    if (function->Name == ConstructorName)
    {
      this->StartNativeLocation(function->NameLocation);
      codeBuilder.WriteKeywordOrSymbol(Grammar::Constructor);
      this->EndNativeLocation(function->NameLocation);
    }
    else if (function->Name == DestructorName)
    {
      this->StartNativeLocation(function->NameLocation);
      codeBuilder.WriteKeywordOrSymbol(Grammar::Destructor);
      this->EndNativeLocation(function->NameLocation);
    }
    // Otherwise we assume its a normal named function
    else
    {
      codeBuilder.WriteKeywordOrSymbol(Grammar::Function);
      codeBuilder.WriteSpace();
      this->StartNativeLocation(function->NameLocation);
      codeBuilder.Write(function->Name);
      this->EndNativeLocation(function->NameLocation);
    }

    codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginFunctionParameters, format.SpaceStyleFunctionDefinitionBeginParenthesis, format.SpaceStyleGlobalDefaultParenthesis);

    ZilchForRange(DelegateParameter& parameter, parameterRange, function->FunctionType->Parameters.all())
    {
      codeBuilder.Write(parameter.Name);
      codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::TypeSpecifier, format.SpaceStyleTypeColon, format.SpaceStyleGlobalDefaultColon);
      codeBuilder.Write(parameter.ParameterType->ToString());

      if (parameterRange.empty() == false)
        codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::ArgumentSeparator, format.SpaceStyleFunctionCallParameterComma, format.SpaceStyleGlobalDefaultComma);
    }

    codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndFunctionParameters, format.SpaceStyleFunctionDefinitionEndParenthesis, format.SpaceStyleGlobalDefaultParenthesis);
    codeBuilder.WriteKeywordOrSymbol(Grammar::StatementSeparator);

    this->EndNativeLocation(function->Location);

    codeBuilder.WriteLineIndented();
    codeBuilder.WriteLineIndented();
  }

  //***************************************************************************
  void StubCode::Generate(SendsEvent* sends)
  {
    ZilchCodeBuilder& codeBuilder = this->Builder;
    CodeFormat& format = codeBuilder.Format;
    
    codeBuilder.WriteKeywordOrSymbol(Grammar::Sends);
    codeBuilder.WriteSpace();
    codeBuilder.Write(sends->Name);
    codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::TypeSpecifier, format.SpaceStyleTypeColon, format.SpaceStyleGlobalDefaultColon);
    codeBuilder.Write(sends->ResultType->ToString());
    codeBuilder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
    codeBuilder.WriteLineIndented();
  }
  
  //***************************************************************************
  void StubCode::Generate(Property* property)
  {
    ZilchCodeBuilder& codeBuilder = this->Builder;
    CodeFormat& format = codeBuilder.Format;
    
    this->StartNativeLocation(property->Location);

    this->GenerateHeader(property);
    ZilchTodo("IsStatic / IsHiddenWhenNull");
    codeBuilder.WriteKeywordOrSymbol(Grammar::Variable);
    codeBuilder.WriteSpace();
    
    this->StartNativeLocation(property->NameLocation);
    codeBuilder.Write(property->Name);
    this->EndNativeLocation(property->NameLocation);

    codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::TypeSpecifier, format.SpaceStyleTypeColon, format.SpaceStyleGlobalDefaultColon);
    codeBuilder.Write(property->PropertyType->ToString());

    // If type is a field (no get/set, just a raw data member)
    Field* field = TypeBinding::DynamicCast<Field*>(property);
    if (field != nullptr)
    {
      codeBuilder.WriteKeywordOrSymbol(Grammar::ArgumentSeparator);

      // We do this again below (but that's alright!)
      // We need to do this here so the get/set locations will be correct
      this->EndNativeLocation(property->Location);

      if (this->SetNativeLocations)
      {
        if (field->Get != nullptr)
        {
          field->Get->Location = property->Location;
          field->Get->NameLocation = property->NameLocation;
        }
        if (field->Set != nullptr)
        {
          field->Set->Location = property->Location;
          field->Set->NameLocation = property->NameLocation;
        }
      }
    }
    // Otherwise type is a property
    else
    {
      codeBuilder.WriteSpace();
      codeBuilder.WriteKeywordOrSymbol(Grammar::BeginScope);
      codeBuilder.WriteSpace();

      if (property->Get != nullptr)
      {
        this->StartNativeLocation(property->Location);
        this->StartNativeLocation(property->NameLocation);
        codeBuilder.WriteKeywordOrSymbol(Grammar::Get);
        this->EndNativeLocation(property->NameLocation);
        this->EndNativeLocation(property->Location);

        codeBuilder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
        codeBuilder.WriteSpace();
      }

      if (property->Set != nullptr)
      {
        this->StartNativeLocation(property->Location);
        this->StartNativeLocation(property->NameLocation);
        codeBuilder.WriteKeywordOrSymbol(Grammar::Set);
        this->EndNativeLocation(property->NameLocation);
        this->EndNativeLocation(property->Location);

        codeBuilder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
        codeBuilder.WriteSpace();
      }

      codeBuilder.WriteKeywordOrSymbol(Grammar::EndScope);
    }

    this->EndNativeLocation(property->Location);

    codeBuilder.WriteLineIndented();
    codeBuilder.WriteLineIndented();
  }

  //***************************************************************************
  void StubCode::GenerateHeader(DocumentedObject* object)
  {
    ZilchCodeBuilder& codeBuilder = this->Builder;
    CodeFormat& format = codeBuilder.Format;

    // We don't actually have a grammar symbol for single line comment (we should probably make it one...)
    String wrappedDescription = Zero::WordWrap(object->Description, format.CommentWordWrapLength);
    ZilchForEach(StringRange line, wrappedDescription.Split("\n"))
    {
      codeBuilder.WriteSingleLineComment(line);
      codeBuilder.WriteLineIndented();
    }

    ZilchTodo("We may want to handle the 'IsHidden' attribute specially here because it may not exist inside 'Attributes'");

    // Write out all attributes
    ZilchForEach(Attribute& attribute, object->Attributes.all())
    {
      codeBuilder.WriteKeywordOrSymbol(Grammar::BeginAttribute);
      codeBuilder.Write(attribute.Name);
      codeBuilder.WriteKeywordOrSymbol(Grammar::BeginFunctionCall);

      size_t parameterCount = attribute.Parameters.size();
      size_t lastParameter = parameterCount - 1;
      for (size_t i = 0; i < parameterCount; ++i)
      {
        AttributeParameter& parameter = attribute.Parameters[i];
        if (parameter.Name.empty() == false)
        {
          codeBuilder.Write(parameter.Name);
          codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::NameSpecifier, format.SpaceStyleNamedArgumentColon, format.SpaceStyleGlobalDefaultColon);
        }

        codeBuilder.Write(parameter.Token);

        if (i != lastParameter)
          codeBuilder.WriteKeywordOrSymbolSpaceStyle(Grammar::ArgumentSeparator, format.SpaceStyleFunctionCallParameterComma, format.SpaceStyleGlobalDefaultComma);
      }

      codeBuilder.WriteKeywordOrSymbol(Grammar::EndFunctionCall);
      codeBuilder.WriteKeywordOrSymbol(Grammar::EndAttribute);
    }

    if (object->Attributes.empty() == false)
      codeBuilder.WriteLineIndented();
  }
  
  //***************************************************************************
  void StubCode::StartNativeLocation(CodeLocation& location)
  {
    // If we're not tracking native locations, or this location isn't native then early out
    // Note: Non-native locations should already be set by the tokenizer/parser/syntaxer
    if (this->SetNativeLocations == false || location.IsNative == false)
      return;

    // Track this location so that we can set the 'Code' portion when we finalize this stub code
    this->NativeLocations.push_back(&location);
    
    ZilchCodeBuilder& codeBuilder = this->Builder;
    location.Origin = this->GeneratedOriginOrName;
    location.StartLine = codeBuilder.GetLine();
    location.PrimaryLine = codeBuilder.GetLine();
    location.EndLine = codeBuilder.GetLine();
    //location.StartCharacter;
    //location.PrimaryCharacter;
    //location.EndCharacter;
    location.StartPosition = codeBuilder.GetSize();
    location.PrimaryPosition = codeBuilder.GetSize();
    location.EndPosition = codeBuilder.GetSize();
  }
  
  //***************************************************************************
  void StubCode::EndNativeLocation(CodeLocation& location)
  {
    // If we're not tracking native locations, or this location isn't native then early out
    // Note: Non-native locations should already be set by the tokenizer/parser/syntaxer
    if (this->SetNativeLocations == false || location.IsNative == false)
      return;

    ZilchCodeBuilder& codeBuilder = this->Builder;
    location.EndLine = codeBuilder.GetLine();
    //location.EndCharacter;
    location.EndPosition = codeBuilder.GetSize();
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes

















namespace Zilch
{
  //***************************************************************************
  void TypingContext::Clear(bool tolerantMode)
  {
    // If we're not in tolerant mode, we better not have anything in our context
    ErrorIf(tolerantMode == false && this->ClassTypeStack.empty() == false,
      "Classes still leftover in the typing context after it was done being used");
    ErrorIf(tolerantMode == false && this->FunctionStack.empty() == false,
      "Functions still leftover in the typing context after it was done being used");

    // Always clear everything from the context, regardless of the mode (just for safety)
    this->ClassTypeStack.clear();
    this->FunctionStack.clear();
  }

  //***************************************************************************
  Syntaxer::Syntaxer(CompilationErrors& errors) :
    Errors(errors),
    Builder(nullptr),
    Tree(nullptr),
    ParentProject(nullptr),
    Dependencies(nullptr),
    ClassWalker(&errors),
    MemberWalker(&errors),
    FunctionWalker(&errors),
    TypingWalker(&errors),
    ExpressionWalker(&errors)
  {
    ZilchErrorIfNotStarted(Syntaxer);

    // Collect all the classes first
    // We need to do a pass over all classes in the entire code base because if
    // anything references a type name later on, we need to be able to resolve it
    // or know if it's an error on the spot!
    this->ClassWalker.Register(&Syntaxer::CollectClass);
    this->ClassWalker.Register(&Syntaxer::CollectEnum);

    // We need to walk every expression, every node, every place where we could find types
    // We basically need to collect all uses of templates
    this->TemplateWalker.RegisterNonLeafBase(&Syntaxer::CollectTemplateInstantiations);

    // The next pass we do, we dive into each class definition and pull out member variables
    // and property declarations. This is so that if we reference anything using the member
    // access operator '.' in the next pass, then we know if it's an error or not
    this->MemberWalker.Register(&Syntaxer::CollectClassInheritance);
    this->MemberWalker.Register(&Syntaxer::CollectSendsEvents);
    this->MemberWalker.Register(&Syntaxer::CollectEnumInheritance);
    this->MemberWalker.Register(&Syntaxer::CollectMemberVariableAndProperty);

    this->IndexerWalker.Register(&Syntaxer::IndexerBinaryOperator);
    this->IndexerWalker.Register(&Syntaxer::IndexerUnaryOperator);
    this->IndexerWalker.Register(&Syntaxer::IndexerIndexerCall);

    // We have to do functions as a separate pass since we must know
    // the sizes of all objects before doing function signatures
    // We also do parameters here because function delegate types must be done by this point
    this->FunctionWalker.Register(&Syntaxer::PushClass);
    this->FunctionWalker.Register(&Syntaxer::CollectConstructor);
    this->FunctionWalker.Register(&Syntaxer::CollectDestructor);
    this->FunctionWalker.Register(&Syntaxer::CollectFunction);
    this->FunctionWalker.Register(&Syntaxer::CollectPropertyGetSet);
    this->FunctionWalker.RegisterDerived<ParameterNode>(&Syntaxer::CheckLocalVariable);

    // Walk through the tree and attempt to assign locations to every node (class, function, etc)
    this->LocationWalker.RegisterNonLeafBase(&Syntaxer::DecorateCodeLocations);

    // Walk all any type of expression (often, expressions are nested within each other)
    this->TypingWalker.Register(&Syntaxer::PushClass);
    this->TypingWalker.RegisterDerived<ConstructorNode>(&Syntaxer::PushFunction);
    this->TypingWalker.RegisterDerived<DestructorNode>(&Syntaxer::PushFunction);
    this->TypingWalker.RegisterDerived<FunctionNode>(&Syntaxer::PushFunction);
    this->TypingWalker.Register(&Syntaxer::DecorateInitializer);
    this->TypingWalker.Register(&Syntaxer::DecorateValue);
    this->TypingWalker.Register(&Syntaxer::DecorateStringInterpolant);
    this->TypingWalker.Register(&Syntaxer::DecorateStaticTypeOrCreationCall);
    this->TypingWalker.Register(&Syntaxer::DecorateExpressionInitializer);
    this->TypingWalker.Register(&Syntaxer::DecorateMultiExpression);
    this->TypingWalker.Register(&Syntaxer::DecorateTypeId);
    this->TypingWalker.Register(&Syntaxer::DecorateCheckTypeCast);
    this->TypingWalker.Register(&Syntaxer::DecorateCheckBinaryOperator);
    this->TypingWalker.Register(&Syntaxer::DecorateCheckUnaryOperator);
    this->TypingWalker.Register(&Syntaxer::DecorateCheckPropertyDelegateOperator);
    this->TypingWalker.Register(&Syntaxer::DecorateCheckFunctionCall);
    this->TypingWalker.Register(&Syntaxer::CheckReturn);
    this->TypingWalker.Register(&Syntaxer::CheckDelete);
    this->TypingWalker.Register(&Syntaxer::CheckThrow);
    this->TypingWalker.Register(&Syntaxer::CheckMemberVariable);
    this->TypingWalker.Register(&Syntaxer::CheckLocalVariable);
    this->TypingWalker.Register(&Syntaxer::CheckWhile);
    this->TypingWalker.Register(&Syntaxer::CheckDoWhile);
    this->TypingWalker.Register(&Syntaxer::CheckFor);
    this->TypingWalker.RegisterDerived<ForEachNode>(&Syntaxer::CheckFor);
    this->TypingWalker.Register(&Syntaxer::CheckLoop);
    this->TypingWalker.Register(&Syntaxer::CheckScope);
    this->TypingWalker.Register(&Syntaxer::CheckTimeout);
    this->TypingWalker.Register(&Syntaxer::CheckIfRoot);
    this->TypingWalker.Register(&Syntaxer::CheckIf);
    this->TypingWalker.Register(&Syntaxer::CheckBreak);
    this->TypingWalker.Register(&Syntaxer::CheckContinue);
    this->TypingWalker.Register(&Syntaxer::ResolveLocalVariableReference);
    this->TypingWalker.Register(&Syntaxer::ResolveMember);

    // The last thing we do is walk all expressions and verify that r-values and l-values get treated properly
    this->ExpressionWalker.RegisterNonLeafBase(&Syntaxer::CheckExpressionIoModes);
  }

  //***************************************************************************
  Syntaxer::~Syntaxer()
  {
    // Get a list of all template root nodes
    HashMap<String, ClassNode*>::valuerange templateRootNodes = this->InternalBoundTemplates.values();

    // Loop through all the template root nodes...
    while (templateRootNodes.empty() == false)
    {
      // Get the current template and move to the next
      ClassNode* templateClassNode = templateRootNodes.front();
      templateRootNodes.popFront();

      // Delete the node (free's all the memory even of children)
      delete templateClassNode;
    }
  }

  //***************************************************************************
  void Syntaxer::ErrorAt(SyntaxNode* node, ErrorCode::Enum errorCode, ...)
  {
    // Start a variadic argument list
    va_list argList;
    va_start(argList, errorCode);

    // Call the other error function
    ErrorAtArgs(node, errorCode, argList);

    // End the argument list
    va_end(argList);
  }

  //***************************************************************************
  void Syntaxer::ErrorAtArgs(SyntaxNode* node, ErrorCode::Enum errorCode, va_list argList)
  {
    // Now call the error function
    this->Errors.RaiseArgs(node->Location, errorCode, argList);
  }

  //***************************************************************************
  Type* Syntaxer::RetrieveType(SyntaxType* syntaxType, const CodeLocation& location, const Module& dependencies)
  {
    // Store the dependencies and all their types into a map
    this->Dependencies = &dependencies;
    this->PopulateDependencies();

    // Now attempt to turn the syntax type into an actual type (or return null)
    return this->RetrieveType(syntaxType, location);
  }

  //***************************************************************************
  void Syntaxer::PopulateDependencies()
  {
    // Clear any previous stored bound types, in case we're reusing the syntaxer
    this->ExternalBoundTypes.clear();

    // Loop through all the passed in libraries
    for (size_t i = 0; i < this->Dependencies->size(); ++i)
    {
      // Get the current library
      LibraryRef library = (*this->Dependencies)[i];

      // Get a range of all bound types in the library
      BoundTypeRange libraryBoundTypes = library->BoundTypes.all();

      // Loop through all named types in the library
      while (libraryBoundTypes.empty() == false)
      {
        // Grab the current named type in the library and iterate forward
        BoundTypePair& pair = libraryBoundTypes.front();
        libraryBoundTypes.popFront();

        // If we didn't insert the type because something was in its place...
        if (this->ExternalBoundTypes.insertNoOverwrite(pair) == false)
        {
          // Add all the named true types from this library into to the hash map
          return this->Errors.Raise(CodeLocation(), ErrorCode::ExternalTypeNamesCollide,
            pair.first.c_str(),
            library->Name.c_str(),
            pair.second->SourceLibrary->Name.c_str());
        }
      }
    }
  }

  //***************************************************************************
  void Syntaxer::FindDependencyCycles(BoundType* type, HashMap<BoundType*, DependencyState::Enum>& dependencies, const CodeLocation& location)
  {
    // Based on the current dependency state of the type
    switch (dependencies[type])
    {
      case DependencyState::BeingDetermined:
      {
        // This is an error, since we should never try to determine the size of an object again
        // whilst its already being determined from a parent call (it indicates a cycle of aggrigation)
        // This should actually be a compiler error
        this->Errors.Raise(location, ErrorCode::CompositionCycleDetected);
        return;
      }
      
      case DependencyState::Undetermined:
      {
        // We're in the middle of determining this type's dependencies now
        // If we ever attempt to walk this class again, (see the above case) then we know
        // that there was a cycle of dependencies!
        dependencies[type] = DependencyState::BeingDetermined;

        // If we have a base class type and its in the same library...
        BoundType* baseType = type->BaseType;
        if (baseType != nullptr && baseType->SourceLibrary == type->SourceLibrary)
          this->FindDependencyCycles(baseType, dependencies, baseType->Location);

        // Loop through all the members
        FieldMapRange allFields = type->InstanceFields.all();
        while (allFields.empty() == false)
        {
          // Get the member
          Field& field = *allFields.front().second;
          allFields.popFront();

          // We only care about computing the size of the type if it's a value type
          if (Type::IsValueType(field.PropertyType))
          {
            BoundType* propertyType = nullptr;
            
            if (field.PropertyType->SourceLibrary == type->SourceLibrary)
              propertyType = TypeBinding::DynamicCast<BoundType*>(field.PropertyType);

            if (propertyType)
              this->FindDependencyCycles(propertyType, dependencies, field.Location);
          }
        }

        // We finished walking all the dependencies for this type
        dependencies[type] = DependencyState::Completed;
      }
      return;
    }
  }

  //***************************************************************************
  void Syntaxer::ApplyToTree
  (
    SyntaxTree& syntaxTree,
    LibraryBuilder& builder,
    Project& project,
    const Module& dependencies
  )
  {
    // Store syntaxer state
    this->Tree = &syntaxTree;
    this->ParentProject = &project;

    // Store the builder so we can add things to it as we run the syntaxer
    this->Builder = &builder;

    // Store the dependencies and all their types into a map
    this->Dependencies = &dependencies;
    this->PopulateDependencies();

    // Add our own builder's library to the mix
    this->AllLibraries.push_back(builder.BuiltLibrary);

    // Copy over all the dependencies into our library array
    this->AllLibraries.insert(this->AllLibraries.end(), this->Dependencies->all());

    // Note: Technically with single expression mode, we should only have to evaluate
    // the types of just the expression (no class/member gathering, etc)
    // However, the expression COULD be referring to a template, which may need to be instantiated

    // Collect all the class types first
    ClassContext classContext;
    this->ClassWalker.Walk(this, syntaxTree.Root, &classContext);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Walk the tree and look for any template instantiations
    this->TemplateWalker.Walk(this, syntaxTree.Root, &classContext);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Walk the tree and collect members
    TypingContext typingContext;
    this->MemberWalker.Walk(this, syntaxTree.Root, &typingContext);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Loop through all class nodes
    for (size_t i = 0; i < syntaxTree.Root->Classes.size(); ++i)
    {
      // Grab the current node
      ClassNode* node = syntaxTree.Root->Classes[i];
      if (node == nullptr)
        continue;

      // Send out an event letting the user know that we just parsed this type (but its members have yet to be parsed)
      // NOTE: The user may add things to the library such as extension properties, or more...
      ParseEvent toSend;
      toSend.Builder = this->Builder;
      toSend.Type = node->Type;
      toSend.Location = &node->Location;
      EventSend(this->ParentProject, Events::TypeParsed, &toSend);
    }

    // Loop through all enum nodes
    for (size_t i = 0; i < syntaxTree.Root->Enums.size(); ++i)
    {
      // Grab the current node
      EnumNode* node = syntaxTree.Root->Enums[i];
      if (node == nullptr)
        continue;
      
      // Send out an event letting the user know that we just parsed this type (but its members have yet to be parsed)
      // NOTE: The user may add things to the library such as extension properties, or more...
      ParseEvent toSend;
      toSend.Builder = this->Builder;
      toSend.Type = node->Type;
      toSend.Location = &node->Location;
      EventSend(this->ParentProject, Events::TypeParsed, &toSend);
    }

    // We've collected all the classes we're compiling, as well as the members
    // Loop through all the classes and look for cycles of dependencies
    HashMap<BoundType*, DependencyState::Enum> dependencyStates;
    for (size_t i = 0; i < classContext.AllClasses.size(); ++i)
    {
      // Grab the current class type
      BoundType* type = classContext.AllClasses[i];

      this->FindDependencyCycles(type, dependencyStates, type->Location);
    }

    // Clear the typing context after every use (not necessary, except in tolerant mode)
    typingContext.Clear(this->Errors.TolerantMode);

    // Walk the tree and re-arrange the indexer node
    this->IndexerWalker.Walk(this, syntaxTree.Root, &typingContext);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    SyntaxNode::FixParentPointers(syntaxTree.Root, nullptr);

    // Clear the typing context after every use (not necessary, except in tolerant mode)
    typingContext.Clear(this->Errors.TolerantMode);

    // Walk the tree and give functions types
    this->FunctionWalker.Walk(this, syntaxTree.Root, &typingContext);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Clear the typing context after every use (not necessary, except in tolerant mode)
    typingContext.Clear(this->Errors.TolerantMode);

    // Now actually walk the code and do all the checking
    this->LocationWalker.Walk(this, syntaxTree.Root, &typingContext);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Generate field properties here (after the sizing has been computed)
    builder.GenerateGetSetFields();

    // Clear the typing context after every use (not necessary, except in tolerant mode)
    typingContext.Clear(this->Errors.TolerantMode);

    // Now actually walk the code and do all the checking
    this->TypingWalker.Walk(this, syntaxTree.Root, &typingContext);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Clear the typing context after every use (not necessary, except in tolerant mode)
    typingContext.Clear(this->Errors.TolerantMode);

    // Lastly, we walk expressions to verify that all reads/writes were properly handled
    this->ExpressionWalker.Walk(this, syntaxTree.Root, &typingContext);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Clear the typing context after every use (not necessary, except in tolerant mode)
    typingContext.Clear(this->Errors.TolerantMode);
  }

  //***************************************************************************
  void Syntaxer::ReplaceTypes(SyntaxTypes& typesToReplace, Array<const UserToken*>& names, const BoundSyntaxType* instanceType, const CodeLocation& location)
  {
    // Loop through all the node's types
    for (size_t i = 0; i < typesToReplace.size(); ++i)
    {
      // Get the current type
      SyntaxType*& typeToReplace = *typesToReplace[i];

      // If the type we're looking at is a bound syntax type...
      if (BoundSyntaxType* dataTypeToReplace = TypeBinding::DynamicCast<BoundSyntaxType*>(typeToReplace))
      {
        // Loop through all the template names
        for (size_t j = 0; j < names.size(); ++j)
        {
          // Get the current template argument name
          const String& name = names[j]->Token;
          
          // Compare the data type name with each of the template argument type names
          if (dataTypeToReplace->TypeName == name)
          {
            // If the name matches, simply replace the name with what was passed in
            SyntaxType* replaceWithType = instanceType->TemplateArguments[j];

            // If the type we're currently replacing is a template, we have special logic...
            if (dataTypeToReplace->IsTemplateInstantiation())
            {
              // If the type we're replacing with is a data type
              if (BoundSyntaxType* replaceWithDataType = TypeBinding::DynamicCast<BoundSyntaxType*>(replaceWithType))
              {
                // We cannot replace a template type with another templated type
                if (replaceWithDataType->IsTemplateInstantiation() == false)
                {
                  dataTypeToReplace->TypeName = replaceWithDataType->TypeName;
                }
                else
                {
                  // We cannot perform the replacement of a templated arugment list with a non templatable type
                  return this->Errors.Raise(location, ErrorCode::CannotReplaceTemplateInstanceWithTemplateArguments);
                }
              }
              else
              {
                // We cannot perform the replacement of a templated arugment list with a non templatable type
                return this->Errors.Raise(location, ErrorCode::CannotReplaceTemplateInstanceWithTemplateArguments);
              }
            }
            else
            {
              // Otherwise, we just do a full replacement :)
              // We MUST do a clone here or else we'll get a double delete situation
              typeToReplace = (SyntaxType*)replaceWithType->Clone();
            }
          }
        }
      }

      // Traverse the syntax type recursively and apply the replacement
      this->PerformTemplateReplacement(typeToReplace, names, instanceType);

      // If we had an error, return out early
      if (this->Errors.WasError)
        return;
    }
  }

  //***************************************************************************
  void Syntaxer::PerformTemplateReplacement(SyntaxType* type, Array<const UserToken*>& names, const BoundSyntaxType* instanceType)
  {
    // Get all the syntax types from this node
    SyntaxTypes types;
    type->PopulateSyntaxTypes(types);

    // Perform recursive replacements of types
    this->ReplaceTypes(types, names, instanceType, CodeLocation());
  }

  //***************************************************************************
  void Syntaxer::PerformTemplateReplacement(SyntaxNode* node, Array<const UserToken*>& names, const BoundSyntaxType* instanceType)
  {
    // Get the children for the current node
    NodeChildren children;
    node->PopulateChildren(children);

    // Loop through all the children...
    for (size_t i = 0; i < children.size(); ++i)
    {
      // Get the current child
      SyntaxNode*& child = *children[i];

      // Traverse to that child recursively and apply the replacement
      this->PerformTemplateReplacement(child, names, instanceType);

      // If we had an error, return out early
      if (this->Errors.WasError)
        return;
    }

    // Get all the syntax types from this node
    SyntaxTypes types;
    node->PopulateSyntaxTypes(types);

    // Perform recursive replacements of types
    this->ReplaceTypes(types, names, instanceType, node->Location);
  }

  //***************************************************************************
  BoundType* Syntaxer::RetrieveBoundType(BoundSyntaxType* type, const CodeLocation& location)
  {
    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // In tolerant mode, it is possible to get here and not have the template instantiation replaced
    // because templates are currently not exported in the library (which is reused by code completion)
    // and only the current class we're writing is actually parsed/seen by code completion
    if (this->Errors.TolerantMode == false)
    {
      // Error checking
      ErrorIf(type->IsTemplateInstantiation(),
        "All template instantiations should have been resolved by the TemplateWalker");

      // We ignore the builder not being set in tolerant mode
      ErrorIf(this->Builder == nullptr, "Attempted to retrieve a type without a builder being set");
    }

    // Make sure we have a valid builder, since this function can get called without one
    if (this->Builder != nullptr)
    {
      // Check to see if we found the type
      if (BoundType* namedType = this->Builder->FindBoundType(type->TypeName))
      {
        // Return the found type...
        type->ResolvedType = namedType;
        return namedType;
      }
    }

    // Check to see if we found the type
    if (BoundType* namedType = this->ExternalBoundTypes.findValue(type->TypeName, nullptr))
    {
      // Return the found type...
      type->ResolvedType = namedType;
      return namedType;
    }

    // If we stopped here, it means the user referenced a type that wasn't defined
    this->Errors.Raise(location, ErrorCode::ReferenceToUndefinedType, type->ToString().c_str());

    // Return null since we don't have a valid type!
    return core.ErrorType;
  }

  //***************************************************************************
  Type* Syntaxer::RetrieveType(SyntaxType* syntaxType, const CodeLocation& location)
  {
    // Get the instance of the type database
    Core& core = Core::GetInstance();
    
    // If the syntax type is an 'any' syntax type...
    if (TypeBinding::DynamicCast<AnySyntaxType*>(syntaxType) != nullptr)
    {
      // We only ever have one instance of this type
      syntaxType->ResolvedType = core.AnythingType;
      return core.AnythingType;
    }
    // If the syntax type is an indirection syntax type...
    else if (IndirectionSyntaxType* indirectionSyntaxType = TypeBinding::DynamicCast<IndirectionSyntaxType*>(syntaxType))
    {
      // Get our type as a named syntax type
      SyntaxType* referencedType = indirectionSyntaxType->ReferencedType;
      BoundSyntaxType* boundSyntaxType = TypeBinding::DynamicCast<BoundSyntaxType*>(referencedType);

      // We're only allowed to refer to a named type
      if (boundSyntaxType == nullptr)
      {
        // The type must not be a named type...
        this->Errors.Raise(location, ErrorCode::ReferencesOnlyToNamedValueTypes, referencedType->ToString().c_str());
        return core.ErrorType;
      }

      // Grab the type it is referring to...
      BoundType* type = this->RetrieveBoundType(boundSyntaxType, location);

      // If the type is not a value type, then we cannot form a reference to it
      if (type->CopyMode == TypeCopyMode::ReferenceType)
      {
        // The ref keyword can only be used to refer to value types
        this->Errors.Raise(location, ErrorCode::ReferencesOnlyToNamedValueTypes, referencedType->ToString().c_str());
        return core.ErrorType;
      }

      // Return the result of attempting to find or create the type from a true type and its qualifiers
      IndirectionType* indirectType = this->Builder->ReferenceOf(type);
      syntaxType->ResolvedType = indirectType;
      return indirectType;
    }
    // If the syntax type is a named syntax type...
    else if (BoundSyntaxType* boundSyntaxType = TypeBinding::DynamicCast<BoundSyntaxType*>(syntaxType))
    {
      // Find types by name since it's a data type
      BoundType* boundType = this->RetrieveBoundType(boundSyntaxType, location);
      syntaxType->ResolvedType = boundType;
      return boundType;
    }
    // If the syntax type is a delegate syntax type...
    else if (DelegateSyntaxType* delegateSyntaxType = TypeBinding::DynamicCast<DelegateSyntaxType*>(syntaxType))
    {
      // Store the return type
      Type* returnType = nullptr;
      
      // Store all the delegate parameters
      ParameterArray parameters;

      // Loop through all the parameters
      for (size_t i = 0; i < delegateSyntaxType->Parameters.size(); ++i)
      {
        // Get the syntax parameter
        const DelegateSyntaxParameter& syntaxParameter = delegateSyntaxType->Parameters[i];

        // Add the next parameter to the list
        DelegateParameter& parameter = parameters.push_back();
        parameter.Name = syntaxParameter.Name->Token;
        parameter.ParameterType = this->RetrieveType(syntaxParameter.Type, location);
      }

      // Loop through all the returns
      if (delegateSyntaxType->Return != nullptr)
      {
        // Set the return type of the delegate (resolve the proper type)
        returnType = this->RetrieveType(delegateSyntaxType->Return, location);
      }
      else
      {
        // Otherwise, there is no return type (use void)
        returnType = core.VoidType;
      }

      // Return the delegate type after adding or merging into the set
      DelegateType* delegateType = this->Builder->GetDelegateType(parameters, returnType);
      syntaxType->ResolvedType = delegateType;
      return delegateType;
    }

    // If we stopped here, it means the user referenced a type that wasn't defined
    this->Errors.Raise(location, ErrorCode::ReferenceToUndefinedType, syntaxType->ToString().c_str());

    // We return a special error type because it makes it so we crash less on null pointers
    return core.ErrorType;
  }
  
  //***************************************************************************
  void Syntaxer::ReadAttributes(SyntaxNode* parentNode, NodeList<AttributeNode>& nodes, Array<Attribute>& attributesOut)
  {
    // Go through all attributes and attach them to the class type
    for (size_t i = 0; i < nodes.size(); ++i)
    {
      // Add each attribute string to the class attributes
      AttributeNode* attributeNode = nodes[i];
      Attribute& attribute = attributesOut.push_back();
      attribute.Name = attributeNode->TypeName->Token;
      
      // If the attribute node has a function call...
      FunctionCallNode* attributeCall = attributeNode->AttributeCall;
      if (attributeCall != nullptr)
      {
        // To avoid later errors, set the io modes of the function call
        attributeCall->Io = IoMode::ReadRValue;
        attributeCall->IoUsage = IoMode::Ignore;

        // Loop through all the arguments to the function call
        for (size_t i = 0; i < attributeCall->Arguments.size(); ++i)
        {
          // Grab the current argument value
          ExpressionNode* argument = attributeCall->Arguments[i];

          // We only support literals in the attribute arguments
          ValueNode* literalArgument = TypeBinding::DynamicCast<ValueNode*>(argument);
          TypeIdNode* typeId = TypeBinding::DynamicCast<TypeIdNode*>(argument);
          
          // If this isn't a literal argument, give an error
          if (literalArgument == nullptr && typeId == nullptr)
            return this->ErrorAt(argument, ErrorCode::AttributeArgumentMustBeLiteral);

          // We also only accept type ids that directly take a type (not an expression)
          if (typeId != nullptr && typeId->CompileTimeSyntaxType == nullptr)
            return this->ErrorAt(argument, ErrorCode::AttributeArgumentMustBeLiteral);
          
          // Just so we don't get any errors complaining later, give this things an io mode
          argument->Io = IoMode::ReadRValue;
          argument->IoUsage = IoMode::Ignore;

          // Add the parameter to the attribute
          AttributeParameter& parameter = attribute.Parameters.push_back();

          // If this argument has a name...
          if (i < attributeCall->ArgumentNames.size())
            parameter.Name = attributeCall->ArgumentNames[i];

          // If this was a literal value...
          if (literalArgument != nullptr)
          {
            // Store the original token text, just in case the user wants it
            parameter.Token = literalArgument->Value.Token;

            // Check to see what type of literal we have here
            switch (literalArgument->Value.TokenId)
            {
              // The value is an number
              case Grammar::IntegerLiteral:
              case Grammar::DoubleIntegerLiteral:
              case Grammar::RealLiteral:
              case Grammar::DoubleRealLiteral:
              {
                parameter.Type = AttributeType::Number;
                parameter.NumberValue = atof(parameter.Token.c_str());
                break;
              }

              // The value is a String
              case Grammar::StringLiteral:
              {
                parameter.Type = AttributeType::String;
                parameter.StringValue = ReplaceStringEscapesAndStripQuotes(parameter.Token);
                break;
              }

              // The value is a Bool
              case Grammar::True:
              case Grammar::False:
              {
                parameter.Type = AttributeType::Boolean;
                parameter.BooleanValue = (literalArgument->Value.TokenId == Grammar::True);
                break;
              }

              // The value is a null (which means that the type is unknown)
              case Grammar::Null:
              {
                parameter.Type = AttributeType::Null;
                break;
              }

              default:
              {
                // We don't know what type it is???
                // This especially should not be an identifier, since identifiers are caught as VariableReferences
                return ErrorAt(parentNode, ErrorCode::GenericError,
                  "The literal in an attribute's argument list was of an unknown token type.");
              }
            }
          }
          // It must be a typeid...
          else
          {
            ErrorIf(typeId == nullptr, "The attribute argument wasn't a literal value or a typeid, but we should have validated that above");

            // Store the original token text, just in case the user wants it
            parameter.Token = typeId->CompileTimeSyntaxType->ToString();
            parameter.Type = AttributeType::Type;
            parameter.StringValue = parameter.Token;
          }
        }
      }
    }
  }

  //***************************************************************************
  void Syntaxer::SetupFunctionLocation(Function* function, const CodeLocation& location, const CodeLocation& nameLocation)
  {
    function->Location = location;
    function->NameLocation = nameLocation;

    // We also want to set the location of 'this' to just point at the function name
    Variable* thisVariable = function->This;
    if (thisVariable != nullptr)
    {
      thisVariable->Location = function->NameLocation;
      thisVariable->NameLocation = function->NameLocation;
    }
  }

  //***************************************************************************
  void Syntaxer::SetupClassInstance(ClassNode* node, ClassContext* context)
  {
    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // Create the class type
    BoundType* type = this->Builder->AddBoundType(node->Name.Token, node->CopyMode, UndeterminedSize, 0);
    node->Type = type;
    
    // Mark this type as not being native
    type->Native = false;

    // Use the comments as the class description
    String description = node->GetMergedComments();
    type->Description = description;

    // Set the class type's originating location
    type->Location = node->Location;
    type->NameLocation = node->Name.Location;

    // Push this class onto the list of all classes in the context
    context->AllClasses.push_back(type);

    // Go through all attributes and attach them to the class type
    this->ReadAttributes(node, node->Attributes, type->Attributes);

    // Set whether we're hidden or not (hides us from documentation, auto-complete, etc)
    type->IsHidden =  type->HasAttribute(HiddenAttribute);

    // Create a new function for the pre-constructor
    String preConstructorName = String::Format("%s%s", PreConstructorName.c_str(), type->Name.c_str());
    Function* preConstructor = this->Builder->CreateRawFunction(type, preConstructorName, VirtualMachine::ExecuteNext, ParameterArray(), core.VoidType, FunctionOptions::None);
    node->PreConstructor = preConstructor;
    this->SetupFunctionLocation(preConstructor, node->Location, node->Name.Location);

    // Only generate a post-destructor if our class is a reference type
    if (type->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Create the post-destructor for this class
      type->PostDestructor = VirtualMachine::PostDestructor;
    }

    // Add the function to the type's list of functions
    type->PreConstructor = node->PreConstructor;
  }

  //***************************************************************************
  void Syntaxer::CollectTemplateInstantiations(SyntaxNode*& node, ClassContext* context)
  {
    // Get all the types for this node
    SyntaxTypes types;
    node->PopulateSyntaxTypes(types);

    // Instantiate any template types
    this->InstantiateTemplatesFromSyntaxTypes(types, context, node->Location);

    // Continue walking all of this node's children
    context->Walker->GenericWalkChildren(this, node, context);
  }

  //***************************************************************************
  void Syntaxer::InstantiateTemplatesFromSyntaxTypes(SyntaxTypes& types, ClassContext* context, const CodeLocation& location)
  {
    // Loop through all the types
    for (size_t i = 0; i < types.size(); ++i)
    {
      // Get the current type
      SyntaxType* type = *types[i];

      // CHECK THIS LOGIC
      // The first thing we need to do is traverse any sub-types
      // I believe this MUST happen before we try to instantiate templates (makes sense...)
      // otherwise we would try and instantiate a template with incorrect types

      // Get all child types of this type
      SyntaxTypes childTypes;
      type->PopulateSyntaxTypes(childTypes);

      // Traverse those child types and instantiate any templates
      // NOTE: It is very important this happens first
      // If a template type uses templates in it's instantiation (eg Array<Dictionary<Foo, Bar>>)
      // Then we must have instantiated the Dictionary before the Array can complete
      this->InstantiateTemplatesFromSyntaxTypes(childTypes, context, location);

      // If the type is a template instance
      if (type->IsTemplateInstantiation())
      {
        // If the type is a data type
        if (BoundSyntaxType* dataType = TypeBinding::DynamicCast<BoundSyntaxType*>(type))
        {
          // Get the fully qualified template name (unique for this instantiation)
          String fullyQualifiedTemplateName = dataType->ToString();

          // Get the base name of the template
          String baseName = dataType->TypeName;

          // First, look to see if we already instantiated this type...
          if (this->Builder->FindBoundType(fullyQualifiedTemplateName) == nullptr &&
              this->ExternalBoundTypes.findValue(fullyQualifiedTemplateName, nullptr) == nullptr)
          {
            // Check to see if we found the type as a named template
            if (ClassNode* classNode = this->InternalBoundTemplates.findValue(baseName, nullptr))
            {
              // Make sure the exact number of template arguments were given
              if (classNode->TemplateArguments.size() != dataType->TemplateArguments.size())
              {
                // The number of arguments -must- be the same
                return this->ErrorAt
                (
                  classNode,
                  ErrorCode::InvalidNumberOfTemplateArguments,
                  classNode->TemplateArguments.size(),
                  dataType->TemplateArguments.size()
                );
              }

              // Clone the class node and everything beneith it
              ClassNode* cloneTree = classNode->Clone();

              // Perform the advanced type replacement for the template
              this->PerformTemplateReplacement(cloneTree, classNode->TemplateArguments, dataType);

              // Tell the class node what type it is an instantiation of (normally null)
              cloneTree->TemplateInstantiation = dataType;

              // Change the name of the class to reflect its template type
              // The data type that we're instantiating it with should be able to represent the new name
              cloneTree->Name.Token = fullyQualifiedTemplateName;

              // Setup the class as an instantiation
              this->SetupClassInstance(cloneTree, context);

              // Add ourselves to the roots. Note this will not be traversed
              // as the walker already grabbed the child list from the root
              ZilchTodo("Make sure we traverse the added class");
              this->Tree->Root->Classes.Add(cloneTree);

              // Now we need to walk the class node we just generated,
              // in case it has other template instantiations/references
              // This isn't exactly 'safe' for the walker, but I know
              // internally how walking works and it will be fine
              context->Walker->Walk(this, cloneTree, context);
            }
            else
            {
              // The resolved type arguments
              Array<Type*> templateInstanceArguments;
              templateInstanceArguments.resize(dataType->TemplateArguments.size());

              // Loop through all the given template instance arguments (the actual types)
              for (size_t i = 0; i < dataType->TemplateArguments.size(); ++i)
              {
                // Get the template argument
                SyntaxType* sytaxType = dataType->TemplateArguments[i];

                // Attempt to retrieve it as a valid type (this should always work...)
                Type* resolvedType = this->RetrieveType(sytaxType, location);

                // Get a reference to the core library
                Core& core = Core::GetInstance();

                // If we got no type back, we failed to instantiate this template
                if (resolvedType == core.VoidType)
                {
                  return;
                }

                // Store the type in our array of resolved types...
                templateInstanceArguments[i] = resolvedType;
              }

              // Attempt to instantiate the template
              InstantiatedTemplate instantiatedTemplate = this->Builder->InstantiateTemplate(baseName, templateInstanceArguments, *this->Dependencies);

              // If we failed to instantiate the 
              if (instantiatedTemplate.Result == TemplateResult::FailedNameNotFound)
              {
                // If we got here, it means the user referenced a type that wasn't defined
                // Note that this is the same as in RetrieveNamedType
                return this->Errors.Raise(location, ErrorCode::ReferenceToUndefinedType, fullyQualifiedTemplateName.c_str());
              }
              // If we failed to instantiate the template due to an improper number of arguments...
              else if (instantiatedTemplate.Result == TemplateResult::FailedInvalidArgumentCount)
              {
                // The number of arguments -must- be the same
                //TODO: ExpectedArguments is not currently filled out
                return this->Errors.Raise
                (
                  location,
                  ErrorCode::InvalidNumberOfTemplateArguments,
                  instantiatedTemplate.ExpectedArguments,
                  dataType->TemplateArguments.size()
                );
              }
              else if (instantiatedTemplate.Result == TemplateResult::FailedInstantiatorDidNotReturnType)
              {
                // Show an error message
                return this->ErrorAt(classNode, ErrorCode::InternalError,
                  "Unable to instantiate template via callback.");
              }

              // Make sure that we got a template type back
              ErrorIf(instantiatedTemplate.Type == nullptr,
                "The template instantiator did not return a failure, but the type was not created");
            }
          }

          // We need to clear and free the nodes that are template arguments since
          // we're replacing this type with an instantiated template type
          for (size_t i = 0; i < dataType->TemplateArguments.size(); ++i)
          {
            // Free all the template argument nodes
            // (what we're instantiating this template with)
            delete dataType->TemplateArguments[i];
          }

          // Clear out the template arguments and point it to the new class name
          dataType->TemplateArguments.clear();
          dataType->TypeName = fullyQualifiedTemplateName;
        }
        else
        {
          // Error handling
          Error("Unhandled case: A template instance was made for a type we didn't handle");
        }
      }
    }
  }

  //***************************************************************************
  void Syntaxer::PreventDuplicateTypeNames(StringParam name, const CodeLocation& location)
  {
    // Get our own library name (for convenience)
    cstr ourLibraryName = this->Builder->GetName().c_str();

    // Prevent duplicate template type names with the internal project
    ClassNode* foundTemplate = this->InternalBoundTemplates.findValue(name, nullptr);
    if (foundTemplate != nullptr)
      return this->Errors.Raise(location, String(), foundTemplate->Location, ErrorCode::DuplicateTypeName, name.c_str(), ourLibraryName);
    
    // Prevent duplicate type names with the internal project
    BoundType* foundInternalType = this->Builder->BoundTypes.findValue(name, nullptr);
    if (foundInternalType != nullptr)
    {
      // Give a better error message that tells us where the class was defined
      return this->Errors.Raise(location, String(), foundInternalType->Location, ErrorCode::DuplicateTypeName, name.c_str(), ourLibraryName);
    }

    // Prevent duplicate type names that come from external libraries
    BoundType* foundExternalType = this->ExternalBoundTypes.findValue(name, nullptr);
    if (foundExternalType != nullptr)
    {
      // Give a better error message that tells us where the class was defined
      return this->Errors.Raise(location, String(), foundExternalType->Location, ErrorCode::DuplicateTypeName, name.c_str(), foundExternalType->SourceLibrary->Name.c_str());
    }
  }

  //***************************************************************************
  void Syntaxer::PreventDuplicateMemberNames(BoundType* type, StringParam memberName, const CodeLocation& location, bool isStatic, bool isFunction)
  {
    // Make sure we don't have a property of the same name as this member
    PropertyMap& properties = type->GetPropertyMap(isStatic);
    Property* foundProperty = properties.findValue(memberName, nullptr);
    if (foundProperty != nullptr)
      return this->Errors.Raise(location, String(), foundProperty->Location, ErrorCode::DuplicateMemberName, memberName.c_str());
    
    // Make sure we don't have a field of the same name as this member
    FieldMap& fields = type->GetFieldMap(isStatic);
    Field* foundField = fields.findValue(memberName, nullptr);
    if (fields.containsKey(memberName))
      return this->Errors.Raise(location, String(), foundField->Location, ErrorCode::DuplicateMemberName, memberName.c_str());
    
    // Make sure we don't have a function of the same name as this member
    FunctionMultiMap& functionMap = type->GetFunctionMap(isStatic);
    FunctionArray* foundFunctions = functionMap.findPointer(memberName);
    if (foundFunctions != nullptr && foundFunctions->empty() == false)
    {
      // We only really want to show the location of the first function we find (it's really not necessary to show all of them...)
      return this->Errors.Raise(location, ErrorCode::DuplicateMemberName, memberName.c_str());
    }
  }

  //***************************************************************************
  void Syntaxer::CollectClass(ClassNode*& node, ClassContext* context)
  {
    // Error checking
    ErrorIf(node->TemplateInstantiation != nullptr,
      "We should never find any template instantiations");

    // Make sure another class or type of the same name doesn't conflict with ours
    this->PreventDuplicateTypeNames(node->Name.Token, node->Location);
    if (this->Errors.WasError)
      return;

    // If the class type is a template
    if (node->IsTemplate())
    {
      // Add this node to the named templates list
      this->InternalBoundTemplates.insertOrError(node->Name.Token, node);

      // Unlink the parent
      node->Parent = nullptr;
      node = nullptr;
    }
    else
    {
      // Setup the class as an instance
      this->SetupClassInstance(node, context);
    }
  }

  //***************************************************************************
  void Syntaxer::CollectEnum(EnumNode*& node, ClassContext* context)
  {
    // Make sure another class or type of the same name doesn't conflict with ours
    this->PreventDuplicateTypeNames(node->Name.Token, node->Location);
    if (this->Errors.WasError)
      return;

    // Note: Most everything we do in major phases due to type references, member references, or template resolving
    // Enums are simple, and therefore can mostly be handled here (apart from inheritance and code generation)
    BoundType* type = new BoundType(node->Name.Token, TypeCopyMode::ValueType, sizeof(Integer), 0);
    node->Type = type;

    // Use the comments as the class description
    String description = node->GetMergedComments();
    type->Description = description;

    // Set the class type's originating location
    type->Location = node->Location;
    type->NameLocation = node->Name.Location;

    // Push this class onto the list of all classes in the context
    context->AllClasses.push_back(type);

    // Add the type to the list of types
    this->Builder->AddRawBoundType(type);

    // Go through all attributes and attach them to the enum type
    this->ReadAttributes(node, node->Attributes, type->Attributes);

    // Assume this type is just a regular enum (if it's a 'flags', we will set that below)
    type->SpecialType = SpecialType::Enumeration;
    type->ToStringFunction = VirtualMachine::EnumerationToString;

    // The values we assign to any unassigned enum value
    // We automatically count up in value giving each one a
    // unique value, unless the user intervenes
    Integer valueCounter = 0;

    // If this is a flags enum...
    if (node->IsFlags)
    {
      // Flags should always start with 1 (the first bit set)
      valueCounter = 1;
      type->SpecialType = SpecialType::Flags;
      type->ToStringFunction = VirtualMachine::FlagsToString;
    }

    // Make sure we don't allow two names that are the same
    HashSet<String> uniqueNames;

    // Walk through all the enum values
    for (size_t i = 0; i < node->Values.size(); ++i)
    {
      // Add each attribute string to the class attributes
      EnumValueNode* enumValueNode = node->Values[i];

      // First, check to see if the name is already taken
      if (uniqueNames.contains(enumValueNode->Name.Token))
      {
        // We cannot have two names are the same
        return this->ErrorAt
        (
          enumValueNode,
          ErrorCode::EnumDuplicateValue,
          enumValueNode->Name.c_str(),
          node->Name.c_str()
        );
      }

      // Since the name wasn't taken, add it to the list
      uniqueNames.insert(enumValueNode->Name.Token);
      
      // If the user actually assigned a value to this entry
      if (enumValueNode->Value != nullptr)
      {
        // Convert the string to an integer value
        valueCounter = atoi(enumValueNode->Value->Token.c_str());
      }

      // Let the enum entry know what it's integral value is
      enumValueNode->IntegralValue = valueCounter;

      // If this is a flags enum...
      if (node->IsFlags)
      {
        // There's a special case where we have a bit flag of zero
        if (valueCounter == 0)
        {
          // Start at a value of 1
          valueCounter = 1;
        }
        else
        {
          // Flags enums jump by powers of 2 for the next enum value
          valueCounter *= 2;
        }
      }
      else
      {
        // Standard enums just increment for the next enum value
        ++valueCounter;
      }

      // Create the property using the builder (auto added to our type)
      // Let the CodeGenerator create the getter and setter functions
      // Note: The enum value's type is the enum's type itself
      Property* property = this->Builder->AddBoundProperty
      (
        type,
        enumValueNode->Name.Token,
        type,
        nullptr,
        LibraryBuilder::NoOperation,
        MemberOptions::Static
      );
      enumValueNode->IntegralProperty = property;

      // Set the documentation on the property to be any comments on the value, as well as the locations
      property->Description = enumValueNode->GetMergedComments();
      property->Location = enumValueNode->Location;
      property->NameLocation = enumValueNode->Name.Location;
    }
  }

  //***************************************************************************
  void Syntaxer::CollectSendsEvents(SendsEventNode*& node, TypingContext* context)
  {
    // Let the type know which events are sent
    BoundType* classType = context->ClassTypeStack.back();
    SendsEvent& sendsEvent = classType->SendsEvents.push_back();
    sendsEvent.Name = node->Name->Token;
    sendsEvent.ResultType = this->RetrieveType(node->EventType, node->Location);

    // If we encountered an error with getting a type back, early out
    if (this->Errors.WasError)
      return;
    
    // Get a reference to the core events
    Core& core = Core::GetInstance();

    // Get the extension properties for the events type
    GuidType guid  = ZilchTypeId(EventsClass)->Hash();
    PropertyMap& properties = this->Builder->BuiltLibrary->StaticExtensionProperties[guid];

    // Check to see if we do not yet have a property by this name (if we do, we won't bother to create another)
    if (properties.findValue(sendsEvent.Name, nullptr) == nullptr)
    {
      // Create an extension property on the events object so that the event can be accessed by name
      Property* property = this->Builder->AddExtensionProperty
      (
        ZilchTypeId(EventsClass),
        sendsEvent.Name,
        ZilchTypeId(String),
        nullptr,
        LibraryBuilder::NoOperation,
        MemberOptions::Static
      );
      node->EventProperty = property;
      
      // Use the comments as the event description
      String comments = node->GetMergedComments();

      // Add in the type that the event declares it sends
      property->Description = BuildString("Event Type: ", sendsEvent.ResultType->ToString(), ". ", comments);

      // Set the location where this property originates from
      property->Location = node->Location;
      property->NameLocation = node->Name->Location;
    }
  }

  //***************************************************************************
  void Syntaxer::CollectClassInheritance(ClassNode*& classNode, TypingContext* context)
  {
    // Walk the class and it's children
    this->PushClass(classNode, context);
    
    // Iterate through all inherited tokens
    for (SyntaxTypeList::range i = classNode->Inheritance.all(); !i.empty(); i.popFront())
    {
      // Grab the current token
      SyntaxType* syntaxType = i.front();

      // Get the actual inherited type
      Type* inheritedType = this->RetrieveType(syntaxType, classNode->Location);

      // If we had an error, return out early
      if (this->Errors.WasError)
        return;

      // Error checking!
      ErrorIf(inheritedType == nullptr, "Type should be valid");

      // If the type is a class type...
      if (BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(inheritedType))
      {
        // If we have no base class...
        if (classNode->Type->BaseType == nullptr)
        {
          // Store the base type
          classNode->Type->BaseType = boundType;
        }
        else
        {
          // We don't support multiple inheritance
          return this->ErrorAt(classNode, ErrorCode::MultipleInheritanceNotSupported);
        }
      }
      else
      {
        // We only support inheriting from classes (bound types) and interfaces (which we don't have yet!)
        return this->ErrorAt(classNode, ErrorCode::GenericError,
          "We don't yet support inheriting from types other than class/struct/bound types.");
      }
    }
  }

  //***************************************************************************
  void Syntaxer::CollectEnumInheritance(EnumNode*& node, TypingContext* context)
  {
    // Note: We don't really care about walking children here (our only children are enum values)

    // If we have inheritance...
    if (node->Inheritance)
    {
      // Right now we don't support enum inheritance, but we will in the future
        return this->ErrorAt(node, ErrorCode::GenericError,
          "Enum inheritance is not yet supported.");

      //// Get the actual inherited type
      //Type* inheritedType = this->RetrieveType(node->Inheritance, node->Location);

      //// If we had an error, return out early
      //if (this->Errors.WasError)
      //  return;

      //// Error checking!
      //ErrorIf(inheritedType == nullptr, "Type should be valid");
    }
  }

  //***************************************************************************
  void Syntaxer::SetupGenericFunction(GenericFunctionNode* node, TypingContext* context, const UserToken& name, FunctionOptions::Enum options, Type* returnType, BoundType* owner)
  {
    // If an owner was not passed in, then get a pointer to the current class type that this function is being implemented in
    // Owner can be passed in when we're binding an extension function
    if (owner == nullptr)
      owner = context->ClassTypeStack.back();

    // Store all the delegate parameters
    ParameterArray delegateParameters;

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Walk through parameters
    NodeList<ParameterNode>::range parameters = node->Parameters.all();
    for (; parameters.empty() == false; parameters.popFront())
    {
      // Get the current parameter
      ParameterNode* parameter = parameters.front();

      // Add the parameter type to the signature (get the type from the parameter node)
      DelegateParameter& delegateParameter = delegateParameters.push_back();
      delegateParameter.Name = parameter->Name.Token;
      
      // Get the variable's type from the syntax type
      delegateParameter.ParameterType = this->RetrieveType(parameter->ResultSyntaxType, node->Location);
    }

    // Set the function on the node
    Function* function = this->Builder->CreateRawFunction(owner, name.Token, VirtualMachine::ExecuteNext, delegateParameters, returnType, options);
    node->DefinedFunction = function;
    this->SetupFunctionLocation(function, node->Location, name.Location);

    // Push the function onto the stack so that children can access it
    // (the top of the stack will be the most relevant function to them)
    context->FunctionStack.push_back(function);
    
    // Walk all the parameters (which should give them types and generate variables)
    context->Walker->Walk(this, node->Parameters, context);

    // Mark the node as virtual if it is
    function->IsVirtual = (options == FunctionOptions::Virtual);

    // Use the comments as the class description
    String description = node->GetMergedComments();
    function->Description = description;

    // Go through all attributes and attach them to the function
    this->ReadAttributes(node, node->Attributes, function->Attributes);

    // Set whether we're hidden or not (hides us from documentation, auto-complete, etc)
    function->IsHidden =  function->HasAttribute(HiddenAttribute);

     // If the function is a member function (not a static function)...
    if (options != FunctionOptions::Static)
    {
      // Get the scoped variable from the map
      // Note that it should probably be null (we're just getting a reference to the pointer)
      Variable*& thisVariable = node->ScopedVariables[ThisKeyword];

      // If the variable is not null, that means we somehow ended up with a 'this' variable already defined
      if (thisVariable != nullptr)
        return ErrorAt(node, ErrorCode::InternalError,
        "The variable 'this' was already defined.");

      // Adding the function should have created a this variable (since we're not static)
      thisVariable = function->This;
    }

    // Pop the function from the stack
    context->FunctionStack.pop_back();

    // Finally, set the node type so that we'll know it later
    node->Type = node->DefinedFunction->FunctionType;
  }

  //***************************************************************************
  void Syntaxer::CollectConstructor(ConstructorNode*& node, TypingContext* context)
  {
    // Get the instance of the type database
    Core& core = Core::GetInstance();
    
    // Setup the function generically (this actually creates the compiled function object)
    this->SetupGenericFunction(node, context, node->Name, FunctionOptions::None, core.VoidType);

    // Grab the class type
    BoundType* classType = context->ClassTypeStack.back();

    Function* constructor = node->DefinedFunction;
    AddMemberResult::Enum addResult = classType->AddRawConstructor(constructor);

    // If an overload of the function already existed with the exact same signature (and name)
    if (addResult == AddMemberResult::AlreadyExists)
      return ErrorAt(node, ErrorCode::OverloadsCannotBeTheSame, constructor->Name.c_str());

    // If we have a base class type but we aren't initializing it...
    BoundType* baseType = classType->BaseType;
    if (baseType != nullptr && node->BaseInitializer == nullptr)
    {
      // It is an error to not initialize our base class
      return ErrorAt(node, ErrorCode::BaseInitializerRequired, classType->Name.c_str(), baseType->Name.c_str());
    }
  }

  //***************************************************************************
  void Syntaxer::CollectDestructor(DestructorNode*& node, TypingContext* context)
  {
    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // Setup the function generically (this actually creates the compiled function object)
    this->SetupGenericFunction(node, context, node->Name, FunctionOptions::None, core.VoidType);

    // Add the destructor function to the class
    context->ClassTypeStack.back()->Destructor = node->DefinedFunction;
  }

  //***************************************************************************
  void Syntaxer::CollectFunction(FunctionNode*& node, TypingContext* context)
  {
    // Store the return type
    Type* delegateReturn = nullptr;

    // Loop through all the return values
    if (node->ReturnType != nullptr)
    {
      // Add the return type to the signature
      //HACK (needs to be actually at the return node, maybe syntax types should get locations?)
      delegateReturn = this->RetrieveType(node->ReturnType, node->Location);

      // If we had an error, return out early
      if (this->Errors.WasError)
        return;
    }
    else
    {
      // Get the instance of the type database
      Core& core = Core::GetInstance();

      // There is no return type
      delegateReturn = core.VoidType;
    }

    // Assume no options are on this function
    FunctionOptions::Enum options = FunctionOptions::None;
    ErrorIf(node->IsStatic && node->Virtualized != VirtualMode::NonVirtual,
      "A function cannot be both static and virtual");

    // Static and virtual are mutually exclusive
    if (node->IsStatic)
      options = FunctionOptions::Static;
    else if (node->Virtualized != VirtualMode::NonVirtual)
      options = FunctionOptions::Virtual;

    // Assume the owner of this function is always the class itself
    BoundType* owner = context->ClassTypeStack.back();

    // If this is an extension method...
    if (node->ExtensionOwner != nullptr)
      owner = this->RetrieveBoundType(node->ExtensionOwner, node->Location);

    // If we had an error getting the extension type, return out early
    if (this->Errors.WasError)
      return;

    // Setup the function generically (this actually creates the compiled function object)
    this->SetupGenericFunction(node, context, node->Name, options, delegateReturn, owner);

    // If we had an error, return out early
    if (this->Errors.WasError)
      return;

    // Grab the function that was created above in 'SetupGenericFunction'
    Function* function = node->DefinedFunction;

    // If this is a normal function (not an extension function...)
    if (node->ExtensionOwner == nullptr)
    {
      // Add the function to the type's list of functions (checks for static or instance methods)
      AddMemberResult::Enum addResult = owner->AddRawFunction(function);

      // If an overload of the function already existed with the exact same signature (and name)
      if (addResult == AddMemberResult::AlreadyExists)
        return ErrorAt(node, ErrorCode::OverloadsCannotBeTheSame, function->Name.c_str());
    }
    // Otherwise, this is an extension method, so add it specially via the library
    else
    {
      ZilchTodo("Handle extension function overload colliisons");
      this->Builder->AddRawExtensionFunction(function);
    }
  }

  //***************************************************************************
  void Syntaxer::CollectMemberVariableAndProperty(MemberVariableNode*& node, TypingContext* context)
  {
    // As long as the type is not inferred...
    ErrorIf(node->IsInferred(),
      "Member variables should never have an inferred type (should be checked by the parser)");

    // Store the type on the node (this helps us with byte-code generation later)
    // Essentially, we are decorating the tree :)
    node->ResultType = this->RetrieveType(node->ResultSyntaxType, node->Location);

    // If we had an error, return out early
    if (this->Errors.WasError)
      return;

    // Set the member node's parent class type
    BoundType* classType = context->ClassTypeStack.back();
    node->ParentClassType = classType;

    // Make sure we don't have any other members of the same name
    this->PreventDuplicateMemberNames(classType, node->Name.Token, node->Location, node->IsStatic, false);
    if (this->Errors.WasError)
      return;

    // Any options we want to apply to the creation of a member
    MemberOptions::Flags options = MemberOptions::None;
      
    // If the variable is a static variable we need to set the option
    if (node->IsStatic)
    {
      options |= MemberOptions::Static;
    }
    
    // The property we create below (members are properties...)
    Property* property = nullptr;

    // If this node is a property...
    if (node->IsProperty)
    {
      // The function we use to tell the library builder to ignore it (we will build it later)
      BoundFn doNotGenerate = LibraryBuilder::DoNotGenerate;

      // If this is a normal class property...
      if (node->ExtensionOwner == nullptr)
      {
        // Create the property using the builder (this adds it directly to the class)
        property = this->Builder->AddBoundProperty(classType, node->Name.Token, node->ResultType, doNotGenerate, doNotGenerate, options);
      }
      else
      {
        // We have to lookup the extension type that the user specified (this could fail)
        BoundType* extensionOwner = this->RetrieveBoundType(node->ExtensionOwner, node->Location);

        // If we had a problem resolving the type, then early out
        if (this->Errors.WasError)
          return;
        
        // Create the property using the builder (this adds it to the library but maps it to the owner)
        property = this->Builder->AddExtensionProperty(extensionOwner, node->Name.Token, node->ResultType, doNotGenerate, doNotGenerate, options);
      }

      // Store the property variable on the node
      node->CreatedProperty = property;
    }
    else
    {
      // If this is a value type (struct) and the member is non-static...
      if (classType->CopyMode == TypeCopyMode::ValueType && node->IsStatic == false)
      {
        // If this member has a complex copy
        if (node->ResultType->IsCopyComplex())
        {
          // A struct is only allowed to contain value types
          return ErrorAt
          (
            node,
            ErrorCode::StructsCanOnlyContainValueTypes,
            classType->Name.c_str(),
            node->Name.c_str()
          );
        }
      }

      // Create the member using the builder
      // The given offset is zero for now (we'll initialize it later when collecting sizes of objects)
      Field* field = this->Builder->AddBoundField(classType, node->Name.Token, node->ResultType, 0, options);
      property = field;

      // Store the member variable on the node
      node->CreatedField = field;
    }

    // Use the comments as the class description
    String description = node->GetMergedComments();
    property->Description = description;
    
    // Go through all attributes and attach them to the property
    this->ReadAttributes(node, node->Attributes, property->Attributes);

    // Set whether we're hidden or not (hides us from documentation, auto-complete, etc)
    property->IsHidden = property->HasAttribute(HiddenAttribute);

    // Set the location of the property
    property->Location = node->Location;
    property->NameLocation = node->Name.Location;
  }

  //***************************************************************************
  void Syntaxer::CollectPropertyGetSet(MemberVariableNode*& node, TypingContext* context)
  {
    // Note: The first thing we must do is walk the Get/Set functions since whatever member
    //       we create, we want to give it the proper get and set functions

    // If the member has a get
    if (node->Get != nullptr)
    {
      // Walk the get function
      context->Walker->Walk(this, node->Get, context);

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;

      // Mark this function as special
      node->Get->DefinedFunction->IsPropertyGetOrSet = true;
      node->Get->DefinedFunction->IsHidden = true;
    }

    // If the member has a set
    if (node->Set != nullptr)
    {
      // Walk the get function
      context->Walker->Walk(this, node->Set, context);

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;

      // Mark this function as special
      node->Set->DefinedFunction->IsPropertyGetOrSet = true;
      node->Set->DefinedFunction->IsHidden = true;
    }
    
    // If this node is a property...
    if (node->IsProperty)
    {
      // Store the get function on the property
      if (node->Get != nullptr)
      {
        // Error checking
        ErrorIf(node->CreatedProperty->Get != nullptr,
          "The property getter should not be set yet (we're generating it)");

        // Point the property's getter at the compiled function
        node->CreatedProperty->Get = node->Get->DefinedFunction;
      }
      
      // Store the set function on the property
      if (node->Set != nullptr)
      {
        // Error checking
        ErrorIf(node->CreatedProperty->Set != nullptr,
          "The property setter should not be set yet (we're generating it)");

        // Point the property's setter at the compiled function
        node->CreatedProperty->Set = node->Set->DefinedFunction;
      }
    }
  }

  //***************************************************************************
  void Syntaxer::PushClass(ClassNode*& node, TypingContext* context)
  {
    // Push the class onto the stack so that children can access it
    // (the top of the stack will be the most relevant class to them)
    context->ClassTypeStack.push_back(node->Type);

    // Let any member initialization generation know what function it belongs to
    context->FunctionStack.push_back(node->PreConstructor);

    // Generically walk the children
    context->Walker->GenericWalkChildren(this, node, context);

    // Pop the pre-constructor
    context->FunctionStack.pop_back();

    // We are exiting this class, so pop it off
    context->ClassTypeStack.pop_back();
  }

  //***************************************************************************
  template <typename FunctionNodeType>
  void Syntaxer::PushFunctionHelper
  (
    FunctionNodeType* node,
    TypingContext* context,
    void (Syntaxer::*postArgs)(FunctionNodeType* node)
  )
  {
    // Push the function onto the stack so that children can access it
    // (the top of the stack will be the most relevant function to them)
    context->FunctionStack.push_back(node->DefinedFunction);

    // Loop through all the parameters
    for (size_t i = 0; i < node->Parameters.size(); ++i)
    {
      // Walk the statements
      ParameterNode* parameterNode = node->Parameters[i];
      context->Walker->Walk(this, parameterNode, context);

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;
    }

    // If we have a post arguments function...
    if (postArgs != nullptr)
    {
      // Call the function...
      (this->*postArgs)(node);

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;
    }

    // Process the statements inside the function
    this->ProcessScopeStatements(node, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Get a reference to the core library
    Core& core = Core::GetInstance();

    // If not all paths return and we have a return type...
    if (node->AllPathsReturn == false && Type::IsSame(node->Type->Return, core.VoidType) == false)
    {
      // No child statement reported to us that it returned properly
      return ErrorAt(node, ErrorCode::NotAllPathsReturn);
    }

    // We are exiting this function, so pop it off
    context->FunctionStack.pop_back();
  }

  //***************************************************************************
  void Syntaxer::PushFunction(GenericFunctionNode*& node, TypingContext* context)
  {
    return PushFunctionHelper<GenericFunctionNode>(node, context, nullptr);
  }

  //***************************************************************************
  void Syntaxer::PushConstructor(ConstructorNode*& node, TypingContext* context)
  {
    return PushFunctionHelper<ConstructorNode>(node, context, &Syntaxer::CheckInitializerList);
  }

  //***************************************************************************
  void Syntaxer::CheckInitializerList(ConstructorNode* node)
  {
    ZilchTodo("Finish up initializer lists (at least checking if they pass type validation)");
    //DecorateCheckFunctionCall(node, node->BaseInitializer,
    //node->BaseInitializer
  }

  //***************************************************************************
  void Syntaxer::DecorateInitializer(InitializerNode*& node, TypingContext* /*context*/)
  {
    // Mark the node as being read only (we should not be able to change it)
    node->Io = IoMode::ReadRValue;
  }

  //***************************************************************************
  void Syntaxer::DecorateStringInterpolant(StringInterpolantNode*& node, TypingContext* context)
  {
    // Mark the node as being read only
    node->Io = IoMode::ReadRValue;

    // String interpolants always result in a string type
    node->ResultType = ZilchTypeId(String);

    // Walk through all the children we want to stringify
    for (size_t i = 0; i < node->Elements.size(); ++i)
    {
      // Get the current element (it may be a string itself...)
      ExpressionNode* elementNode = node->Elements[i];

      // Make sure we walk the element expression
      context->Walker->Walk(this, elementNode, context);

      // If we had an error, return out early
      if (this->Errors.WasError)
        return;
      
      // The element expression only needs to be readable
      elementNode->IoUsage = IoMode::ReadRValue;
    }
  }

  //***************************************************************************
  void Syntaxer::DecorateValue(ValueNode*& node, TypingContext* /*context*/)
  {
    // Mark the node as being read only
    node->Io = IoMode::ReadRValue;

    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // Check to see what type of literal we have here
    switch (node->Value.TokenId)
    {
      // The value is an Integer
      case Grammar::IntegerLiteral:
      {
        node->ResultType = core.IntegerType;
        break;
      }

      // The value is a DoubleInteger
      case Grammar::DoubleIntegerLiteral:
      {
        node->ResultType = core.DoubleIntegerType;
        break;
      }

      // The value is a Real
      case Grammar::RealLiteral:
      {
        node->ResultType = core.RealType;
        break;
      }

      // The value is a DoubleReal
      case Grammar::DoubleRealLiteral:
      {
        node->ResultType = core.DoubleRealType;
        break;
      }

      // The value is a String
      case Grammar::StringLiteral:
      {
        node->ResultType = core.StringType;
        break;
      }

      // The value is a Bool
      case Grammar::True:
      case Grammar::False:
      {
        node->ResultType = core.BooleanType;
        break;
      }

      // The value is a null (which means that the type is unknown)
      case Grammar::Null:
      {
        // Always assume we're going to be a null handle (implicit cast may change us!)
        node->ResultType = core.NullType;
        break;
      }

      default:
      {
        // We don't know what type it is???
        // This especially should not be an identifier, since identifiers are caught as VariableReferences
        return ErrorAt(node, ErrorCode::InternalError,
          "We reached what should be a literal value and we have no idea what type it is.");
      }
    }
  }

  //***************************************************************************
  void SetAllIoToReadAndIgnore(SyntaxNode* node)
  {
    // If the current node is an expression...
    ExpressionNode* expression = TypeBinding::DynamicCast<ExpressionNode*>(node);
    if (expression != nullptr)
    {
      // Set the io and usage (technically usage should only be set by the parent, but this is a special case)
      expression->Io = IoMode::ReadRValue;
      expression->IoUsage = IoMode::Ignore;
    }

    // Get all this node's children
    NodeChildren children;
    node->PopulateChildren(children);

    // Loop through all the children and recursively set all their nodes to read only
    for (size_t i = 0; i < children.size(); ++i)
      SetAllIoToReadAndIgnore(*children[i]);
  }

  //***************************************************************************
  void Syntaxer::DecorateExpressionInitializer(ExpressionInitializerNode*& node, TypingContext* context)
  {
    // Mark the node as being read only (we don't ever write directly to this value on the stack)
    // Note that doesn't mean we can't access a value on the type and write to it
    node->Io = IoMode::ReadRValue;

    // Mark all child nodes as using ignoring io access (we know this is generated by us, so it's ok/valid)
    // This should really come before we do anything else, just because member initialization does actually need to write
    SetAllIoToReadAndIgnore(node);
    
    // Walk the creation initializer (create the node, invoke the constructor...)
    context->Walker->Walk(this, node->LeftOperand, context);

    // If we had an error, return out early
    if (this->Errors.WasError)
      return;

    // Our type is the left operands type
    node->ResultType = node->LeftOperand->ResultType;

    // The creation expression only needs to be readable (always should be!)
    node->LeftOperand->IoUsage = IoMode::ReadRValue;
    
    // Walk the statements that generate the 'Add' and member initializations
    context->Walker->Walk(this, node->InitializerStatements, context);
  }

  //***************************************************************************
  void Syntaxer::DecorateStaticTypeOrCreationCall(StaticTypeNode*& node, TypingContext* /*context*/)
  {
    // Mark the node as being read only
    // Note that doesn't mean we can't access a value on the type and write to it
    node->Io = IoMode::ReadRValue;

    // Get the type that is referenced by the syntax type (the type we're possibly creating, or accessing statics upon)
    node->ReferencedType = this->RetrieveBoundType(node->ReferencedSyntaxType, node->Location);
    
    // If we had an error, return out early
    if (this->Errors.WasError)
      return;

    // For the member access case and inferred creation call, this is
    // always correct (the result of the expression is the same as the named type
    // However: In the case where we are using 'new' on a value type, the result is a reference type
    // Warning: If this is a static member access, the type is NOT an instance, but is static (we don't actually return a value)
    node->ResultType = node->ReferencedType;
    
    // Get the copy mode of the type we're possibly creating (reference or value type)
    TypeCopyMode::Enum copyMode = node->ReferencedType->CopyMode;

    // This could be a creation call or a member access
    FunctionCallNode* constructorCall = TypeBinding::DynamicCast<FunctionCallNode*>(node->Parent);
    MemberAccessNode* memberAccess = TypeBinding::DynamicCast<MemberAccessNode*>(node->Parent);

    // Determine right here if this is a creation call... (we MUST be the left operand of our parent in this case)
    // For example, we could be passed as a parameter in code that should NOT compile, eg SomeCall(String)
    if (constructorCall != nullptr && node == constructorCall->LeftOperand)
    {
      // Check if this is an inferred node
      if (node->Mode == CreationMode::Invalid)
      {
        // Because it's a reference type, we infer the 'new'
        if (copyMode == TypeCopyMode::ReferenceType)
          node->Mode = CreationMode::New;
        // Because it's a value type, we infer the 'local'
        else
          node->Mode = CreationMode::Local;
      }
    }
    // Otherwise, this should be a member access...
    else if (memberAccess != nullptr)
    {
      // If we're trying to do a member access on a new/local node, this would never make sense
      if (node->Mode != CreationMode::Invalid)
        return this->ErrorAt(node, ErrorCode::ConstructorCannotAccessStaticMembers);
    }
    // Otherwise the user is trying to do something with the node that we don't understand
    else if (this->Errors.TolerantMode == false)
    {
      if (node->Mode != CreationMode::Invalid)
        return this->ErrorAt(node, ErrorCode::ConstructorCallNotFound);
      else
        return this->ErrorAt(node, ErrorCode::StaticTypeConstructorOrAccessNotFound);
    }

    // Note: We do this regardless of this being a construction node because auto-complete uses it
    // Walk up the base class chain until we find any constructors (we inherit constructors)
    // We start with the current class we're trying to create
    // Note: We can safely look up to our base classes because if we don't have a constructor
    // then we at least have been pre-constructed, and the user opted to not initialize anything with a constructor
    node->OverloadedConstructors = node->ReferencedType->GetOverloadedInheritedConstructors();

    // If this is being used as a creation node (may have been determined above, or by an explicit new/local)
    if (node->Mode != CreationMode::Invalid)
    {
      // If the type has a flag that stops itself from being created in script...
      // Let the user know that this type can't be created (even if it has a constructor!)
      if (node->ReferencedType->CreatableInScript == false)
        return this->ErrorAt(node, ErrorCode::CannotCreateType, node->ReferencedType->ToString().c_str());

      // If we're doing a call to 'new', meaning we're making a heap object and its a value type then we know it must be a ref...
      if (node->Mode == CreationMode::New && copyMode == TypeCopyMode::ValueType)
      {
        // The result is a reference (indirection) to the created value type
        node->ResultType = this->Builder->ReferenceOf(node->ReferencedType);
      }
      // Otherwise, we're making a stack local or member
      else if (node->Mode == CreationMode::Local)
      {
        // If this type is a reference type...
        if (copyMode == TypeCopyMode::ReferenceType)
        {
          // We can only use local to create value types
          return this->ErrorAt(node, ErrorCode::LocalCreateMustBeValueType, node->ReferencedType->ToString().c_str());
        }
      }
    }
  }
  
  //***************************************************************************
  void Syntaxer::DecorateMultiExpression(MultiExpressionNode*& node, TypingContext* context)
  {
    // If the yield index was never set, this is an internal error!
    // (also handles invalid, because invalid is greater than size!)
    if (node->YieldChildExpressionIndex > node->Expressions.size())
    {
      return this->ErrorAt
      (
        node,
        ErrorCode::InternalError,
        "YieldChildExpressionIndex was not properly set on MultiExpressionNode."
      );
    }

    // Loop through all the child expressions
    for (size_t i = 0; i < node->Expressions.size(); ++i)
    {
      // Process all child expressions (this should compute their IO and types)
      ExpressionNode* expression = node->Expressions[i];
      context->Walker->Walk(this, expression, context);

      // Unfortunately, we need to actually forward the IoUsage of whoever was using our node
      // however we don't know, because typically it has yet to be set
      // Right now, we set that we require only read access to the node (because we only use this internally)
      // This means if we try to yield something that is write only, then we will get an error
      expression->IoUsage = (IoMode::Enum)(IoMode::ReadRValue);
    }
    
    // Forward all parameters that the syntaxer typically handles to the yielded expression
    ExpressionNode* yieldedExpression = node->Expressions[node->YieldChildExpressionIndex];
    node->ResultType = yieldedExpression->ResultType;
    node->Io = yieldedExpression->Io;
    node->IsUsedAsStatement = yieldedExpression->IsUsedAsStatement;
  }
  
  //***************************************************************************
  void Syntaxer::DecorateTypeId(TypeIdNode*& node, TypingContext* context)
  {
    // Mark the node as being read only
    // Note that doesn't mean we can't access a value on the type and write to it
    node->Io = IoMode::ReadRValue;

    // If we're attempting to get a the type of an expression
    if (node->Value != nullptr)
    {
      // Process the value expression
      context->Walker->Walk(this, node->Value, context);

      // The value expression only needs to be readable
      node->Value->IoUsage = IoMode::ReadRValue;

      // Get the resulting type of the expression
      node->CompileTimeType = node->Value->ResultType;
    }
    // Otherwise, we're getting the typeid of a static type
    else
    {
      // Error checking
      ErrorIf(node->CompileTimeSyntaxType == nullptr, "If the value wasn't parsed, the type should have been!");

      // Just get the type of what they passed in
      node->CompileTimeType = this->RetrieveType(node->CompileTimeSyntaxType, node->Location);
      
      // If we weren't able to determine the type, then we already threw an error
      if (this->Errors.WasError)
        return;
    }

    // By default the typeid will always something that derives from 'Type'
    // If this is an any type, then we could technically return anything (unless this is a static typeid(any))
    if (Type::IsAnyType(node->CompileTimeType) && node->Value != nullptr)
      node->ResultType = ZilchTypeId(Type);
    else
      node->ResultType = node->CompileTimeType->ZilchGetDerivedType();
  }

  //***************************************************************************
  void Syntaxer::CheckMemberVariable(MemberVariableNode*& node, TypingContext* context)
  {
    // Get the initial value expression
    ExpressionNode* initialValue = node->InitialValue;

    // Error checking
    ErrorIf(node->IsProperty && initialValue,
      "Properties should never have initial values");

    // If we have an initial value...
    if (initialValue != nullptr)
    {
      // Process the initial value expression
      context->Walker->Walk(this, initialValue, context);

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;

      // The initial value only needs to be readable
      initialValue->IoUsage = IoMode::ReadRValue;

      // Check if the types match, or if we can implicitly convert one to our resulting type
      if (this->ImplicitConvertAfterWalkAndIo(node->InitialValue, node->ResultType) == false)
      {
        // The expression assigned to the variable was not of the same type as the variable
        return ErrorAt
        (
          node, ErrorCode::VariableTypeMismatch,
          node->Name.c_str(),
          node->ResultType->ToString().c_str(),
          initialValue->ResultType->ToString().c_str()
        );
      }
    }
    
    // Process the get function if we have it
    if (node->Get != nullptr)
    {
      context->Walker->Walk(this, node->Get, context);
    }
    
    // Process the set function if we have it
    if (node->Set != nullptr)
    {
      context->Walker->Walk(this, node->Set, context);
    }
  }

  //***************************************************************************
  void Syntaxer::CheckLocalVariable(LocalVariableNode*& node, TypingContext* context)
  {
    // Note: This extends to both local variables AND parameters
    //       (hence checking for a possibly missing initial value)

    // Get the initial value expression
    ExpressionNode* initialValue = node->InitialValue;

    // If we have an initial value...
    if (initialValue != nullptr)
    {
      // Process the initial value expression
      context->Walker->Walk(this, initialValue, context);

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;

      // The initial value only needs to be readable
      initialValue->IoUsage = IoMode::ReadRValue;
    }

    // Find the first scope that we're within (where we add our variable to)
    ScopeNode* immediateScope = nullptr;
    SyntaxNode* currentParent = node->Parent;

    // Loop through our scope parents until we hit the root
    do
    {
      // Grab the current scope
      ScopeNode* currentScope = TypeBinding::DynamicCast<ScopeNode*>(currentParent);

      // If the parent was a scope...
      if (currentScope != nullptr)
      {
        // If we have no immediate scope yet, then set it (this will always be set to the first one we hit)
        if (immediateScope == nullptr)
          immediateScope = currentScope;

        // Make sure we have no variables defined in our parent scope
        // (or any parent of that) with the same exact name
        if (currentScope->ScopedVariables.containsKey(node->Name.Token))
        {
          // We encountered a variable of the same name
          return ErrorAt(node, ErrorCode::DuplicateLocalVariableName, node->Name.c_str());
        }
      }

      // Get our parent's parent as a scope node
      currentParent = currentParent->Parent;
    }
    while (currentParent != nullptr);

    // Add the variable to the current function that we're working on
    Function* function = context->FunctionStack.back();
    Variable* variable = this->Builder->CreateRawVariable(function, node->Name.Token);
    variable->NameLocation = node->Name.Location;
    variable->Location = node->Location;

    // Use the comments as the variable description
    String description = node->GetMergedComments();
    variable->Description = description;

    // Go through all attributes and attach them to the variable
    this->ReadAttributes(node, node->Attributes, variable->Attributes);
    
    // Try to insert the variable into the scope, but if we fail...
    // There should NEVER be an error here since we checked above (or something really bad happened)
    immediateScope->ScopedVariables.insertOrError(variable->Name, variable);

    // Store the variable information
    node->CreatedVariable = variable;

    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // If the variable's type is inferred...
    if (node->IsInferred() == true)
    {
      // Error checking
      ErrorIf(initialValue == nullptr, "The initial value of a local variable was null");
      ErrorIf(initialValue->ResultType == nullptr, "The initial value's type was null");
      
      // Set the variable's type to the initial value's type
      variable->ResultType = initialValue->ResultType;
    }
    else
    {
      // Get the variables type from the syntax type
      variable->ResultType = this->RetrieveType(node->ResultSyntaxType, node->Location);

      // If we weren't able to determine the type, then we already threw an error
      if (this->Errors.WasError)
        return;

      // If we have an initial value...
      if (initialValue != nullptr)
      {
        // We need to check for cases where the result types could be null
        if (this->Errors.TolerantMode)
        {
          // If the variable was not able to resolve its type...
          if (variable->ResultType == nullptr)
          {
            // Lets just try and assume the type will be our initial value type, if it works?
            if (initialValue->ResultType != nullptr)
            {
              // This is actually similar to how we infer local variable types
              variable->ResultType = initialValue->ResultType;
            }
            else
            {
              // Otherwise, we have nothing better to assume this type is
              // Just make it void so it won't crash later
              variable->ResultType = core.ErrorType;
            }
          }

          // If for some reason the initial value has no type...
          if (initialValue->ResultType == nullptr)
          {
            // Lets assume the initial value type will be the variable's type!
            initialValue->ResultType = variable->ResultType;
          }
        }

        // Check if the types match, or if we can implicitly convert one to our resulting type
        if (this->ImplicitConvertAfterWalkAndIo(node->InitialValue, variable->ResultType) == false)
        {
          // The expression assigned to the variable was not of the same type as the variable
          return ErrorAt
          (
            node, ErrorCode::VariableTypeMismatch,
            variable->Name.c_str(),
            variable->ResultType->ToString().c_str(),
            initialValue->ResultType->ToString().c_str()
          );
        }
      }
    }

    // We treat local variables as expressions, so they must output their resulting type (just the type of the variable)
    node->ResultType = variable->ResultType;
  }

  //***************************************************************************
  void Syntaxer::CheckDelete(DeleteNode*& node, TypingContext* context)
  {
    // Process the deleted object expression
    context->Walker->Walk(this, node->DeletedObject, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // The handle we're deleting needs to be readable (so we can read the handle's value)
    // For example, it cannot be a 'set' only property that we are deleting
    node->DeletedObject->IoUsage = IoMode::ReadRValue;

    // The type of the deleted object has to at least be a reference
    if (Type::IsHandleType(node->DeletedObject->ResultType) == false)
    {
      return this->ErrorAt(node->DeletedObject, ErrorCode::DeletingNonReferenceType);
    }
  }

  //***************************************************************************
  void Syntaxer::CheckThrow(ThrowNode*& node, TypingContext* context)
  {
    // Process the exception expression
    context->Walker->Walk(this, node->Exception, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // The value we're throwing needs to be readable
    node->Exception->IoUsage = IoMode::ReadRValue;

    // Grab the core library so we can use the exception type
    Core& core = Core::GetInstance();

    // Get the exception type as a bound type (it must be!)
    BoundType* exceptionType = TypeBinding::DynamicCast<BoundType*>(node->Exception->ResultType);

    // First, we need to check if the type is even a bound type (if not, it can't be thrown!)
    if (exceptionType == nullptr)
    {
      return this->ErrorAt(node->Exception, ErrorCode::ThrowTypeMustDeriveFromException);
    }

    // The type of the exception expression must derive from the core 'Exception' type
    if (TypeBinding::IsA(exceptionType, core.ExceptionType) == false)
    {
      return this->ErrorAt(node->Exception, ErrorCode::ThrowTypeMustDeriveFromException);
    }

    // Mark the parent scope as being a full return (nothing executes after a throw, much like a return)
    this->MarkParentScopeAsAllPathsReturn(node->Parent, false);
  }

  //***************************************************************************
  void Syntaxer::ProcessScopeStatements(ScopeNode* node, TypingContext* context)
  {
    // Loop through all the statements
    // Note: If any of the statements are a return value, it will set 'AllPathsReturn' for this node
    for (size_t i = 0; i < node->Statements.size(); ++i)
    {
      // If we hit a point where all code paths return,
      // yet we still have a statement left to parse...
      if (node->AllPathsReturn && node->IsDebugReturn == false)
      {
        // Statements after this point will never be reached!
        return ErrorAt(node->Statements[i], ErrorCode::StatementsWillNotBeExecutedEarlyReturn);
      }

      // Get the current statement
      StatementNode* statement = node->Statements[i];

      // Walk the statements
      context->Walker->Walk(this, statement, context);

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;

      // Check if the statement is an expression
      ExpressionNode* expression = TypeBinding::DynamicCast<ExpressionNode*>(statement);

      // If the node was an expression node...
      if (expression != nullptr)
      {
        // We mark every expression statement as having an
        // ignored IO usage, we don't care if it's read/write!
        expression->IoUsage = IoMode::Ignore;
      }
    }
  }

  //***************************************************************************
  // Check the condition and statements in a conditional loop
  void Syntaxer::CheckConditionalLoop(ConditionalLoopNode* node, TypingContext* context)
  {
    // Process the initial value expression
    context->Walker->Walk(this, node->Condition, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // We need to be able to read the conditional value
    node->Condition->IoUsage = IoMode::ReadRValue;

    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // Now that we've walked the condition, check to make sure it's a bool type
    // Check if the types match, or if we can implicitly convert one to our resulting type
    if (this->ImplicitConvertAfterWalkAndIo(node->Condition, core.BooleanType) == false)
    {
      // The condition was not a bool
      return ErrorAt
      (
        node->Condition,
        ErrorCode::ConditionMustBeABooleanType,
        node->Condition->ResultType->ToString().c_str()
      );
    }

    // Process all the statements inside the conditional loop
    this->ProcessScopeStatements(node, context);
  }

  //***************************************************************************
  void Syntaxer::CheckWhile(WhileNode*& node, TypingContext* context)
  {
    return CheckConditionalLoop(node, context);
  }

  //***************************************************************************
  void Syntaxer::CheckDoWhile(DoWhileNode*& node, TypingContext* context)
  {
    return CheckConditionalLoop(node, context);
  }

  //***************************************************************************
  void Syntaxer::CheckFor(ForNode*& node, TypingContext* context)
  {
    // If we have a range variable (only used in foreach)
    if (node->RangeVariable != nullptr)
    {
      // Process the variable
      context->Walker->Walk(this, node->RangeVariable, context);
    }

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // If we have a variable...
    if (node->ValueVariable != nullptr)
    {
      // Process the variable
      context->Walker->Walk(this, node->ValueVariable, context);
    }
    // Otherwise, we assume that we have an initialization expression
    else if (node->Initialization != nullptr)
    {
      // Process the initialization expression
      context->Walker->Walk(this, node->Initialization, context);

      // When using an initialization expression, we never need to either read or write from in
      // In that regard, we completely ignore however the user decides to use it
      node->Initialization->IoUsage = IoMode::Ignore;
    }

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Process the iterator expression
    context->Walker->Walk(this, node->Iterator, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // The iterator expression must be a readable one
    node->Iterator->IoUsage = IoMode::ReadRValue;

    // Now we want to check the condition
    return CheckConditionalLoop(node, context);
  }

  //***************************************************************************
  void Syntaxer::CheckLoop(LoopNode*& node, TypingContext* context)
  {
    // Process all the statements inside the loop
    this->ProcessScopeStatements(node, context);
  }

  //***************************************************************************
  void Syntaxer::CheckScope(ScopeNode*& node, TypingContext* context)
  {
    // Process all the statements inside the scope
    this->ProcessScopeStatements(node, context);
  }

  //***************************************************************************
  void Syntaxer::CheckTimeout(TimeoutNode*& node, TypingContext* context)
  {
    // Process all the statements inside the scope
    this->ProcessScopeStatements(node, context);
  }

  //***************************************************************************
  void Syntaxer::CheckIfRoot(IfRootNode*& node, TypingContext* context)
  {
    // Walk all the parts of the if statement
    context->Walker->GenericWalkChildren(this, node, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // We got a completely empty if statement (probably an if with no body), just early out
    if (this->Errors.TolerantMode && node->IfParts.empty())
      return;

    // Check if we have a standalone else statement (only logical when we have at least 2 parts of the if)
    bool hasNonConditionalElse = (node->IfParts.back()->Condition == nullptr);
    
    // If we have a non-conditional else, then it's possible that all paths of the if statement return from the function (or throw, etc)
    if (hasNonConditionalElse)
    {
      // We want to know if all the if parts of our if statement return, and if any of them are a debug return
      bool allIfPartsReturn = true;
      bool anyDebugReturns = false;

      // If any of the children are 'debug returns' then we mark all returns as being debug returns
      for (size_t i = 0; i < node->IfParts.size(); ++i)
      {
        // Grab the current part of the if statement
        IfNode* part = node->IfParts[i];

        // If we encounter any part of the if statement that doesn't return, then not all paths return!
        if (part->AllPathsReturn == false)
        {
          // Early out, no need to check anything else
          allIfPartsReturn = false;
          break;
        }

        // We just want to know if any if statement 
        anyDebugReturns |= part->IsDebugReturn;
      }

      // If we found that all of our if parts return...
      if (allIfPartsReturn)
      {
        // Inform our parent that all the paths return
        this->MarkParentScopeAsAllPathsReturn(node->Parent, anyDebugReturns);
      }
    }
  }

  //***************************************************************************
  void Syntaxer::CheckIf(IfNode*& node, TypingContext* context)
  {
    // If we have a condition...
    if (node->Condition != nullptr)
    {
      // Process the initial value expression
      context->Walker->Walk(this, node->Condition, context);

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;

      // We need to be able to read the conditional value
      node->Condition->IoUsage = IoMode::ReadRValue;

      // Get the instance of the type database
      Core& core = Core::GetInstance();

      // Now that we've walked the condition, check to make sure it's a bool type
      // Check if the types match, or if we can implicitly convert one to our resulting type
      if (this->ImplicitConvertAfterWalkAndIo(node->Condition, core.BooleanType) == false)
      {
        // The condition was not a bool
        return ErrorAt
        (
          node->Condition,
          ErrorCode::ConditionMustBeABooleanType,
          node->Condition->ResultType->ToString().c_str()
        );
      }
    }

    // Process all the statements inside the if
    this->ProcessScopeStatements(node, context);
  }

  //***************************************************************************
  LoopScopeNode* Syntaxer::FindLoopScope(size_t scopeCount, SyntaxNode* parent)
  {
    // Loop until we reach the root (we never should actually...)
    while (parent != nullptr)
    {
      // We want to stop if we hit a function node
      if (TypeBinding::IsA(parent->ZilchGetDerivedType(), ZilchTypeId(FunctionNode)))
      {
        // We did not find it
        return nullptr;
      }

      // If we hit some kind of breakable scope, then decrement the scope counter
      LoopScopeNode* loopScope = TypeBinding::DynamicCast<LoopScopeNode*>(parent);
      if (loopScope != nullptr)
      {
        // Decrement the counter
        --scopeCount;

        // If the counter hits zero, we found the loop we wish to break out of
        if (scopeCount == 0)
        {
          // Return the found loop scope
          return loopScope;
        }
      }

      // Iterate to the parent node
      parent = parent->Parent;
    }

    // We did not find the node
    Error("We actually shouldn't be able to get here, since we should at least hit a class node");
    return nullptr;
  }

  //***************************************************************************
  void Syntaxer::CheckBreak(BreakNode*& node, TypingContext* /*context*/)
  {
    // Attempt to find the scope we're supposed to break out of
    LoopScopeNode* scope = FindLoopScope(node->ScopeCount, node->Parent);

    // If we found that scope
    if (scope != nullptr)
    {
      // Add ourselves to a break
      scope->Breaks.push_back(node);
    }
    else
    {
      // Error, we didn't find it
      return ErrorAt(node, ErrorCode::BreakLoopNotFound);
    }
  }

  //***************************************************************************
  void Syntaxer::CheckContinue(ContinueNode*& node, TypingContext* /*context*/)
  {
    // Attempt to find the scope we're supposed to break out of
    LoopScopeNode* scope = FindLoopScope(1, node->Parent);

    // If we found that scope
    if (scope != nullptr)
    {
      // Add ourselves to a break
      scope->Continues.push_back(node);
    }
    else
    {
      // Error, we didn't find it
      return ErrorAt(node, ErrorCode::ContinueLoopNotFound);
    }
  }

  //***************************************************************************
  void Syntaxer::ResolveLocalVariableReference(LocalVariableReferenceNode*& node, TypingContext* /*context*/)
  {
    // We can both read and write to local variables
    node->Io = (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue);

    // Get the parent node (we'll also use this for iteration up the nodes)
    SyntaxNode* parent = node->Parent;

    // Loop until we reach the root (or something else below breaks us out)
    while (parent != nullptr)
    {
      // Check if our parent is a scope
      ScopeNode* scopedParent = TypeBinding::DynamicCast<ScopeNode*>(parent);

      // If it is indeed a scope...
      if (scopedParent != nullptr)
      {
        // Loop through all the variables at that scope
        for (size_t i = 0; i < scopedParent->ScopedVariables.size(); ++i)
        {
          // Get the current variable
          VariableRange range = scopedParent->ScopedVariables.find(node->Value.Token);

          // If we have a match with the variable's name...
          if (range.empty() == false)
          {
            // Get a pointer to the variable info
            Variable* variable = range.front().second;

            // Copy over the value, the node the identifier is referencing, and the type
            node->Access.Type = OperandType::Local;
            node->AccessedVariable    = variable;
            node->ResultType  = variable->ResultType;
            return;
          }
        }
      }

      // Iterate to the next parent
      parent = parent->Parent;
    }

    // An identifier was used, but we couldn't find the variable it was referencing!
    return ErrorAt
    (
      node,
      ErrorCode::LocalVariableReferenceNotFound,
      node->Value.Token.c_str()
    );
  }

  //***************************************************************************
  void Syntaxer::MarkParentScopeAsAllPathsReturn(SyntaxNode* parent, bool isDebugReturn)
  {
    // After we've actually checked the return is valid
    // Loop up the parents until we reach a scope node or the root
    while (parent != nullptr)
    {
      // Check if our parent is a scope
      ScopeNode* scopedParent = TypeBinding::DynamicCast<ScopeNode*>(parent);

      // If it is indeed a scope...
      if (scopedParent != nullptr)
      {
        // We hit a return statement, so this scope must return
        scopedParent->AllPathsReturn = true;

        // Debug return bubbles up
        scopedParent->IsDebugReturn |= isDebugReturn;
        return;
      }

      // Iterate to the next parent
      parent = parent->Parent;
    }

    // Error checking
    Error("We should never reach the root node!");
  }

  //***************************************************************************
  bool Syntaxer::ImplicitConvertAfterWalkAndIo(ExpressionNode*& nodeToReparent, Type* toType)
  {
    // We're casting from the original type of the node that we're re-parenting
    Type* fromType = nodeToReparent->ResultType;

    // First we need to see what kind of cast operation we're dealing with
    Shared& shared = Shared::GetInstance();
    CastOperator cast = shared.GetCastOperator(fromType, toType);

    // If there is no cast operator or it's not implicit, return that we can't do it!
    if (cast.IsValid == false || cast.CanBeImplicit == false)
      return false;

    // If the cast is a 'raw' cast, then there's nothing to do!
    // This means it is valid cast, but we don't actually need to generate a type cast node since no code-gen is required
    if (cast.RequiresCodeGeneration == false)
      return true;

    // Create the type cast node (our main operand is the given node, we are re-parenting the cast)
    TypeCastNode* typeCast = new TypeCastNode();
    typeCast->Operand = nodeToReparent;
    typeCast->OperatorInfo = cast;
    typeCast->Location = nodeToReparent->Location;
    
    // The result type is the type we're casting to in the type cast operation
    typeCast->ResultType = toType;

    // A type cast only requires read ability from the operand
    typeCast->Io = IoMode::ReadRValue;

    // We inherit whatever type of Io we applied to the node itself (typically just Read)
    typeCast->IoUsage = nodeToReparent->IoUsage;
    typeCast->IsUsedAsStatement = false;

    // Finally, perform the re-parenting
    nodeToReparent = typeCast;

    // We performed the implicit cast
    return true;
  }

  //***************************************************************************
  void Syntaxer::CheckReturn(ReturnNode*& node, TypingContext* context)
  {
    // Get the function on the top of the stack
    Function* function = context->FunctionStack.back();

    // Get the return type for convenience
    Type* returnType = function->FunctionType->Return;

    // Get a reference to the core library
    Core& core = Core::GetInstance();

    // If we have a return type for this function...
    if (Type::IsSame(returnType, core.VoidType) == false)
    {
      // As long as we have an actual return value
      if (node->ReturnValue != nullptr)
      {
        // Process the return value expression
        context->Walker->Walk(this, node->ReturnValue, context);

        // If an error occurred, exit out
        if (this->Errors.WasError)
          return;

        // We need to be able to read the value we're returning
        node->ReturnValue->IoUsage = IoMode::ReadRValue;

        // Check if the types match, or if we can implicitly convert one to our resulting type
        if (this->ImplicitConvertAfterWalkAndIo(node->ReturnValue, returnType) == false)
        {
          // The return values given did not match the function signature
          return ErrorAt
          (
            node,
            ErrorCode::ReturnTypeMismatch,
            node->ReturnValue->ResultType->ToString().c_str(),
            returnType->ToString().c_str()
          );
        }
      }
      else
      {
        // The return value was not found
        return ErrorAt(node, ErrorCode::ReturnValueNotFound, returnType->ToString().c_str());
      }
    }
    else
    {
      // As long as we have an actual return value
      if (node->ReturnValue != nullptr)
      {
        // A return value was given, but was totally not expected
        return ErrorAt
        (
          node,
          ErrorCode::ReturnValueUnexpected,
          node->ReturnValue->ResultType->ToString().c_str());
      }
    }

    // Mark the parent scope as being a full return (since this is a return!)
    this->MarkParentScopeAsAllPathsReturn(node->Parent, node->IsDebugReturn);
  }

  //***************************************************************************
  void Syntaxer::DecorateCheckTypeCast(TypeCastNode*& node, TypingContext* context)
  {
    // The result of a type cast will always be read only
    node->Io = IoMode::ReadRValue;

    // Get the actual type definition associated with the type-cast
    node->ResultType = this->RetrieveType(node->Type, node->Location);

    // If for some reason the type was not resolved, exit out
    if (this->Errors.WasError)
      return;

    // Now we need to traverse the expression!
    context->Walker->Walk(this, node->Operand, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // The operand only needs to be readable
    node->Operand->IoUsage = IoMode::ReadRValue;

    // Rename the types for convenience
    Type* fromType = node->Operand->ResultType;
    Type* toType = node->ResultType;

    // Figure out what kind of cast this is
    Shared& shared = Shared::GetInstance();
    node->OperatorInfo = shared.GetCastOperator(fromType, toType);

    // If the cast was not valid any way we tried it...
    if (node->OperatorInfo.IsValid == false)
    {
      // Inform the user that the types they were attempting to cast between are not valid
      return ErrorAt
      (
        node,
        ErrorCode::InvalidTypeCast,
        fromType->ToString().c_str(),
        toType->ToString().c_str()
      );
    }
  }

  //***************************************************************************
  void Syntaxer::DecorateCheckFunctionCall(FunctionCallNode*& node, TypingContext* context)
  {
    // For right now, all function calls will result in a read only
    // (note that when we get references properly working, this won't be the case)
    node->Io = IoMode::ReadRValue;

    // Process the left expression first
    if (node->LeftOperand != nullptr)
    {
      // Walk the left expression and compute its types
      context->Walker->Walk(this, node->LeftOperand, context);

      // The left hand node only needs to be readable
      node->LeftOperand->IoUsage = IoMode::ReadRValue;
    }

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Loop through all the arguments
    for (size_t i = 0; i < node->Arguments.size(); ++i)
    {
      // Get the current argument
      ExpressionNode* argument = node->Arguments[i];

      // Walk the arguments so they get properly typed
      context->Walker->Walk(this, argument, context);

      // The arguments only need to be readable
      argument->IoUsage = IoMode::ReadRValue;

      // If an error occurred, exit out
      if (this->Errors.WasError)
        return;
    }

    // Tells us if we already resolved the function and therefore checked parameter types
    bool resolvedAndChecked = false;

    // If this function call node is being used to invoke a constructor, we'll know because our left operand will actually
    // be a local variable whose initial value is a CreationCallNode
    // This is a bit complicated and maybe should be refactored, but this works for now
    StaticTypeNode* creationNode = node->FindCreationCall();
    if (creationNode != nullptr)
    {
      // Our resulting type should be the same as the creation call's type
      node->ResultType = creationNode->ResultType;

      // Attempt to find the overloaded functions with the matching name...
      BoundType* createdType = creationNode->ReferencedType;

      // Look at the creation node's overloaded/inherited constructors (see DecorateCreationCall)
      const FunctionArray* constructors = creationNode->OverloadedConstructors;

      // If we have one or more constructor, then resolve which one it is
      if (constructors != nullptr && constructors->empty() == false)
      {
        // Resolve the overload
        bool result = Overload::ResolveAndImplicitConvert(constructors, creationNode->ConstructorFunction, *node);
        
        // If the overload failed to be resolved... we need to throw an error
        if (result == false)
        {
          // Give a details report of the error
          return Overload::ReportError(this->Errors, node->Location, constructors, *node);
        }

        // If we got here, it means we successfully resolved the overload and checked it
        resolvedAndChecked = true;
      }
      // If the type we're creating is a native reference type and it has no constructors...
      else if (createdType->Native && createdType->CopyMode == TypeCopyMode::ReferenceType)
      {
        // It is always an error if we have no constructors
        return this->ErrorAt(node, ErrorCode::NativeTypesRequireConstructors, createdType->ToString().c_str());
      }
      // It is legal to have no constructors so long as no arguments were provided
      else if (node->Arguments.empty() == false)
      {
        // It is always an error if we have no constructors
        return this->ErrorAt(node, ErrorCode::NoArgumentConstructorsProvided, createdType->ToString().c_str());
      }
    }
    // If the left hand node is a base class initializer
    else if (InitializerNode* initializerNode = TypeBinding::DynamicCast<InitializerNode*>(node->LeftOperand))
    {
      // As long as this is a base class initializer...
      if (initializerNode->InitializerType->TokenId == Grammar::Base)
      {
        // Get a reference to the core library
        Core& core = Core::GetInstance();

        // We have no resulting type for this call
        node->ResultType = core.VoidType;

        // We should always be able to assume that an initializer is ONLY being called from the class it is within
        BoundType* classType = context->ClassTypeStack.front();
        BoundType* baseType = classType->BaseType;

        // Make sure the class type has a base class
        if (baseType == nullptr)
        {
          // It is an error to use a base class initializer without a base class
          return ErrorAt
          (
            node,
            ErrorCode::BaseClassInitializerRequiresBaseClassInheritance,
            classType->Name.c_str()
          );
        }

        // Walk up the base class chain until we find any constructors (we inherit constructors)
        // We start with the current class we're trying to create
        // Note: We can safely look up to our base classes because if we don't have a constructor
        // then we at least have been pre-constructed, and the user opted to not initialize anything with a constructor
        const FunctionArray* constructors = baseType->GetOverloadedInheritedConstructors();

        // If there is only one overload of the function, then we know its type!
        if (constructors != nullptr && constructors->empty() == false)
        {
          // Resolve the overload
          bool result = Overload::ResolveAndImplicitConvert(constructors, initializerNode->InitializerFunction, *node);
      
          // If the overload failed to be resolved... we need to throw an error
          if (result == false)
          {
            // Give a details report of the error
            return Overload::ReportError(this->Errors, node->Location, constructors, *node);
          }

          // Set the resulting type (the function on the node should now be valid)
          initializerNode->ResultType = initializerNode->InitializerFunction->FunctionType;

          // If we got here, it means we successfully resolved the overload and checked it
          resolvedAndChecked = true;
        }
        // If the type we're creating is a native reference type and it has no constructors...
        else if (baseType->Native && baseType->CopyMode == TypeCopyMode::ReferenceType)
        {
          // It is always an error if we have no constructors
          return this->ErrorAt(node, ErrorCode::NativeTypesRequireConstructors, baseType->ToString().c_str());
        }
        else
        {
          // It is always an error if we have no constructors
          return ErrorAt(node, ErrorCode::NoArgumentConstructorsProvided, baseType->ToString().c_str());
        }
      }
      else
      {
        // We need to handle 'this' constructor calling
        ZilchTodo("Handle constructor calling");
        Error("We don't currently handle constructor calling");
      }
    }
    // Otherwise, it's something else (like a direct function call, a delegate call, or an error)
    else if (node->LeftOperand != nullptr)
    {
      // If the left hand node is a member access node...
      // Otherwise, it could just be a delegate type!
      if (MemberAccessNode* functionMember = TypeBinding::DynamicCast<MemberAccessNode*>(node->LeftOperand))
      {
        // As long as the member access type is a functino
        if (functionMember->MemberType == MemberAccessType::Function)
        {
          // Resolve the overload
          bool result = Overload::ResolveAndImplicitConvert(functionMember->OverloadedFunctions, functionMember->AccessedFunction, *node);
      
          // If the overload failed to be resolved... we need to throw an error
          if (result == false)
          {
            // Give a details report of the error
            return Overload::ReportError(this->Errors, node->Location, functionMember->OverloadedFunctions, *node);
          }

          // Set the resulting type
          functionMember->ResultType = functionMember->AccessedFunction->FunctionType;

          // If we got here, it means we successfully resolved the overload and checked it
          resolvedAndChecked = true;
        }
      }

      // Attempt to get the left operand's type as a function type (signature)
      DelegateType* delegateType = TypeBinding::DynamicCast<DelegateType*>(node->LeftOperand->ResultType);

      // If the left hand side was not a delegate type...
      if (delegateType == nullptr)
      {
        // We're trying to invoke a function on something that isn't a function, like "5()"
        return ErrorAt(node, ErrorCode::FunctionCallOnNonCallableType);
      }

      // Note: I believe this got removed in error but we STILL need to check against
      // the delegate type IF we did not need to do overload resolution, as an example, invoking a stored delegate
      // We never want to run this twice due to double implicit conversion issues
      if (resolvedAndChecked == false && Overload::TestCallAndImplicitConvert(delegateType, *node) == false)
      {
        // Report and error that we failed to resolve against the delegate
        return Overload::ReportSingleError(this->Errors, node->Location, delegateType, *node);
      }

      // The "type" of the function call will be the type that it resolves to,
      // basically the return type of the function it's evaluating
      node->ResultType = delegateType->Return;
    } // Not a creation call
  }

  //***************************************************************************
  void Syntaxer::DecorateCheckBinaryOperator(BinaryOperatorNode*& node, TypingContext* context)
  {
    // Process all the left expression
    context->Walker->Walk(this, node->LeftOperand, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Process all the right expression
    context->Walker->Walk(this, node->RightOperand, context);

    // The right hand node only needs to be readable (in all cases, assignment, addition, etc)
    node->RightOperand->IoUsage = IoMode::ReadRValue;

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Get the instance of the type database
    Core& core = Core::GetInstance();
    Type* lhs = node->LeftOperand->ResultType;
    Type* rhs = node->RightOperand->ResultType;

    // Get the shared database and lookup the binary operator
    Shared& shared = Shared::GetInstance();
    node->OperatorInfo = shared.GetBinaryOperator(lhs, rhs, node->Operator->TokenId);

    // If we actually found a valid operator...
    if (node->OperatorInfo.IsValid)
    {
      // Note: Since an implicit cast of the left operand would change the node type, we must set the io-usage
      // BEFORE we perform the implicit cast. Also note that an implicit cast of the left argument should never
      // occur if the io usage is an l-value (that wouldn't make sense, GetBinaryOperator blocks these)
      // Output the result type and outmode
      node->ResultType = node->OperatorInfo.Result;
      node->LeftOperand->IoUsage = node->OperatorInfo.Io;

      // We already visited the left/right operands, which means its valid for us to generate any implicit type casts here
      // Check to see if we need to cast the left side
      if (node->OperatorInfo.CastLhsTo != nullptr)
      {
        // Apply the implicit conversion
        bool implicitCastResult = ImplicitConvertAfterWalkAndIo(node->LeftOperand, node->OperatorInfo.CastLhsTo);
        ErrorIf(implicitCastResult == false, "The operator told us that we could implicit cast, why did this fail?");
      }

      // Check to see if we need to cast the right side
      if (node->OperatorInfo.CastRhsTo != nullptr)
      {
        // Apply the implicit conversion
        bool implicitCastResult = ImplicitConvertAfterWalkAndIo(node->RightOperand, node->OperatorInfo.CastRhsTo);
        ErrorIf(implicitCastResult == false, "The operator told us that we could implicit cast, why did this fail?");
      }

      // Our usage is always the most restrictive of how the node designates
      // it can be used and how our operator designates it can be used
      node->Io = (IoMode::Enum)(node->LeftOperand->Io & node->LeftOperand->IoUsage);
    }
    else
    {
      // Report an error since we used two types that weren't of the same type!
      return ErrorAt(node, ErrorCode::InvalidBinaryOperation,
        node->Operator->Token.c_str(),
        Grammar::GetName(node->Operator->TokenId).c_str(),
        lhs->ToString().c_str(),
        rhs->ToString().c_str());
    }
  }

  //***************************************************************************
  void Syntaxer::DecorateCheckPropertyDelegateOperator(PropertyDelegateOperatorNode*& node, TypingContext* context)
  {
    // Process all the operand
    context->Walker->Walk(this, node->Operand, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Attempt to get the operand as a member access node...
    // This operator only works on properties and members
    MemberAccessNode* memberNode = TypeBinding::DynamicCast<MemberAccessNode*>(node->Operand);

    // If the operand is a member
    if (memberNode != nullptr)
    {
      // We only care if we accessed a property
      Property* property = nullptr;

      // If the member is a property...
      if (memberNode->AccessedProperty != nullptr)
      {
        property = memberNode->AccessedProperty;
      }
      // If the member is a straight data field (which is also a property!)
      else if (memberNode->AccessedField != nullptr)
      {
        property = memberNode->AccessedField;
      }

      // If we didn't find a property...
      if (property == nullptr)
      {
        // Report an error since we attempted to use the property delegate operator on a non-property
        return ErrorAt(node, ErrorCode::PropertyDelegateOperatorRequiresProperty);
      }

      // Make sure the property has the get and set functions
      if (property->Get == nullptr && property->Set == nullptr)
      {
        // Report an error since we can't form a property delegate to an object that has neither a get or set
        return ErrorAt(node, ErrorCode::PropertyDelegateRequiresGetOrSet, property->Name.c_str());
      }

      // The operand should either have a get or set, but we don't require one or the other
      node->Operand->IoUsage = IoMode::Ignore;

      // We're generating a temporary (just a read value)
      node->Io = IoMode::ReadRValue;

      // We need to instantiate the 'Property' template (an object that contains the get/set delegates)
      Array<Type*> templateArguments;
      templateArguments.push_back(property->PropertyType);

      // Instantiate the property object
      InstantiatedTemplate propertyTemplate = this->Builder->InstantiateTemplate(PropertyDelegateName, templateArguments, *this->Dependencies);

      // Make sure we instantiated the template
      ErrorIf(propertyTemplate.Result != TemplateResult::Success,
        "We should always be able to instantiate the property template!");

      // Our node's type is that property template type
      node->ResultType = propertyTemplate.Type;
      node->AccessedProperty = property;
    }
    else
    {
      // Report an error since we did some sort of an invalid binary operation between two types
      return ErrorAt(node, ErrorCode::PropertyDelegateOperatorRequiresProperty);
    }
  }

  //***************************************************************************
  void Syntaxer::DecorateCheckUnaryOperator(UnaryOperatorNode*& node, TypingContext* context)
  {
    // Process all the operand
    context->Walker->Walk(this, node->Operand, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // Get the operand type
    Type* operandType = node->Operand->ResultType;

    // Get the shared database and lookup the binary operator
    Shared& shared = Shared::GetInstance();
    node->OperatorInfo = shared.GetUnaryOperator(operandType, node->Operator->TokenId);

    // If we actually found a valid operator...
    if (node->OperatorInfo.IsValid)
    {
      // Output the result type and outmode
      node->ResultType = node->OperatorInfo.Result;
      node->Operand->IoUsage = node->OperatorInfo.Io;

      // Our usage is always the most restrictive of how the node designates
      // it can be used and how our operator designates it can be used
      node->Io = (IoMode::Enum)(node->Operand->Io & node->Operand->IoUsage);
    }
    else
    {
      // Report an error since we did some sort of an invalid binary operation between two types
      return ErrorAt(node, ErrorCode::InvalidUnaryOperation, operandType->ToString().c_str());
    }
  }

  //***************************************************************************
  void Syntaxer::DecorateCodeLocations(SyntaxNode*& node, TypingContext* context)
  {
    // If this node is a class node...
    ClassNode* classNode = TypeBinding::DynamicCast<ClassNode*>(node);
    if (classNode != nullptr)
    {
      // Push the class onto the stack so that children can access it
      // (the top of the stack will be the most relevant class to them)
      context->ClassTypeStack.push_back(classNode->Type);
    }
    
    // If this node is a function node...
    GenericFunctionNode* functionNode = TypeBinding::DynamicCast<GenericFunctionNode*>(node);
    if (functionNode != nullptr)
    {
      // Push the function onto the stack so that children can access it
      // (the top of the stack will be the most relevant function to them)
      context->FunctionStack.push_back(functionNode->DefinedFunction);
    }

    // The library is the name of our library builder
    node->Location.Library = this->Builder->BuiltLibrary->Name;

    // If we have a class in our context (we are inside a class)
    if (context->ClassTypeStack.empty() == false)
    {
      // Set the class name on the code location
      node->Location.Class = context->ClassTypeStack.back()->Name;
    }

    // If we have a function in our context (we are inside a function)
    if (context->FunctionStack.empty() == false)
    {
      // Why would we ever be inside a function but not inside a class?
      ErrorIf(context->ClassTypeStack.empty(), "Found a function that was not inside a class");

      // Set the function name on the code location
      node->Location.Function = context->FunctionStack.back()->Name;
    }

    // We need to traverse the children!
    // Normally we would return if any error occurred, but this is all useful information even with errors
    context->Walker->GenericWalkChildren(this, node, context);

    // If this node is a class node...
    if (classNode != nullptr)
    {
      // We are exiting this class, so pop it off
      context->ClassTypeStack.pop_back();
    }
    
    // If this node is a function node...
    if (functionNode != nullptr)
    {
      // We are exiting this class, so pop it off
      context->FunctionStack.pop_back();
    }
  }

  //***************************************************************************
  void Syntaxer::CheckExpressionIoModes(ExpressionNode*& node, TypingContext* context)
  {
    // We need to traverse the children!
    context->Walker->GenericWalkChildren(this, node, context);

    // If we had an error, do not continue
    if (this->Errors.WasError)
      return;

    // Skip any error checking if we're in tolerant mode...
    if (this->Errors.TolerantMode == false)
    {
      // Error checking
      ErrorIf(node->Io == IoMode::NotSet || node->Io == IoMode::Ignore,
        "A node's usage case was not set by its handler (or somehow it was set to ignore)");
      ErrorIf(node->IoUsage == IoMode::NotSet,
        "The parent node of an expression did not set the child's io usage");
      ErrorIf(node->ResultType == nullptr,
        "All expression node types must be valid (or void)");
    }

    // If we're trying to read from the node, but it's not readable...
    if ((node->IoUsage & IoMode::ReadRValue) != 0 && (node->Io & IoMode::ReadRValue) == 0)
    {
      // Report an error
      return ErrorAt(node, ErrorCode::ReadingFromAWriteOnlyValue);
    }

    // If we're trying to write to the node, but it's not writable...
    if ((node->IoUsage & IoMode::WriteLValue) != 0 && (node->Io & IoMode::WriteLValue) == 0)
    {
      // Report an error
      return ErrorAt(node, ErrorCode::WritingToAReadOnlyValue);
    }
  }

  //***************************************************************************
  void Syntaxer::ResolveMemberAccess(MemberAccessNode* node, const Resolver& resolver)
  {
    // Get access to the core library
    Core& core = Core::GetInstance();

    // Get the type instance for the type we're attempting to resolve on (the left operand generally)
    BoundType* type = resolver.TypeInstance;

    // Attempt to find a field with the matching name...
    Field* field = (type->*resolver.GetField)(node->Name);

    // If we found the member...
    if (field != nullptr)
    {
      // Set the member type (and resulting type)
      // We also want to set the access type to be a member, so that way anyone
      // who tries to modify it knows they can write directly to the member
      node->MemberType      = MemberAccessType::Field;
      node->Access.Type     = OperandType::Field;
      node->ResultType      = field->PropertyType;
      node->AccessedField   = field;

      // We can both read and write to a data member
      node->Io = (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue);

      // Exit out early
      return;
    }

    // Attempt to find a property with the matching name...
    Property* property = (type->*resolver.GetProperty)(node->Name);

    // If we found no property... attempt to look in dependency extension methods
    if (property == nullptr)
    {
      //ForEachExtensionProperty

      // Loop through all the libraries
      for (size_t i = 0; i < this->AllLibraries.size() && property == nullptr; ++i)
      {
        // Grab the current library
        LibraryRef& library = this->AllLibraries[i];

        // We need to look up the entire heirarchy (the property could be on any base classes)
        Type* baseIterator = type;
        do
        {
          // Get the guid of the type (this should be legal here since we've collected all members)
          GuidType guid = baseIterator->Hash();

          // If we're resolving a static member
          PropertyMap* properties = nullptr;
          if (resolver.IsStatic)
            properties = library->StaticExtensionProperties.findPointer(guid);
          else
            properties = library->InstanceExtensionProperties.findPointer(guid);
        
          // If we got a valid array of properties...
          if (properties != nullptr)
          {
            // Attempt to find the property by name
            // If we find it, the loop will terminate because we don't need to keep looking
            property = properties->findValue(node->Name, nullptr);
            if (property != nullptr)
              break;
          }
          
          // Iterate to the next type
          baseIterator = Type::GetBaseType(baseIterator);
        }
        while (baseIterator != nullptr);
      }
    }

    // If we found the property...
    if (property != nullptr)
    {
      // Set the property type (and resulting type)
      // We also want to set the access type to be a property, so that way anyone
      // who tries to modify it knows they must use a getter/setter
      node->MemberType        = MemberAccessType::Property;
      node->Access.Type       = OperandType::Property;
      node->AccessedProperty  = property;

      // Clear the io so we can set the flags below
      node->Io = IoMode::Ignore;

      // The resulting type is always the type of the property
      // Note this does NOT mean we produce this type (a set only property does not return a value)
      // But the result type must be set in order to assign to this property
      node->ResultType = property->PropertyType;

      // If we have a valid getter
      if (property->Get != nullptr)
        node->Io = (IoMode::Enum)(node->Io | IoMode::ReadRValue);
      
      // If we have a valid setter
      if (property->Set != nullptr)
        node->Io = (IoMode::Enum)(node->Io | IoMode::WriteLValue);

      // Exit out early
      return;
    }

    // Attempt to find the overloaded functions with the matching name...
    const FunctionArray* functions = (type->*resolver.GetOverloadedFunctions)(node->Name);

    // If we found no functions... attempt to look in dependency extension methods
    if (functions == nullptr || functions->empty())
    {
      // Loop through all the libraries
      for (size_t i = 0; i < this->AllLibraries.size(); ++i)
      {
        // Grab the current library
        LibraryRef& library = this->AllLibraries[i];

        // We need to look up the entire heirarchy (the property could be on any base classes)
        Type* baseIterator = type;
        do
        {
          // Get the guid of the type (this should be legal here since we've collected all members)
          GuidType guid = baseIterator->Hash();

          // If we're resolving a static member
          FunctionMultiMap* functionsByName = nullptr;
          if (resolver.IsStatic)
            functionsByName = library->StaticExtensionFunctions.findPointer(guid);
          else
            functionsByName = library->InstanceExtensionFunctions.findPointer(guid);
        
          // If we got a valid array of properties...
          if (functionsByName != nullptr)
          {
            // Attempt to find the property by name
            functions = functionsByName->findPointer(node->Name);

            // If we found a valid function array...
            if (functions != nullptr)
            {
              // We found it!
              break;
            }
          }

          // Iterate to the next type
          baseIterator = Type::GetBaseType(baseIterator);
        }
        while (baseIterator != nullptr);
      }
    }

    // If we found the functions...
    if (functions != nullptr && functions->empty() == false)
    {
      // The node represents a function member access
      node->MemberType = MemberAccessType::Function;

      // The function will be referenced as a local (delegates are always locally generated)
      node->Access.Type = OperandType::Local;
    
      // A function can only be read (and in that same note, it really means create a delegate)
      node->Io = IoMode::ReadRValue;

      // If we have only one function
      if (functions->size() == 1)
      {
        // For now, we assume that the function we result in is the only one it can be
        node->AccessedFunction = functions->front();
        node->ResultType = node->AccessedFunction->FunctionType;
      }
      else
      {
        // We don't yet know the function we'll resolve
        node->AccessedFunction = nullptr;
        node->ResultType = core.OverloadedMethodsType;
      }

      // Set the functions on the node
      node->OverloadedFunctions = functions;

      // Exit out early
      return;
    }

    // A member access/identifier was used, but we couldn't find the member it was referencing!
    return ErrorAt(node, ErrorCode::MemberNotFound, node->Name.c_str(), type->ToString().c_str());
  }
  
  //***************************************************************************
  template <typename NodeType>
  void Syntaxer::BuildGetSetSideEffectIndexerNodes(NodeType*& node, IndexerCallNode* indexer, ExpressionNode* NodeType::* operandMemberThatWasIndexer, TypingContext* context)
  {
    // No node directly points at a BinaryOperatorNode/UnaryOperatorNode (typically just expression children)
    // This would otherwise be an unsafe assumption
    NodeType* operatorNode = node;
    ExpressionNode*& parentsChildPointer = (ExpressionNode*&)node;

    // Example:
    // this.GameBoard.Grid[this.ComputeIndexX(), yValue] += Real3(1, 1, 5);
    // var [source] = this.GameBoard.Grid;
    // var [index0] = this.ComputeIndex();
    // var [index1] = yValue;
    // var [value] = [source].Get([index0], [index1]);
    // [value] += Real3(1, 1, 5);
    // yield [source].Set([index0], [index1], [value]);

    // The entire binary/unary operator gets replaced with a multi-expression that does get/op/set
    MultiExpressionNode* multiGetSet = new MultiExpressionNode();
    multiGetSet->Location = indexer->Location;
    parentsChildPointer = multiGetSet;

    // We explicitly use this as an expression (the indexer no longer owns the left hand side, typically member access)
    // var [source] = this.GameBoard.Grid;
    LocalVariableNode* sourceVar = new LocalVariableNode("source", this->ParentProject, indexer->LeftOperand);
    indexer->LeftOperand = nullptr;
    sourceVar->Location = indexer->Location;
    multiGetSet->Expressions.Add(sourceVar);

    // [source].Get([index0], [index1]...);
    LocalVariableReferenceNode* getSourceRef = new LocalVariableReferenceNode();
    getSourceRef->Location = indexer->Location;
    getSourceRef->Value = sourceVar->Name;
    MemberAccessNode* getMember = new MemberAccessNode();
    getMember->Location = indexer->Location;
    getMember->LeftOperand = getSourceRef;
    getMember->Name = OperatorGet;
    getMember->Operator = Grammar::Access;
    FunctionCallNode* getCall = new FunctionCallNode();
    getCall->Location = indexer->Location;
    getCall->LeftOperand = getMember;

    // [source].Set([index0], [index1]..., [value]);
    LocalVariableReferenceNode* setSourceRef = new LocalVariableReferenceNode();
    setSourceRef->Location = indexer->Location;
    setSourceRef->Value = sourceVar->Name;
    MemberAccessNode* setMember = new MemberAccessNode();
    setMember->Location = indexer->Location;
    setMember->LeftOperand = setSourceRef;
    setMember->Name = OperatorSet;
    setMember->Operator = Grammar::Access;
    FunctionCallNode* setCall = new FunctionCallNode();
    setCall->Location = indexer->Location;
    setCall->LeftOperand = setMember;

    for (size_t i = 0; i < indexer->Arguments.size(); ++i)
    {
      // var [index#] = this.ComputeIndex();
      ExpressionNode* computeIndex = indexer->Arguments[i];
      LocalVariableNode* indexVar = new LocalVariableNode(String::Format("index%d_", i), this->ParentProject, computeIndex);
      indexVar->Location = indexer->Location;
      multiGetSet->Expressions.Add(indexVar);

      // Make a local variable reference to the index variable (for invoking the getter)
      LocalVariableReferenceNode* indexRefGet = new LocalVariableReferenceNode();
      indexRefGet->Location = indexer->Location;
      indexRefGet->Value = indexVar->Name;
      getCall->Arguments.Add(indexRefGet);

      // Make a local variable reference to the index variable (for invoking the setter)
      LocalVariableReferenceNode* indexRefSet = new LocalVariableReferenceNode();
      indexRefSet->Location = indexer->Location;
      indexRefSet->Value = indexVar->Name;
      setCall->Arguments.Add(indexRefSet);
    }

    // The indexer no longer owns its arguments
    indexer->Arguments.clear();
        
    // var [value] = [source].Get([index0], [index1]...);
    // Because our multi-expression yields this value, we need to get the index that we pushed it into the expressions list as
    LocalVariableNode* valueVar = new LocalVariableNode("value", this->ParentProject, getCall);
    valueVar->Location = indexer->Location;
    multiGetSet->Expressions.Add(valueVar);
    
    // [value] += Real3(1, 1, 5); // Binary
    // ++[value];                 // Unary
    // Here, we actually re-assign the left operand of the binary/unary node to be a reference to the above value variable
    LocalVariableReferenceNode* valueRefOperation = new LocalVariableReferenceNode();
    valueRefOperation->Location = indexer->Location;
    valueRefOperation->Value = valueVar->Name;
    operatorNode->*operandMemberThatWasIndexer = valueRefOperation;
    multiGetSet->Expressions.Add(operatorNode);
    
    // Now we actually add in the full set call (constructed above)
    // yield [source].Set([index0], [index1]..., [value]);
    LocalVariableReferenceNode* valueRefSet = new LocalVariableReferenceNode();
    valueRefSet->Location = indexer->Location;
    valueRefSet->Value = valueVar->Name;
    setCall->Arguments.Add(valueRefSet);
    multiGetSet->YieldChildExpressionIndex = multiGetSet->Expressions.size();
    multiGetSet->Expressions.Add(setCall);

    // We're done with the indexer (may want to store this later for formatting walkers)
    delete indexer;

    // Walk the children of the multi-node (because they could have binary/unary operators that also need to be transformed)
    context->Walker->GenericWalkChildren(this, multiGetSet, context);
  }
  
  //***************************************************************************
  void Syntaxer::IndexerBinaryOperator(BinaryOperatorNode*& node, TypingContext* context)
  {
    // No node directly points at a BinaryOperatorNode (typically just expression children)
    // This would otherwise be an unsafe assumption
    BinaryOperatorNode* binaryOperator = node;
    ExpressionNode*& parentsChildPointer = (ExpressionNode*&)node;

    // We only need to do the transformation if the left operand 
    IndexerCallNode* indexer = TypeBinding::DynamicCast<IndexerCallNode*>(binaryOperator->LeftOperand);
    if (indexer == nullptr)
    {
      // Walk the children (because they could have binary operators that also need to be transformed)
      context->Walker->GenericWalkChildren(this, binaryOperator, context);
      return;
    }

    // Based on the operator (if its a side effect operator...)
    switch (binaryOperator->Operator->TokenId)
    {
      // The ultimate side effect operator! Not a compound operator though so we only need to run Set
      case Grammar::Assignment:
      {
        // Example:
        // this.GameBoard.Grid[this.ComputeIndexX(), yValue] = Real3(1, 1, 5);
        // this.GameBoard.Grid.Set(this.ComputeIndexX(), yValue, [value]);
        MemberAccessNode* setMember = new MemberAccessNode();
        setMember->Location = indexer->Location;
        setMember->LeftOperand = indexer->LeftOperand;
        indexer->LeftOperand = nullptr;
        setMember->Name = OperatorSet;
        setMember->Operator = Grammar::Access;
        FunctionCallNode* setCall = new FunctionCallNode();
        setCall->Location = indexer->Location;
        setCall->LeftOperand = setMember;
        parentsChildPointer = setCall;

        // Our set call has all the same arguments as the indexer (plus the value, which we handle below)
        // The indexer no longer owns these arguments
        setCall->Arguments = indexer->Arguments;
        indexer->Arguments.clear();
        
        // Finally, add the 'set' as the last argument to our call to 'Set'
        setCall->Arguments.Add(binaryOperator->RightOperand);
        binaryOperator->RightOperand = nullptr;

        // We're done with the binary operator and indexer (may want to store this later for formatting walkers)
        // Note: The indexer gets deleted by the binary operator because its a child!
        delete binaryOperator;

        // Walk the children of the multi-node (because they could have binary operators that also need to be transformed)
        context->Walker->GenericWalkChildren(this, setCall, context);
        return;
      }

      // If the operator is a compound side-effect operator, then we need to invoke both Get and Set on the indexer
      case Grammar::AssignmentSubtract:
      case Grammar::AssignmentAdd:
      case Grammar::AssignmentDivide:
      case Grammar::AssignmentMultiply:
      case Grammar::AssignmentModulo:
      case Grammar::AssignmentExponent:
      case Grammar::AssignmentLeftShift:
      case Grammar::AssignmentRightShift:
      case Grammar::AssignmentBitwiseXor:
      case Grammar::AssignmentBitwiseOr:
      case Grammar::AssignmentBitwiseAnd:
      {
        // Build the nodes that perform the Get/Operator/Set
        // Binary and unary are similar, so this was refactored into a single function
        this->BuildGetSetSideEffectIndexerNodes(node, indexer, &BinaryOperatorNode::LeftOperand, context);
        return;
      }

      // We hit another operator, but it wasn't a side effect operator (just continue visiting)
      default:
      {

        // Walk the children (because they could have binary operators that also need to be transformed)
        context->Walker->GenericWalkChildren(this, binaryOperator, context);
        return;
      }
    }
  }
  
  //***************************************************************************
  void Syntaxer::IndexerUnaryOperator(UnaryOperatorNode*& node, TypingContext* context)
  {
    // No node directly points at a UnaryOperatorNode (typically just expression children)
    // This would otherwise be an unsafe assumption
    UnaryOperatorNode* unaryOperator = node;
    ExpressionNode*& parentsChildPointer = (ExpressionNode*&)node;

    // We only need to do the transformation if the left operand 
    IndexerCallNode* indexer = TypeBinding::DynamicCast<IndexerCallNode*>(unaryOperator->Operand);
    if (indexer == nullptr)
    {
      // Walk the children (because they could have binary operators that also need to be transformed)
      context->Walker->GenericWalkChildren(this, unaryOperator, context);
      return;
    }

    // Based on the operator (if its a side effect operator...)
    switch (unaryOperator->Operator->TokenId)
    {
      // The ultimate side effect operator! Not a compound operator though so we only need to run Set
      case Grammar::Increment:
      case Grammar::Decrement:
      {
        // Build the nodes that perform the Get/Operator/Set
        // Binary and unary are similar, so this was refactored into a single function
        this->BuildGetSetSideEffectIndexerNodes(node, indexer, &UnaryOperatorNode::Operand, context);
        return;
      }

      // We hit another operator, but it wasn't a side effect operator (just continue visiting)
      default:
      {
        // Walk the children (because they could have binary operators that also need to be transformed)
        context->Walker->GenericWalkChildren(this, unaryOperator, context);
        return;
      }
    }
  }
  
  //***************************************************************************
  void Syntaxer::IndexerIndexerCall(IndexerCallNode*& node, TypingContext* context)
  {
    // No node directly points at a IndexerCallNode (typically just expression children)
    // This would otherwise be an unsafe assumption
    IndexerCallNode* indexer = node;
    ExpressionNode*& parentsChildPointer = (ExpressionNode*&)node;

    // Walk the children (because they could have binary operators that also need to be transformed)
    context->Walker->GenericWalkChildren(this, indexer, context);

    // this.GameBoard.Grid[this.ComputeIndexX(), yValue];
    // this.GameBoard.Grid.Get(this.ComputeIndexX(), yValue);
    // We remove the indexer call and replace it with the get call
    MemberAccessNode* getMember = new MemberAccessNode();
    getMember->Location = indexer->Location;
    getMember->LeftOperand = indexer->LeftOperand;
    indexer->LeftOperand = nullptr;
    getMember->Name = OperatorGet;
    getMember->Operator = Grammar::Access;
    FunctionCallNode* getCall = new FunctionCallNode();
    getCall->Location = indexer->Location;
    getCall->LeftOperand = getMember;
    parentsChildPointer = getCall;

    // Our get call has all the exact same arguments as the indexer
    // The indexer no longer owns these arguments
    getCall->Arguments = indexer->Arguments;
    indexer->Arguments.clear();

    // We're done with the indexer (may want to store this later for formatting walkers)
    delete indexer;
    return;
  }

  //***************************************************************************
  void Syntaxer::ResolveMember(MemberAccessNode*& node, TypingContext* context)
  {
    // Process the left expression first
    context->Walker->Walk(this, node->LeftOperand, context);

    // If an error occurred, exit out
    if (this->Errors.WasError)
      return;

    // The left operand only needs to be readable
    node->LeftOperand->IoUsage = IoMode::ReadRValue;
    
    // Get a reference to the left expression's type
    Type* leftType = node->LeftOperand->ResultType;

    // If the left hand side is the 'any' type, it means we're accessing a dynamic property
    // A dynamic property is one that is resolved by string at runtime
    AnyType* anyType = TypeBinding::DynamicCast<AnyType*>(leftType);
    if (anyType != nullptr)
    {
      // Set the member type (and resulting type)
      // We also want to set the access type to be a member, so that way anyone
      // who tries to modify it knows they can write directly to the member
      node->MemberType = MemberAccessType::Dynamic;
      //node->Access.Type     = OperandType::;????

      // Right now, we're only allowing reading from 'any' values (no writing to them)
      node->Io = IoMode::ReadRValue;
      //node->Io = (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue);

      // The resulting type will always end up being the 'any' type (which allows for chaining)
      node->ResultType = ZilchTypeId(Any);
      this->ErrorAt(node, ErrorCode::GenericError,
        "Accessing members on the 'Any' type will result in dynamically looking up the value, however this is not yet supported");
      // Exit out early
      return;
    }

    // Check if the left type is a bound type because we can directly look up members on a bound type
    BoundType* boundType = Type::GetBoundType(leftType);
    if (boundType != nullptr)
    {
      // If this is accessing statics then use a static resolver, otherwise we're accessing instance members
      StaticTypeNode* staticType = TypeBinding::DynamicCast<StaticTypeNode*>(node->LeftOperand);
      if (staticType != nullptr)
      {
        // We're accessing a static member
        node->IsStatic = true;
        this->ResolveMemberAccess(node, Resolver::Static(boundType));
      }
      else
      {
        // We're accessing an instance member
        node->IsStatic = false;
        this->ResolveMemberAccess(node, Resolver::Instance(boundType));
      }
    }
    else
    {
      // Only bound types have actual members that can be looked up
      // Any types are handled above and use a special dynamic access
      this->ErrorAt(node, ErrorCode::MemberNotFound, node->Name.c_str(), leftType->ToString().c_str());
    }
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes








namespace Zilch
{
  //***************************************************************************
  ZilchDefineStaticLibrary(Syntax)
  {
    ZilchInitializeType(SyntaxType);
    ZilchInitializeType(AnySyntaxType);
    ZilchInitializeType(IndirectionSyntaxType);
    ZilchInitializeType(BoundSyntaxType);
    ZilchInitializeType(DelegateSyntaxType);

    ZilchInitializeType(SyntaxNode);
    ZilchInitializeType(RootNode);
    ZilchInitializeType(AttributeNode);
    ZilchInitializeType(StatementNode);
    ZilchInitializeType(ExpressionNode);
    ZilchInitializeType(BinaryOperatorNode);
    ZilchInitializeType(UnaryOperatorNode);
    ZilchInitializeType(PropertyDelegateOperatorNode);
    ZilchInitializeType(TypeCastNode);
    ZilchInitializeType(PostExpressionNode);
    ZilchInitializeType(IndexerCallNode);
    ZilchInitializeType(FunctionCallNode);
    ZilchInitializeType(MemberAccessNode);
    ZilchInitializeType(ExpressionInitializerNode);
    ZilchInitializeType(ExpressionInitializerMemberNode);
    ZilchInitializeType(ExpressionInitializerAddNode);
    ZilchInitializeType(MultiExpressionNode);
    ZilchInitializeType(VariableNode);
    ZilchInitializeType(LocalVariableNode);
    ZilchInitializeType(ParameterNode);
    ZilchInitializeType(MemberVariableNode);
    ZilchInitializeType(ValueNode);
    ZilchInitializeType(StringInterpolantNode);
    ZilchInitializeType(DeleteNode);
    ZilchInitializeType(ReturnNode);
    ZilchInitializeType(ScopeNode);
    ZilchInitializeType(StaticTypeNode);
    ZilchInitializeType(TimeoutNode);
    ZilchInitializeType(IfNode);
    ZilchInitializeType(IfRootNode);
    ZilchInitializeType(SendsEventNode);
    ZilchInitializeType(BreakNode);
    ZilchInitializeType(DebugBreakNode);
    ZilchInitializeType(ContinueNode);
    ZilchInitializeType(LoopScopeNode);
    ZilchInitializeType(ConditionalLoopNode);
    ZilchInitializeType(WhileNode);
    ZilchInitializeType(DoWhileNode);
    ZilchInitializeType(ForNode);
    ZilchInitializeType(ForEachNode);
    ZilchInitializeType(LoopNode);
    ZilchInitializeType(GenericFunctionNode);
    ZilchInitializeType(FunctionNode);
    ZilchInitializeType(InitializerNode);
    ZilchInitializeType(ConstructorNode);
    ZilchInitializeType(DestructorNode);
    ZilchInitializeType(ClassNode);
    ZilchInitializeType(TypeDefineNode);
    ZilchInitializeType(LocalVariableReferenceNode);
    ZilchInitializeType(ThrowNode);
    ZilchInitializeType(TypeIdNode);
    ZilchInitializeType(EnumValueNode);
    ZilchInitializeType(EnumNode);
  }

  //***************************************************************************
  ZilchDefineType(SyntaxType,                       "SyntaxType",                       Syntax, builder, type) {}
  ZilchDefineType(AnySyntaxType,                    "AnySyntaxType",                    Syntax, builder, type) {}
  ZilchDefineType(IndirectionSyntaxType,            "IndirectionSyntaxType",            Syntax, builder, type) {}
  ZilchDefineType(BoundSyntaxType,                  "BoundSyntaxType",                  Syntax, builder, type) {}
  ZilchDefineType(DelegateSyntaxType,               "DelegateSyntaxType",               Syntax, builder, type) {}
  
  //***************************************************************************
  ZilchDefineType(SyntaxNode,                       "SyntaxNode",                       Syntax, builder, type) {}
  ZilchDefineType(RootNode,                         "RootNode",                         Syntax, builder, type) {}
  ZilchDefineType(AttributeNode,                    "AttributeNode",                    Syntax, builder, type) {}
  ZilchDefineType(StatementNode,                    "StatementNode",                    Syntax, builder, type) {}
  ZilchDefineType(ExpressionNode,                   "ExpressionNode",                   Syntax, builder, type) {}
  ZilchDefineType(BinaryOperatorNode,               "BinaryOperatorNode",               Syntax, builder, type) {}
  ZilchDefineType(UnaryOperatorNode,                "UnaryOperatorNode",                Syntax, builder, type) {}
  ZilchDefineType(PropertyDelegateOperatorNode,     "PropertyDelegateOperatorNode",     Syntax, builder, type) {}
  ZilchDefineType(TypeCastNode,                     "TypeCastNode",                     Syntax, builder, type) {}
  ZilchDefineType(PostExpressionNode,               "PostExpressionNode",               Syntax, builder, type) {}
  ZilchDefineType(IndexerCallNode,                  "IndexerCallNode",                  Syntax, builder, type) {}
  ZilchDefineType(FunctionCallNode,                 "FunctionCallNode",                 Syntax, builder, type) {}
  ZilchDefineType(MemberAccessNode,                 "MemberAccessNode",                 Syntax, builder, type) {}
  ZilchDefineType(ExpressionInitializerNode,        "ExpressionInitializerNode",        Syntax, builder, type) {}
  ZilchDefineType(ExpressionInitializerMemberNode,  "ExpressionInitializerMemberNode",  Syntax, builder, type) {}
  ZilchDefineType(ExpressionInitializerAddNode,     "ExpressionInitializerAddNode",     Syntax, builder, type) {}
  ZilchDefineType(MultiExpressionNode,              "MultiExpressionNode",              Syntax, builder, type) {}
  ZilchDefineType(VariableNode,                     "VariableNode",                     Syntax, builder, type) {}
  ZilchDefineType(LocalVariableNode,                "LocalVariableNode",                Syntax, builder, type) {}
  ZilchDefineType(ParameterNode,                    "ParameterNode",                    Syntax, builder, type) {}
  ZilchDefineType(MemberVariableNode,               "MemberVariableNode",               Syntax, builder, type) {}
  ZilchDefineType(ValueNode,                        "ValueNode",                        Syntax, builder, type) {}
  ZilchDefineType(StringInterpolantNode,            "StringInterpolantNode",            Syntax, builder, type) {}
  ZilchDefineType(DeleteNode,                       "DeleteNode",                       Syntax, builder, type) {}
  ZilchDefineType(ReturnNode,                       "ReturnNode",                       Syntax, builder, type) {}
  ZilchDefineType(ScopeNode,                        "ScopeNode",                        Syntax, builder, type) {}
  ZilchDefineType(StaticTypeNode,                   "StaticTypeNode",                   Syntax, builder, type) {}
  ZilchDefineType(TimeoutNode,                      "TimeoutNode",                      Syntax, builder, type) {}
  ZilchDefineType(IfNode,                           "IfNode",                           Syntax, builder, type) {}
  ZilchDefineType(IfRootNode,                       "IfRootNode",                       Syntax, builder, type) {}
  ZilchDefineType(SendsEventNode,                   "SendsEventNode",                   Syntax, builder, type) {}
  ZilchDefineType(BreakNode,                        "BreakNode",                        Syntax, builder, type) {}
  ZilchDefineType(DebugBreakNode,                   "DebugBreakNode",                   Syntax, builder, type) {}
  ZilchDefineType(ContinueNode,                     "ContinueNode",                     Syntax, builder, type) {}
  ZilchDefineType(LoopScopeNode,                    "LoopScopeNode",                    Syntax, builder, type) {}
  ZilchDefineType(ConditionalLoopNode,              "ConditionalLoopNode",              Syntax, builder, type) {}
  ZilchDefineType(WhileNode,                        "WhileNode",                        Syntax, builder, type) {}
  ZilchDefineType(DoWhileNode,                      "DoWhileNode",                      Syntax, builder, type) {}
  ZilchDefineType(ForNode,                          "ForNode",                          Syntax, builder, type) {}
  ZilchDefineType(ForEachNode,                      "ForEachNode",                      Syntax, builder, type) {}
  ZilchDefineType(LoopNode,                         "LoopNode",                         Syntax, builder, type) {}
  ZilchDefineType(GenericFunctionNode,              "GenericFunctionNode",              Syntax, builder, type) {}
  ZilchDefineType(FunctionNode,                     "FunctionNode",                     Syntax, builder, type) {}
  ZilchDefineType(InitializerNode,                  "InitializerNode",                  Syntax, builder, type) {}
  ZilchDefineType(ConstructorNode,                  "ConstructorNode",                  Syntax, builder, type) {}
  ZilchDefineType(DestructorNode,                   "DestructorNode",                   Syntax, builder, type) {}
  ZilchDefineType(ClassNode,                        "ClassNode",                        Syntax, builder, type) {}
  ZilchDefineType(TypeDefineNode,                   "TypeDefineNode",                   Syntax, builder, type) {}
  ZilchDefineType(LocalVariableReferenceNode,       "LocalVariableReferenceNode",       Syntax, builder, type) {}
  ZilchDefineType(ThrowNode,                        "ThrowNode",                        Syntax, builder, type) {}
  ZilchDefineType(TypeIdNode,                       "TypeIdNode",                       Syntax, builder, type) {}
  ZilchDefineType(EnumValueNode,                    "EnumValueNode",                    Syntax, builder, type) {}
  ZilchDefineType(EnumNode,                         "EnumNode",                         Syntax, builder, type) {}
  
  //***************************************************************************
  SyntaxTree::SyntaxTree() :
    SingleExpressionScope(nullptr),
    SingleExpressionIndex((size_t)-1)
  {
    // Create the root node
    this->Root = new RootNode();
  }

  //***************************************************************************
  SyntaxTree::~SyntaxTree()
  {
    delete this->Root;
  }

  //***************************************************************************
  SyntaxType::SyntaxType() :
    ResolvedType(nullptr)
  {
  }
  
  //***************************************************************************
  bool SyntaxType::IsTemplateInstantiation() const
  {
    // By default, we assume all syntax types are not templated
    return false;
  }

  //***************************************************************************
  String AnySyntaxType::ToString() const
  {
    return Grammar::GetKeywordOrSymbol(Grammar::Any);
  }

  //***************************************************************************
  IndirectionSyntaxType::IndirectionSyntaxType() :
    ReferencedType(nullptr)
  {
  }

  //***************************************************************************
  String IndirectionSyntaxType::ToString() const
  {
    // Create a string builder since we're doing some concatenation
    StringBuilder output;

    // Add the 'ref' keyword
    output += Grammar::GetKeywordOrSymbol(Grammar::Ref);
    output += " ";
    
    // Add the type we're referencing
    output += this->ReferencedType->ToString();

    // Output the string
    return output.ToString();
  }

  //***************************************************************************
  void IndirectionSyntaxType::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->ReferencedType);
  }

  //***************************************************************************
  bool BoundSyntaxType::IsTemplateInstantiation() const
  {
    return this->TemplateArguments.size() > 0;
  }

  //***************************************************************************
  String BoundSyntaxType::ToString() const
  {
    if (this->IsTemplateInstantiation())
    {
      StringBuilder builder;
      builder.Append(this->TypeName);

      builder.Append('[');

      for (size_t i = 0; i < this->TemplateArguments.size(); ++i)
      {
        builder.Append(this->TemplateArguments[i]->ToString());

        if (i != this->TemplateArguments.size() - 1)
        {
          builder.Append(", ");
        }
      }

      builder.Append(']');

      return builder.ToString();
    }
    else
    {
      return this->TypeName;
    }
  }

  //***************************************************************************
  void BoundSyntaxType::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->TemplateArguments.Populate(childrenOut);
  }

  //***************************************************************************
  DelegateSyntaxParameter::DelegateSyntaxParameter() :
    Name(nullptr),
    Type(nullptr)
  {
  }

  //***************************************************************************
  DelegateSyntaxType::DelegateSyntaxType() :
    Return(nullptr)
  {
  }

  //***************************************************************************
  bool DelegateSyntaxType::IsTemplateInstantiation() const
  {
    return this->TemplateArguments.size() > 0;
  }

  //***************************************************************************
  String DelegateSyntaxType::ToString() const
  {
    // Create a string builder for concatenation
    StringBuilder output;

    // Output the delegate keyword and the opening argument parentheses
    output += Grammar::GetKeywordOrSymbol(Grammar::Delegate);
    output += " (";

    // Loop through all the parameters
    for (size_t i = 0; i < this->Parameters.size(); ++i)
    {
      // Output the name of the parameter
      output += this->Parameters[i].Name->Token.c_str();
      output += " : ";
      
      // Always output the type of the parameter
      output += this->Parameters[i].Type->ToString();

      // If this is not the last parameter...
      if (i < this->Parameters.size() - 1)
      {
        // Output an argument separator
        output += ", ";
      }
    }

    // Output the ending argument parentheses
    output += ")";

    // If we have a return type
    if (this->Return != nullptr)
    {
      // Output the return type...
      output += " : ";
      output += this->Return->ToString();
    }

    // Finally, output the full concatenated type string
    return output.ToString();
  }

  //***************************************************************************
  void DelegateSyntaxType::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Return);

    // Loop through all the parameters in the function
    for (size_t i = 0; i < this->Parameters.size(); ++i)
    {
      childrenOut.Add(this->Parameters[i].Type);
    }
  }

  //***************************************************************************
  SyntaxNode::SyntaxNode() :
    Parent(nullptr)
  {
  }

  //***************************************************************************
  void SyntaxNode::DestroyChildren()
  {
    // Get all the children for this node
    NodeChildren children;
    this->PopulateChildren(children);
    this->PopulateNonTraversedChildren(children);

    // Loop through all this node's children
    for (size_t i = 0; i < children.size(); ++i)
    {
      // Get the current child
      SyntaxNode*& child = *children[i];

      // Destroy all of that child's children
      delete child;
      child = nullptr;
    }
  }

  //***************************************************************************
  SyntaxNode::SyntaxNode(const SyntaxNode& toCopy) :
    Location(toCopy.Location),
    Parent(nullptr)
  {
    // We never copy the parent from other nodes
  }

  //***************************************************************************
  String SyntaxNode::ToString() const
  {
    return this->ZilchGetDerivedType()->Name;
  }

  //***************************************************************************
  void SyntaxNode::PopulateChildren(NodeChildren& /*childrenOut*/)
  {
  }

  //***************************************************************************
  void SyntaxNode::PopulateNonTraversedChildren(NodeChildren& /*childrenOut*/)
  {
  }
  
  //***************************************************************************
  void SyntaxNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
  {
    NodeChildren children;
    this->PopulateChildren(children);
    this->PopulateNonTraversedChildren(children);

    // Walk through all the children we have
    for (size_t i = 0; i < children.size(); ++i)
    {
      // Grab the current child and check if its a SyntaxType
      SyntaxNode** node = children[i];
      if (TypeBinding::DynamicCast<SyntaxType*>(*node) != nullptr)
      {
        // We know this is a syntax type, but we need a pointer to the pointer so it can be possibly modified
        // This is technically an unsafe cast, but we 'soft' guarantee that we will only modify the second pointer with the correct type
        const SyntaxType*& syntaxType = *(const SyntaxType**)node;
        typesOut.Add(syntaxType);
      }
    }
  }

  //***************************************************************************
  void SyntaxNode::FixParentPointers(SyntaxNode* node, SyntaxNode* parent)
  {
    // Get all the children for this node
    NodeChildren children;
    node->PopulateChildren(children);

    // Loop through all this node's children
    for (size_t i = 0; i < children.size(); ++i)
    {
      // Get the current child
      SyntaxNode* child = *children[i];

      // Destroy all of that child's children
      FixParentPointers(child, node);
    }

    // Setup the parent pointer for the current node
    node->Parent = parent;
  }

  //***************************************************************************
  String SyntaxNode::GetMergedComments()
  {
    // Create a string builder
    StringBuilder builder;

    // Loop through all the comment strings
    for (size_t i = 0; i < this->Comments.size(); ++i)
    {
      // Get the current comment
      String& comment = this->Comments[i];

      // Get a string range for the comment, since we're going to trim starting white space
      StringRange range = comment.all();
      
      // While we're reading a space...
      while (*range.begin == ' ')
      {
        // Move the range start forward
        ++range.begin;
      }
      
      // Append the string range for the comment
      builder.Append(range);

      // Checks if this is not the last comment...
      bool isNotLast = (i != (this->Comments.size() - 1));
      if (isNotLast)
      {
        builder.Append("\n");
      }
    }

    // Return the merged comments
    return builder.ToString();
  }

  //***************************************************************************
  String ToNodeString(int nodeID)
  {
    // Return the node name
    return String::Format("node%d", nodeID);
  }

  //***************************************************************************
  String NodeConnection(int nodeA, int nodeB)
  {
    StringBuilder output;
    output += "  ";
    output += ToNodeString(nodeA);
    output += " -- ";
    output += ToNodeString(nodeB);
    output += "\n";
    return output.ToString();
  }

  //***************************************************************************
  String GetStart(int nodeID, const char* shape = "box")
  {
    // Return the node starting text
    StringBuilder output;
    output += "  ";
    output += ToNodeString(nodeID);
    output += " [shape = ";
    output += shape;
    output += ", label = \"";
    return output.ToString();
  }

  //***************************************************************************
  String GetEnd()
  {
    static const String ending = "\"];\n";
    return ending;
  }

  //***************************************************************************
  int GetGraphVizNodeRepresentation(StringBuilder& outString, int nodeID, SyntaxNode* node)
  {
    outString += GetStart(nodeID);
    outString += node->ToString();
    outString += GetEnd();

    int childNodeID = nodeID + 1;

    NodeChildren children;
    node->PopulateChildren(children);

    for (size_t i = 0; i < children.size(); ++i)
    {
      SyntaxNode* child = *children[i];

      outString += NodeConnection(nodeID, childNodeID);
      childNodeID = GetGraphVizNodeRepresentation(outString, childNodeID, child);
    }

    return childNodeID + 1;
  }
  
  //***************************************************************************
  void SyntaxTree::GetNodesAtCursor(size_t cursorPosition, StringParam cursorOrigin, Array<SyntaxNode*>& nodesOut)
  {
    // Start at the root and walk down looking for nodes that our cursor is within
    nodesOut.reserve(10);
    GetNodesAtCursorRecursive(this->Root, cursorPosition, cursorOrigin, nodesOut);
  }
  
  //***************************************************************************
  void SyntaxTree::GetNodesAtCursorRecursive(SyntaxNode* node, size_t cursorPosition, StringParam cursorOrigin, Array<SyntaxNode*>& nodesOut)
  {
    // Check if the cursor is within the location of this node
    CodeLocation& location = node->Location;
    if (location.Origin == cursorOrigin && cursorPosition >= location.StartPosition && cursorPosition <= location.EndPosition)
        nodesOut.push_back(node);

    // Walk through all child nodes of the current node
    NodeChildren children;
    node->PopulateChildren(children);
    for (size_t i = 0; i < children.size(); ++i)
    {
      // Recursively walk the tree looking for other nodes
      SyntaxNode* child = *children[i];
      GetNodesAtCursorRecursive(child, cursorPosition, cursorOrigin, nodesOut);
    }
  }

  //***************************************************************************
  String SyntaxTree::GetGraphVizRepresentation()
  {
    StringBuilder output;
    output += "graph \"Syntax Tree\"\n{\n";

    GetGraphVizNodeRepresentation(output, 0, this->Root);

    output += "}";
    return output.ToString();
  }

  //***************************************************************************
  void SyntaxTree::ShowGraphVizRepresentation()
  {
    FILE* fp = fopen("C:\\Temp\\Parse.gv", "w");

    if (fp)
    {
      String gv = GetGraphVizRepresentation();

      fwrite(gv.c_str(), gv.size(), 1, fp);
      fwrite("\0", 1, 1, fp);

      fclose(fp);

      //system("C:\\Progra~1\\Graphviz2.26.3\\bin\\dot.exe -Tpng \"C:\\temp.gv\" > \"C:\\temp.png\"");
      system("C:\\Progra~2\\Graphviz2.28\\bin\\dot.exe -Tpng \"C:\\Temp\\Parse.gv\" > \"C:\\Temp\\Parse.png\"");

      system("C:\\Temp\\Parse.png");
    }
  }

  //***************************************************************************
  void RootNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Classes.Populate(childrenOut);
    this->Enums.Populate(childrenOut);
  }

  //***************************************************************************
  bool StatementNode::IsNodeUsedAsStatement(SyntaxNode* node)
  {
    // If the node is an expression...
    ExpressionNode* expression = TypeBinding::DynamicCast<ExpressionNode*>(node);
    if (expression != nullptr)
    {
      // Return if the expression is being used as a statement
      return expression->IsUsedAsStatement;
    }

    // If the node is a function or class node... which, because it's a scope node,
    // is considered a statement (and should probably not be!)
    if (TypeBinding::DynamicCast<GenericFunctionNode*>(node) != nullptr || TypeBinding::DynamicCast<ClassNode*>(node) != nullptr)
    {
      return false;
    }

    // If the node is a member variable node... which, because it's a variable node,
    // is considered a statement (and should probably not be!)
    if (TypeBinding::DynamicCast<MemberVariableNode*>(node) != nullptr)
    {
      return false;
    }

    // Otherwise, just return if this node is a statement node
    return (TypeBinding::DynamicCast<StatementNode*>(node) != nullptr);
  }

  
  //***************************************************************************
  AttributeNode::AttributeNode() :
    AttributeCall(nullptr),
    TypeName(nullptr)
  {
  }
  
  //***************************************************************************
  void AttributeNode::PopulateChildren(NodeChildren& childrenOut)
  {
    childrenOut.Add(this->AttributeCall);
  }

  //***************************************************************************
  ExpressionNode::ExpressionNode() :
    Io(IoMode::NotSet),
    IoUsage(IoMode::NotSet),
    ResultType(Core::GetInstance().ErrorType),
    IsUsedAsStatement(false)
  {
  }

  //***************************************************************************
  BinaryOperatorNode::BinaryOperatorNode() : 
    LeftOperand(nullptr),
    RightOperand(nullptr),
    Operator(nullptr)
  {
  }

  //***************************************************************************
  String BinaryOperatorNode::ToString() const
  {
    return this->Operator->Token;
  }

  //***************************************************************************
  void BinaryOperatorNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->LeftOperand);
    childrenOut.Add(this->RightOperand);
  }

  //***************************************************************************
  UnaryOperatorNode::UnaryOperatorNode() : 
    Operand(nullptr),
    Operator(nullptr)
  {
  }

  //***************************************************************************
  String UnaryOperatorNode::ToString() const
  {
    return this->Operator->Token;
  }

  //***************************************************************************
  void UnaryOperatorNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Operand);
  }

  //***************************************************************************
  PropertyDelegateOperatorNode::PropertyDelegateOperatorNode() :
    AccessedProperty(nullptr)
  {
  }
  
  //***************************************************************************
  TypeCastNode::TypeCastNode() :
    Operand(nullptr),
    Type(nullptr)
  {
  }

  //***************************************************************************
  String TypeCastNode::ToString() const
  {
    if (this->Type == nullptr)
      return "Implicit cast";
    return BuildString("Cast to ", this->Type->ToString());
  }

  //***************************************************************************
  void TypeCastNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Operand);
    childrenOut.Add(this->Type);
  }

  //***************************************************************************
  PostExpressionNode::PostExpressionNode() :
    LeftOperand(nullptr)
  {
  }

  //***************************************************************************
  void PostExpressionNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->LeftOperand);
  }
  
  //***************************************************************************
  IndexerCallNode::IndexerCallNode() :
    Get(nullptr),
    GetSet(nullptr),
    Set(nullptr)
  {
  }

  //***************************************************************************
  String IndexerCallNode::ToString() const
  {
    return "[...]";
  }

  //***************************************************************************
  void IndexerCallNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Arguments.Populate(childrenOut);
    childrenOut.Add(this->Get);
    childrenOut.Add(this->GetSet);
    childrenOut.Add(this->Set);
  }

  //***************************************************************************
  FunctionCallNode::FunctionCallNode() :
    IsNamed(false)
  {
  }

  //***************************************************************************
  String FunctionCallNode::ToString() const
  {
    return "(...)";
  }

  //***************************************************************************
  void FunctionCallNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Arguments.Populate(childrenOut);
  }
  
  //***************************************************************************
  StaticTypeNode* FunctionCallNode::FindCreationCall()
  {
    // If the left operand itself is the static type, then just return it directly
    if (StaticTypeNode* staticType = TypeBinding::DynamicCast<StaticTypeNode*>(this->LeftOperand))
      return staticType;

    // If this function call node is being used to invoke a constructor, we'll know because our left operand will actually
    // be a local variable whose initial value is a CreationCallNode
    // This is a bit complicated and maybe should be refactored, but this works for now
    StaticTypeNode* creationNode = nullptr;
    LocalVariableNode* creationLocalVariable = TypeBinding::DynamicCast<LocalVariableNode*>(this->LeftOperand);

    // If the left operand was indeed a local variable, then look for a direct reference to the CreationCallNode as the initial value
    if (creationLocalVariable != nullptr)
      return TypeBinding::DynamicCast<StaticTypeNode*>(creationLocalVariable->InitialValue);

    // We didn't find anything
    return nullptr;
  }

  //***************************************************************************
  MemberAccessNode::MemberAccessNode() :
    Operator(Grammar::Invalid),
    AccessedFunction(nullptr),
    OverloadedFunctions(nullptr),
    AccessedProperty(nullptr),
    AccessedField(nullptr),
    MemberType(MemberAccessType::Invalid),
    IsStatic(false)
  {
  }

  //***************************************************************************
  String MemberAccessNode::ToString() const
  {
    return BuildString(Grammar::GetKeywordOrSymbol(this->Operator), this->Name);
  }
  
  //***************************************************************************
  TypeIdNode::TypeIdNode() :
    Value(nullptr),
    CompileTimeSyntaxType(nullptr),
    CompileTimeType(Core::GetInstance().ErrorType)
  {
  }
    
  //***************************************************************************
  void TypeIdNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Value);
    childrenOut.Add(this->CompileTimeSyntaxType);
  }

  //***************************************************************************
  StaticTypeNode::StaticTypeNode() :
    ReferencedSyntaxType(nullptr),
    ReferencedType(Core::GetInstance().ErrorType),
    Mode(CreationMode::Invalid),
    ConstructorFunction(nullptr),
    OverloadedConstructors(nullptr),
    ThisHandleLocal(0)
  {
  }

  //***************************************************************************
  void StaticTypeNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->ReferencedSyntaxType);
  }

  //***************************************************************************
  ExpressionInitializerMemberNode::ExpressionInitializerMemberNode() :
    Value(nullptr)
  {
  }
  
  //***************************************************************************
  void ExpressionInitializerMemberNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Value);
  }
  
  //***************************************************************************
  void ExpressionInitializerAddNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Arguments.Populate(childrenOut);
  }

  //***************************************************************************
  ExpressionInitializerNode::ExpressionInitializerNode()
  {
  }
  
  //***************************************************************************
  void ExpressionInitializerNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->AddValues.Populate(childrenOut);
    this->InitailizeMembers.Populate(childrenOut);
    this->InitializerStatements.Populate(childrenOut);
  }

  //***************************************************************************
  MultiExpressionNode::MultiExpressionNode() :
    YieldChildExpressionIndex(InvalidIndex)
  {
  }
    
  //***************************************************************************
  void MultiExpressionNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Expressions.Populate(childrenOut);
  }

  //***************************************************************************
  VariableNode::VariableNode() :
    InitialValue(nullptr),
    IsStatic(false),
    ResultSyntaxType(nullptr)
  {
    // All variables can be both read from and written to
    this->Io = (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue);

    // Because we reuse this node as a statement in many explicit cases, then the parent 'IoUsage' is always set to ignore
    // Normally this should be set by every parent, but variable nodes can only be used as expressions internally (not in the parser)
    this->IoUsage = IoMode::Ignore;
  }

  //***************************************************************************
  bool VariableNode::IsInferred() const
  {
    // We are inferred if we have no syntax type
    return this->ResultSyntaxType == nullptr;
  }

  //***************************************************************************
  LocalVariableNode::LocalVariableNode() :
    CreatedVariable(nullptr),
    ForwardLocalAccessIfPossible(false),
    IsGenerated(false)
  {
  }
    
  //***************************************************************************
  LocalVariableNode::LocalVariableNode(StringParam baseName, Project* parentProject, ExpressionNode* optionalInitialValue) :
    CreatedVariable(nullptr),
    IsGenerated(true)
  {
    // The variable name includes the base name as well as brackets (so that the user cannot type the name in via the parser)
    if (optionalInitialValue != nullptr)
      this->Name.Location = optionalInitialValue->Location;
    this->Name.Token = String::Format("[%s%llu]", baseName.c_str(), (unsigned long long)parentProject->VariableUniqueIdCounter);
    ++parentProject->VariableUniqueIdCounter;

    // This is entirely just to avoid a redudant copy into a local variable,
    // since the CreationCallNode already allocates stack space (and we only need the local variable for the name lookup!)
    this->InitialValue = optionalInitialValue;
    this->ForwardLocalAccessIfPossible = true;
  }

  //***************************************************************************
  String VariableNode::ToString() const
  {
    return this->Name.Token;
  }

  //***************************************************************************
  void VariableNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->InitialValue);
    childrenOut.Add(this->ResultSyntaxType);
  }

  //***************************************************************************
  ParameterNode::ParameterNode() :
    ParameterIndex(0)
  {
  }

  //***************************************************************************
  MemberVariableNode::MemberVariableNode() :
    Get(nullptr),
    Set(nullptr),
    IsProperty(false),
    CreatedProperty(nullptr),
    CreatedField(nullptr),
    ParentClassType(nullptr),
    ResultType(Core::GetInstance().ErrorType),
    Virtualized(VirtualMode::NonVirtual),
    ExtensionOwner(nullptr)
  {
  }

  //***************************************************************************
  void MemberVariableNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Attributes.Populate(childrenOut);
    childrenOut.Add(this->Get);
    childrenOut.Add(this->Set);
    childrenOut.Add(this->ExtensionOwner);
  }

  //***************************************************************************
  ValueNode::ValueNode()
  {
  }

  //***************************************************************************
  String ValueNode::ToString() const
  {
    return this->Value.Token;
  }

  //***************************************************************************
  StringInterpolantNode::StringInterpolantNode()
  {
  }
  
  //***************************************************************************
  void StringInterpolantNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Elements.Populate(childrenOut);
  }

  //***************************************************************************
  DeleteNode::DeleteNode() :
    DeletedObject(nullptr)
  {
  }

  //***************************************************************************
  void DeleteNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->DeletedObject);
  }

  //***************************************************************************
  ReturnNode::ReturnNode() :
    ReturnValue(nullptr),
    IsDebugReturn(false)
  {
  }
    
  //***************************************************************************
  void ReturnNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->ReturnValue);
  }

  //***************************************************************************
  ScopeNode::ScopeNode() :
    AllPathsReturn(false),
    IsDebugReturn(false)
  {
  }
    
  //***************************************************************************
  void ScopeNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Statements.Populate(childrenOut);
  }

  //***************************************************************************
  TimeoutNode::TimeoutNode() :
    Seconds(0)
  {
  }

  //***************************************************************************
  IfNode::IfNode() :
    Condition(nullptr),
    IsFirstPart(false)
  {
  }
    
  //***************************************************************************
  void IfNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Condition);
  }

  //***************************************************************************
  IfRootNode::IfRootNode()
  {
  }
    
  //***************************************************************************
  void IfRootNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->IfParts.Populate(childrenOut);
  }

  //***************************************************************************
  SendsEventNode::SendsEventNode() :
    EventType(nullptr),
    Name(nullptr),
    EventProperty(nullptr)
  {
  }

  //***************************************************************************
  void SendsEventNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->EventType);
  }

  //***************************************************************************
  BreakNode::BreakNode() :
    ScopeCount(0),
    InstructionIndex(InvalidOpcodeLocation),
    JumpOpcode(nullptr)
  {
  }

  //***************************************************************************
  ContinueNode::ContinueNode() :
    InstructionIndex(InvalidOpcodeLocation),
    JumpOpcode(nullptr)
  {
  }
    
  //***************************************************************************
  ThrowNode::ThrowNode() :
    Exception(nullptr)
  {
  }
    
  //***************************************************************************
  void ThrowNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Exception);
  }

  //***************************************************************************
  LoopScopeNode::LoopScopeNode()
  {
  }

  //***************************************************************************
  LoopScopeNode::LoopScopeNode(const LoopScopeNode& toCopy) :
    ScopeNode(toCopy)
  {
    // Error checking
    ErrorIf(toCopy.Breaks.empty() == false,
      "You cannot copy a loop scope node with pointers to other break nodes");

    // Error checking
    ErrorIf(toCopy.Continues.empty() == false,
      "You cannot copy a loop scope node with pointers to other continue nodes");
  }

  //***************************************************************************
  ConditionalLoopNode::ConditionalLoopNode() :
    Condition(nullptr)
  {
  }
  
  //***************************************************************************
  void ConditionalLoopNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Condition);
  }

  //***************************************************************************
  ForNode::ForNode() :
    ValueVariable(nullptr),
    RangeVariable(nullptr),
    Initialization(nullptr),
    Iterator(nullptr)
  {
  }
  
  //***************************************************************************
  void ForNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->ValueVariable);
    childrenOut.Add(this->RangeVariable);
    childrenOut.Add(this->Initialization);
    childrenOut.Add(this->Iterator);
  }
  
  //***************************************************************************
  ForEachNode::ForEachNode() :
    NonTraversedVariable(nullptr),
    NonTraversedRange(nullptr)
  {
  }

  //***************************************************************************
  void ForEachNode::PopulateNonTraversedChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->NonTraversedVariable);
    childrenOut.Add(this->NonTraversedRange);
  }

  //***************************************************************************
  GenericFunctionNode::GenericFunctionNode() :
    Type(nullptr),
    DefinedFunction(nullptr)
  {
  }
  
  //***************************************************************************
  void GenericFunctionNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Parameters.Populate(childrenOut);
    this->Attributes.Populate(childrenOut);
  }

  //***************************************************************************
  FunctionNode::FunctionNode() :
    ReturnType(nullptr),
    IsStatic(false),
    Virtualized(VirtualMode::NonVirtual),
    ExtensionOwner(nullptr)
  {
  }

  //***************************************************************************
  String FunctionNode::ToString() const
  {
    return BuildString("Function ", this->Name.Token);
  }

  //***************************************************************************
  void FunctionNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->ReturnType);
    childrenOut.Add(this->ExtensionOwner);
  }

  //***************************************************************************
  InitializerNode::InitializerNode() :
    InitializerType(nullptr),
    InitializerFunction(nullptr)
  {
  }

  //***************************************************************************
  ConstructorNode::ConstructorNode() :
    BaseInitializer(nullptr),
    ThisInitializer(nullptr)
  {
  }

  //***************************************************************************
  ClassNode::ClassNode() :
    TemplateInstantiation(nullptr),
    Destructor(nullptr),
    Type(nullptr),
    PreConstructor(nullptr),
    CopyMode(TypeCopyMode::ReferenceType)
  {
  }

  //***************************************************************************
  bool ClassNode::IsTemplate() const
  {
    return this->TemplateArguments.size() > 0;
  }

  //***************************************************************************
  String ClassNode::ToString() const
  {
    return BuildString("Class ", this->Name.Token);
  }

  //***************************************************************************
  void ClassNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Attributes.Populate(childrenOut);
    this->SendsEvents.Populate(childrenOut);
    this->Variables.Populate(childrenOut);
    this->Constructors.Populate(childrenOut);
    childrenOut.Add(this->Destructor);
    this->Functions.Populate(childrenOut);
    this->Inheritance.Populate(childrenOut);
  }

  //***************************************************************************
  EnumValueNode::EnumValueNode() :
    Value(nullptr),
    IntegralValue(0),
    IntegralProperty(nullptr)
  {
  }

  //***************************************************************************
  String EnumValueNode::ToString() const
  {
    // Return both the value name and the actual assigned integral value
    return String::Format("%s = %d", this->Name.c_str(), this->IntegralValue);
  }

  //***************************************************************************
  EnumNode::EnumNode() :
    IsFlags(false),
    Inheritance(nullptr),
    Type(nullptr)
  {
  }

  //***************************************************************************
  String EnumNode::ToString() const
  {
    return this->Name.Token;
  }
  
  //***************************************************************************
  void EnumNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    this->Values.Populate(childrenOut);
    this->Attributes.Populate(childrenOut);
    childrenOut.Add(this->Inheritance);
  }

  //***************************************************************************
  TypeDefineNode::TypeDefineNode() :
    Name(nullptr)
  {
  }

  //***************************************************************************
  String TypeDefineNode::ToString() const
  {
    return BuildString(this->Name->Token, " : ", this->Type->ToString());
  }

  //***************************************************************************
  void TypeDefineNode::PopulateChildren(NodeChildren& childrenOut)
  {
    ZilchBase::PopulateChildren(childrenOut);
    childrenOut.Add(this->Type);
  }

  //***************************************************************************
  LocalVariableReferenceNode::LocalVariableReferenceNode() :
    AccessedVariable(nullptr)
  {
  }

  //***************************************************************************
  String LocalVariableReferenceNode::ToString() const
  {
    return BuildString("[Local Variable]", this->Value.Token);
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes





int gPublicSymbol = 1;

namespace Zilch
{
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes





namespace Zilch
{
  //***************************************************************************
  void ParameterNameTokenizing(ErrorEvent* e)
  {
    // Assert using the formatted error message
    Error("Error parsing parameter names: %s", e->ExactError.c_str());
  }

  //***************************************************************************
  void TemplateBinding::ParseParameterArrays(ParameterArray& parameters, StringRange commaDelimitedNames)
  {
    // We return immediately if the string is empty because this function
    // gets generically called even when no arguments are supplied
    if (commaDelimitedNames.empty())
      return;

    // We're just going to use the tokenizer to parse the parameter names
    CompilationErrors errors;
    EventConnect(&errors, Events::CompilationError, ParameterNameTokenizing);
    Tokenizer tokenizer(errors);

    // The tokens and comments we'll parse (comments are entirely ignored)
    Array<UserToken> tokens;
    Array<UserToken> comments;

    // Parse the names into tokens (commas are allowed)
    CodeEntry namesEntry;
    namesEntry.Code = commaDelimitedNames;
    tokenizer.Parse(namesEntry, tokens, comments);

    // Store the index we're on in the parameters array
    size_t parameterIndex = 0;
    
    // Loop through the tokens in the order they were parsed
    for (size_t i = 0; i < tokens.size(); ++i)
    {
      // If the parameter index goes outside the bounds...
      ErrorIf(parameterIndex >= parameters.size(),
        "Too many parameter names for the number of parameter arguments provided");

      // If the current token is a name...
      UserToken& token = tokens[i];
      if (token.TokenId == Grammar::LowerIdentifier)
      {
        // Set the name of the current parameter
        parameters[parameterIndex].Name = token.Token;
        ++parameterIndex;
      }
      else if (token.TokenId != Grammar::ArgumentSeparator)
      {
        // Show an error to the user
        Error
        (
          "Unexpected token type when reading parameter names (must be lowercase identifiers): %s of token type %s",
          token.Token.c_str(),
          Grammar::GetName(token.TokenId).c_str()
        );
      }
    }

    // If we didn't parse as many tokens as the parameters, then we also throw an error
    ErrorIf(parameterIndex != parameters.size(), "A different number of parameter names were given for the number of parameters");
  }
}/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes











namespace Zilch
{
  //***************************************************************************
  void CodeGenerator::CreateLocal(Function* function, size_t size, Operand& accessOut)
  {
    // All r-value binary operations result in a value on the stack
    // Therefore we need to allocate a register to store our result in
    accessOut.HandleConstantLocal = function->AllocateRegister(size);
    
    // We don't use the secondary index (we aren't writing to a member or anything) so just ignore it
    accessOut.FieldOffset = 0;

    // Since we are going to be stored on the stack, our access type is as a local
    accessOut.Type = OperandType::Local;
  }

  //***************************************************************************
  void CodeGenerator::CreateRValueUnaryOpcode(Function* function, UnaryOperatorNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin)
  {
    // Create the opcode
    UnaryRValueOpcode& opcode = function->AllocateOpcode<UnaryRValueOpcode>(instruction, debugOrigin, node.Location);

    // All r-value binary operations result in a value on the stack
    // Therefore we need to allocate a register to store our result in
    CreateLocal(function, node.ResultType->GetCopyableSize(), node.Access);

    // We always output to the stack
    opcode.Output = node.Access.HandleConstantLocal;

    // Initialize the only operand
    opcode.SingleOperand = node.Operand->Access;
  }

  //***************************************************************************
  void CodeGenerator::CreateLValueUnaryOpcode(Function* function, UnaryOperatorNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin)
  {
    // Create the opcode
    UnaryLValueOpcode& opcode = function->AllocateOpcode<UnaryLValueOpcode>(instruction, debugOrigin, node.Location);

    // All l-value binary operations result in a chained left hand value,
    // therefore we use the same primary and secondary index as the left operand
    // (no register allocation should ever be needed)
    node.Access = node.Operand->Access;

    // Initialize the only operand
    opcode.SingleOperand = node.Operand->Access;
  }

  //***************************************************************************
  void CodeGenerator::CreateConversionOpcode(Function* function, TypeCastNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin)
  {
    // Create the opcode
    ConversionOpcode& opcode = function->AllocateOpcode<ConversionOpcode>(instruction, debugOrigin, node.Location);

    // This expression's result will be stored in the last created register
    CreateLocal(function, node.ResultType->GetCopyableSize(), node.Access);

    // We always output to the stack (it's a conversion, not a storage operator)
    opcode.Output = node.Access.HandleConstantLocal;
    
    // We pull the value out of our node's operand
    // (the operand is the left side of the 'as', eg 5 as Real, 5 would be the Operand)
    opcode.ToConvert = node.Operand->Access;
  }

  //***************************************************************************
  void CodeGenerator::GenerateUnaryOp(Function* function, UnaryOperatorNode& node, DebugOrigin::Enum debugOrigin)
  {
    // Create the opcode so that we can fill it in
    size_t opcodeStart = function->GetCurrentOpcodeIndex();

    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // If this is creating a property delegate object
    ErrorIf(node.Operator->TokenId == Grammar::PropertyDelegate,
      "The property delegate operator is a unary operator, but should be handled by a separate handler");

    // Store the unary operator info for convenience (shared definition)
    UnaryOperator& info = node.OperatorInfo;

    // Unary plus always does nothing
    if (node.Operator->TokenId == Grammar::Positive)
    {
      // We need to make sure that the node knows its output is just its only operand (early out)
      node.Access = node.Operand->Access;
      return;
    }

    // If the operator results in an l-value...
    if (info.Io & IoMode::WriteLValue)
    {
      CreateLValueUnaryOpcode(function, node, info.Instruction, debugOrigin);
    }
    // Otherwise, the operator results in an r-value...
    else
    {
      CreateRValueUnaryOpcode(function, node, info.Instruction, debugOrigin);
    }

    // Error checking
    ErrorIf(opcodeStart == function->GetCurrentOpcodeIndex(), "No instructions were written!");
  }

  //***************************************************************************
  void CodeGenerator::GenerateConversion(Function* function, TypeCastNode& node, DebugOrigin::Enum debugOrigin)
  {
    // Create the opcode so that we can fill it in
    size_t opcodeStart = function->GetCurrentOpcodeIndex();
    
    // Get the instance of the type database
    Core& core = Core::GetInstance();

    // Store the cast operation for convenience
    CastOperation::Enum castOperation = node.OperatorInfo.Operation;

    // If the type cast is a primitive cast...
    if (castOperation == CastOperation::Primitive)
    {
      // Use the primitive instruction on the conversion operator
      CreateConversionOpcode(function, node, node.OperatorInfo.PrimitiveInstruction, debugOrigin);

      // Error checking
      ErrorIf(opcodeStart == function->GetCurrentOpcodeIndex(), "No instructions were written!");
    }
    // If it's an up cast, we pretty much don't do anything (just forward the access, type should be changed already)
    // Note: Dynamic down is currently NOT SAFE at all
    // It can also be a 'Same' cast, ex: Integer to Integer, in which we do absolutely nothing
    else if (castOperation == CastOperation::Raw)
    {
      // Forward access (there's no actual opcode we need to write!)
      node.Access = node.Operand->Access;
    }
    // Stores the value generically into an 'any' type, which does proper reference counting / handle / delegate / value copies
    // This also constructs an Any on the stack and initializes it
    // Note: May not go through the Any constructor as an optimization!
    else if (castOperation == CastOperation::ToAny)
    {
      // Create the opcode
      AnyConversionOpcode& opcode = function->AllocateOpcode<AnyConversionOpcode>(Instruction::ConvertToAny, debugOrigin, node.Location);
      
      // This expression's result will be stored in the last created register
      size_t anySize = node.ResultType->GetCopyableSize();
      ErrorIf(anySize != sizeof(Any), "The only way we should hit the 'ToAny' case is if we're casting to an Any type");
      CreateLocal(function, anySize, node.Access);

      // We always output to the stack (it's a conversion, not a storage operator)
      opcode.Output = node.Access.HandleConstantLocal;

      // We pull the value out of our node's operand
      // (the operand is the left side of the 'as', eg 5 as Real, 5 would be the Operand)
      opcode.ToConvert = node.Operand->Access;

      // The conversion opcode needs to know about the operands type so it knows how to store it in the Any
      // (see the comment above for what 'Operand' is)
      opcode.RelatedType = node.Operand->ResultType;
    }
    // Copies the value back out of the any onto the stack
    else if (castOperation == CastOperation::FromAny)
    {
      // Create the opcode
      AnyConversionOpcode& opcode = function->AllocateOpcode<AnyConversionOpcode>(Instruction::ConvertFromAny, debugOrigin, node.Location);
      
      // This expression's result will be stored in the last created register
      CreateLocal(function, node.ResultType->GetCopyableSize(), node.Access);

      // We always output to the stack (it's a conversion, not a storage operator)
      opcode.Output = node.Access.HandleConstantLocal;

      // We pull the value out of our node's operand
      // (the operand is the left side of the 'as', eg 5 as Real, 5 would be the Operand)
      ErrorIf(node.Operand->ResultType != core.AnythingType, "When converting from an Any, the Operand should always be an Any");
      opcode.ToConvert = node.Operand->Access;

      // The conversion opcode needs to know about the type its converting to
      opcode.RelatedType = node.ResultType;
    }
    // When we cast from a base class down into a more derived class (handles only at the moment)
    else if (castOperation == CastOperation::DynamicDown)
    {
      // Create the opcode
      DowncastConversionOpcode& opcode = function->AllocateOpcode<DowncastConversionOpcode>(Instruction::ConvertDowncast, debugOrigin, node.Location);
      
      // This expression's result will be stored in the last created register
      ErrorIf(node.ResultType->GetCopyableSize() != sizeof(Handle),
        "We only support downcasting of handles at the moment");
      CreateLocal(function, node.ResultType->GetCopyableSize(), node.Access);

      // We always output to the stack (it's a conversion, not a storage operator)
      opcode.Output = node.Access.HandleConstantLocal;

      // We pull the value out of our node's operand
      // (the operand is the left side of the 'as', eg 5 as Real, 5 would be the Operand)
      opcode.ToConvert = node.Operand->Access;

      // The conversion opcode needs to know about the type its converting to
      opcode.ToType = node.ResultType;
    }
    else if (castOperation == CastOperation::NullToDelegate)
    {
      // The 'Null' object is allocated as a constant, and the constant is guaranteed to be as big as a delegate or handle
      // Just redirect access to the same constant
      node.Access = node.Operand->Access;
    }
    else
    {
      Error("Unknown cast type!");
    }
  }

  //***************************************************************************
  void CodeGenerator::CreateCopyOpcode(Function* function, CopyMode::Enum mode, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
  {
    // The instruction that we will end up using
    Instruction::Enum instruction = Instruction::InvalidInstruction;

    // Get the instance of the type database
    Core& core = Core::GetInstance();

    if (Type::IsSame(type, core.IntegerType))
    {
      instruction = Instruction::CopyInteger;
    }
    else if (Type::IsSame(type, core.RealType))
    {
      instruction = Instruction::CopyReal;
    }
    else if (Type::IsSame(type, core.BooleanType))
    {
      instruction = Instruction::CopyBoolean;
    }
    else if (Type::IsHandleType(type))
    {
      instruction = Instruction::CopyHandle;
    }
    else if (Type::IsDelegateType(type))
    {
      instruction = Instruction::CopyDelegate;
    }
    else if (Type::IsValueType(type))
    {
      instruction = Instruction::CopyValue;
    }
    else if (Type::IsAnyType(type))
    {
      instruction = Instruction::CopyAny;
    }
    else
    {
      Error("Unhandled case, should have been caught in syntaxer (what type could this be?)");
    }

    // Create the opcode
    CopyOpcode& opcode = function->AllocateOpcode<CopyOpcode>(instruction, debugOrigin, location);

    // Initialize the source and destination of the opcode
    opcode.Source = source;
    opcode.Destination = destination;
    opcode.Mode = mode;

    // The object opcode requires a size
    // Currently, unless we introduce the concept back
    // of general memory copy, this concept is not used
    opcode.Size = type->GetCopyableSize();
  }

  //***************************************************************************
  void CodeGenerator::GenerateCopyToReturn(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
  {
    return CreateCopyOpcode(function, CopyMode::ToReturn, type, source, destination, debugOrigin, location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateCopyInitialize(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
  {
    return CreateCopyOpcode(function, CopyMode::Initialize, type, source, destination, debugOrigin, location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateCopyToParameter(Function* function, Type* type, const Operand& source, OperandIndex destRegister, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
  {
    return CreateCopyOpcode(function, CopyMode::ToParameter, type, source, Operand(destRegister), debugOrigin, location);
  }

  //***************************************************************************
  void CodeGenerator::GenerateCopyFromReturn(Function* function, Type* type, OperandIndex sourceRegister, OperandIndex destRegister, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
  {
    // Side note, copying returns always copies to an uninitialized
    // place in memory so it must always be an initializing copy
    return CreateCopyOpcode(function, CopyMode::FromReturn, type, Operand(sourceRegister), Operand(destRegister), debugOrigin, location);
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes




namespace Zilch
{
  //***************************************************************************
  const long long Timer::TicksPerSecond = CLOCKS_PER_SEC;

  //***************************************************************************
  Timer::Timer() :
    TotalTicks(0),
    LastClock(Zero::Time::Clock())
  {
  }

  //***************************************************************************
  long long Timer::GetAndUpdateTicks()
  {
    // Get the current clock tick count (it may have wrapped around / overflowed!)
    long long currentClock = Zero::Time::Clock();

    // If the current value we sampled is greater than the last value, there's a good chance
    // that we didn't wrap around. The only time this could fail is if this function only gets
    // called once every 500 hours or so, giving it time to wrap back up to its last value
    if (currentClock >= this->LastClock)
    {
      // Just append the difference in ticks
      long long difference = currentClock - this->LastClock;
      this->TotalTicks += difference;

      // Because of wrap around, we need this timer to be updated periodicially (on a regular basis)
      // We'll basically throw an assert/warning if the user only calls this once an hour or longer
      const long long SecondsPerMinute = 60;
      const long long MinutesPerHour = 60;
      const long long HoursPerDay = 24;
      ErrorIf(difference > Timer::TicksPerSecond * SecondsPerMinute * MinutesPerHour * HoursPerDay,
        "The timer should be called at least once a day to prevent wrap around issues");
    }
    else
    {
      // Otherwise, we probably just wrapped around so we need to figure out how much we added
      // The amount that was added is the current clock value minus the bottom value (since it wrapped around)
      // plus the difference between the last clock value and the max, where it would have wrapped
      // We add 1 because the wrap itself actually represents an increment of 1
      this->TotalTicks += currentClock - numeric_limits<clock_t>::min();
      this->TotalTicks += numeric_limits<clock_t>::max() - this->LastClock;
      this->TotalTicks += 1;
    }

    // Store the last clock, used for resolving time
    this->LastClock = currentClock;

    // Return the ticks we've acounted for
    return this->TotalTicks;
  }
  
  //***************************************************************************
  void Timer::Reset()
  {
    // Just clear the tick count
    this->TotalTicks = 0;
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes








namespace Zilch
{
  //***************************************************************************
  UserToken::UserToken() :
    TokenId(Grammar::Invalid),
    Start(0),
    Length(0)
  {
  }
  
  //***************************************************************************
  UserToken::UserToken(Grammar::Enum tokenId, CodeLocation* location) :
    Token(Grammar::GetKeywordOrSymbol(tokenId)),
    TokenId(tokenId),
    Start(0),
    Length(0)
  {
    this->SetLocationAndStartLength(location);
  }

  //***************************************************************************
  UserToken::UserToken(StringParam token, Grammar::Enum tokenId, CodeLocation* location) :
    Token(token),
    TokenId(tokenId),
    Start(0),
    Length(0)
  {
    this->SetLocationAndStartLength(location);
  }
  
  //***************************************************************************
  void UserToken::SetLocationAndStartLength(CodeLocation* location)
  {
    // If the user provided a location, then use that to fill token locations
    if (location != nullptr)
    {
      this->Location = *location;
      this->Start = location->StartPosition;
      this->Length = location->EndPosition - location->StartPosition;
    }
  }
  
  //***************************************************************************
  cstr UserToken::c_str() const
  {
    return this->Token.c_str();
  }

  //***************************************************************************
  Tokenizer::Tokenizer(CompilationErrors& errors) :
    WasCarriageReturn(false),
    Errors(errors),
    EnableStringInterpolation(true)
  {
    ZilchErrorIfNotStarted(Tokenizer);

    // Start the position off at the beginning
    this->Position = 0;
    this->ForwardPosition = 0;

    // Start off with a comment depth of zero (we're not in a comment yet!)
    this->CommentDepth = 0;

    // Setup the 'Eof' token
    this->Eof.TokenId = Grammar::End;
    this->Eof.Start  = 0;
    this->Eof.Length = 0;
  }

  //***************************************************************************
  void Tokenizer::Finalize(Array<UserToken>& tokensOut)
  {
    UserToken eof = this->Eof;
    eof.Location = this->Location;
    tokensOut.push_back(eof);
  }

  //***************************************************************************
  const UserToken* Tokenizer::GetBaseToken()
  {
    static UserToken token(Grammar::GetKeywordOrSymbol(Grammar::Base), Grammar::Base);
    return &token;
  }

  //***************************************************************************
  const UserToken* Tokenizer::GetThisToken()
  {
    static UserToken token(ThisKeyword, Grammar::LowerIdentifier);
    return &token;
  }

  //***************************************************************************
  const UserToken* Tokenizer::GetValueToken()
  {
    static UserToken token(ValueKeyword, Grammar::LowerIdentifier);
    return &token;
  }

  //***************************************************************************
  const UserToken* Tokenizer::GetAccessToken()
  {
    static UserToken token(Grammar::GetKeywordOrSymbol(Grammar::Access), Grammar::Access);
    return &token;
  }

  //***************************************************************************
  const UserToken* Tokenizer::GetAssignmentToken()
  {
    static UserToken token(Grammar::GetKeywordOrSymbol(Grammar::Assignment), Grammar::Assignment);
    return &token;
  }

  //***************************************************************************
  bool Tokenizer::Parse(const CodeEntry& entry, Array<UserToken>& tokensOut, Array<UserToken>& commentsOut)
  {
    // Clear out our location for proper line and character counting
    this->Location = CodeLocation();
    this->Location.Origin = entry.Origin;
    this->Location.CodeUserData = entry.CodeUserData;
    this->Location.Code = entry.Code;
    this->Location.IsNative = false;
    this->Line = 1;
    this->Character = 1;

    // Store the data pointer
    this->Data = entry.Code;

    // The average number of characters per token (including whitespace)
    const int AverageCharsPerToken = 5;

    // Reserve some memory for parsed tokens
    tokensOut.reserve(this->Data.size() / AverageCharsPerToken);
    
    // Start the position off at the beginning
    this->Position = 0;
    this->ForwardPosition = 0;

    // Now attempt to parse the data
    return ParseInternal(tokensOut, commentsOut);
  }

  //***************************************************************************
  bool Tokenizer::ParseInternal(Array<UserToken>& tokensOut, Array<UserToken>& commentsOut)
  {
    // The next token that will be parsed as we move along
    UserToken nextToken;

    // Loop and read tokens until we get an error or reach the end
    while (this->ReadToken(&nextToken))
    {
      // If we got here, then we know the symbol is valid because the ReadToken returned true
      // Do something based on the symbol's type
      switch (nextToken.TokenId)
      {
        // If we get a comment start symbol, continue on into block comment testing
        case Grammar::CommentStart:
        {
          // Since we just hit a comment start, increment the comment depth
          ++this->CommentDepth;
        }
        break;

        // If we get a comment end symbol, back one comment scope out
        case Grammar::CommentEnd:
        {
          // Make sure our comment depth is greater than zero
          if (this->CommentDepth > 0)
          {
            // Since we just hit a comment end, decrement the comment depth
            --this->CommentDepth;
          }
          else
          {
            // Add a parsing error
            this->Errors.Raise(this->Location, ErrorCode::BlockCommentNotFound);
          }
        }
        break;

        // If we begin a line comment, skip to the end of the line
        case Grammar::CommentLine:
        {
          // Check and make sure we're not in a comment
          if (this->CommentDepth == 0)
          {
            // Skip to the end of the line via modifying the position
            nextToken.Token = this->SkipToEndOfLine();
            commentsOut.push_back(nextToken);
          }
        }
        break;

        // Whitespace we do absolutely nothing (just ignore it)
        case Grammar::Whitespace:
        {
        }
        break;

        // This was not a special symbol, just report it to the user
        default:
        {
          // Check and make sure we're not in a comment
          if (this->CommentDepth == 0)
          {
            // Push the token into the list
            tokensOut.push_back(nextToken);
          }
        }
        break;
      }
    }

    //printf("Was Error: %d\n", this->Errors.WasError);
    //printf("------ Begin Tokens ------\n");
    //for (size_t i = 0; i < tokensOut.size(); ++i)
    //{
    //  printf("Token: %d : %d '%s'\n", i, tokensOut[i].TokenId, tokensOut[i].Token.c_str());
    //}
    //printf("------ End Tokens ------\n");

    // As long as there were no errors...
    if (this->Errors.WasError == false)
    {
      // Check and make sure we're not in a comment
      if (this->CommentDepth == 0)
      {
        // We reached the end, no problems!
        return true;
      }
      // If we were in the middle of a comment, this is an error!
      else
      {
        // Add a parsing error and return out
        this->Errors.Raise(this->Location, ErrorCode::BlockCommentNotComplete);
        return false;
      }
    }
    else
    {
      // There was an error, so we failed
      return false;
    }
  }

  //***************************************************************************
  char Tokenizer::ReadCharacter()
  {
    // If the current position is outside the data bounds...
    if (this->Position >= this->Data.size())
    {
      // Increment the position by a byte even though we're past the end
      // We rely on this position being pushed out to properly get the length of tokens
      ++this->Position;

      // Return the null character. Every place that calls ReadCharacter
      // should expect and handle the case of reaching the end
      return '\0';
    }

    // Stores the result of the read
    char result = this->Data[this->Position];

    // Increment the position by a byte
    ++this->Position;

    // If we've actually moved forward
    if (this->ForwardPosition < this->Position)
    {
      // Update the line and character number
      UpdateLineAndCharacterNumber(result);

      // Move the forward position forward
      this->ForwardPosition = this->Position;
    }

    // Return the stored temporary value
    return result;
  }

  //***************************************************************************
  bool Tokenizer::DiffString(const char* string)
  {
    // Store the local string position
    int localStringPos = 0;

    // Have we matched the string to the input stream yet?
    bool match = false;

    // Loop until we reach the end of the given string, or we hit an invalid character
    ZilchLoop
    {
      // If we hit the end of our given string (and we've matched up to this point) then it's a match!
      if (string[localStringPos] == '\0')
      {
        // Mark it as being a match and jump out
        match = true;
        break;
      }
      // Otherwise, if the characters were not the same, we must break out
      // Eof is handled because the string we compare with should never have eof in it (see the check above)
      else if (ReadCharacter() != string[localStringPos])
      {
        // Backup the position by once since we just read a character that wasn't in this string
        --this->Position;
        break;
      }

      // Increment the local string position
      ++localStringPos;
    }

    // Return whether we matched or not
    return match;
  }

  //***************************************************************************
  bool Tokenizer::ReadKeywordOrSymbol(UserToken* outToken, size_t& lastAcceptedPos, char& character, TokenCategory::Enum& tokenType)
  {
    // Was a token ever accepted?
    bool acceptedToken = false;

    // Store the type of token we're parsing (we should know immediately from the first branch)
    tokenType = TokenCategory::Unknown;

    // In the event that we've gotten here, 
character = ReadCharacter();

switch (character)
{
  case 'a':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'b':
      {
        acceptedToken = false;

        if (DiffString("stract"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Abstract /* Abstract */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 's':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::As /* As */;
        acceptedToken = true;

        character = ReadCharacter();

        switch (character)
        {
          case 's':
          {
            acceptedToken = false;

            if (DiffString("ert"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Assert /* Assert */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'l':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'i':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'a':
              {
                acceptedToken = false;

                if (DiffString("s"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Alias /* Alias */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

              case 'g':
              {
                acceptedToken = false;

                if (DiffString("nof"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Alignof /* Alignof */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

            }
            break;
          }

        }
        break;
      }

      case 'n':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'd':
          {
            lastAcceptedPos = this->Position;
            outToken->TokenId = Grammar::And /* And */;
            acceptedToken = true;

            character = ReadCharacter();

            break;
          }

          case 'y':
          {
            lastAcceptedPos = this->Position;
            outToken->TokenId = Grammar::Any /* Any */;
            acceptedToken = true;

            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'u':
      {
        acceptedToken = false;

        if (DiffString("to"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Auto /* Auto */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'b':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'a':
      {
        acceptedToken = false;

        if (DiffString("se"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Base /* Base */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'r':
      {
        acceptedToken = false;

        if (DiffString("eak"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Break /* Break */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 's':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 't':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'a':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 't':
              {
                acceptedToken = false;

                if (DiffString("ic"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Static /* Static */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

              case 'c':
              {
                acceptedToken = false;

                if (DiffString("kalloc"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Stackalloc /* Stackalloc */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

            }
            break;
          }

          case 'r':
          {
            acceptedToken = false;

            if (DiffString("uct"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Struct /* Struct */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'c':
      {
        acceptedToken = false;

        if (DiffString("ope"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Scope /* Scope */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'i':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'g':
          {
            acceptedToken = false;

            if (DiffString("ned"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Signed /* Signed */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'z':
          {
            acceptedToken = false;

            if (DiffString("eof"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Sizeof /* Sizeof */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'e':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'a':
          {
            acceptedToken = false;

            if (DiffString("led"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Sealed /* Sealed */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 't':
          {
            lastAcceptedPos = this->Position;
            outToken->TokenId = Grammar::Set /* Set */;
            acceptedToken = true;

            character = ReadCharacter();

            break;
          }

          case 'n':
          {
            acceptedToken = false;

            if (DiffString("ds"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Sends /* Sends */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'w':
      {
        acceptedToken = false;

        if (DiffString("itch"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Switch /* Switch */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 't':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'r':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'u':
          {
            acceptedToken = false;

            if (DiffString("e"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::True /* True */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'y':
          {
            lastAcceptedPos = this->Position;
            outToken->TokenId = Grammar::Try /* Try */;
            acceptedToken = true;

            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'i':
      {
        acceptedToken = false;

        if (DiffString("meout"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Timeout /* Timeout */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'h':
      {
        acceptedToken = false;

        if (DiffString("row"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Throw /* Throw */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'y':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'p':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'e':
              {
                acceptedToken = false;

                character = ReadCharacter();

                switch (character)
                {
                  case 'i':
                  {
                    acceptedToken = false;

                    if (DiffString("d"))
                    {
                      lastAcceptedPos = this->Position;
                      outToken->TokenId = Grammar::Typeid /* Typeid */;
                      acceptedToken = true;
                    }
                    character = ReadCharacter();

                    break;
                  }

                  case 'n':
                  {
                    acceptedToken = false;

                    if (DiffString("ame"))
                    {
                      lastAcceptedPos = this->Position;
                      outToken->TokenId = Grammar::Typename /* Typename */;
                      acceptedToken = true;
                    }
                    character = ReadCharacter();

                    break;
                  }

                  case 'o':
                  {
                    acceptedToken = false;

                    if (DiffString("f"))
                    {
                      lastAcceptedPos = this->Position;
                      outToken->TokenId = Grammar::Typeof /* Typeof */;
                      acceptedToken = true;
                    }
                    character = ReadCharacter();

                    break;
                  }

                  case 'd':
                  {
                    acceptedToken = false;

                    if (DiffString("ef"))
                    {
                      lastAcceptedPos = this->Position;
                      outToken->TokenId = Grammar::Typedef /* Typedef */;
                      acceptedToken = true;
                    }
                    character = ReadCharacter();

                    break;
                  }

                }
                break;
              }

            }
            break;
          }

        }
        break;
      }

    }
    break;
  }

  case 'r':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'e':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'a':
          {
            acceptedToken = false;

            if (DiffString("donly"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Readonly /* Readonly */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 't':
          {
            acceptedToken = false;

            if (DiffString("urn"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Return /* Return */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'g':
          {
            acceptedToken = false;

            if (DiffString("ister"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Register /* Register */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'f':
          {
            lastAcceptedPos = this->Position;
            outToken->TokenId = Grammar::Ref /* Ref */;
            acceptedToken = true;

            character = ReadCharacter();

            break;
          }

          case 'q':
          {
            acceptedToken = false;

            if (DiffString("uire"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Require /* Require */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

    }
    break;
  }

  case 'c':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'a':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 's':
          {
            acceptedToken = false;

            if (DiffString("e"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Case /* Case */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 't':
          {
            acceptedToken = false;

            if (DiffString("ch"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Catch /* Catch */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'l':
      {
        acceptedToken = false;

        if (DiffString("ass"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Class /* Class */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'o':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'n':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 's':
              {
                acceptedToken = false;

                character = ReadCharacter();

                switch (character)
                {
                  case 't':
                  {
                    lastAcceptedPos = this->Position;
                    outToken->TokenId = Grammar::Const /* Const */;
                    acceptedToken = true;

                    character = ReadCharacter();

                    switch (character)
                    {
                      case 'r':
                      {
                        acceptedToken = false;

                        if (DiffString("uctor"))
                        {
                          lastAcceptedPos = this->Position;
                          outToken->TokenId = Grammar::Constructor /* Constructor */;
                          acceptedToken = true;
                        }
                        character = ReadCharacter();

                        break;
                      }

                    }
                    break;
                  }

                }
                break;
              }

              case 't':
              {
                acceptedToken = false;

                if (DiffString("inue"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Continue /* Continue */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

            }
            break;
          }

        }
        break;
      }

      case 'h':
      {
        acceptedToken = false;

        if (DiffString("ecked"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Checked /* Checked */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'l':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'o':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'c':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'a':
              {
                acceptedToken = false;

                if (DiffString("l"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Local /* Local */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

              case 'k':
              {
                lastAcceptedPos = this->Position;
                outToken->TokenId = Grammar::Lock /* Lock */;
                acceptedToken = true;

                character = ReadCharacter();

                break;
              }

            }
            break;
          }

          case 'o':
          {
            acceptedToken = false;

            if (DiffString("p"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Loop /* Loop */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

    }
    break;
  }

  case 'i':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 's':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::Is /* Is */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case 'n':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::In /* In */;
        acceptedToken = true;

        character = ReadCharacter();

        switch (character)
        {
          case 't':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'e':
              {
                acceptedToken = false;

                character = ReadCharacter();

                switch (character)
                {
                  case 'r':
                  {
                    acceptedToken = false;

                    character = ReadCharacter();

                    switch (character)
                    {
                      case 'n':
                      {
                        acceptedToken = false;

                        if (DiffString("al"))
                        {
                          lastAcceptedPos = this->Position;
                          outToken->TokenId = Grammar::Internal /* Internal */;
                          acceptedToken = true;
                        }
                        character = ReadCharacter();

                        break;
                      }

                      case 'f':
                      {
                        acceptedToken = false;

                        if (DiffString("ace"))
                        {
                          lastAcceptedPos = this->Position;
                          outToken->TokenId = Grammar::Interface /* Interface */;
                          acceptedToken = true;
                        }
                        character = ReadCharacter();

                        break;
                      }

                    }
                    break;
                  }

                }
                break;
              }

            }
            break;
          }

          case 'c':
          {
            acceptedToken = false;

            if (DiffString("lude"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Include /* Include */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'l':
          {
            acceptedToken = false;

            if (DiffString("ine"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Inline /* Inline */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'f':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::If /* If */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case 'm':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'm':
          {
            acceptedToken = false;

            if (DiffString("utable"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Immutable /* Immutable */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'p':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'l':
              {
                acceptedToken = false;

                if (DiffString("icit"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Implicit /* Implicit */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

              case 'o':
              {
                acceptedToken = false;

                if (DiffString("rt"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Import /* Import */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

            }
            break;
          }

        }
        break;
      }

    }
    break;
  }

  case 'g':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'l':
      {
        acceptedToken = false;

        if (DiffString("obal"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Global /* Global */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'o':
      {
        acceptedToken = false;

        if (DiffString("to"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Goto /* Goto */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'e':
      {
        acceptedToken = false;

        if (DiffString("t"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Get /* Get */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'n':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'a':
      {
        acceptedToken = false;

        if (DiffString("mespace"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Namespace /* Namespace */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'o':
      {
        acceptedToken = false;

        if (DiffString("t"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Not /* Not */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'e':
      {
        acceptedToken = false;

        if (DiffString("w"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::New /* New */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'u':
      {
        acceptedToken = false;

        if (DiffString("ll"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Null /* Null */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'o':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'r':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::Or /* Or */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case 'u':
      {
        acceptedToken = false;

        if (DiffString("t"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Out /* Out */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'p':
      {
        acceptedToken = false;

        if (DiffString("erator"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Operator /* Operator */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'v':
      {
        acceptedToken = false;

        if (DiffString("erride"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Override /* Override */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'f':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'a':
      {
        acceptedToken = false;

        if (DiffString("lse"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::False /* False */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'r':
      {
        acceptedToken = false;

        if (DiffString("iend"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Friend /* Friend */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'l':
      {
        acceptedToken = false;

        if (DiffString("ags"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Flags /* Flags */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'i':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'n':
          {
            acceptedToken = false;

            if (DiffString("ally"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Finally /* Finally */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'x':
          {
            acceptedToken = false;

            if (DiffString("ed"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Fixed /* Fixed */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'o':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'r':
          {
            lastAcceptedPos = this->Position;
            outToken->TokenId = Grammar::For /* For */;
            acceptedToken = true;

            character = ReadCharacter();

            switch (character)
            {
              case 'e':
              {
                acceptedToken = false;

                if (DiffString("ach"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::ForEach /* ForEach */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

            }
            break;
          }

        }
        break;
      }

      case 'u':
      {
        acceptedToken = false;

        if (DiffString("nction"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Function /* Function */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'e':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'l':
      {
        acceptedToken = false;

        if (DiffString("se"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Else /* Else */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'n':
      {
        acceptedToken = false;

        if (DiffString("um"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Enumeration /* Enumeration */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'x':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 't':
          {
            acceptedToken = false;

            if (DiffString("ern"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Extern /* Extern */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'p':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'l':
              {
                acceptedToken = false;

                if (DiffString("icit"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Explicit /* Explicit */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

              case 'o':
              {
                acceptedToken = false;

                if (DiffString("rt"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Export /* Export */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

            }
            break;
          }

        }
        break;
      }

    }
    break;
  }

  case 'u':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 's':
      {
        acceptedToken = false;

        if (DiffString("ing"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Using /* Using */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'n':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 's':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'a':
              {
                acceptedToken = false;

                if (DiffString("fe"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Unsafe /* Unsafe */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

              case 'i':
              {
                acceptedToken = false;

                if (DiffString("gned"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Unsigned /* Unsigned */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

            }
            break;
          }

          case 'c':
          {
            acceptedToken = false;

            if (DiffString("hecked"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Unchecked /* Unchecked */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

    }
    break;
  }

  case 'd':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'o':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::Do /* Do */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case 'e':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'b':
          {
            acceptedToken = false;

            if (DiffString("ug"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Debug /* Debug */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 's':
          {
            acceptedToken = false;

            if (DiffString("tructor"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Destructor /* Destructor */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'l':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'e':
              {
                acceptedToken = false;

                character = ReadCharacter();

                switch (character)
                {
                  case 't':
                  {
                    acceptedToken = false;

                    if (DiffString("e"))
                    {
                      lastAcceptedPos = this->Position;
                      outToken->TokenId = Grammar::Delete /* Delete */;
                      acceptedToken = true;
                    }
                    character = ReadCharacter();

                    break;
                  }

                  case 'g':
                  {
                    acceptedToken = false;

                    if (DiffString("ate"))
                    {
                      lastAcceptedPos = this->Position;
                      outToken->TokenId = Grammar::Delegate /* Delegate */;
                      acceptedToken = true;
                    }
                    character = ReadCharacter();

                    break;
                  }

                }
                break;
              }

            }
            break;
          }

          case 'f':
          {
            acceptedToken = false;

            if (DiffString("ault"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Default /* Default */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'y':
      {
        acceptedToken = false;

        if (DiffString("namic"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Dynamic /* Dynamic */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'y':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    if (DiffString("ield"))
    {
      lastAcceptedPos = this->Position;
      outToken->TokenId = Grammar::Yield /* Yield */;
      acceptedToken = true;
    }
    character = ReadCharacter();

    break;
  }

  case 'm':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'o':
      {
        acceptedToken = false;

        if (DiffString("dule"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Module /* Module */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'u':
      {
        acceptedToken = false;

        if (DiffString("table"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Mutable /* Mutable */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'p':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'a':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'r':
          {
            acceptedToken = false;

            character = ReadCharacter();

            switch (character)
            {
              case 'a':
              {
                acceptedToken = false;

                if (DiffString("ms"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Params /* Params */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

              case 't':
              {
                acceptedToken = false;

                if (DiffString("ial"))
                {
                  lastAcceptedPos = this->Position;
                  outToken->TokenId = Grammar::Partial /* Partial */;
                  acceptedToken = true;
                }
                character = ReadCharacter();

                break;
              }

            }
            break;
          }

          case 'c':
          {
            acceptedToken = false;

            if (DiffString("kage"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Package /* Package */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'r':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'i':
          {
            acceptedToken = false;

            if (DiffString("vate"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Private /* Private */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'o':
          {
            acceptedToken = false;

            if (DiffString("tected"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Protected /* Protected */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case 'o':
      {
        acceptedToken = false;

        if (DiffString("sitional"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Positional /* Positional */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'u':
      {
        acceptedToken = false;

        if (DiffString("blic"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Public /* Public */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'v':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'a':
      {
        acceptedToken = false;

        if (DiffString("r"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Variable /* Variable */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'i':
      {
        acceptedToken = false;

        if (DiffString("rtual"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Virtual /* Virtual */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

      case 'o':
      {
        acceptedToken = false;

        if (DiffString("latile"))
        {
          lastAcceptedPos = this->Position;
          outToken->TokenId = Grammar::Volatile /* Volatile */;
          acceptedToken = true;
        }
        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case 'w':
  {
    tokenType = TokenCategory::Keyword;

    acceptedToken = false;

    character = ReadCharacter();

    switch (character)
    {
      case 'h':
      {
        acceptedToken = false;

        character = ReadCharacter();

        switch (character)
        {
          case 'i':
          {
            acceptedToken = false;

            if (DiffString("le"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::While /* While */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

          case 'e':
          {
            acceptedToken = false;

            if (DiffString("re"))
            {
              lastAcceptedPos = this->Position;
              outToken->TokenId = Grammar::Where /* Where */;
              acceptedToken = true;
            }
            character = ReadCharacter();

            break;
          }

        }
        break;
      }

    }
    break;
  }

  case '.':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::Access /* Access */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case '-':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::Negative /* Negative, Subtract */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '-':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::Decrement /* Decrement */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '>':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::DynamicAccess /* DynamicAccess */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentSubtract /* AssignmentSubtract */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '>':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::GreaterThan /* GreaterThan */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '>':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::BitshiftRight /* BitshiftRight */;
        acceptedToken = true;

        character = ReadCharacter();

        switch (character)
        {
          case '=':
          {
            lastAcceptedPos = this->Position;
            outToken->TokenId = Grammar::AssignmentRightShift /* AssignmentRightShift */;
            acceptedToken = true;

            character = ReadCharacter();

            break;
          }

        }
        break;
      }

      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::GreaterThanOrEqualTo /* GreaterThanOrEqualTo */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '~':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::BitwiseNot /* BitwiseNot */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '>':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::NonVirtualAccess /* NonVirtualAccess */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case ':':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::TypeSpecifier /* TypeSpecifier, NameSpecifier, Inheritance, InitializerList */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case ',':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::ArgumentSeparator /* ArgumentSeparator */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case '=':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::Assignment /* Assignment */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '>':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::RefersTo /* RefersTo */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::Equality /* Equality */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '+':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::Positive /* Positive, Add */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentAdd /* AssignmentAdd */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '+':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::Increment /* Increment */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '/':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::Divide /* Divide */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentDivide /* AssignmentDivide */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '/':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::CommentLine /* CommentLine */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '*':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::CommentStart /* CommentStart */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '*':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::Multiply /* Multiply */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentMultiply /* AssignmentMultiply */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '/':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::CommentEnd /* CommentEnd */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '%':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::Modulo /* Modulo */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentModulo /* AssignmentModulo */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '^':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::Exponent /* Exponent */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentExponent /* AssignmentExponent */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '<':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::LessThan /* LessThan */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::LessThanOrEqualTo /* LessThanOrEqualTo */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '<':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::BitshiftLeft /* BitshiftLeft */;
        acceptedToken = true;

        character = ReadCharacter();

        switch (character)
        {
          case '=':
          {
            lastAcceptedPos = this->Position;
            outToken->TokenId = Grammar::AssignmentLeftShift /* AssignmentLeftShift */;
            acceptedToken = true;

            character = ReadCharacter();

            break;
          }

        }
        break;
      }

    }
    break;
  }

  case '$':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::BitwiseXor /* BitwiseXor */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentBitwiseXor /* AssignmentBitwiseXor */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '|':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::BitwiseOr /* BitwiseOr */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentBitwiseOr /* AssignmentBitwiseOr */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '|':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::LogicalOr /* LogicalOr */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '&':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::BitwiseAnd /* BitwiseAnd */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::AssignmentBitwiseAnd /* AssignmentBitwiseAnd */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

      case '&':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::LogicalAnd /* LogicalAnd */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '!':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::LogicalNot /* LogicalNot */;
    acceptedToken = true;

    character = ReadCharacter();

    switch (character)
    {
      case '=':
      {
        lastAcceptedPos = this->Position;
        outToken->TokenId = Grammar::Inequality /* Inequality */;
        acceptedToken = true;

        character = ReadCharacter();

        break;
      }

    }
    break;
  }

  case '@':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::PropertyDelegate /* PropertyDelegate */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case ';':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::StatementSeparator /* StatementSeparator */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case '[':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::BeginIndex /* BeginIndex, BeginTemplate, BeginAttribute, OldBeginInitializer */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case ']':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::EndIndex /* EndIndex, EndTemplate, EndAttribute, OldEndInitializer */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case '(':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::BeginFunctionCall /* BeginFunctionCall, BeginFunctionParameters, BeginGroup */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case ')':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::EndFunctionCall /* EndFunctionCall, EndFunctionParameters, EndGroup */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case '{':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::BeginScope /* BeginScope, BeginInitializer */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

  case '}':
  {
    tokenType = TokenCategory::Symbol;

    lastAcceptedPos = this->Position;
    outToken->TokenId = Grammar::EndScope /* EndScope, EndInitializer */;
    acceptedToken = true;

    character = ReadCharacter();

    break;
  }

}


    // If we accepted a token...
    if (acceptedToken)
    {
      // If the token type we started reading was a keyword...
      if (tokenType == TokenCategory::Keyword)
      {
        // As long as the last character read was not an alpha-numeric character...
        if (CharacterUtilities::IsAlphaNumeric(character) == false && character != '_')
        {
          // Backup the last read character
          --this->Position;

          // Return true since it must be a keyword
          return true;
        }

        // It's not at the end of a token, don't accept it... (but keep the position where it is)
        return false;
      }
      else
      {
        // Backup to the last accepted position
        this->Position = lastAcceptedPos;

        // Accept the token
        return true;
      }
    }

    // Since we got here, we must not have accepted the token
    return false;
  }

  //***************************************************************************
  bool Tokenizer::ReadIdentifier(UserToken* outToken, bool startedFromKeyword, size_t& lastAcceptedPos, char& character)
  {
    // Whether or not we've accepted the token
    bool acceptedToken = startedFromKeyword;

    // By default, assume we parsed a lower-case identifier
    // (starting from keywords will always lead to this case)
    Grammar::Enum assumedTokenType = Grammar::LowerIdentifier;

    // Loop until we hit a non-alpha numeric character
    ZilchLoop
    {
      // If we've accepted the token already
      if (acceptedToken)
      {
        // If it's not an alpha-numeric value or underscore, then we have to stop
        if (CharacterUtilities::IsAlphaNumeric(character) == false && character != '_')
          break;
      }
      // Otherwise, we haven't accepted anything yet (so we're on the first character)
      else
      {
        // If the first character is not just an alpha character, then we must stop
        // We cannot begin an identifier with an underscore
        if (CharacterUtilities::IsAlpha(character) == false)
          break;

        // If the first character is upper case, then this is an upper case identifier
        if (CharacterUtilities::IsUpper(character))
          assumedTokenType = Grammar::UpperIdentifier;
      }

      // Store away the position
      lastAcceptedPos = this->Position;

      // We read something! So we must accept the identifier
      acceptedToken = true;

      // Read the next character. We handle the eof in the next loop;
      // we will terminate since the character is not alphanumeric
      character = ReadCharacter();
    }

    // If we accepted the identifier...
    if (acceptedToken)
    {
      // Backup to the last accepted position
      this->Position = lastAcceptedPos;

      // It must be an identifier
      outToken->TokenId = assumedTokenType;
    }

    // Return the result...
    return acceptedToken;
  }

  //***************************************************************************
  bool Tokenizer::ReadNumber(UserToken* outToken, size_t& lastAcceptedPos, char& character)
  {
    // Whether or not we've accepted the token
    bool acceptedToken = false;

    // Is the number a real? This will be -1 if it's not
    size_t isRealPos = (size_t) -1;

    // If we're parsing an exponential number, then we can expect an exponent sign
    bool nextCanBeExplonentialSign = false;

    // If we hit an exponent 'e' or not (only may occur once)
    bool isScientificNotation = false;

    // If the number is double size (or precision)
    bool isDoubleSize = false;

    // While what we're reading is a digit or a decimal place
    ZilchLoop
    {
      // Clear the flag so we know that the next character cannot be a sign (store the flag for this loop)
      bool canBeExplonentialSign = nextCanBeExplonentialSign;
      nextCanBeExplonentialSign = false;

      // Note: Normally if ReadNumber was standalone, we'd need to be careful that we never
      // read something that starts with a '.', 'e', or 'd' as a token, however
      // because it only ever gets called after ReadIdentifier and ReadKeywordOrSymbol it cannot happen

      // If the character is a digit...
      if (CharacterUtilities::IsNumeric(character))
      {
        // Store away the position
        lastAcceptedPos = this->Position;

        // We read something! So we must accept the token
        acceptedToken = true;
      }
      // We only bother to read any other kind of symbol if we read a number already
      else if (acceptedToken)
      {
        // If the character is a decimal place...
        if (character == '.')
        {
          // If we haven't yet accepted a number, then it can't just start with '.'
          // (Though technically this should have been accepted as a symbol in the first place...)
          // Also break if we already determined it was a real, and then we broke out
          if (isRealPos != (size_t) -1 || acceptedToken == false)
            break;

          // Since we found a decimal, it must be a real number
          isRealPos = this->Position;
        }
        // If we hit an exponent 'e' and we're not already an exponent
        else if (character == 'e' && isScientificNotation == false)
        {
          // Since we're an exponent, the next character is allowed to be a '-' or '+'
          nextCanBeExplonentialSign = true;
        }
        // Check to see if this character is a sign...
        else if (canBeExplonentialSign && (character == '-' || character == '+'))
        {
          // We don't do anything here, including not accepting this token position
          // We need a number to follow in order to accept this!
        }
        // If we hit the 'double size' marker...
        else if (character == 'd')
        {
          // If the number ends in a 'd', it means our number is double sized (64 bit typically)
          isDoubleSize = true;

          // Accept the number and break out, since 'd' only ever occurs at the end
          lastAcceptedPos = this->Position;
          acceptedToken = true;
          break;
        }
        // If the character is unknown, we must break out
        else
        {
          break;
        }
      }
      // We attempted to read something that wasn't a number...
      else
      {
        break;
      }
      
      // Read the next character. We handle the eof in the next loop;
      // we will terminate since the character is not numeric or '.'
      character = ReadCharacter();
    }

    // If we accepted the identifier...
    if (acceptedToken)
    {
      // Backup to the last accepted position
      this->Position = lastAcceptedPos;

      // If the numeric literal is double sized...
      if (isDoubleSize)
      {
        // If we found a real instead of an integer...
        if (isRealPos < lastAcceptedPos)
          outToken->TokenId = Grammar::DoubleRealLiteral;
        else
          outToken->TokenId = Grammar::DoubleIntegerLiteral;
      }
      else
      {
        // If we found a real instead of an integer...
        if (isRealPos < lastAcceptedPos)
          outToken->TokenId = Grammar::RealLiteral;
        else
          outToken->TokenId = Grammar::IntegerLiteral;
      }
    }

    // Return the result...
    return acceptedToken;
  }

  //***************************************************************************
  bool Tokenizer::ReadString(UserToken* outToken, size_t& lastAcceptedPos, char& character)
  {
    // We only consider this string to be an interpolant end if it starts with a grave accent
    bool isInterpolantEnd = (this->EnableStringInterpolation && character == '`');

    // If the character is not a quote, then return failure immediately
    if (character != '"' && isInterpolantEnd == false)
      return false;

    // This is only used for tolerant mode when we don't parse a string because it wasn't closed
    size_t startPosition = this->Position;

    // Was an escape character hit?
    bool escaped = false;

    // Loop until we hit a non-alpha numeric character
    ZilchLoop
    {
      // Read the next character. We handle the eof specifically below
      character = ReadCharacter();

      // If the character is an escape character...
      if (character == '\\')
      {
        // Toggle the escaped flag
        // Note that we toggle it, instead of just turning it on
        // This is because \\ is actually escaping an escape
        escaped = !escaped;
      }
      else
      {
        // If we are currently escaped...
        if (escaped)
        {
          // Determine all the valid characters that we could escape on
          if (CharacterUtilities::IsStringEscapee(character) == false)
          {
            // If we're in a comment, ignroe invalid escape sequences
            if (this->CommentDepth == 0)
            {
              // We hit an invalid escape
              this->Errors.Raise(this->Location, ErrorCode::InvalidEscapeInStringLiteral, character);
              return false;
            }
          }

          // We are no longer escaped
          escaped = false;
        }
        // Otherwise, if it's a non escaped quotation..
        else if (character == '"' || (this->EnableStringInterpolation && character == '`'))
        {
          // Set that the last accepted position was this position
          lastAcceptedPos = this->Position;
          
          // If we're ending this string with a grave, then it means we're starting an interpolant
          bool isInterpolantStart = (this->EnableStringInterpolation && character == '`');

          // If the character is an interpolant starting character...
          if (isInterpolantStart)
          {
            if (isInterpolantEnd)
            {
              // We are both ending an intpolant and starting another...
              outToken->TokenId = Grammar::EndBeginStringInterpolate;
            }
            else
            {
              // We are just starting a new interpolant
              outToken->TokenId = Grammar::BeginStringInterpolate;
            }
          }
          else
          {
            if (isInterpolantEnd)
            {
              // We are just ending an interpolant
              outToken->TokenId = Grammar::EndStringInterpolate;
            }
            else
            {
              // It's just a straight up string literal
              outToken->TokenId = Grammar::StringLiteral;
            }
          }

          // We parsed the string or interpolant, call it good!
          return true;
        }
        // Is it the eof character or the end of a line?
        else if (character == '\0' || character == '\r' || character == '\n')
        {
          // If we're in tolerant mode, most likely the user was typing a string
          // or string interpolant and it wasn't yet closed
          // What we're going to do here is just parse this as a string token and cut it off
          if (this->Errors.TolerantMode)
          {
            // Set that the last accepted position was this position
            lastAcceptedPos = this->Position;

            // Just return this as if the entire line is a string
            outToken->TokenId = Grammar::StringLiteral;
            return true;
          }
          else
          {
            // We hit the eof before closing the string
            this->Errors.Raise(this->Location, ErrorCode::StringLiteralNotComplete);
            return false;
          }
        }
      }
    }
  }

  //***************************************************************************
  bool Tokenizer::ReadToken(UserToken* outToken)
  {
    // Store the last position at which we accepted a token (or the beginning of the token)
    size_t lastAcceptedPos = this->Position;

    // Set the starting position that the token is reading from
    outToken->Start = this->Position;

    // Store the character that we read
    char character = '\0';

    // Store the type of token we're parsing (we should know immediately from the first branch)
    TokenCategory::Enum tokenType;

    // Loop until we accept a token
    ZilchLoop
    {
      // Attempt to read a keyword or symbol
      // Internally we call 'ReadCharacter', which can return eof, so we handle it below
      if (ReadKeywordOrSymbol(outToken, lastAcceptedPos, character, tokenType) == true)
      {
        // Break out since we've found the full token
        break;
      }
      else
      {
        // If we started by reading a keyword...
        if (tokenType == TokenCategory::Keyword)
        {
          // Store away the position
          lastAcceptedPos = this->Position - 1;

          // Read the identifier (we don't actually need to check the return since we always know its 'true')
          bool result = ReadIdentifier(outToken, true, lastAcceptedPos, character);
          ErrorIf(result != true, "Reading the identifier must always succeed");
          break;
        }
        // If we didn't read anything yet...
        else if (tokenType == TokenCategory::Unknown)
        {
          // If the character is some sort of space character...
          if (CharacterUtilities::IsWhiteSpace(character))
          {
            // Set the starting position that the token is reading from
            outToken->Start = this->Position;

            // Since we hit whitespace, we want to update the location
            // so that the next token doesn't think it started in whitespace
            this->Location.StartLine = this->Line;
            this->Location.StartCharacter = this->Character;
            this->Location.StartPosition = this->Position;
            this->Location.PrimaryLine = this->Line;
            this->Location.PrimaryCharacter = this->Character;
            this->Location.PrimaryPosition = this->Position;

            // Continue to the next loop iteration
            continue;
          }
          // Attempt to read it as an identifier
          else if (ReadIdentifier(outToken, false, lastAcceptedPos, character)  ||
                   ReadNumber(outToken, lastAcceptedPos, character)             ||
                   ReadString(outToken, lastAcceptedPos, character))
          {
            // Break out since we've found the full token
            break;
          }
          // If we reach the end of the file...
          else if (character == '\0')
          {
            // We hit the end
            return false;
          }
          // Otherwise, if there was an error...
          else if (this->Errors.WasError)
          {
            // An error occurred, return that we failed
            return false;
          }
        }

        // As long as we're not in the middle of a comment...
        if (this->CommentDepth == 0)
        {
          // Get the bad character
          char badCharacter = '?';

          // Ensure that the bad character was within the data bounds (for safety)
          if (outToken->Start < this->Data.size())
          {
            // Get the bad character
            badCharacter = this->Data[outToken->Start];
          }

          // If we got here, some sort of unknown data must have been input
          // Add a parsing error that informs the user that a token could not be read
          this->Errors.Raise(this->Location, ErrorCode::UnidentifiedSymbol, badCharacter);
          return false;
        }
      }
    }
    
    // Set the token's line and character number
    outToken->Location = this->Location;

    // Set the length of the token as the last recorded end minus the start
    outToken->Length = lastAcceptedPos - outToken->Start;

    // Read in the token
    outToken->Token = String(this->Data.c_str() + outToken->Start, outToken->Length);

    // Move the location's start forward
    this->Location.StartLine = this->Location.EndLine;
    this->Location.StartCharacter = this->Location.EndCharacter;
    this->Location.StartPosition = this->Location.EndPosition;
    this->Location.PrimaryLine = this->Location.EndLine;
    this->Location.PrimaryCharacter = this->Location.EndCharacter;
    this->Location.PrimaryPosition = this->Location.EndPosition;

    // Return if the symbol was not null
    return true;
  }


  //***************************************************************************
  void Tokenizer::UpdateLineAndCharacterNumber(char character)
  {
    // The end of the location is always one character behind
    this->Location.EndLine = this->Line;
    this->Location.EndCharacter = this->Character;
    this->Location.EndPosition = this->Position - 1;

    // Skip the null character
    if (character != '\0')
    {
      // Increment the character count for the current line
      ++this->Character;

      // Check if the character matches that of the newline or carriage return
      if (character == '\n' || character == '\r')
      {
        // As long as the last character wasn't a carriage return and this character isn't a newline (CRLF)...
        // Note: If this was a full CRLF, we already incremented the line on the first CR, no need to do it again!
        if ((this->WasCarriageReturn && character == '\n') == false)
        {
          // Increment the line count since we hit a line
          ++this->Line;
        }

        // If the character is a carriage return then set it
        this->WasCarriageReturn = (character == '\r');

        // For this new line, we start out on character one
        this->Character = 1;
      }
    }
  }

  //***************************************************************************
  String Tokenizer::SkipToEndOfLine()
  {
    // Get the range of text
    StringRange range;
    range.begin = this->Data.c_str() + this->Position;
    
    // Loop until we hit the end of a line or the end of the file
    ZilchLoop
    {
      // Read the next character. We handle eof specifically below
      char character = ReadCharacter();

      // Check if we hit either a newline or a carriage return
      if (character == '\n' || character == '\r' || character == '\0')
      {
        // Break out of the loop
        break;
      }
    }
     
    // Backup the input stream by one character
    --this->Position;

    // Set the end of the string range
    range.end = this->Data.c_str() + this->Position;

    // Return the parsed string
    return range;
  }

  //***************************************************************************
  bool CharacterUtilities::IsWhiteSpace(char c)
  {
    // Depending on the character...
    switch (c)
    {
      // Look for any of the standard white-space characters
      case ' ':
      case '\t':
      case '\n':
      case '\v':
      case '\f':
      case '\r':
        return true;
    }

    // Otherwise, we got here so it must not be white-space!
    return false;
  }

  //***************************************************************************
  bool CharacterUtilities::IsAlpha(char c)
  {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
  }

  //***************************************************************************
  bool CharacterUtilities::IsNumeric(char c)
  {
    return (c >= '0'&& c <= '9');
  }

  //***************************************************************************
  bool CharacterUtilities::IsAlphaNumeric(char c)
  {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0'&& c <= '9');
  }

  //***************************************************************************
  bool CharacterUtilities::IsUpper(char c)
  {
    return (c & 0x20) == 0;
  }

  //***************************************************************************
  bool CharacterUtilities::IsStringEscapee(char c)
  {
    // Determine all the valid characters that we could escape on
    switch (c)
    {
      // All of these are valid characters to be escaped (in a string literal)
      case '"':
      case '`':
      case '\\':
      case '0':
      case 'a':
      case 'b':
      case 'f':
      case 'n':
      case 'r':
      case 't':
      case 'v':
        return true;

      // We hit an invalid character...
      default:
        return false;
    }
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes












namespace Zilch
{
  //***************************************************************************
  ZilchDefineType(Type, "Type", Core, builder, type)
  {
  }
  
  //***************************************************************************
  ZilchDefineType(AnyType, "AnyType", Core, builder, type)
  {
  }
  
  //***************************************************************************
  ZilchDefineType(IndirectionType, "IndirectionType", Core, builder, type)
  {
  }
  
  //***************************************************************************
  ZilchDefineType(DelegateType, "DelegateType", Core, builder, type)
  {
  }

  //***************************************************************************
  ZilchDefineType(BoundType, "BoundType", Core, builder, type)
  {
    ZilchBindField(builder, type, &BoundType::Name, "Name", PropertyBinding::Get);
  }

  //***************************************************************************
  Type::Type() :
    SourceLibrary(nullptr),
    UserData(nullptr)
  {
  }
  
  //***************************************************************************
  Library* Type::GetOwningLibrary()
  {
    return this->SourceLibrary;
  }
  
  //***************************************************************************
  Type* Type::GetTypeOrNull()
  {
    return this;
  }

  //***************************************************************************
  Resolver Resolver::Instance(BoundType* type)
  {
    Resolver resolver;
    resolver.IsStatic               = false;
    resolver.TypeInstance           = type;
    resolver.GetOverloadedFunctions = &BoundType::GetOverloadedInstanceFunctions;
    resolver.GetField               = &BoundType::GetInstanceField;
    resolver.GetProperty            = &BoundType::GetInstanceProperty;
    return resolver;
  }

  //***************************************************************************
  Resolver Resolver::Static(BoundType* type)
  {
    Resolver resolver;
    resolver.IsStatic               = true;
    resolver.TypeInstance           = type;
    resolver.GetOverloadedFunctions = &BoundType::GetOverloadedStaticFunctions;
    resolver.GetField               = &BoundType::GetStaticField;
    resolver.GetProperty            = &BoundType::GetStaticProperty;
    return resolver;
  }

  //***************************************************************************
  size_t Type::GetCopyableSize() const
  {
    return this->GetAllocatedSize();
  }

  //***************************************************************************
  byte* Type::GenericGetMemory(const byte* value) const
  {
    return const_cast<byte*>(value);
  }

  //***************************************************************************
  bool Type::IsHandleType(Type* type)
  {
    // See if the type is an indirection type...
    IndirectionType* indirectionType = TypeBinding::DynamicCast<IndirectionType*>(type);

    // If so, then it is a handle!
    if (indirectionType != nullptr)
    {
      return true;
    }

    // Otherwise, get the type as a named type...
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

    // If the type is a handle...
    return boundType != nullptr && boundType->CopyMode == TypeCopyMode::ReferenceType;
  }

  //***************************************************************************
  bool Type::IsValueType(Type* type)
  {
    // Otherwise, get the type as a named type...
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

    // If the type is a value...
    return boundType != nullptr && boundType->CopyMode == TypeCopyMode::ValueType;
  }

  //***************************************************************************
  bool Type::IsDelegateType(Type* type)
  {
    // See if the type is a delegate type...
    DelegateType* delegateType = TypeBinding::DynamicCast<DelegateType*>(type);
    return (delegateType != nullptr);
  }

  //***************************************************************************
  bool Type::IsEnumType(Type* type)
  {
    // Otherwise, get the type as a named type...
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

    // If the type is a bound type set to enumeration...
    return boundType != nullptr && boundType->SpecialType == SpecialType::Enumeration;
  }

  //***************************************************************************
  bool Type::IsFlagsType(Type* type)
  {
    // Otherwise, get the type as a named type...
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

    // If the type is a bound type set to flags...
    return boundType != nullptr && boundType->SpecialType == SpecialType::Flags;
  }

  //***************************************************************************
  bool Type::IsEnumOrFlagsType(Type* type)
  {
    // Otherwise, get the type as a named type...
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

    // If the type is a bound type set to flags or enumeration...
    return boundType != nullptr && (boundType->SpecialType == SpecialType::Flags || boundType->SpecialType == SpecialType::Enumeration);
  }

  //***************************************************************************
  bool Type::IsAnyType(Type* type)
  {
    // See if the type is a any type...
    AnyType* anyType = TypeBinding::DynamicCast<AnyType*>(type);
    return (anyType != nullptr);
  }

  //***************************************************************************
  Type* Type::GetBaseType(Type* type)
  {
    // Attempt to get the given type as a bound type
    BoundType* boundType = Type::GetBoundType(type);

    // If the type was a bound type then return its base (could be null if it has no base class)
    if (boundType != nullptr)
      return boundType->BaseType;

    // If we got here then either the given type doesn't support base types (delegates, etc)
    return nullptr;
  }
  
  //***************************************************************************
  BoundType* Type::GetBoundType(Type* handleType)
  {
    // First check if the type is already a bound type and directly return it
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(handleType);
    if (boundType != nullptr)
      return boundType;

    // An indirection type is generally a struct with the 'ref' keyword before it (making it a handle type)
    // We can access members on indirection types by going through the referenced bound type
    IndirectionType* indirectionType = TypeBinding::DynamicCast<IndirectionType*>(handleType);
    if (indirectionType != nullptr)
      return indirectionType->ReferencedType;

    // Otherwise the type was not a bound type (and did not contain one)
    return nullptr;
  }

  //***************************************************************************
  BoundType* Type::GetHandleType(Type* handleType)
  {
    // See if the type is an indirection type...
    IndirectionType* indirectionType = TypeBinding::DynamicCast<IndirectionType*>(handleType);

    // If so, then it is a handle!
    if (indirectionType != nullptr)
      return indirectionType->ReferencedType;

    // Otherwise, get the type as a named type...
    BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(handleType);

    // If the type is a handle...
    if (boundType != nullptr && boundType->CopyMode == TypeCopyMode::ReferenceType)
      return boundType;

    // If it was neither, then it is not a handle type
    return nullptr;
  }

  //***************************************************************************
  bool Type::IsSame(Type* a, Type* b)
  {
    // If the two pointers are exactly the same, then of course its the same!
    if (a == b)
    {
      // Early out and return that they are the same :D
      return true;
    }

    // Compare the hashes (we do this anyways in the linking phase, might as well do it here too)
    GuidType hashA = a->Hash();
    GuidType hashB = b->Hash();
    bool result = (hashA == hashB);

    // We better not get the same hash when hashing two different types...
    ErrorIf(result && a->ZilchGetDerivedType() != b->ZilchGetDerivedType(),
      "The same hash/guid was computed for two different types!");
    
    // Return the result (true if they are the same, false otherwise)
    return result;
  }

  //***************************************************************************
  IndirectionType::IndirectionType() :
    ReferencedType(nullptr)
  {
  }

  //***************************************************************************
  bool IndirectionType::IsCopyComplex() const
  {
    // Handles are always a complex copy
    return true;
  }

  //***************************************************************************
  size_t IndirectionType::GetAllocatedSize() const
  {
    return sizeof(Handle);
  }

  //***************************************************************************
  GuidType IndirectionType::Hash() const
  {
    return 118465894487008423 ^ this->ReferencedType->Hash();
  }
  
  //***************************************************************************
  String IndirectionType::ToString() const
  {
    // Create a string builder since we're doing some concatenation
    StringBuilder output;

    // Add the 'ref' keyword
    output += Grammar::GetKeywordOrSymbol(Grammar::Ref);
    output += " ";
    
    // Add the type we're referencing
    output += this->ReferencedType->ToString();

    // Output the string
    return output.ToString();
  }
  
  //***************************************************************************
  String IndirectionType::GetShortLowerCamelCaseName() const
  {
    return this->ReferencedType->GetShortLowerCamelCaseName();
  }

  //***************************************************************************
  void IndirectionType::GenericDefaultConstruct(byte* toConstruct) const
  {
    // Construct a null / empty handle
    new (toConstruct) Handle();
  }

  //***************************************************************************
  void IndirectionType::GenericCopyConstruct(byte* to, const byte* from) const
  {
    // Indirect types are always represented as handles (just perform a handle copy)
    new (to) Handle(*(Handle*)from);
  }

  //***************************************************************************
  void IndirectionType::GenericDestruct(byte* value) const
  {
    // Destroy the handle object
    ((Handle*)value)->~Handle();
  }
  
  //***************************************************************************
  int IndirectionType::GenericHash(const byte* value) const
  {
    return ((Handle*)value)->Hash();
  }

  //***************************************************************************
  String IndirectionType::GenericToString(const byte* value) const
  {
    // Grab the handle primitive
    Handle* handle = (Handle*)value;

    // By default, we know at least a base class type of what we're referencing
    const BoundType* type = this->ReferencedType;

    // The handle may store a more derived type inside it, if so, we should use that to print instead (virtual)
    if (handle->Type != nullptr)
      type = handle->Type;
    
    // Get a pointer to the data of the object
    byte* data = handle->Dereference();

    // If converting a null handle to a string... let the user know it's null, and what type it is
    if (data == nullptr)
      return BuildString("(null) ", type->ToString());

    // Run the user provided to-string function
    return type->ToStringFunction(type, data);
  }

  //***************************************************************************
  bool IndirectionType::GenericEquals(const byte* lhs, const byte* rhs) const
  {
    // Compare the two handles
    Handle& lHandle = *((Handle*)lhs);
    Handle& rHandle = *((Handle*)rhs);
    return lHandle == rHandle;
  }
  
  //***************************************************************************
  byte* IndirectionType::GenericGetMemory(const byte* value) const
  {
    // Get a pointer to the data of the object (indirect types are always handles)
    return ((Handle*)value)->Dereference();
  }

  //***************************************************************************
  Type* IndirectionType::GenericGetVirtualType(const byte* value) const
  {
    // Grab the handle
    Handle* handle = ((Handle*)value);
    
    // If it has no type, then return our own type
    if (handle->Type == nullptr)
      return (Type*)(this);

    // Otherwise return the type stored on the handle
    return handle->Type;
  }

  //***************************************************************************
  AnyType::AnyType()
  {
  }

  //***************************************************************************
  bool AnyType::IsCopyComplex() const
  {
    // The 'Any' class has a proper copy constructor
    return true;
  }

  //***************************************************************************
  size_t AnyType::GetAllocatedSize() const
  {
    return sizeof(Any);
  }

  //***************************************************************************
  GuidType AnyType::Hash() const
  {
    return 764373915523575397;
  }

  //***************************************************************************
  String AnyType::ToString() const
  {
    return Grammar::GetKeywordOrSymbol(Grammar::Any);
  }
  
  //***************************************************************************
  String AnyType::GetShortLowerCamelCaseName() const
  {
    return Grammar::GetKeywordOrSymbol(Grammar::Any);
  }

  //***************************************************************************
  void AnyType::GenericDefaultConstruct(byte* toConstruct) const
  {
    // Construct a default instance of 'any', should be null
    new (toConstruct) Any();
  }

  //***************************************************************************
  void AnyType::GenericCopyConstruct(byte* to, const byte* from) const
  {
    // Copy construct the 'any' to the given location
    new (to) Any(*(Any*)from);
  }

  //***************************************************************************
  void AnyType::GenericDestruct(byte* value) const
  {
    // Destroy the any type
    ((Any*)value)->~Any();
  }

  //***************************************************************************
  int AnyType::GenericHash(const byte* value) const
  {
    return ((Any*)value)->Hash();
  }

  //***************************************************************************
  String AnyType::GenericToString(const byte* value) const
  {
    return ((Any*)value)->ToString();
  }

  //***************************************************************************
  bool AnyType::GenericEquals(const byte* lhs, const byte* rhs) const
  {
    // Compare the two any types
    Any& lAny = *((Any*)lhs);
    Any& rAny = *((Any*)rhs);
    return lAny == rAny;
  }

  //***************************************************************************
  byte* AnyType::GenericGetMemory(const byte* value) const
  {
    // Get access to the any primitive
    Any* any = ((Any*)value);

    // Get the data pointed at by the any
    const byte* storedValue = any->GetData();

    // If we have a valid stored type... recursively get its memory
    if (any->StoredType != nullptr)
      return any->StoredType->GenericGetMemory(storedValue);

    // Otherwise we had nothing stored... just return ourselves
    // This MUST match the 'GenericGetVirtualType' behavior!
    return (byte*)value;
  }
  
  //***************************************************************************
  Type* AnyType::GenericGetVirtualType(const byte* value) const
  {
    // Get access to the any primitive
    Any* any = ((Any*)value);

    // If we have a valid stored type... recursively get its memory
    if (any->StoredType != nullptr)
      return any->StoredType->GenericGetVirtualType(value);

    // Otherwise we had nothing stored... just return ourselves
    // This MUST match the 'GenericGetMemory' behavior!
    return (Type*)this;
  }

  //***************************************************************************
  EventHandler* BoundType::GetEventHandler(const byte* data)
  {
    // Walk up the entire type hierarchy starting with this type
    BoundType* type = this;
    while (type != nullptr)
    {
      // If the type has a defined function for getting an event handler then attempt to call it
      if (type->GetEventHandlerFunction != nullptr)
      {
        // This may still result in null if for some reason the user determined there was no event handler
        EventHandler* handler = type->GetEventHandlerFunction(this, data);
        if (handler != nullptr)
          return handler;
      }

      // Iterate to the base type (may be null)
      type = type->BaseType;
    }

    // Otherwise, we know there's no way to get the handler
    return nullptr;
  }

  //***************************************************************************
  bool BoundType::IsTypeOrBaseNative()
  {
    // Start at this class and walk up all base classes and check for the Native flag
    BoundType* baseIterator = this;
    while (baseIterator != nullptr)
    {
      if (baseIterator->Native)
        return true;

      baseIterator = baseIterator->BaseType;
    }
    return false;
  }

  //***************************************************************************
  String BoundType::DefaultTypeToString(const BoundType* type, const byte* data)
  {
    return String::Format("%s (%p)", type->Name.c_str(), data);
  }

  //***************************************************************************
  BoundType::BoundType(const String& name, TypeCopyMode::Enum copyMode, size_t size, size_t nativeVirtualCount) : 
    Name(name),
    CopyMode(copyMode),
    BaseType(nullptr),
    RawNativeVirtualCount(nativeVirtualCount),
    BoundNativeVirtualCount(0),
    HandleManager(ZilchManagerId(HeapManager)),
    PostDestructor(nullptr),
    ToStringFunction(DefaultTypeToString),
    GetEventHandlerFunction(nullptr),
    PreConstructor(nullptr),
    Destructor(nullptr),
    SpecialType(SpecialType::Standard),
    CreatableInScript(true),
    Native(true),
    Size(size)
  {
  }

  //***************************************************************************
  BoundType::~BoundType()
  {
  }

  //***************************************************************************
  GuidType BoundType::Hash() const
  {
    return this->Name.hash();
  }
  
  //***************************************************************************
  bool BoundType::IsCopyComplex() const
  {
    // We've only got a compex copy if we're a reference type
    return (this->CopyMode == TypeCopyMode::ReferenceType);
  }

  //***************************************************************************
  size_t BoundType::GetCopyableSize() const
  {
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      return sizeof(Handle);
    }
    else
    {
      return this->GetAllocatedSize();
    }
  }

  //***************************************************************************
  size_t BoundType::GetAllocatedSize() const
  {
    // Return the size of the class since it's already been computed
    ErrorIf(this->Size == UndeterminedSize && this->SourceLibrary->TolerantMode == false,
      "Attempting to get the size of a class when it has not been determined!");
    return this->Size;
  }
  
  //***************************************************************************
  String BoundType::ToString() const
  {
    return this->Name;
  }
  
  //***************************************************************************
  String BoundType::GetShortLowerCamelCaseName() const
  {
    return LibraryBuilder::FixIdentifier(this->Name, TokenCheck::IsLower);
  }

  //***************************************************************************
  void BoundType::GenericDefaultConstruct(byte* toConstruct) const
  {
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Create a null handle if it's a reference type...
      new (toConstruct) Handle();
    }
    else
    {
      // Otherwise, clear the memory out to zeros (a valid configuration for all structs)
      memset(toConstruct, 0, this->GetCopyableSize());
    }
  }

  //***************************************************************************
  void BoundType::GenericCopyConstruct(byte* to, const byte* from) const
  {
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Copy the handle to it's destination position
      new (to) Handle(*(Handle*)from);
    }
    else
    {
      // Copy the value type directly
      memcpy(to, from, this->GetCopyableSize());
    }
  }

  //***************************************************************************
  void BoundType::GenericDestruct(byte* value) const
  {
    // We only need to do anything if this is a reference type
    // Value types do not need to be released
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Copy the handle to it's destination position
      ((Handle*)value)->~Handle();
    }
  }
  
  //***************************************************************************
  int BoundType::GenericHash(const byte* value) const
  {
    // If this is a reference type, it means it's a handle
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Hash the handle and return that value
      return ((Handle*)value)->Hash();
    }
    else
    {
      // Otherwise generate a hash from the value-type memory
      return (int)HashString((const char*)value, this->Size);
    }
  }

  //***************************************************************************
  String BoundType::GenericToString(const byte* value) const
  { 
    // By default, we know at least a base class type of what we're referencing
    // For value types, this is always the case
    const BoundType* type = this;

    // For value types, we assume that the type is just the data we get (not for reference types!)
    byte* data = (byte*)value;

    // If this is a reference type (it may be virtual)
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Grab the handle primitive
      Handle* handle = (Handle*)value;

      // The handle may store a more derived type inside it, if so, we should use that to print instead (virtual)
      if (handle->Type != nullptr)
        type = handle->Type;
    
      // Get a pointer to the data of the object
      data = handle->Dereference();

      // If converting a null handle to a string... let the user know it's null, and what type it is
      if (data == nullptr)
        return BuildString("(null) ", type->ToString());
    }

    // Run the user provided to-string function
    return type->ToStringFunction(type, data);
  }

  //***************************************************************************
  bool BoundType::GenericEquals(const byte* lhs, const byte* rhs) const
  {
    // If this is a reference type, it means it's a handle
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Compare the two handles
      Handle& lHandle = *((Handle*)lhs);
      Handle& rHandle = *((Handle*)rhs);
      return lHandle == rHandle;
    }
    else
    {
      // Otherwise, do a comparison of the value-type memory
      return (memcmp(lhs, rhs, this->Size) == 0);
    }
  }

  //***************************************************************************
  byte* BoundType::GenericGetMemory(const byte* value) const
  {
    // If this is a reference type, it means it's a handle
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Hash the handle and return that value
      return ((Handle*)value)->Dereference();
    }
    else
    {
      // Otherwise this is a value type, so we just directly return the memory
      return const_cast<byte*>(value);
    }
  }
  
  //***************************************************************************
  Type* BoundType::GenericGetVirtualType(const byte* value) const
  {
    // If this is a reference type, it means it's a handle
    if (this->CopyMode == TypeCopyMode::ReferenceType)
    {
      // Grab the handle (this behavior matches indirect type!)
      Handle* handle = ((Handle*)value);
    
      // If it has no type, then return our own type
      if (handle->Type == nullptr)
        return (Type*)(this);

      // Otherwise return the type stored on the handle
      return handle->Type;
    }
    else
    {
      // Otherwise this is a value type, so we the type is always the same
      return (Type*)this;
    }
  }

  //***************************************************************************
  Function* BoundType::GetDefaultConstructor(const FunctionArray* constructors)
  {
    // Grab a reference to the core
    Core& core = Core::GetInstance();

    // Loop through all of our constructors
    for (size_t i = 0; i < constructors->size(); ++i)
    {
      // Grab the current constructor
      Function* constructor = (*constructors)[i];

      // Make sure none of the constructors have return values
      ErrorIf(constructor->FunctionType->Return != core.VoidType,
        "A constructor was bound with a non-void return type");

      // As long as we have no parameters... this is the default constructor!
      if (constructor->FunctionType->Parameters.empty())
      {
        return constructor;
      }
    }

    // If we got here, we failed to find a default constructor
    return nullptr;
  }

  //***************************************************************************
  Function* BoundType::FindFunction(StringParam name, DelegateType* type, FindMemberOptions::Flags options) const
  {
    // The map of functions we'll look in (either static or instance)
    const FunctionMultiMap* functions = nullptr;

    // If we're looking for static functions...
    if (options & FindMemberOptions::Static)
      functions = &this->StaticFunctions;
    else
      functions = &this->InstanceFunctions;

    // Attempt to find the array
    const FunctionArray* foundFunctions = functions->findPointer(name);

    // Check if we found any functions by that name at this level
    if (foundFunctions != nullptr)
    {
      // Get a range so we can walk through all these functions
      FunctionArray::range foundRange = foundFunctions->all();

      // Loop through all the functions by the same name
      while (foundRange.empty() == false)
      {
        // Grab the current function and iterate to the next
        Function* function = foundRange.front();
        foundRange.popFront();
        
        // If the signature matches...
        if (Type::IsSame(function->FunctionType, type))
        {
          // Return the function we found
          return function;
        }
      }
    }
    // If we found nothing...
    else
    {
      // If we're not searching base classes, just return out
      if (options & FindMemberOptions::DoNotIncludeBaseClasses || this->BaseType == nullptr)
        return nullptr;
      else
        // Walk up the base class looking for that same function
        return this->BaseType->FindFunction(name, type, options);
    }

    return nullptr;
  }
  
  //***************************************************************************
  Property* BoundType::FindPropertyOrField(StringParam name, FindMemberOptions::Flags options) const
  {
    // The map of properties and fields we'll look in (either static or instance)
    const PropertyMap* properties = nullptr;
    const FieldMap* fields = nullptr;

    // If we're looking for static members...
    if (options & FindMemberOptions::Static)
    {
      properties = &this->StaticProperties;
      fields = &this->StaticFields;
    }
    else
    {
      properties = &this->InstanceProperties;
      fields = &this->InstanceFields;
    }

    // Attempt to find the property or field
    Property* foundProperty = properties->findValue(name, nullptr);
    if (foundProperty == nullptr)
      foundProperty = fields->findValue(name, nullptr);

    // Check if we found any properties by that name at this level then immediately return it
    if (foundProperty != nullptr)
    {
      return foundProperty;
    }
    // If we found nothing...
    else
    {
      // If we're not searching base classes, just return out
      if (options & FindMemberOptions::DoNotIncludeBaseClasses || this->BaseType == nullptr)
        return nullptr;
      // Otherwise, walk up the base classes
      else
        return this->BaseType->FindPropertyOrField(name, options);
    }
  }

  //***************************************************************************
  Function* BoundType::FindFunction(StringParam name, const Array<Type*>& parameters, Type* returnType, FindMemberOptions::Flags options) const
  {
    // The map of functions we'll look in (either static or instance)
    const FunctionMultiMap* functions = nullptr;

    // If we're looking for static functions...
    if (options & FindMemberOptions::Static)
      functions = &this->StaticFunctions;
    else
      functions = &this->InstanceFunctions;

    // Attempt to find the array
    const FunctionArray* foundFunctions = functions->findPointer(name);

    // Check if we found any functions by that name at this level
    if (foundFunctions != nullptr)
    {
      // Get a range so we can walk through all these functions
      FunctionArray::range foundRange = foundFunctions->all();

      // Loop through all the functions by the same name
      while (foundRange.empty() == false)
      {
        // Grab the current function and iterate to the next
        Function* function = foundRange.front();
        foundRange.popFront();

        // Skip this function if the return type doesn't match
        if (Type::IsSame(returnType, function->FunctionType->Return) == false)
          continue;

        // Get the type parameters of this function
        ParameterArray& params = function->FunctionType->Parameters;

        // If the function we're looking at has a different number of parameters, skip it
        if (parameters.size() != params.size())
          continue;

        // Check to see that all the parameter's types match
        bool sameParameters = true;
        for (size_t i = 0; i < params.size(); ++i)
        {
          // If any of them don't match, break out early and set that not all were the same
          DelegateParameter& current = params[i];
          if (Type::IsSame(current.ParameterType, parameters[i]) == false)
          {
            sameParameters = false;
            break;
          }
        }

        // If the signature matches...
        if (sameParameters)
        {
          // Return the function we found
          return function;
        }
      }
    }
    // If we found nothing...
    else
    {
      // If we're not searching base classes, just return out
      if (options & FindMemberOptions::DoNotIncludeBaseClasses || this->BaseType == nullptr)
        return nullptr;
      else
        return this->BaseType->FindFunction(name, parameters, returnType, options);
    }

    return nullptr;
  }

  //***************************************************************************
  const FunctionArray* BoundType::GetOverloadedInstanceFunctions(StringParam name) const
  {
    // Attempt to find the array
    const FunctionArray* found = this->InstanceFunctions.findPointer(name);

    // If we found nothing...
    if (found == nullptr && this->BaseType != nullptr)
    {
      // Search our parent
      return this->BaseType->GetOverloadedInstanceFunctions(name);
    }

    // Return whatever we found
    return found;
  }

  //***************************************************************************
  const FunctionArray* BoundType::GetOverloadedStaticFunctions(StringParam name) const
  {
    // Attempt to find the array
    const FunctionArray* found = this->StaticFunctions.findPointer(name);

    // If we found nothing...
    if (found == nullptr && this->BaseType != nullptr)
    {
      // Search our parent
      return this->BaseType->GetOverloadedStaticFunctions(name);
    }

    // Return whatever we found
    return found;
  }

  //***************************************************************************
  Field* BoundType::GetInstanceField(StringParam name) const
  {
    // Attempt to find the value
    Field* found = this->InstanceFields.findValue(name, nullptr);

    // If we found nothing...
    if (found == nullptr && this->BaseType != nullptr)
    {
      // Search our parent
      return this->BaseType->GetInstanceField(name);
    }

    // Return whatever we found
    return found;
  }

  //***************************************************************************
  Field* BoundType::GetStaticField(StringParam name) const
  {
    // Attempt to find the value
    Field* found = this->StaticFields.findValue(name, nullptr);

    // If we found nothing...
    if (found == nullptr && this->BaseType != nullptr)
    {
      // Search our parent
      return this->BaseType->GetStaticField(name);
    }

    // Return whatever we found
    return found;
  }

  //***************************************************************************
  Property* BoundType::GetInstanceProperty(StringParam name) const
  {
    // Attempt to find the value
    Property* found = this->InstanceProperties.findValue(name, nullptr);

    // If we found nothing...
    if (found == nullptr && this->BaseType != nullptr)
    {
      // Search our parent
      return this->BaseType->GetInstanceProperty(name);
    }

    // Return whatever we found
    return found;
  }

  //***************************************************************************
  Property* BoundType::GetStaticProperty(StringParam name) const
  {
    // Attempt to find the value
    Property* found = this->StaticProperties.findValue(name, nullptr);

    // If we found nothing...
    if (found == nullptr && this->BaseType != nullptr)
    {
      // Search our parent
      return this->BaseType->GetStaticProperty(name);
    }

    // Return whatever we found
    return found;
  }

  //***************************************************************************
  const FunctionArray* BoundType::GetOverloadedInheritedConstructors() const
  {
    // Walk up the base class chain until we find any constructors (we inherit constructors)
    // We start with the current class we're trying to create
    // Note: We can safely look up to our base classes because if we don't have a constructor
    // then we at least have been pre-constructed, and the user opted to not initialize anything with a constructor
    const BoundType* constructedType = this;

    ZilchLoop
    {
      // If we found any constructors, early out
      if (constructedType->Constructors.empty() == false)
        break;

      // If the type we're constructing is native, then we don't look for inherited constructors
      if (constructedType->Native)
        break;

      // We didn't find anything, so walk up to the base type and see if it has any (constructor inheritance)
      constructedType = constructedType->BaseType;

      // If we had no base, early out
      if (constructedType == nullptr)
        return nullptr;
    }

    // Return the constructors we found, or nothing (or an empty array!)
    return &constructedType->Constructors;
  }

  //***************************************************************************
  // Writes a line out that is tabbed in by two spaces
  // and every newline in the text will also be tabbed in
  void WriteLineTabbed(StringBuilderExtended& builder, StringParam text)
  {
    // Start off with two spaces of tabs
    builder.Write("  ");

    // Loop through every character in the text
    for (size_t i = 0; i < text.size(); ++i)
    {
      // Get the current character
      char c = text[i];
      
      // Write the character out
      builder.Write(c);

      // If the character was a newline, we need to insert a tab
      if (c == '\n')
      {
        // Write another two space tab, note that this is AFTER the newline
        builder.Write("  ");
      }
    }

    // Finally, write an ending newline
    builder.WriteLine();
  };

  //***************************************************************************
  AddMemberResult::Enum BoundType::AddRawFunction(Function* function)
  {
    // Assume we properly added the functino
    AddMemberResult::Enum result = AddMemberResult::Added;

    // Grab either the static or instance map of functions
    bool isStatic = (function->This == nullptr);
    FunctionMultiMap& map = this->GetFunctionMap(isStatic);

    // Grab the array of functions
    FunctionArray& functions = map[function->Name];

    // If we already have an overload of the exact same signature...
    for (size_t i = 0; i < functions.size(); ++i)
    {
      // If the type of each function exactly matches
      if (Type::IsSame(functions[i]->FunctionType, function->FunctionType))
      {
        result = AddMemberResult::AlreadyExists;
        break;
      }
    }

    // Add the function to the type's list of functions
    functions.push_back(function);

    // Add the function to the lsit of all functions
    this->AllFunctions.push_back(function);
    return result;
  }

  //***************************************************************************
  AddMemberResult::Enum BoundType::AddRawConstructor(Function* function)
  {
    // Assume we properly added the functino
    AddMemberResult::Enum result = AddMemberResult::Added;

    // Grab the array of functions
    FunctionArray& constructors = this->Constructors;

    // If we already have an overload of the exact same signature...
    for (size_t i = 0; i < constructors.size(); ++i)
    {
      // If the type of each function exactly matches
      if (Type::IsSame(constructors[i]->FunctionType, function->FunctionType))
      {
        result = AddMemberResult::AlreadyExists;
        break;
      }
    }

    // Add the function to the type's list of functions
    constructors.push_back(function);
    return result;
  }

  //***************************************************************************
  AddMemberResult::Enum BoundType::AddRawProperty(Property* property)
  {
    // Grab either the instance or static map of properties
    PropertyMap& map = this->GetPropertyMap(property->IsStatic);

    // Map the name of the property to the property itself
    bool inserted = map.insertNoOverwrite(property->Name, property);
    ErrorIf(inserted == false, "Another property with the same name (%s) was added to the BoundType", property->Name.c_str());

    // Add the property to the list of all properties
    this->AllProperties.push_back(property);

    // Return whether we inserted it or not
    if (inserted)
      return AddMemberResult::Added;
    else
      return AddMemberResult::AlreadyExists;
  }

  //***************************************************************************
  AddMemberResult::Enum BoundType::AddRawField(Field* field)
  {
    // Grab either the instance or static map of fields
    FieldMap& map = this->GetFieldMap(field->IsStatic);

    // Map the name of the field to the field itself
    bool inserted = map.insertNoOverwrite(field->Name, field);
    ErrorIf(inserted == false, "Another member with the same name (%s) was added to the BoundType", field->Name.c_str());

    // Add the member to the list of all properties
    this->AllProperties.push_back(field);

    // Return whether we inserted it or not
    if (inserted)
      return AddMemberResult::Added;
    else
      return AddMemberResult::AlreadyExists;
  }
  
  //***************************************************************************
  FieldMap& BoundType::GetFieldMap(bool isStatic)
  {
    if (isStatic)
      return this->StaticFields;
    else
      return this->InstanceFields;
  }

  //***************************************************************************
  PropertyMap& BoundType::GetPropertyMap(bool isStatic)
  {
    if (isStatic)
      return this->StaticProperties;
    else
      return this->InstanceProperties;
  }

  //***************************************************************************
  FunctionMultiMap& BoundType::GetFunctionMap(bool isStatic)
  {
    if (isStatic)
      return this->StaticFunctions;
    else
      return this->InstanceFunctions;
  }

  //***************************************************************************
  DelegateParameter::DelegateParameter() :
    ParameterType(nullptr),
    StackOffset(0),
    IsNameGenerated(false)
  {
  }

  //***************************************************************************
  DelegateParameter::DelegateParameter(Type* type) :
    ParameterType(type),
    StackOffset(0),
    IsNameGenerated(false)
  {
  }

  //***************************************************************************
  DelegateType::DelegateType() :
    Return(nullptr),
    ReturnStackOffset(0),
    ThisHandleStackOffset(0),
    TotalStackSizeExcludingThisHandle(0)
  {
  }

  //***************************************************************************
  GuidType DelegateType::Hash() const
  {
    // Store the hash result
    GuidType result = 0;

    // Loop through all the parameters
    for (size_t i = 0; i < this->Parameters.size(); ++i)
    {
      // Get a reference to the current parameter
      const DelegateParameter& parameter = this->Parameters[i];
      
      // Add the parameter type to the hash (we can just use the pointer value since it should be unique)
      result ^= parameter.ParameterType->Hash() * 983ULL * (i + 331ULL);

      // Add the parameter name hash
      result ^= parameter.Name.hash() * 6793ULL * (i + 13ULL);

      // We want to use i in some way so that the hash becomes order dependent
      result ^= 12764787846358441471ULL * i + 5463458053ULL + i;
    }

    // Add the return type to the hash (we can just use the pointer value since it should be unique)
    // Note that void is a type, and therefore has its own hash value (no special case)
    result ^= this->Return->Hash();

    // Use a random prime to make returns more unique
    result ^= 2305843009213693951ULL;

    // Return the computed hash
    return result;
  }

  //***************************************************************************
  void DelegateType::BuildParameterString(StringBuilder& builder, bool includeGeneratedNames) const
  {
    // Output the opening argument parentheses
    builder.Append("(");

    // Get the last parameter in the list
    size_t lastParameter = this->Parameters.size() - 1;

    // Loop through all the parameters
    for (size_t i = 0; i < this->Parameters.size(); ++i)
    {
      // Grab the current parameter
      const DelegateParameter& parameter = this->Parameters[i];

      // If the parameter actually has a name
      if (parameter.Name.empty() == false)
      {
        // Only include generated names if requested (or if it has a valid non-generated name)
        if (includeGeneratedNames || parameter.IsNameGenerated == false)
        {
          // Output the name of the parameter
          builder.Append(parameter.Name.c_str());
          builder.Append(" : ");
        }
      }
      
      // Always output the type of the parameter
      builder.Append(parameter.ParameterType->ToString());

      // If this is not the last parameter...
      if (i < lastParameter)
      {
        // Output an argument separator
        builder.Append(", ");
      }
    }

    // Output the ending argument parentheses
    builder.Append(")");
  }

  //***************************************************************************
  void DelegateType::BuildSignatureString(StringBuilder& builder, bool includeGeneratedNames) const
  {
    // Build the parameter portion first
    this->BuildParameterString(builder, includeGeneratedNames);

    // Get a reference to the core library
    Core& core = Core::GetInstance();

    // If we have a return type
    if (this->Return != core.VoidType)
    {
      // Output the return type...
      builder.Append(" : ");
      builder.Append(this->Return->ToString());
    }
  }

  //***************************************************************************
  String DelegateType::GetSignatureString() const
  {
    // Create a string builder to build the signature
    StringBuilder builder;

    // Build the signature string
    this->BuildSignatureString(builder);

    // Return the resulting string
    return builder.ToString();
  }

  //***************************************************************************
  String DelegateType::ToString() const
  {
    // Create a string builder for concatenation
    StringBuilder builder;

    // Output the delegate keyword
    builder.Append(Grammar::GetKeywordOrSymbol(Grammar::Delegate));
    builder.Append(" ");
    
    // Build the parameter list string and return
    this->BuildSignatureString(builder);

    // Finally, output the full concatenated type string
    return builder.ToString();
  }
  
  //***************************************************************************
  String DelegateType::GetShortLowerCamelCaseName() const
  {
    return Grammar::GetKeywordOrSymbol(Grammar::Delegate);
  }

  //***************************************************************************
  bool DelegateType::IsCopyComplex() const
  {
    // Delegates always have a complex copy
    return true;
  }

  //***************************************************************************
  size_t DelegateType::GetAllocatedSize() const
  {
    // Functions take up the size of a function index
    return sizeof(Delegate);
  }

  //***************************************************************************
  void DelegateType::GenericDefaultConstruct(byte* toConstruct) const
  {
    // Construct a null / empty delegate
    new (toConstruct) Delegate();
  }

  //***************************************************************************
  void DelegateType::GenericCopyConstruct(byte* to, const byte* from) const
  {
    // Copy construct the delegate to the given location
    new (to) Delegate(*(Delegate*)from);
  }

  //***************************************************************************
  void DelegateType::GenericDestruct(byte* value) const
  {
    // Destroy the delegate type
    ((Delegate*)value)->~Delegate();
  }

  //***************************************************************************
  int DelegateType::GenericHash(const byte* value) const
  {
    return ((Delegate*)value)->Hash();
  }

  //***************************************************************************
  String DelegateType::GenericToString(const byte* value) const
  {
    // Get the delegate value and write it's function out as a string
    Delegate& delegate = *(Delegate*)value;
    if (delegate.BoundFunction == nullptr)
      return BuildString("(null) ", this->ToString());
    else
      return delegate.BoundFunction->ToString();
  }

  //***************************************************************************
  bool DelegateType::GenericEquals(const byte* lhs, const byte* rhs) const
  {
    // Compare the two delegates
    Delegate& lDelegate = *((Delegate*)lhs);
    Delegate& rDelegate = *((Delegate*)rhs);
    return lDelegate == rDelegate;
  }

  //***************************************************************************
  Type* DelegateType::GenericGetVirtualType(const byte* value) const
  {
    Delegate* delegate = (Delegate*)value;
    Function* function = delegate->BoundFunction;
    if (function == nullptr)
      return (Type*)this;

    return function->FunctionType;
  }
}/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes











namespace Zilch
{
  //***************************************************************************
  // This is just a special identifier that means we jumped, there's really no reason to the number... ;)
  static const int ExceptionJumpResult = 1729;

  //***************************************************************************
  template <>
  void VirtualMachine::GenericPow<Byte>(Byte& out, const Byte& base, const Byte& exponent)
  {
    out = (Byte)IntegralPower(base, exponent);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericPow<Integer>(Integer& out, const Integer& base, const Integer& exponent)
  {
    out = IntegralPower(base, exponent);
  }

  //***************************************************************************
  template <>
  inline void VirtualMachine::GenericPow<Integer2>(Integer2& out, const Integer2& base, const Integer2& exponent)
  {
    out.x = IntegralPower(base.x, exponent.x);
    out.y = IntegralPower(base.y, exponent.y);
  }

  //***************************************************************************
  template <>
  inline void VirtualMachine::GenericPow<Integer3>(Integer3& out, const Integer3& base, const Integer3& exponent)
  {
    out.x = IntegralPower(base.x, exponent.x);
    out.y = IntegralPower(base.y, exponent.y);
    out.z = IntegralPower(base.z, exponent.z);
  }

  //***************************************************************************
  template <>
  inline void VirtualMachine::GenericPow<Integer4>(Integer4& out, const Integer4& base, const Integer4& exponent)
  {
    out.x = IntegralPower(base.x, exponent.x);
    out.y = IntegralPower(base.y, exponent.y);
    out.z = IntegralPower(base.z, exponent.z);
    out.w = IntegralPower(base.w, exponent.w);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericPow<DoubleInteger>(DoubleInteger& out, const DoubleInteger& base, const DoubleInteger& exponent)
  {
    out = IntegralPower(base, exponent);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericPow<Real2>(Real2& out, const Real2& base, const Real2& exponent)
  {
    out.x = pow(base.x, exponent.x);
    out.y = pow(base.y, exponent.y);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericPow<Real3>(Real3& out, const Real3& base, const Real3& exponent)
  {
    out.x = pow(base.x, exponent.x);
    out.y = pow(base.y, exponent.y);
    out.z = pow(base.z, exponent.z);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericPow<Real4>(Real4& out, const Real4& base, const Real4& exponent)
  {
    out.x = pow(base.x, exponent.x);
    out.y = pow(base.y, exponent.y);
    out.z = pow(base.z, exponent.z);
    out.w = pow(base.w, exponent.w);
  }
  
  //***************************************************************************
  template <>
  void VirtualMachine::GenericMod<Real>(Real& out, const Real& value, const Real& mod)
  {
    out = fmod(value, mod);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericMod<DoubleReal>(DoubleReal& out, const DoubleReal& value, const DoubleReal& mod)
  {
    out = fmod(value, mod);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericMod<Real2>(Real2& out, const Real2& value, const Real2& mod)
  {
    out.x = fmod(value.x, mod.x);
    out.y = fmod(value.y, mod.y);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericMod<Real3>(Real3& out, const Real3& value, const Real3& mod)
  {
    out.x = fmod(value.x, mod.x);
    out.y = fmod(value.y, mod.y);
    out.z = fmod(value.z, mod.z);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericMod<Real4>(Real4& out, const Real4& value, const Real4& mod)
  {
    out.x = fmod(value.x, mod.x);
    out.y = fmod(value.y, mod.y);
    out.z = fmod(value.z, mod.z);
    out.w = fmod(value.w, mod.w);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarPow<Integer2, Integer>(Integer2& out, const Integer2& base, const Integer& exponent)
  {
    out.x = IntegralPower(base.x, exponent);
    out.y = IntegralPower(base.y, exponent);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarPow<Integer3, Integer>(Integer3& out, const Integer3& base, const Integer& exponent)
  {
    out.x = IntegralPower(base.x, exponent);
    out.y = IntegralPower(base.y, exponent);
    out.z = IntegralPower(base.z, exponent);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarPow<Integer4, Integer>(Integer4& out, const Integer4& base, const Integer& exponent)
  {
    out.x = IntegralPower(base.x, exponent);
    out.y = IntegralPower(base.y, exponent);
    out.z = IntegralPower(base.z, exponent);
    out.w = IntegralPower(base.w, exponent);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarPow<Real2, Real>(Real2& out, const Real2& base, const Real& exponent)
  {
    out.x = pow(base.x, exponent);
    out.y = pow(base.y, exponent);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarPow<Real3, Real>(Real3& out, const Real3& base, const Real& exponent)
  {
    out.x = pow(base.x, exponent);
    out.y = pow(base.y, exponent);
    out.z = pow(base.z, exponent);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarPow<Real4, Real>(Real4& out, const Real4& base, const Real& exponent)
  {
    out.x = pow(base.x, exponent);
    out.y = pow(base.y, exponent);
    out.z = pow(base.z, exponent);
    out.w = pow(base.w, exponent);
  }
  

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarMod<Real2, Real>(Real2& out, const Real2& value, const Real& mod)
  {
    out.x = fmod(value.x, mod);
    out.y = fmod(value.y, mod);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarMod<Real3, Real>(Real3& out, const Real3& value, const Real& mod)
  {
    out.x = fmod(value.x, mod);
    out.y = fmod(value.y, mod);
    out.z = fmod(value.z, mod);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericScalarMod<Real4, Real>(Real4& out, const Real4& value, const Real& mod)
  {
    out.x = fmod(value.x, mod);
    out.y = fmod(value.y, mod);
    out.z = fmod(value.z, mod);
    out.w = fmod(value.w, mod);
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericIncrement<Real2>(Real2& out)
  {
    ++out.x;
    ++out.y;
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericIncrement<Real3>(Real3& out)
  {
    ++out.x;
    ++out.y;
    ++out.z;
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericIncrement<Real4>(Real4& out)
  {
    ++out.x;
    ++out.y;
    ++out.z;
    ++out.w;
  }
  
  //***************************************************************************
  template <>
  void VirtualMachine::GenericDecrement<Real2>(Real2& out)
  {
    --out.x;
    --out.y;
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericDecrement<Real3>(Real3& out)
  {
    --out.x;
    --out.y;
    --out.z;
  }

  //***************************************************************************
  template <>
  void VirtualMachine::GenericDecrement<Real4>(Real4& out)
  {
    --out.x;
    --out.y;
    --out.z;
    --out.w;
  }

  //***************************************************************************
  template <>
  bool VirtualMachine::GenericIsZero<Integer2>(const Integer2& value)
  {
    return
      value.x == 0 ||
      value.y == 0;
  }

  //***************************************************************************
  template <>
  bool VirtualMachine::GenericIsZero<Integer3>(const Integer3& value)
  {
    return
      value.x == 0 ||
      value.y == 0 ||
      value.z == 0;
  }

  //***************************************************************************
  template <>
  bool VirtualMachine::GenericIsZero<Integer4>(const Integer4& value)
  {
    return
      value.x == 0 ||
      value.y == 0 ||
      value.z == 0 ||
      value.w == 0;
  }
  
  //***************************************************************************
  template <>
  bool VirtualMachine::GenericIsZero<Real2>(const Real2& value)
  {
    return
      value.x == 0.0f ||
      value.y == 0.0f;
  }

  //***************************************************************************
  template <>
  bool VirtualMachine::GenericIsZero<Real3>(const Real3& value)
  {
    return
      value.x == 0.0f ||
      value.y == 0.0f ||
      value.z == 0.0f;
  }

  //***************************************************************************
  template <>
  bool VirtualMachine::GenericIsZero<Real4>(const Real4& value)
  {
    return
      value.x == 0.0f ||
      value.y == 0.0f ||
      value.z == 0.0f ||
      value.w == 0.0f;
  }

  //***************************************************************************
  // Get a reference to a member variable (field), given the place in the registers that the handle exists, and the member index...
  template <typename T>
  ZilchForceInline T& GetField(PerFrameData* stackFrame, PerFrameData* reportFrame, OperandIndex handleOperand, size_t memberOperand)
  {
    // Grab the handle to the object
    Handle& handle = *(Handle*)(stackFrame->Frame + handleOperand);

    // Get a pointer to the data
    byte* data = handle.Dereference();

    // If our data is null
    if (data == nullptr)
    {
      // Throw an exception (we'll need to unwind our stack)
      stackFrame->State->ThrowNullReferenceException(*reportFrame->Report);

      // Unwind our stack
      longjmp(reportFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Return the data (with the member offset)
    return *(T*)(data + memberOperand);
  }

  //***************************************************************************
  // Get a particular constant from a function
  template <typename T>
  ZilchForceInline T& GetConstant(Function* function, OperandIndex constantOperand)
  {
    // Make sure the value we're grabbing is inside the constant buffer (error checking)
    ErrorIf(constantOperand < 0 || constantOperand + sizeof(T) > function->Constants.GetSize(),
      "The constant's position was outside the memory of the function's constants");

    // Grab the constant from the constants array
    return *(T*)(function->Constants.GetElement(constantOperand));
  }

  //***************************************************************************
  // Get a particular local from a function
  template <typename T>
  ZilchForceInline T& GetLocal(byte* frame, OperandIndex localOperand)
  {
    return *(T*)(frame + localOperand);
  }

  //***************************************************************************
  // Get a particular static from an operand
  template <typename T>
  ZilchForceInline T& GetStatic(PerFrameData* stackFrame, PerFrameData* reportFrame, const Operand& operand)
  {
    // Look for the static memory in a map of the fields on our state
    // Static fields are done per executable state, so they get wiped each time we quit
    ExecutableState* state = stackFrame->State;
    return *(T*)(state->GetStaticField(operand.StaticField, *reportFrame->Report) + operand.FieldOffset);
  }

  //***************************************************************************
  // Get an operand (we don't know what type it is)
  template <typename T>
  ZilchForceInline T& GetOperand(PerFrameData* stackFrame, PerFrameData* reportFrame, const Operand& operand)
  {
    // Based on what kind of operand it is...
    switch (operand.Type)
    {
      case OperandType::Field:
        return GetField<T>(stackFrame, reportFrame, operand.HandleConstantLocal, operand.FieldOffset);

      case OperandType::Constant:
        return GetConstant<T>(stackFrame->CurrentFunction, operand.HandleConstantLocal);

      case OperandType::Local:
        return GetLocal<T>(stackFrame->Frame, operand.HandleConstantLocal);

      case OperandType::StaticField:
        return GetStatic<T>(stackFrame, reportFrame, operand);
    }
    
    // This means that something REALLY bad happened...
    // Throw an exception (we'll need to unwind our stack)
    const char* message = "We reached a garbage operand, or the operand was NotSet (something wrong in CodeGeneration?)";
    Error(message);
    stackFrame->State->ThrowException(*reportFrame->Report, message);

    // Unwind our stack
    longjmp(reportFrame->ExceptionJump, ExceptionJumpResult);
  }

  //***************************************************************************
  // Reusable code for the if opcodes
  template <Boolean IfTrue>
  ZilchForceInline void IfHandler(PerFrameData* stackFrame, const Opcode& opcode)
  {
    // Validate the timeout (this will throw an exception if we go beyond the time we need to)
    // This only really needs to be ran in jumps
    if (stackFrame->State->ThrowExceptionOnTimeout(*stackFrame->Report))
    {
      // Unwind our stack
      longjmp(stackFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Grab the rest of the data
    const IfOpcode& op = (const IfOpcode&) opcode;

    // Read the boolean value
    Boolean result = GetOperand<Boolean>(stackFrame, stackFrame, op.Condition);

    // If the register evaluates to true...
    if (result == IfTrue)
    {
      // Move the instruction counter by the given offset
      stackFrame->ProgramCounter += op.JumpOffset;
    }
    // Otherwise, we need to skip it
    else
    {
      // Move the instruction counter past this opcode
      stackFrame->ProgramCounter += sizeof(op);
    }
  }

  //***************************************************************************
  ZilchForceInline void CopyHandlerEx(PerFrameData* ourFrame, PerFrameData* topFrame, const byte*& sourceOut, byte*& destinationOut, const CopyOpcode& op)
  {
    // When we copy to parameters, it's always a destination
    // (we are placing parameters in the place they must go before we call)
    // When we copy a return, it is always the source, as we are getting the result
    // from a called function and storing it in the caller's stack
    // Note: Returns may be removed in the future as we can just directly refer to them

    // Offsets that may change depending on the copy mode
    size_t returnOffset = 0;
    PerFrameData* parameterFrame = ourFrame;

    // Based off the copy mode we're in...
    switch (op.Mode)
    {
      case CopyMode::ToParameter:
        parameterFrame = topFrame;
        break;

      case CopyMode::FromReturn:
        returnOffset = topFrame->NextFrame - ourFrame->Frame;
        break;
    }

    // Get pointers to both the source and destination memory
    sourceOut = &GetOperand<byte>(ourFrame, ourFrame, op.Source) + returnOffset;
    destinationOut = &GetOperand<byte>(parameterFrame, ourFrame, op.Destination);
    
    // Increment the program counter to point past the opcode
    ourFrame->ProgramCounter += sizeof(CopyOpcode);
  }

  //***************************************************************************
  // Note: This function return a pointer to the newly initialized handle
  // (where we copied to) unless we're performing a 'FromReturn' copy, where
  // it will return a pointer to the source handle (for cleanup purposes!)
  template <typename CopyType>
  ZilchForceInline void CopyHandler
  (
    PerFrameData* ourFrame,
    PerFrameData* topFrame,
    CopyType*& sourceTyped,
    CopyType*& destinationTyped,
    const CopyOpcode& op
  )
  {
    const byte* source;
    byte* destination;

    CopyHandlerEx(ourFrame, topFrame, source, destination, op);

    // Now copy from the source to the destination and return a pointer to the new copy
    sourceTyped = (CopyType*)source;

    // If this is an assignment...
    if (op.Mode == CopyMode::Assignment)
    {
      // We know the destination is the same type as us
      destinationTyped = (CopyType*)destination;

      // Perform the direct assignment
      *destinationTyped = *sourceTyped;
    }
    else
    {
      // Otherwise, we need to construct a new one over the memory
      destinationTyped = new (destination) CopyType(*sourceTyped);
    }
  }

  //***************************************************************************
  void VirtualMachine::EnumerationProperty(Call& call, ExceptionReport& report)
  {
    // Get the integral value for this enum value
    Integer integralValue = (Integer)(DoubleInteger)call.GetFunction()->UserData;

    // Return the integral value
    call.Set<Integer>(Call::Return, integralValue);
  }

  //***************************************************************************
  void VirtualMachine::EventsProperty(Call& call, ExceptionReport& report)
  {
    // Get the calling function (the property getter)
    Function* function = call.GetFunction();

    // Read its user data to get the string back that we want to return
    String& eventName = function->ComplexUserData.ReadObject<String>(0);

    // Simply just return the string (there are no parameters or anything else)
    call.Set<String>(Call::Return, eventName);
  }
  
  //***************************************************************************
  void VirtualMachine::NativeConstructor(Call& call, ExceptionReport& report)
  {
    Function* constructor = call.GetFunction();
    Handle& thisHandle = call.Get<Handle&>(Call::This);
    thisHandle.Manager->SetNativeTypeFullyConstructed(thisHandle, true);
    // Invoke the actual constructor
    constructor->NativeConstructor(call, report);
  }
  
  //***************************************************************************
  void VirtualMachine::PatchDummy(Call& call, ExceptionReport& report)
  {
    // Default construct the return value
    byte* returnValue = call.GetReturnUnchecked();
    call.GetFunction()->FunctionType->Return->GenericDefaultConstruct(returnValue);
  }

  //***************************************************************************
  typedef void (*VirtualInstructionFn)(ExecutableState* state, Call& call, ExceptionReport& report, size_t& programCounter, PerFrameData* ourFrame, const Opcode& opcode);
  VirtualInstructionFn InstructionTable[Instruction::Count] = {0};
  #define ZilchVirtualInstruction(Name) void VirtualMachine::Instruction##Name (ExecutableState* state, Call& call, ExceptionReport& report, size_t& programCounter, PerFrameData* ourFrame, const Opcode& opcode)
  
  //*****************************************************************************
  #define ZilchCaseBinaryRValue2(argType1, argType2, resultType, operation, expression)                   \
    ZilchVirtualInstruction(operation##argType1)                                                          \
    {                                                                                                     \
      const BinaryRValueOpcode& op = (const BinaryRValueOpcode&) opcode;                                  \
      const argType1& left = GetOperand<argType1>(ourFrame, ourFrame, op.Left);                           \
      const argType2& right = GetOperand<argType2>(ourFrame, ourFrame, op.Right);                         \
      resultType& output = GetLocal<resultType>(ourFrame->Frame, op.Output);                              \
      expression;                                                                                         \
      programCounter += sizeof(BinaryRValueOpcode);                                                       \
    }

  //*****************************************************************************
  #define ZilchCaseBinaryLValue2(argType1, argType2, operation, expression)                               \
    ZilchVirtualInstruction(operation##argType1)                                                          \
    {                                                                                                     \
      const BinaryLValueOpcode& op = (const BinaryLValueOpcode&) opcode;                                  \
      argType1& output = GetOperand<argType1>(ourFrame, ourFrame, op.Output);                             \
      const argType2& right = GetOperand<argType2>(ourFrame, ourFrame, op.Right);                         \
      expression;                                                                                         \
      programCounter += sizeof(BinaryLValueOpcode);                                                       \
    }

  //*****************************************************************************
  #define ZilchCaseBinaryRValue(argType, resultType, operation, expression)                               \
    ZilchCaseBinaryRValue2(argType, argType, resultType, operation, expression)

  //*****************************************************************************
  #define ZilchCaseBinaryLValue(argType, operation, expression)                                           \
    ZilchCaseBinaryLValue2(argType, argType, operation, expression)

  //*****************************************************************************
  #define ZilchCaseUnaryRValue(argType, resultType, operation, expression)                                \
    ZilchVirtualInstruction(operation##argType)                                                           \
    {                                                                                                     \
      const UnaryRValueOpcode& op = (const UnaryRValueOpcode&) opcode;                                    \
      const argType& operand = GetOperand<argType>(ourFrame, ourFrame, op.SingleOperand);                 \
      resultType& output = GetLocal<resultType>(ourFrame->Frame, op.Output);                              \
      expression;                                                                                         \
      programCounter += sizeof(UnaryRValueOpcode);                                                        \
    }

  //*****************************************************************************
  #define ZilchCaseUnaryLValue(argType, operation, expression)                                            \
    ZilchVirtualInstruction(operation##argType)                                                           \
    {                                                                                                     \
      const UnaryLValueOpcode& op = (const UnaryLValueOpcode&) opcode;                                    \
      argType& operand = GetOperand<argType>(ourFrame, ourFrame, op.SingleOperand);                       \
      expression;                                                                                         \
      programCounter += sizeof(UnaryLValueOpcode);                                                        \
    }

  //*****************************************************************************
  #define ZilchCaseConversion(fromType, toType, expression)                                               \
    ZilchVirtualInstruction(Convert##fromType##To##toType)                                                \
    {                                                                                                     \
      const ConversionOpcode& op = (const ConversionOpcode&) opcode;                                      \
      const fromType& value = GetOperand<fromType>(ourFrame, ourFrame, op.ToConvert);                     \
      toType& output = GetLocal<toType>(ourFrame->Frame, op.Output);                                      \
      expression;                                                                                         \
      programCounter += sizeof(ConversionOpcode);                                                         \
    }

  //*****************************************************************************
  #define ZilchCaseSimpleCopy(T)                                                                          \
    ZilchVirtualInstruction(Copy##T)                                                                      \
    {                                                                                                     \
      PerFrameData* topFrame = state->StackFrames.back();                                                 \
      T* source;                                                                                          \
      T* destination;                                                                                     \
      CopyHandler<T>                                                                                      \
      (                                                                                                   \
        ourFrame,                                                                                         \
        topFrame,                                                                                         \
        source,                                                                                           \
        destination,                                                                                      \
        (const CopyOpcode&) opcode                                                                        \
      );                                                                                                  \
    }

  //*****************************************************************************
  #define ZilchCaseComplexCopy(T)                                                                         \
    ZilchVirtualInstruction(Copy##T)                                                                      \
    {                                                                                                     \
      /* Grab the rest of the data */                                                                     \
      const CopyOpcode& op = (const CopyOpcode&) opcode;                                                  \
                                                                                                          \
      /* Get the current frame on the top of the stack */                                                 \
      PerFrameData* topFrame = state->StackFrames.back();                                                 \
                                                                                                          \
      T* source;                                                                                          \
      T* destination;                                                                                     \
      CopyHandler<T>(ourFrame, topFrame, source, destination, op);                                        \
                                                                                                          \
      /* We need to make sure we cleanup any primitives */                                                \
      /* If this is just a standard copy from our stack to our stack... */                                \
      switch (op.Mode)                                                                                    \
      {                                                                                                   \
        case CopyMode::Initialize:                                                                        \
        {                                                                                                 \
          /* For any standard copy, if it's to the stack then */                                          \
          /* we just let our own stack frame clean it up */                                               \
          /* Note: Copies to properties are considered on the stack */                                    \
          /* We don't queue cleans for field initializers because the destructors will clean those up */  \
          OperandType::Enum destType = op.Destination.Type;                                               \
          if (destType != OperandType::Field && destType != OperandType::StaticField)                     \
          {                                                                                               \
            /* Queue the destination to be cleaned up */                                                  \
            ourFrame->Queue##T##Cleanup(destination);                                                     \
          }                                                                                               \
          break;                                                                                          \
        }                                                                                                 \
                                                                                                          \
        case CopyMode::ToParameter:                                                                       \
        {                                                                                                 \
          /* For parameter copies, our stack frame will still clean it up */                              \
          /* but the cleanup must occur right after the function is called */                             \
          /* eg PopFrame (which will pop the top!) */                                                     \
          topFrame->Queue##T##Cleanup(destination);                                                       \
          break;                                                                                          \
        }                                                                                                 \
                                                                                                          \
        case CopyMode::FromReturn:                                                                        \
        {                                                                                                 \
          /* Note: The primitive used here is actually the source primitive! */                           \
          /* See the comment above 'CopyHandler' */                                                       \
          /* For returns, we need to clean up the primitive immediately after */                          \
          /* copy since that space could be reused by anyone else */                                      \
          source->~T();                                                                                   \
                                                                                                          \
          /* We also need to queue our own frame to clean */                                              \
          /* up where we copied it to */                                                                  \
          ourFrame->Queue##T##Cleanup(destination);                                                       \
          break;                                                                                          \
        }                                                                                                 \
      }                                                                                                   \
    }

  // Note: These macros mirror those inside of InstructionEnum and Shared (for generation of instructions)

  // Copy
  #define ZilchCopyCases(WithType)                                                                                                                \
    ZilchCaseSimpleCopy(WithType)

  // Equality and inequality
  #define ZilchEqualityCases(WithType, ResultType)                                                                                                \
    ZilchCaseBinaryRValue(WithType, ResultType, TestInequality,  output = left != right);                                                         \
    ZilchCaseBinaryRValue(WithType, ResultType, TestEquality,    output = left == right);

  // Less and greater comparison
  #define ZilchComparisonCases(WithType, ResultType)                                                                                              \
    ZilchCaseBinaryRValue(WithType, ResultType, TestLessThan,              output = left < right);                                                \
    ZilchCaseBinaryRValue(WithType, ResultType, TestLessThanOrEqualTo,     output = left <= right);                                               \
    ZilchCaseBinaryRValue(WithType, ResultType, TestGreaterThan,           output = left > right);                                                \
    ZilchCaseBinaryRValue(WithType, ResultType, TestGreaterThanOrEqualTo,  output = left >= right);

  // Generic numeric operators, copy, equality
  #define ZilchNumericCases(WithType, ComparisonType)                                                                                             \
    ZilchCopyCases(WithType)                                                                                                                      \
    ZilchEqualityCases(WithType, ComparisonType)                                                                                                  \
    /* No case for unary plus */                                                                                                                  \
    ZilchCaseUnaryRValue (WithType, WithType, Negate,             output = -operand);                                                             \
    ZilchCaseUnaryLValue (WithType,           Increment,          GenericIncrement(operand));                                                     \
    ZilchCaseUnaryLValue (WithType,           Decrement,          GenericDecrement(operand));                                                     \
    ZilchCaseBinaryRValue(WithType, WithType, Add,                output = left + right);                                                         \
    ZilchCaseBinaryRValue(WithType, WithType, Subtract,           output = left - right);                                                         \
    ZilchCaseBinaryRValue(WithType, WithType, Multiply,           output = left * right);                                                         \
    ZilchCaseBinaryRValue(WithType, WithType, Divide,             if (GenericIsZero(right))                                                       \
                                                                  {                                                                               \
                                                                    state->ThrowException(report, "Attempted to divide by zero");                 \
                                                                    longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);                        \
                                                                  }                                                                               \
                                                                  output = left / right);                                                         \
    ZilchCaseBinaryRValue(WithType, WithType, Modulo,             if (GenericIsZero(right))                                                       \
                                                                  {                                                                               \
                                                                    state->ThrowException(report, "Attempted to modulo by zero");                 \
                                                                    longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);                        \
                                                                  }                                                                               \
                                                                  GenericMod(output, left, right));                                               \
    ZilchCaseBinaryRValue(WithType, WithType, Pow,                GenericPow(output, left, right));                                               \
    ZilchCaseBinaryLValue(WithType,           AssignmentAdd,      output += right);                                                               \
    ZilchCaseBinaryLValue(WithType,           AssignmentSubtract, output -= right);                                                               \
    ZilchCaseBinaryLValue(WithType,           AssignmentMultiply, output *= right);                                                               \
    ZilchCaseBinaryLValue(WithType,           AssignmentDivide,   if (GenericIsZero(right))                                                       \
                                                                  {                                                                               \
                                                                    state->ThrowException(report, "Attempted to divide by zero");                 \
                                                                    longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);                        \
                                                                  }                                                                               \
                                                                  output /= right);                                                               \
    ZilchCaseBinaryLValue(WithType,           AssignmentModulo,   if (GenericIsZero(right))                                                       \
                                                                  {                                                                               \
                                                                    state->ThrowException(report, "Attempted to modulo by zero");                 \
                                                                    longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);                        \
                                                                  }                                                                               \
                                                                  GenericMod(output, output, right));                                             \
    ZilchCaseBinaryLValue(WithType,           AssignmentPow,      GenericPow(output, output, right));

  // Generic numeric operators, copy, equality, comparison
  #define ZilchScalarCases(WithType)                                                                                                              \
    ZilchNumericCases(WithType, Boolean)                                                                                                          \
    ZilchComparisonCases(WithType, Boolean)

  // Vector operations, generic numeric operators, copy, equality
  #define ZilchVectorCases(VectorType, ScalarType, ComparisonType)                                                                                \
    ZilchNumericCases(VectorType, Boolean)                                                                                                        \
    ZilchComparisonCases(VectorType, ComparisonType)                                                                                              \
    ZilchCaseBinaryRValue2(VectorType, ScalarType, VectorType,  ScalarMultiply,           output = left * right);                                 \
    ZilchCaseBinaryRValue2(VectorType, ScalarType, VectorType,  ScalarDivide,             output = left / right);                                 \
    ZilchCaseBinaryRValue2(VectorType, ScalarType, VectorType,  ScalarModulo,             GenericScalarMod(output, left, right));                 \
    ZilchCaseBinaryRValue2(VectorType, ScalarType, VectorType,  ScalarPow,                GenericScalarPow(output, left, right));                 \
    ZilchCaseBinaryLValue2(VectorType, ScalarType,              AssignmentScalarMultiply, output *= right);                                       \
    ZilchCaseBinaryLValue2(VectorType, ScalarType,              AssignmentScalarDivide,   output /= right);                                       \
    ZilchCaseBinaryLValue2(VectorType, ScalarType,              AssignmentScalarModulo,   GenericScalarMod(output, output, right));               \
    ZilchCaseBinaryLValue2(VectorType, ScalarType,              AssignmentScalarPow,      GenericScalarPow(output, output, right));

  // Special integral operators, generic numeric operators, copy, equality, and comparison
  #define ZilchIntegralCases(WithType)                                                                                                            \
    ZilchCaseUnaryRValue (WithType, WithType, BitwiseNot,               output = ~operand);                                                       \
    ZilchCaseBinaryRValue(WithType, WithType, BitshiftLeft,             output = left << right);                                                  \
    ZilchCaseBinaryRValue(WithType, WithType, BitshiftRight,            output = left >> right);                                                  \
    ZilchCaseBinaryRValue(WithType, WithType, BitwiseOr,                output = left | right);                                                   \
    ZilchCaseBinaryRValue(WithType, WithType, BitwiseXor,               output = left ^ right);                                                   \
    ZilchCaseBinaryRValue(WithType, WithType, BitwiseAnd,               output = left & right);                                                   \
    ZilchCaseBinaryLValue(WithType,           AssignmentBitshiftLeft,   output <<= right);                                                        \
    ZilchCaseBinaryLValue(WithType,           AssignmentBitshiftRight,  output >>= right);                                                        \
    ZilchCaseBinaryLValue(WithType,           AssignmentBitwiseOr,      output |= right);                                                         \
    ZilchCaseBinaryLValue(WithType,           AssignmentBitwiseXor,     output ^= right);                                                         \
    ZilchCaseBinaryLValue(WithType,           AssignmentBitwiseAnd,     output &= right);

  //***************************************************************************
  ZilchVirtualInstruction(InternalDebugBreakpoint)
  {
    // Trigger the breakpoint
    ZilchDebugBreak();

    // Move the instruction counter past this opcode
    programCounter += sizeof(Opcode);
  }
  
  //***************************************************************************
  ZilchVirtualInstruction(BeginTimeout)
  {
    // Grab the rest of the data
    const TimeoutOpcode& op = (const TimeoutOpcode&) opcode;

    // Let the executable state know we've started a timeout
    // This can technically throw if a timeout above it expired
    if (state->PushTimeout(ourFrame, op.LengthSeconds))
    {
      // Jump out so we don't run any more code
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Move the instruction counter past this opcode
    programCounter += sizeof(TimeoutOpcode);
  }


  //***************************************************************************
  ZilchVirtualInstruction(EndTimeout)
  {
    // Validate the timeout (this will throw an exception if we go beyond the time we need to)
    // This only really needs to be ran in jumps
    if (state->PopTimeout(ourFrame))
    {
      // Jump out so we don't run any more code
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Move the instruction counter past this opcode
    programCounter += sizeof(Opcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(BeginScope)
  {
    // Store a pointer to the newly created (or recycled) scope
    PerScopeData* newScope = state->AllocateScope();

    // Add a new scope so that we can destruct our scope properly
    ourFrame->Scopes.push_back(newScope);

    // Move the instruction counter past this opcode
    programCounter += sizeof(Opcode);
    return;
  }
  
  //***************************************************************************
  ZilchVirtualInstruction(EndScope)
  {
    // Get the latest scope
    PerScopeData* scope = ourFrame->Scopes.back();

    // Cleanup any handles and delegates (this also clears for recycling)
    scope->PerformCleanup();

    // Pop this scope since we're exiting it
    ourFrame->Scopes.pop_back();

    // Instead of deleting this scope, we're going to recycle it for speed
    state->RecycledScopes.push_back(scope);

    // Move the instruction counter past this opcode
    programCounter += sizeof(Opcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(ToHandle)
  {
    // Grab the rest of the data
    const ToHandleOpcode& op = (const ToHandleOpcode&) opcode;

    // If the object we're converting into a handle is a local...
    if (op.ToHandle.Type == OperandType::Local)
    {
      // Get the handle that we're going to write to on the stack
      Handle& handle = *new (ourFrame->Frame + op.SaveLocal) Handle();

      // We need to make sure we cleanup this handle
      ourFrame->QueueHandleCleanup(&handle);

      // Initialize the stack handle to point at the given location
      state->InitializeStackHandle(handle, ourFrame->Frame + op.ToHandle.HandleConstantLocal, ourFrame->Scopes.back(), op.Type);
    }
    else if (op.ToHandle.Type == OperandType::StaticField)
    {
      // Get the handle that we're going to write to on the stack
      Handle& handle = *new (ourFrame->Frame + op.SaveLocal) Handle();

      // We need to make sure we cleanup this handle
      ourFrame->QueueHandleCleanup(&handle);

      // Initialize the stack handle to point at the given location
      byte* fieldPointer = &GetOperand<byte>(ourFrame, ourFrame, op.ToHandle);
      state->InitializePointerHandle(handle, fieldPointer, op.Type);
    }
    else
    {
      // We assume this means we're taking a handle to a field, which should have been copied to the stack
      ErrorIf(op.ToHandle.Type != OperandType::Field,
        "We can only take handles to locals and fields (not constants, for example)");

      // Get the handle that holds the base of the member we're going to make a handle to
      const Handle& baseHandle = *(Handle*)(ourFrame->Frame + op.ToHandle.HandleConstantLocal);

      // Make a copy from the base handle into our handle
      // This should properly handle incrementing a reference, if needed
      Handle& handle = *new (ourFrame->Frame + op.SaveLocal) Handle(baseHandle);

      // We need to make sure we cleanup this handle
      ourFrame->QueueHandleCleanup(&handle);

      // Add the offset to the handle
      handle.Offset += op.ToHandle.FieldOffset;

      // The type we're now referring to is whatever the field is at that offset
      handle.Type = op.Type;
    }

    // Move the instruction counter past this opcode
    programCounter += sizeof(op);

    //TODO the rest of the handle initialization
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(CreateStaticDelegate)
  {
    // Grab the rest of the data
    const CreateStaticDelegateOpcode& op = (const CreateStaticDelegateOpcode&) opcode;

    // Get the delegate that we're going to write to on the stack
    Delegate& delegate = *new (ourFrame->Frame + op.SaveLocal) Delegate();

    // Set the delegate's function index to the opcode's index
    delegate.BoundFunction = op.BoundFunction;

    // Even though the 'this' handle is null, we still need to clean it up
    // just to be proper, but also because someone could theoretically assign to it
    // if we expose it in the future
    ourFrame->QueueDelegateCleanup(&delegate);

    // Move the instruction counter past this opcode
    programCounter += sizeof(op);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(CreateInstanceDelegate)
  {
    // Grab the rest of the data
    const CreateInstanceDelegateOpcode& op = (const CreateInstanceDelegateOpcode&) opcode;

    // Get the delegate that we're going to write to on the stack
    Delegate& delegate = *new (ourFrame->Frame + op.SaveLocal) Delegate();

    // Set the delegate's function index to the opcode's index
    delegate.BoundFunction = op.BoundFunction;

    // Set the handle that will basically act as the 'this' pointer for the delegate
    Handle& thisHandle = GetOperand<Handle>(ourFrame, ourFrame, op.ThisHandle);
    delegate.ThisHandle = thisHandle;

    // If the function we're binding is virtual and we're not calling this function 'non-virtually'
    if (op.BoundFunction->IsVirtual && op.CanBeVirtual && thisHandle.Type != nullptr)
    {
      // Find the function on our derived type that matches the signature / name
      Function* function = thisHandle.Type->FindFunction(op.BoundFunction->Name, op.BoundFunction->FunctionType, FindMemberOptions::None);
      if (function != nullptr)
        delegate.BoundFunction = function;
      else
        Error("Unable to find the most derived virtual function, we can continue but this should not happen");
    }

    // We need to make sure we cleanup this handle
    ourFrame->QueueDelegateCleanup(&delegate);

    // Move the instruction counter past this opcode
    programCounter += sizeof(op);
    return;
  }
  
  //***************************************************************************
  ZilchVirtualInstruction(IfFalseRelativeGoTo)
  {
    IfHandler<false>(ourFrame, opcode);
    return;
  }
  
  //***************************************************************************
  ZilchVirtualInstruction(IfTrueRelativeGoTo)
  {
    IfHandler<true>(ourFrame, opcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(RelativeGoTo)
  {
    // Validate the timeout (this will throw an exception if we go beyond the time we need to)
    // This only really needs to be ran in jumps
    if (state->ThrowExceptionOnTimeout(report))
    {
      // Jump out so we don't run any more code
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Grab the rest of the data
    const RelativeJumpOpcode& op = (const RelativeJumpOpcode&) opcode;

    // Move the instruction counter by the given offset
    programCounter += op.JumpOffset;
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(Return)
  {
  }

  //***************************************************************************
  ZilchVirtualInstruction(PrepForFunctionCall)
  {
    // Validate the timeout (this will throw an exception if we go beyond the time we need to)
    // This only really needs to be ran in jumps
    if (state->ThrowExceptionOnTimeout(report))
    {
      // Jump out so we don't run any more code
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Grab the rest of the data
    const PrepForFunctionCallOpcode& op = (const PrepForFunctionCallOpcode&) opcode;

    // Retrieve the delegate that we have to invoke
    const Delegate& delegate = GetOperand<Delegate>(ourFrame, ourFrame, op.Delegate);

    // Lookup the function in the function array
    Function* functionToInvoke = delegate.BoundFunction;

    // If we attempted to invoke a null delegate then throw an exception
    if (functionToInvoke == nullptr)
    {
      // Throw an exception and bail out
      state->ThrowException(report, "Attempted to invoke a null delegate");
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Get the frame at the top of the stack (it could be ours)
    PerFrameData* topFrame = state->StackFrames.back();

    // Create a new stack frame for our function
    PerFrameData* newFrame = state->PushFrame(topFrame->NextFrame, functionToInvoke);

    // If the stack frame was created in an error state, then attempt to throw exceptions
    // If this returns true (meaning exceptions were thrown) then we'll jump out
    if (newFrame->AttemptThrowStackExceptions(report))
    {
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Check if the "to be invoked" function is a static function (should we skip the next copy opcode?)
    if (functionToInvoke->This == nullptr)
    {
      // Skip copying the 'this' handle (and move past this opcode)
      programCounter += op.JumpOffsetIfStatic;
    }
    else
    {
      // Increment the program counter to point past the opcode
      programCounter += sizeof(PrepForFunctionCallOpcode);
    }
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(FunctionCall)
  {
    // Grab the per frame data from the executable state
    PerFrameData* topFrame = state->StackFrames.back();
    
    // Create a call (this is not a user call, so it should not push a stack frame)
    // Moreover, none of the debug features should be enabled
    Call subCall(topFrame);

    // Invoke the call (calls the bound function with all the parameters)
    subCall.Invoke(report);

    // Check to see if we threw any exceptions in the above invokation
    if (report.HasThrownExceptions())
    {
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Increment the program counter to point past the opcode
    programCounter += sizeof(Opcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(LocalObject)
  {
    // Grab the rest of the data
    const CreateLocalTypeOpcode& op = (const CreateLocalTypeOpcode&) opcode;

    // Get the type that we're creating
    BoundType* createdType = op.CreatedType;

    // Allocate the object
    Handle handle = state->AllocateStackObject(ourFrame->Frame + op.StackLocal, ourFrame->Scopes.back(), createdType, report);

    // If allocating the stack object threw an exception...
    if (report.HasThrownExceptions())
    {
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Copy the handle to the stack
    Handle* handleOnStack = new (ourFrame->Frame + op.SaveHandleLocal) Handle(handle);

    // We need to make sure we cleanup this handle
    ourFrame->QueueHandleCleanup(handleOnStack);

    // Increment the program counter to point past the opcode
    programCounter += sizeof(CreateLocalTypeOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(NewObject)
  {
    // Grab the rest of the data
    const CreateTypeOpcode& op = (const CreateTypeOpcode&) opcode;

    // Get the type that we're creating
    BoundType* createdType = op.CreatedType;

    // Allocate the object
    Handle handle = state->AllocateHeapObject(createdType, report, HeapFlags::ReferenceCounted);

    // If allocating the stack object threw an exception...
    if (report.HasThrownExceptions())
    {
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Copy the handle to the stack
    Handle* handleOnStack = new (ourFrame->Frame + op.SaveHandleLocal) Handle(handle);
    
    // We need to make sure we cleanup this handle
    ourFrame->QueueHandleCleanup(handleOnStack);

    // Increment the program counter to point past the opcode
    programCounter += sizeof(CreateTypeOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(PropertyDelegate)
  {
    // Grab the rest of the data
    const CreatePropertyDelegateOpcode& op = (const CreatePropertyDelegateOpcode&) opcode;

    // Get the type that we're creating
    BoundType* createdType = op.CreatedType;

    // Allocate the object
    Handle handle = state->AllocateDefaultConstructedHeapObject(createdType, report, HeapFlags::ReferenceCounted);

    // If allocating the stack object threw an exception...
    if (report.HasThrownExceptions())
    {
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Copy the handle to the stack
    Handle* handleOnStack = new (ourFrame->Frame + op.SaveHandleLocal) Handle(handle);
    
    // We need to make sure we cleanup this handle
    ourFrame->QueueHandleCleanup(handleOnStack);

    // As long as nothing failed, the object we allocated should be a 'PropertyDelegate' object
    PropertyDelegateTemplate* propertyDelegate = (PropertyDelegateTemplate*)handleOnStack->Dereference();

    // Read the this handle from the stack
    Handle& thisHandle = *(Handle*)(ourFrame->Frame + op.ThisHandleLocal);

    // Set the delegate's function index to the opcode's index
    propertyDelegate->Get.BoundFunction = op.Get;
    propertyDelegate->Set.BoundFunction = op.Set;
    propertyDelegate->Get.ThisHandle = thisHandle;
    propertyDelegate->Set.ThisHandle = thisHandle;

    // Increment the program counter to point past the opcode
    programCounter += sizeof(CreatePropertyDelegateOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(BeginStringBuilder)
  {
    // Create a new string builder
    state->StringBuilders.push_back();

    // Increment the program counter to point past the opcode
    programCounter += sizeof(BeginStringBuilderOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(EndStringBuilder)
  {
    // Grab the rest of the data
    const EndStringBuilderOpcode& op = (const EndStringBuilderOpcode&) opcode;

    // Get the string builder that we're using
    StringBuilder& builder = state->StringBuilders.back();

    // Convert the concatenations into a single reference counted string
    String result = builder.ToString();

    // We're done with the string builder!
    state->StringBuilders.pop_back();

    // Copy the handle to the stack
    Handle* handle = new (ourFrame->Frame + op.SaveStringHandleLocal) Handle();
    
    // We need to make sure we cleanup this handle
    ourFrame->QueueHandleCleanup(handle);

    // Set the handle manager and type of the handle
    // We know explicitly that the string handle manager is a shared manager
    HandleManagers& managers = HandleManagers::GetInstance();
    handle->Manager = managers.GetSharedManager(ZilchManagerId(StringManager));
    handle->Type = ZilchTypeId(String);

    // Copy a string into the handle
    // This method will actually increase the reference count
    // which means we would need to store an array of destructors for constant memory (which we do)
    handle->Manager->ObjectToHandle((byte*)&result, *handle);

    // Increment the program counter to point past the opcode
    programCounter += sizeof(EndStringBuilderOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(AddToStringBuilder)
  {
    // Grab the rest of the data
    const AddToStringBuilderOpcode& op = (const AddToStringBuilderOpcode&) opcode;

    // Get the string builder that we're using
    StringBuilder& builder = state->StringBuilders.back();

    // Generically get the operand that we want to turn into a string
    byte* data = &GetOperand<byte>(ourFrame, ourFrame, op.Value);

    // Convert the value to a string in the best way we know how to
    String stringifiedValue = op.TypeToConvert->GenericToString(data);

    // Append the stringified value to the string builder
    builder.Append(stringifiedValue);

    // Increment the program counter to point past the opcode
    programCounter += sizeof(AddToStringBuilderOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(DeleteObject)
  {
    // Grab the rest of the data
    const DeleteObjectOpcode& op = (const DeleteObjectOpcode&) opcode;

    // Get a pointer to the handle we are deleting
    Handle& handle = GetOperand<Handle>(ourFrame, ourFrame, op.Object);
    
    // Delete the handle
    bool result = handle.Delete();

    // If we failed to delete the handle...
    if (result == false)
    {
      // The user handle type could not be deleted!
      state->ThrowException
      (
        report,
        String::Format("We attempted to delete a '%s' handle, but we aren't allowed to", handle.Manager->GetName().c_str())
      );

      // Jump back since we just threw an exception
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Increment the program counter to point past the opcode
    programCounter += sizeof(DeleteObjectOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(ThrowException)
  {
    // Grab the rest of the data
    const ThrowExceptionOpcode& op = (const ThrowExceptionOpcode&) opcode;

    // Get a pointer to the handle we are deleting
    Handle& handle = GetOperand<Handle>(ourFrame, ourFrame, op.Exception);

    // If the handle itself is null, we actually throw a null reference exception!
    if (handle.IsNull())
    {
      state->ThrowNullReferenceException(report);
    }
    else
    {
      state->ThrowException(report, handle);
    }

    // Jump back since we just threw an exception
    longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
  }

  //***************************************************************************
  ZilchVirtualInstruction(TypeId)
  {
    const TypeIdOpcode& op = (const TypeIdOpcode&) opcode;

    // This function will access the primitive and attempt to get the most derived type from it
    // For the 'any' type, this will get the type stored inside
    // Note: We MUST be sure that the Syntaxer set the actual expresion result type to the correct type
    // eg: any -> Type (because it could be anything!), bound types -> BoundType, delegates -> DelegateType
    byte* expressionResult = &GetOperand<byte>(ourFrame, ourFrame, op.Expression);
    const Type* virtualType = op.CompileTimeType->GenericGetVirtualType(expressionResult);

    // This may not be necessary, but just in case we don't get a valid type returned, assume its the compile time type
    if (virtualType == nullptr)
      virtualType = op.CompileTimeType;

    // Create a handle in constant space for the type pointer
    byte* handlePointer = &GetLocal<byte>(ourFrame->Frame, op.SaveTypeHandleLocal);
    Handle& handle = *new (handlePointer) Handle();
    HandleManagers& managers = HandleManagers::GetInstance();
    handle.Manager = managers.GetSharedManager(ZilchManagerId(PointerManager));
    handle.Type = virtualType->ZilchGetDerivedType();

    // Store the pointer to the compile time type into the handle
    handle.Manager->ObjectToHandle((byte*)virtualType, handle);
    programCounter += sizeof(TypeIdOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(ConvertToAny)
  {
    // Grab the rest of the data
    const AnyConversionOpcode& op = (const AnyConversionOpcode&) opcode;
    const byte* value = &GetOperand<byte>(ourFrame, ourFrame, op.ToConvert);

    // Grab the bytes that will hold the 'Any' value
    byte* anyData = &GetLocal<byte>(ourFrame->Frame, op.Output);

    // Construct the any at the given position (this will do a proper copy of data into the any)
    Any* any = new (anyData) Any(value, op.RelatedType);
    
    // We need to make sure we cleanup this 'any'
    ourFrame->QueueAnyCleanup(any);
    programCounter += sizeof(AnyConversionOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(ConvertFromAny)
  {
    // Grab the rest of the data
    const AnyConversionOpcode& op = (const AnyConversionOpcode&) opcode;
    const Any& any = GetOperand<Any>(ourFrame, ourFrame, op.ToConvert);

    // If we can't directly convert the any into this type...
    Shared& shared = Shared::GetInstance();
    CastOperator cast = shared.GetCastOperator(any.StoredType, op.RelatedType);
    if (cast.IsValid == false || cast.RequiresCodeGeneration)
    {
      // Generate an error string that gives a lot of context clues
      String error = String::Format
      (
        "The 'any' value '%s' of type '%s' cannot be converted to a '%s'. The type must match exactly or be directly convertable",
        any.StoredType->GenericToString(any.Data).c_str(),
        any.StoredType->ToString().c_str(),
        op.RelatedType->ToString().c_str()
      );

      // Throw an exception to let the user know the conversion was invalid
      state->ThrowException(report, error);

      // Jump back since we just threw an exception
      longjmp(ourFrame->ExceptionJump, ExceptionJumpResult);
    }

    // Grab the bytes that will hold the value we copy from the Any
    byte* outputData = &GetLocal<byte>(ourFrame->Frame, op.Output);

    // Copy the value out of the any onto the stack
    any.StoredType->GenericCopyConstruct(outputData, any.Data);
    programCounter += sizeof(AnyConversionOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(ConvertDowncast)
  {
    // Grab the rest of the data
    const DowncastConversionOpcode& op = (const DowncastConversionOpcode&) opcode;
    const Handle& toConvert = GetOperand<Handle>(ourFrame, ourFrame, op.ToConvert);

    // Grab the output that we want to initialize either to a casted handle, or to null
    byte* outputHandle = &GetLocal<byte>(ourFrame->Frame, op.Output);

    // The value we were passed in was null, so just output null
    if (toConvert.IsNull())
    {
      // Initialize the temporary handle to null
      new (outputHandle) Handle();
    }
    // Check to see if this type inherits from the other type
    else if (TypeBinding::GenericIsA(toConvert.Type, op.ToType))
    {
      // Copy the handle over, it's now the down-casted type!
      new (outputHandle) Handle(toConvert);
    }
    else
    {
      // The downcast failed (not the same) so return null
      new (outputHandle) Handle();
    }

    programCounter += sizeof(DowncastConversionOpcode);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(AnyDynamicMemberGet)
  {
    Error("Not implemented");
  }

  //***************************************************************************
  ZilchVirtualInstruction(AnyDynamicMemberSet)
  {
    Error("Not implemented");
  }

  //***************************************************************************
  ZilchVirtualInstruction(InvalidInstruction)
  {
    Error("This case should never be hit");
  }

  //***************************************************************************
  ZilchVirtualInstruction(ConvertStringToStringRangeExtended)
  {
    const ConversionOpcode& op = (const ConversionOpcode&) opcode;

    const Handle& fromTypeHandle = GetOperand<Handle>(ourFrame, ourFrame, op.ToConvert);
    const String* value = (String*)fromTypeHandle.Dereference();

    // Get the toType's memory
    byte* toTypeMemory = &GetLocal<byte>(ourFrame->Frame, op.Output);
    
    // Deal with null strings
    if (value == nullptr)
    {
      new (toTypeMemory) Handle();
    }
    else
    {
      // Construct a new handle for the string range
      Handle rangeHandle = call.GetState()->AllocateDefaultConstructedHeapObject(ZilchTypeId(StringRangeExtended), report, HeapFlags::ReferenceCounted);
      StringRangeExtended& stringRange = *(StringRangeExtended*)rangeHandle.Dereference();

      stringRange.mRange = value->all();
      stringRange.mOriginalStringReference = *value;
      // Copy the handle over the output data
      Handle* stackHandle = new (toTypeMemory) Handle(rangeHandle);
      ourFrame->QueueHandleCleanup(stackHandle);
    }

    programCounter += sizeof(ConversionOpcode);
  }

  //***************************************************************************
  ZilchVirtualInstruction(CopyValue)
  {
    // Grab the rest of the data
    const CopyOpcode& op = (const CopyOpcode&) opcode;

    const byte* source;
    byte* destination;

    // Get the frame at the top of the stack (it could be ours)
    PerFrameData* topFrame = state->StackFrames.back();

    CopyHandlerEx(ourFrame, topFrame, source, destination, op);

    memcpy(destination, source, op.Size);
    return;
  }

  //***************************************************************************
  ZilchVirtualInstruction(TestEqualityValue)
  {
    const BinaryRValueOpcode& op = (const BinaryRValueOpcode&) opcode;
    const byte* left = &GetOperand<byte>(ourFrame, ourFrame, op.Left);
    const byte* right = &GetOperand<byte>(ourFrame, ourFrame, op.Right);
    Boolean& output = GetLocal<Boolean>(ourFrame->Frame, op.Output);
    output = (memcmp(left, right, op.Size) == 0);
    programCounter += sizeof(BinaryRValueOpcode);
  }

  //***************************************************************************
  ZilchVirtualInstruction(TestInequalityValue)
  {
    const BinaryRValueOpcode& op = (const BinaryRValueOpcode&) opcode;
    const byte* left = &GetOperand<byte>(ourFrame, ourFrame, op.Left);
    const byte* right = &GetOperand<byte>(ourFrame, ourFrame, op.Right);
    Boolean& output = GetLocal<Boolean>(ourFrame->Frame, op.Output);
    output = (memcmp(left, right, op.Size) != 0);
    programCounter += sizeof(BinaryRValueOpcode);
  }
    
  //***************************************************************************
  ZilchCaseComplexCopy(Handle);
  ZilchCaseComplexCopy(Delegate);
  ZilchCaseComplexCopy(Any);

  // Primitive type instructions
  ZilchIntegralCases(Byte)
  ZilchScalarCases(Byte)
  ZilchIntegralCases(Integer)
  ZilchScalarCases(Integer)
  ZilchVectorCases(Integer2, Integer, Boolean2)
  ZilchVectorCases(Integer3, Integer, Boolean3)
  ZilchVectorCases(Integer4, Integer, Boolean4)
  ZilchIntegralCases(Integer2)
  ZilchIntegralCases(Integer3)
  ZilchIntegralCases(Integer4)
  ZilchScalarCases(Real)
  ZilchVectorCases(Real2, Real, Boolean2)
  ZilchVectorCases(Real3, Real, Boolean3)
  ZilchVectorCases(Real4, Real, Boolean4)
  ZilchScalarCases(DoubleReal)
  ZilchIntegralCases(DoubleInteger)
  ZilchScalarCases(DoubleInteger)

  ZilchEqualityCases(Boolean, Boolean)
  ZilchEqualityCases(Handle, Boolean)
  ZilchEqualityCases(Delegate, Boolean)
  ZilchEqualityCases(Any, Boolean)

  ZilchCopyCases(Boolean)
  // Handle, Delegate, and Value copy (assignment) operators are handled specially above
        
  ZilchCaseUnaryRValue (Boolean, Boolean, LogicalNot, output = !operand);

  ZilchCaseConversion(Byte,           Real,           output = (Real)value);
  ZilchCaseConversion(Byte,           Boolean,        output = (value != 0));
  ZilchCaseConversion(Byte,           Integer,        output = (Integer)value);
  ZilchCaseConversion(Byte,           DoubleInteger,  output = (DoubleInteger)value);
  ZilchCaseConversion(Byte,           DoubleReal,     output = (DoubleReal)value);
  ZilchCaseConversion(Integer,        Real,           output = (Real)value);
  ZilchCaseConversion(Integer,        Boolean,        output = (value != 0));
  ZilchCaseConversion(Integer,        Byte,           output = (Byte)value);
  ZilchCaseConversion(Integer,        DoubleInteger,  output = (DoubleInteger)value);
  ZilchCaseConversion(Integer,        DoubleReal,     output = (DoubleReal)value);
  ZilchCaseConversion(Real,           Integer,        output = (Integer)value);
  ZilchCaseConversion(Real,           Boolean,        output = (value != 0));
  ZilchCaseConversion(Real,           Byte,           output = (Byte)value);
  ZilchCaseConversion(Real,           DoubleInteger,  output = (DoubleInteger)value);
  ZilchCaseConversion(Real,           DoubleReal,     output = (DoubleReal)value);
  ZilchCaseConversion(Boolean,        Integer,        output = (Integer)value);
  ZilchCaseConversion(Boolean,        Real,           output = (Real)value);
  ZilchCaseConversion(Boolean,        Byte,           output = (Byte)value);
  ZilchCaseConversion(Boolean,        DoubleInteger,  output = (DoubleInteger)value);
  ZilchCaseConversion(Boolean,        DoubleReal,     output = (DoubleReal)value);
  ZilchCaseConversion(DoubleInteger,  Real,           output = (Real)value);
  ZilchCaseConversion(DoubleInteger,  Boolean,        output = (value != 0));
  ZilchCaseConversion(DoubleInteger,  Byte,           output = (Byte)value);
  ZilchCaseConversion(DoubleInteger,  Integer,        output = (Integer)value);
  ZilchCaseConversion(DoubleInteger,  DoubleReal,     output = (DoubleReal)value);
  ZilchCaseConversion(DoubleReal,     Real,           output = (Real)value);
  ZilchCaseConversion(DoubleReal,     Boolean,        output = (value != 0));
  ZilchCaseConversion(DoubleReal,     Byte,           output = (Byte)value);
  ZilchCaseConversion(DoubleReal,     Integer,        output = (Integer)value);
  ZilchCaseConversion(DoubleReal,     DoubleInteger,  output = (DoubleInteger)value);

  ZilchCaseConversion(Integer2, Real2,     output = Real2((Real)value.x, (Real)value.y));
  ZilchCaseConversion(Integer2, Boolean2,  output = Boolean2(value.x != 0, value.y != 0));
  ZilchCaseConversion(Real2,    Integer2,  output = Integer2((Integer)value.x, (Integer)value.y));
  ZilchCaseConversion(Real2,    Boolean2,  output = Boolean2(value.x != 0.0f, value.y != 0.0f));
  ZilchCaseConversion(Boolean2, Integer2,  output = Integer2((Integer)value.x, (Integer)value.y));
  ZilchCaseConversion(Boolean2, Real2,     output = Real2((Real)value.x, (Real)value.y));
        
  ZilchCaseConversion(Integer3, Real3,     output = Real3((Real)value.x, (Real)value.y, (Real)value.z));
  ZilchCaseConversion(Integer3, Boolean3,  output = Boolean3(value.x != 0, value.y != 0, value.z != 0));
  ZilchCaseConversion(Real3,    Integer3,  output = Integer3((Integer)value.x, (Integer)value.y, (Integer)value.z));
  ZilchCaseConversion(Real3,    Boolean3,  output = Boolean3(value.x != 0.0f, value.y != 0.0f, value.z != 0.0f));
  ZilchCaseConversion(Boolean3, Integer3,  output = Integer3((Integer)value.x, (Integer)value.y, (Integer)value.z));
  ZilchCaseConversion(Boolean3, Real3,     output = Real3((Real)value.x, (Real)value.y, (Real)value.z));
        
  ZilchCaseConversion(Integer4, Real4,     output = Real4((Real)value.x, (Real)value.y, (Real)value.z, (Real)value.w));
  ZilchCaseConversion(Integer4, Boolean4,  output = Boolean4(value.x != 0, value.y != 0, value.z != 0, value.w != 0));
  ZilchCaseConversion(Real4,    Integer4,  output = Integer4((Integer)value.x, (Integer)value.y, (Integer)value.z, (Integer)value.w));
  ZilchCaseConversion(Real4,    Boolean4,  output = Boolean4(value.x != 0.0f, value.y != 0.0f, value.z != 0.0f, value.w != 0.0f));
  ZilchCaseConversion(Boolean4, Integer4,  output = Integer4((Integer)value.x, (Integer)value.y, (Integer)value.z, (Integer)value.w));
  ZilchCaseConversion(Boolean4, Real4,     output = Real4((Real)value.x, (Real)value.y, (Real)value.z, (Real)value.w));
  
  //***************************************************************************
  void VirtualMachine::InitializeJumpTable()
  {
    #define ZilchEnumValue(Name) InstructionTable[Instruction::Name] = &Instruction##Name;
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Note: These macros mirror those inside of Shared and VirtualMachine (for generation of instructions)

// Copy
#define ZilchCopyInstructions(Type)               \
  ZilchEnumValue(Copy##Type)

// Equality and inequality
#define ZilchEqualityInstructions(Type)           \
  ZilchEnumValue(TestInequality##Type)            \
  ZilchEnumValue(TestEquality##Type)

// Less and greater comparison
#define ZilchComparisonInstructions(Type)         \
  ZilchEnumValue(TestLessThan##Type)              \
  ZilchEnumValue(TestLessThanOrEqualTo##Type)     \
  ZilchEnumValue(TestGreaterThan##Type)           \
  ZilchEnumValue(TestGreaterThanOrEqualTo##Type)

// Generic numeric operators, copy, equality
#define ZilchNumericInstructions(Type)            \
  ZilchCopyInstructions(Type)                     \
  ZilchEqualityInstructions(Type)                 \
  /* No instruction for unary plus */             \
  ZilchEnumValue(Negate##Type)                    \
  ZilchEnumValue(Increment##Type)                 \
  ZilchEnumValue(Decrement##Type)                 \
  ZilchEnumValue(Add##Type)                       \
  ZilchEnumValue(Subtract##Type)                  \
  ZilchEnumValue(Multiply##Type)                  \
  ZilchEnumValue(Divide##Type)                    \
  ZilchEnumValue(Modulo##Type)                    \
  ZilchEnumValue(Pow##Type)                       \
  ZilchEnumValue(AssignmentAdd##Type)             \
  ZilchEnumValue(AssignmentSubtract##Type)        \
  ZilchEnumValue(AssignmentMultiply##Type)        \
  ZilchEnumValue(AssignmentDivide##Type)          \
  ZilchEnumValue(AssignmentModulo##Type)          \
  ZilchEnumValue(AssignmentPow##Type)

// Generic numeric operators, copy, equality, comparison
#define ZilchScalarInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)

// Vector operations, generic numeric operators, copy, equality
#define ZilchVectorInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)               \
  ZilchEnumValue(ScalarMultiply##Type)            \
  ZilchEnumValue(ScalarDivide##Type)              \
  ZilchEnumValue(ScalarModulo##Type)              \
  ZilchEnumValue(ScalarPow##Type)                 \
  ZilchEnumValue(AssignmentScalarMultiply##Type)  \
  ZilchEnumValue(AssignmentScalarDivide##Type)    \
  ZilchEnumValue(AssignmentScalarModulo##Type)    \
  ZilchEnumValue(AssignmentScalarPow##Type)

// Special integral operators, generic numeric operators, copy, equality, and comparison
#define ZilchIntegralInstructions(Type)           \
  ZilchEnumValue(BitwiseNot##Type)                \
  ZilchEnumValue(BitshiftLeft##Type)              \
  ZilchEnumValue(BitshiftRight##Type)             \
  ZilchEnumValue(BitwiseOr##Type)                 \
  ZilchEnumValue(BitwiseXor##Type)                \
  ZilchEnumValue(BitwiseAnd##Type)                \
  ZilchEnumValue(AssignmentBitshiftLeft##Type)    \
  ZilchEnumValue(AssignmentBitshiftRight##Type)   \
  ZilchEnumValue(AssignmentBitwiseOr##Type)       \
  ZilchEnumValue(AssignmentBitwiseXor##Type)      \
  ZilchEnumValue(AssignmentBitwiseAnd##Type)


// Core instructions
ZilchEnumValue(InvalidInstruction)

ZilchEnumValue(InternalDebugBreakpoint)
ZilchEnumValue(ThrowException)
ZilchEnumValue(PropertyDelegate)

ZilchEnumValue(TypeId)

ZilchEnumValue(BeginTimeout)
ZilchEnumValue(EndTimeout)

ZilchEnumValue(BeginScope)
ZilchEnumValue(EndScope)

ZilchEnumValue(ToHandle)

ZilchEnumValue(BeginStringBuilder)
ZilchEnumValue(EndStringBuilder)
ZilchEnumValue(AddToStringBuilder)

ZilchEnumValue(CreateInstanceDelegate)
ZilchEnumValue(CreateStaticDelegate)

ZilchEnumValue(IfFalseRelativeGoTo)
ZilchEnumValue(IfTrueRelativeGoTo)
ZilchEnumValue(RelativeGoTo)

ZilchEnumValue(Return)
ZilchEnumValue(PrepForFunctionCall)
ZilchEnumValue(FunctionCall)

ZilchEnumValue(NewObject)
ZilchEnumValue(LocalObject)
ZilchEnumValue(DeleteObject)

// Primitive type instructions
ZilchIntegralInstructions(Byte)
ZilchScalarInstructions(Byte)
ZilchIntegralInstructions(Integer)
ZilchScalarInstructions(Integer)
ZilchVectorInstructions(Integer2)
ZilchVectorInstructions(Integer3)
ZilchVectorInstructions(Integer4)
ZilchIntegralInstructions(Integer2)
ZilchIntegralInstructions(Integer3)
ZilchIntegralInstructions(Integer4)
ZilchScalarInstructions(Real)
ZilchVectorInstructions(Real2)
ZilchVectorInstructions(Real3)
ZilchVectorInstructions(Real4)
ZilchScalarInstructions(DoubleReal)
ZilchIntegralInstructions(DoubleInteger)
ZilchScalarInstructions(DoubleInteger)

ZilchEqualityInstructions(Boolean)
ZilchEqualityInstructions(Handle)
ZilchEqualityInstructions(Delegate)
ZilchEqualityInstructions(Any)
ZilchEqualityInstructions(Value)

ZilchCopyInstructions(Boolean)
ZilchCopyInstructions(Any)
ZilchCopyInstructions(Handle)
ZilchCopyInstructions(Delegate)
ZilchCopyInstructions(Value)

ZilchEnumValue(LogicalNotBoolean)

ZilchEnumValue(ConvertByteToReal)
ZilchEnumValue(ConvertByteToBoolean)
ZilchEnumValue(ConvertByteToInteger)
ZilchEnumValue(ConvertByteToDoubleInteger)
ZilchEnumValue(ConvertByteToDoubleReal)
ZilchEnumValue(ConvertIntegerToReal)
ZilchEnumValue(ConvertIntegerToBoolean)
ZilchEnumValue(ConvertIntegerToByte)
ZilchEnumValue(ConvertIntegerToDoubleInteger)
ZilchEnumValue(ConvertIntegerToDoubleReal)
ZilchEnumValue(ConvertRealToInteger)
ZilchEnumValue(ConvertRealToBoolean)
ZilchEnumValue(ConvertRealToByte)
ZilchEnumValue(ConvertRealToDoubleInteger)
ZilchEnumValue(ConvertRealToDoubleReal)
ZilchEnumValue(ConvertBooleanToInteger)
ZilchEnumValue(ConvertBooleanToReal)
ZilchEnumValue(ConvertBooleanToByte)
ZilchEnumValue(ConvertBooleanToDoubleInteger)
ZilchEnumValue(ConvertBooleanToDoubleReal)
ZilchEnumValue(ConvertDoubleIntegerToReal)
ZilchEnumValue(ConvertDoubleIntegerToBoolean)
ZilchEnumValue(ConvertDoubleIntegerToByte)
ZilchEnumValue(ConvertDoubleIntegerToInteger)
ZilchEnumValue(ConvertDoubleIntegerToDoubleReal)
ZilchEnumValue(ConvertDoubleRealToReal)
ZilchEnumValue(ConvertDoubleRealToBoolean)
ZilchEnumValue(ConvertDoubleRealToByte)
ZilchEnumValue(ConvertDoubleRealToInteger)
ZilchEnumValue(ConvertDoubleRealToDoubleInteger)

ZilchEnumValue(ConvertInteger2ToReal2)
ZilchEnumValue(ConvertInteger2ToBoolean2)
ZilchEnumValue(ConvertReal2ToInteger2)
ZilchEnumValue(ConvertReal2ToBoolean2)
ZilchEnumValue(ConvertBoolean2ToInteger2)
ZilchEnumValue(ConvertBoolean2ToReal2)

ZilchEnumValue(ConvertInteger3ToReal3)
ZilchEnumValue(ConvertInteger3ToBoolean3)
ZilchEnumValue(ConvertReal3ToInteger3)
ZilchEnumValue(ConvertReal3ToBoolean3)
ZilchEnumValue(ConvertBoolean3ToInteger3)
ZilchEnumValue(ConvertBoolean3ToReal3)

ZilchEnumValue(ConvertInteger4ToReal4)
ZilchEnumValue(ConvertInteger4ToBoolean4)
ZilchEnumValue(ConvertReal4ToInteger4)
ZilchEnumValue(ConvertReal4ToBoolean4)
ZilchEnumValue(ConvertBoolean4ToInteger4)
ZilchEnumValue(ConvertBoolean4ToReal4)

ZilchEnumValue(ConvertStringToStringRangeExtended)

ZilchEnumValue(ConvertDowncast)
ZilchEnumValue(ConvertToAny)
ZilchEnumValue(ConvertFromAny)
ZilchEnumValue(AnyDynamicMemberGet)
ZilchEnumValue(AnyDynamicMemberSet)

    #undef ZilchEnumValue
  }

  //***************************************************************************
  void VirtualMachine::ExecuteNext(Call& call, ExceptionReport& report)
  {
    // Since we do a raw copy, we always tell the caller to ignore debug checking of the return
    call.DisableReturnChecks();

    // Grab the executable state
    ExecutableState* state = call.GetState();

    // Block vectors are currently only POD
    // Grab the per frame data from the executable state
    PerFrameData* ourFrame = state->StackFrames.back();

    // The program counter increments with each instruction (instructions can also be variable width, and this number is measured in bytes)
    ourFrame->ProgramCounter = 0;
    size_t& programCounter = ourFrame->ProgramCounter;

    // Setup where we jump to if an exception occurs
    int jumpResult = setjmp(ourFrame->ExceptionJump);

    // If an exception occurred...
    if (jumpResult == ExceptionJumpResult)
      return;

    // Store the compacted opcode as an attempt to bring the opcode into crash reports / mini-dumps
    // Also save it into a non-thread safe global pointer (hopefully it will be pulled in)
    byte* compactedOpcode = ourFrame->CurrentFunction->CompactedOpcode.data();
    ZilchLastRunningOpcode = compactedOpcode;
    ZilchLastRunningFunction = ourFrame->CurrentFunction;
    ZilchLastRunningOpcodeLength = ourFrame->CurrentFunction->CompactedOpcode.size();

    // Loop through all the opcodes in the function
    // We don't need to check for the end since the return opcode will exit this function
    ZilchLoop
    {
      // Grab the current opcode that we're executing
      const Opcode& opcode = *(Opcode*)(compactedOpcode + programCounter);

      // If any pre opcode callbacks are set then send the event
      state->SendOpcodeEvent(Events::OpcodePreStep, ourFrame);
      InstructionTable[opcode.Instruction](state, call, report, programCounter, ourFrame, opcode);
      
      // If any post opcode callbacks are set then send the event
      state->SendOpcodeEvent(Events::OpcodePostStep, ourFrame);
      if (opcode.Instruction == Instruction::Return)
        return;
    }
  }

  //***************************************************************************
  void VirtualMachine::PostDestructor(BoundType* boundType, byte* objectData)
  {
    // Loop through all the handles we want to destroy
    for (size_t i = 0; i < boundType->Handles.size(); ++i)
    {
      // Get the index that the primitive is at
      size_t index = boundType->Handles[i];

      // Destroy the primitive (which may decrement a reference)
      Handle& toDestroy = *(Handle*)(objectData + index);
      toDestroy.~Handle();
    }

    // Loop through all the delegates we want to destroy
    for (size_t i = 0; i < boundType->Delegates.size(); ++i)
    {
      // Get the index that the primitive is at
      size_t index = boundType->Delegates[i];

      // Destroy the primitive (which may decrement a reference)
      Delegate& toDestroy = *(Delegate*)(objectData + index);
      toDestroy.~Delegate();
    }
  }


  //***************************************************************************
  String VirtualMachine::EnumerationToString(const BoundType* type, const byte* data)
  {
    // Get the value of the enum
    Integer inputValue = *(const Integer*)data;

    // Loop through all the properties this type defines...
    const PropertyArray& properties = type->AllProperties;
    for (size_t i = 0; i < properties.size(); ++i)
    {
      // Grab the current property
      Property* property = properties[i];

      // Error checking
      ErrorIf(property->Get == nullptr, "The enum should have no properties that do not have a 'get' function");
      ErrorIf(property->IsStatic == false, "All properties on the enum should be static");

      // If this propertie's UserData matches our enum's value...
      if (property->Get->UserData == (void*)inputValue)
      {
        return property->Name;
      }
    }

    // Otherwise, this enum is not a known value... (just return the integer for readability)
    return IntegerToString(inputValue);
  }

  //***************************************************************************
  String VirtualMachine::FlagsToString(const BoundType* type, const byte* data)
  {
    // Get the value of the enum
    Integer inputValue = *(const Integer*)data;

    // With every bit we loop through, we mask the bit off
    // At the end, this value should be 0 unless there were invalid bits that we didn't know what they were
    Integer runningValue = inputValue;

    // Create a string builder so we can concatenate all the flags together
    StringBuilder builder;

    // If we wrote anything to the string buffer, then the next time we need to add the '|'
    bool wroteSomething = false;

    // Loop through all the properties this type defines...
    const PropertyArray& properties = type->AllProperties;
    for (size_t i = 0; i < properties.size(); ++i)
    {
      // Grab the current property
      Property* property = properties[i];

      // Error checking
      ErrorIf(property->Get == nullptr, "The flags should have no properties that do not have a 'get' function");
      ErrorIf(property->IsStatic == false, "All properties on the flags should be static");

      // Grab the value of this flag (may be multiple bits!)
      Integer flagValue = (Integer)(DoubleInteger)property->Get->UserData;

      // If we have a flag value of 0 (typically None) then ignore it
      // Otherwise every bitfield when printed would also have None set
      if (flagValue == 0)
        continue;

      // Mask off the bits so we know if there were any invalid bits leftover
      runningValue &= ~flagValue;

      // If the input value contains all these flags...
      if ((inputValue & flagValue) == flagValue)
      {
        // If we've already written anything, we need to add the delimiter (the bitwise OR operator)
        if (wroteSomething)
        {
          builder.Append(" ");
          builder.Append(Grammar::GetKeywordOrSymbol(Grammar::BitwiseOr));
          builder.Append(" ");
        }

        // Append the property name, and note that we've written something now
        // (meaning the next write needs a delimiter)
        builder.Append(property->Name);
        wroteSomething = true;
      }
    }

    // If nothing was written...
    if (wroteSomething == false)
    {
      // Otherwise, this flags is not a known value... (just return the integer for readability)
      return IntegerToString(inputValue);
    }
    else
    {
      // If we have any bits left that weren't accounted for...
      if (runningValue != 0)
      {
        // Show the user the true value
        builder.Append(" (");
        builder.Append(IntegerToString(inputValue));
        builder.Append(")");
      }

      // Return the bits that were set
      return builder.ToString();
    }
  }
}

//***************************************************************************
// ONLY FOR DEBUGGING CRASH DUMPS
byte* ZilchLastRunningOpcode = nullptr;
Zilch::Function* ZilchLastRunningFunction = nullptr;
size_t ZilchLastRunningOpcodeLength = 0;
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes



/*
cencode.h - c header for a base64 encoding algorithm

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/

#ifndef BASE64_CENCODE_H
#define BASE64_CENCODE_H

typedef enum
{
	step_A, step_B, step_C
} base64_encodestep;

typedef struct
{
	base64_encodestep step;
	char result;
	int stepcount;
} base64_encodestate;

int compute_base64_size(int length);

void base64_init_encodestate(base64_encodestate* state_in);

char base64_encode_value(char value_in);

size_t base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in);

size_t base64_encode_blockend(char* code_out, base64_encodestate* state_in);

#endif /* BASE64_CENCODE_H */





// Using directives
using namespace Zero;

// Note: The entire implementation here is the WebSocket protocol:
// https://tools.ietf.org/html/rfc6455

namespace Zilch
{
  //***************************************************************************
  namespace Events
  {
    ZilchDefineEvent(WebSocketAcceptedConnection);
    ZilchDefineEvent(WebSocketReceivedData);
    ZilchDefineEvent(WebSocketError);
    ZilchDefineEvent(WebSocketDisconnected);
  }

  //***************************************************************************
  ZilchDefineStaticLibrary(WebSockets)
  {
    ZilchInitializeType(WebSocketEvent);
  }

  //***************************************************************************
  ZilchDefineType(WebSocketEvent, "WebSocketEvent", WebSockets, builder, type)
  {
  }

  //***************************************************************************
  WebSocketEvent::WebSocketEvent() :
    Connection(nullptr),
    PacketType(WebSocketPacketType::Invalid)
  {
  }

  //***************************************************************************
  BlockingWebSocketConnection::BlockingWebSocketConnection()
  {
  }
  
  //***************************************************************************
  void BlockingWebSocketConnection::SendFullPacket(Status& status, const byte* data, size_t length, WebSocketPacketType::Enum packetType)
  {
    // The header has a maximum size without the mask, lets build that header
    byte header[10] = {0};
    size_t headerSize = 0;

    // Write the first two bytes (flags / opcode, and the payload)
    // Since we're always sending a full packet (not truncated or fragments) then this is always a FIN packet
    header[0] |= 0x80;

    // Set the opcode bit depending on if we're in text or binary or some other control opcode
    header[0] |= (byte)packetType;

    // We don't bother to set the mask bit, so just set the second byte as the size (and onward if we need it)
    if (length < 126)
    {
      header[1] = (byte)length;
      headerSize = 2;
    }
    // If we're using 2 bytes to describe the size (1 byte just to say we're using 2 bytes...)
    else if (length <= 0xFFFF)
    {
      header[1] = 126;

      *((unsigned short*)(header + 2)) = NetworkFlip((unsigned short)length);
      headerSize = 4;
    }
    // If we're using 8 bytes to describe the size (1 byte just to say we're using 8 bytes...)
    else
    {
      header[1] = 127;
      *((unsigned long long*)(header + 2)) = NetworkFlip((unsigned long long)length);
      headerSize = 10;
    }

    // Send the header off first (this will block until it sends the entire thing!)
    int sentSizeHeader = this->RemoteSocket.Send(status, header, (int)headerSize, SocketFlags::None);
    ErrorIf(sentSizeHeader != 0 && sentSizeHeader != (int)headerSize, "We should always send the entire header, send should block until its all sent!");
    if (status.Failed())
      return;

    // Now send the rest of the payload data (could be done in one send, no problem though!)
    int sentSizeData = this->RemoteSocket.Send(status, data, (int)length, SocketFlags::None);
    ErrorIf(sentSizeData != 0 && sentSizeData != (int)length, "We should always send the entire data, send should block until its all sent!");
    if (status.Failed())
      return;
  }
  
  //***************************************************************************
  bool BlockingWebSocketConnection::IsValid()
  {
    return this->RemoteSocket.IsOpen();
  }

  //***************************************************************************
  WebSocketPacketType::Enum BlockingWebSocketConnection::ReceiveFullPacket(Status& status, String& dataOut)
  {
    // All the information we need for a web-socket header
    bool readHeader = false;
    size_t payloadSize = 0;
    char mask[4] = {0};
    bool fin = false;
    bool rsv1 = false;
    bool rsv2 = false;
    bool rsv3 = false;
    WebSocketPacketType::Enum opcode = WebSocketPacketType::Invalid;

    // Clear the data, just so that if the user is reusing a buffer, they don't get confused
    dataOut.clear();

    // Read until we hit a full packet (return inside loop below)
    for (;;)
    {
      // The default buffer size we use (big enough for a tcp window)
      const int ReceiveBufferSize = 4096;

      // Read the data from the socket
      byte buffer[ReceiveBufferSize];
      int amountReceived = this->RemoteSocket.Receive(status, buffer, ReceiveBufferSize, SocketFlags::None);
      
      // If the receive call failed, or we gracefully disconnected...
      if (status.Failed() || amountReceived == 0)
        return WebSocketPacketType::Invalid;

      // Add the data to a remaining buffer
      this->ReadData.insert(this->ReadData.end(), buffer, buffer + amountReceived);
      byte* data = this->ReadData.data();

      // The minimum amount of data a packet can be is 6, but the header can be larger because of extended sizes
      // This includes the opcode/starting bits (1), the payload length (1), and the mask (4)
      if (readHeader == false && this->ReadData.size() >= 6)
      {
        // First, read the header byte which tells us all the options
        byte headerByte = data[0];
        fin  = (headerByte & 0x80) != 0;
        rsv1 = (headerByte & 0x40) != 0;
        rsv2 = (headerByte & 0x20) != 0;
        rsv3 = (headerByte & 0x10) != 0;
        opcode = (WebSocketPacketType::Enum)(headerByte & 0x0F);
        
        // Read the size of our packet
        byte sizeByte = data[1];

        // The highest bit is always set, basically clear it
        bool masking = (sizeByte & 0x80) != 0;
        sizeByte &= 0x7F;
        
        // We read the opcode/bits and the payload length, which is 2 bytes
        size_t position = 2;
        payloadSize = sizeByte;

        // Assume right now that we successfully read the header (we may still fail below if we don't have enough header data)
        readHeader = true;
        
        // If the size is 126, then it means we have an extra 16 bits of data (2 bytes)
        if (sizeByte == 126)
        {
          // We're reading an extended payload size of 2 bytes, which means we must have at least 8 bytes (6 + 2) of data in total for the whole header
          if (this->ReadData.size() >= 8)
          {
            payloadSize = NetworkFlip((unsigned short)(data[2] + (data[3] << 8)));
            position = 4;
          }
          else
          {
            // We couldn't read the extended payload, because we didn't have enough data read for it
            readHeader = false;
          }
        }
        // If the size is 127, then we have an extra 64 bits of data (8 bytes)
        else if (sizeByte == 127)
        {
          // We're reading an extended payload size of 8 bytes, which means we must have at least 14 bytes (6 + 8) of data in total for the whole header
          if (this->ReadData.size() >= 14)
          {
            payloadSize = (size_t)NetworkFlip((unsigned long long)(data[2] + (data[3] << 8) + (data[4] << 16) + (data[5] << 24) + ((unsigned long long)data[6] << 32) + ((unsigned long long)data[7] << 40) + ((unsigned long long)data[8] << 48) + ((unsigned long long)data[9] << 56)));
            position = 10;
          }
          else
          {
            // We couldn't read the extended payload, because we didn't have enough data read for it
            readHeader = false;
          }
        }

        // If we successfully read in all the header data...
        if (readHeader)
        {
          // Last but not least, read the mask!
          memcpy(mask, data + position, 4);
          position += 4;

          // Remove the header from the data
          this->ReadData.erase(Array<byte>::range(data, data + position));
        }
      }

      // If we already read the header and we have enough data to read the entire packet...
      if (readHeader && this->ReadData.size() >= payloadSize)
      {
        // Get a pointer to the data (for convenience)
        byte* data = this->ReadData.data();

        // Directly create a string node that we'll assign to a string (where we copy our data into)
        String::StringNode* node = String::allocateNode(payloadSize);

        // Loop through the payload and apply the mask to it
        for (size_t i = 0; i < payloadSize; ++i)
        {
          // Grab the current mask character (rotates by 4 over and over)
          // Apply this mask to the current byte we're reading, and put it into the user output
          char maskChar = mask[i % 4];
          node->Data[i] = data[i] ^ maskChar;
        }

        // Now output the string from the node we just created
        dataOut = String(node);

        // We're done, we read a full packet, remove the data we read so that the next packet can be processed
        this->ReadData.erase(Array<byte>::range(data, data + payloadSize));
        return opcode;
      }
    }
  }

  //***************************************************************************
  BlockingWebSocketListener::BlockingWebSocketListener()
  {
  }
  
  //***************************************************************************
  void BlockingWebSocketListener::Initialize(Status& status, int port)
  {
    // Web sockets are strictly TCP
    this->ListenerSocket.Open(status, SocketAddressFamily::InternetworkV4, SocketType::Stream, SocketProtocol::Tcp);

    // First create a local socket address, bound to any network adapter (let the OS choose)
    // Use the port that the user passed in
    SocketAddress localAddress;
    localAddress.SetIpv4(status, String(), ushort(port), SocketAddressFlags::AnyAddress);

    if (status.Failed())
      return;

    // Next, bind our listener socket to that address
    this->ListenerSocket.Bind(status, localAddress);

    if (status.Failed())
      return;

    // Now listen on the socket, which should allow incoming connections to be accepted
    this->ListenerSocket.Listen(status, Socket::GetMaxListenBacklog());
  }
  
  //***************************************************************************
  void BlockingWebSocketListener::Close(Status& status)
  {
    this->ListenerSocket.Close(status);
  }

  //***************************************************************************
  bool BlockingWebSocketListener::IsValid()
  {
    return this->ListenerSocket.IsOpen();
  }
  
  //***************************************************************************
  void BlockingWebSocketListener::Accept(Status& status, BlockingWebSocketConnection& connectionOut)
  {
    // Attempt to accept a connection
    this->ListenerSocket.Accept(status, &connectionOut.RemoteSocket);

    if (status.Failed())
      return;

    // The default buffer size we use (big enough for a tcp window)
    const int ReceiveBufferSize = 4096;

    // Even though it's not the most efficient approach, we're going to take all data we receive
    // and stuff it into this array before we try and parse it (keeps data contiguous)
    // A better data structure would be able to work with the temporary received data, and then
    // only append what isn't read at the end
    Array<byte> remainingHeaderData;

    // Whether or not we read the full header (denoted when we read two newlines in a row)
    bool readFullHttpHeader = false;

    // We've accepted a connection, but we don't know if this is a proper websocket yet...
    do
    {
      // Read the data from the socket
      byte buffer[ReceiveBufferSize];
      int amountReceived = connectionOut.RemoteSocket.Receive(status, buffer, ReceiveBufferSize, SocketFlags::None);
      
      // If the receive call failed, or we gracefully disconnected...
      if (status.Failed() || amountReceived == 0)
        return;

      // Add the data to a remaining buffer
      remainingHeaderData.insert(remainingHeaderData.end(), buffer, buffer + amountReceived);

      // If we process the get request header
      bool getRequest = false;

      // Since the HTTP protocl is line based, store the last line we stopped on
      const char* lastLineStart = (char*)remainingHeaderData.data();

      // Get a pointer to the remaining data, for convenience
      char* data = (char*)remainingHeaderData.data();

      // Track whether we already hit a newline (used to break out from the HTTP request - two newlines)
      bool justHitNewline = false;

      // Loop through remaining data...
      for (size_t i = 0; i < remainingHeaderData.size(); ++i)
      {
        // Read a single character
        char c = data[i];

        // If the character is a newline...
        if (c == '\n')
        {
          // If we hit a newline now and we had just hit a newline before...
          if (justHitNewline)
          {
            // We read the entire HTTP header!
            readFullHttpHeader = true;
            break;
          }

          // Mark that we just hit a newline (gets reset in the 'else' clause below)
          justHitNewline = true;

          // Create a range that points from the start of the current line to the end (where we are now, the newline!)
          StringRange range(lastLineStart, data + i);

          // If we have yet to read that this is a get-request...
          if (getRequest == false)
          {
            // Read the get-request line
            if (String::StartsWith(range, "GET / HTTP/1.1"))
            {
              getRequest = true;
            }
            else
            {
              // This is NOT a get request, or it's an old version!
              connectionOut.RemoteSocket.Close(status);

              // Return that the http request was not valid (regardless of if closing the socket failed)
              status.SetFailed("Not a valid HTTP 1.1 client request");
              return;
            }
          }
          else
          {
            // Look for the HTTP header divider character ':'
            size_t dividerIndex = range.FindFirstOf(':');
            if (dividerIndex != String::InvalidIndex)
            {
              // Parse the key and value part of the header line
              // The +2 is for the ':' and the space after it
              StringRange httpHeaderKey(range.begin, dividerIndex);
              StringRange httpHeaderValue(range.begin + dividerIndex + 2, range.end);

              // Trim the trailing '\r' if it exists (it should, but some non-compliant browsers don't send it)
              if (httpHeaderValue.back() == '\r')
                --httpHeaderValue.end;

              // Finally, map the key to the value so we can lookup any header values later
              connectionOut.Headers.insert(httpHeaderKey, httpHeaderValue);
            }
            else
            {
              // We got some bad data, or just something we didn't yet handle!
              status.SetFailed(BuildString("Invalid line found in the http header request: ", range));
              return;
            }
          }

          // Skip the newline character (hence the +1)
          lastLineStart = data + i + 1;
        }
        else if (c != '\r')
        {
          // As long as we're not hitting the carriage return, mark this as no longer a newline
          justHitNewline = false;
        }
      }

      // Erase all the data we processed already
      remainingHeaderData.erase(Array<byte>::range((byte*)data, (byte*)lastLineStart));
    }
    // Loop until we read the full header
    while (readFullHttpHeader == false);


    // A special guid appended to the 'accept' message that the server sends back (just to identify web sockets)
    static const String ServerGuid("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
    static const String SecWebSocketKey("Sec-WebSocket-Key");

    // Make sure we got a web socket key request
    String* key = connectionOut.Headers.findPointer(SecWebSocketKey);
    if (key == nullptr)
    {
      return status.SetFailed("We did not receive the 'Sec-WebSocket-Key' parameter, and "
                              "therefore the connection was not a valid web socket connection");
    }

    // As per RFC-6455 (page 7)
    // We take the above guid and concatenate it with the given key
    String concatenatedKey = BuildString(*key, ServerGuid);

    // Get the sha1 on of the concatenated key
    byte finalSha1[Sha1Builder::Sha1ByteSize];
    Sha1Builder sha1Builder;
    sha1Builder.Append((byte*)concatenatedKey.data(), concatenatedKey.size());
    sha1Builder.OutputHash(finalSha1);

    // Lastly, we need to base64 encode the sha1 hash
    Array<char> base64Encoded;
    base64Encoded.resize(compute_base64_size(Sha1Builder::Sha1ByteSize));
    base64_encodestate base64EncodeContext;
    base64_init_encodestate(&base64EncodeContext);
    size_t written = base64_encode_block((char*)finalSha1, Sha1Builder::Sha1ByteSize, base64Encoded.data(), &base64EncodeContext);
    base64_encode_blockend(base64Encoded.data() + written, &base64EncodeContext);

    // Send the response to the web socket request
    String response = BuildString
    (
      "HTTP/1.1 101 Switching Protocols\r\n"
      "Upgrade: websocket\r\n"
      "Connection: Upgrade\r\n"
      "Sec-WebSocket-Accept: ",
      StringRange(base64Encoded.data(), base64Encoded.size()),
      "\r\n\r\n"
    );
    
    // This should be the last thing we have to send!
    connectionOut.RemoteSocket.Send(status, (byte*)response.data(), (int)response.size(), SocketFlags::None);
  }
  
  //***************************************************************************
  void ThreadedWebSocketConnection::SendPacket(StringParam message, WebSocketPacketType::Enum packetType)
  {
    // First initiale the lock around the send messages queue, append the message
    // then unlock it so the 'SendThread' can resume its work
    this->SendLock.Lock();

    // We just use the event structure because it has all the data we need
    WebSocketEvent& toSend = this->SendMessages.push_back();
    toSend.Data = message;
    toSend.PacketType = packetType;

    // We need to tell the send thread that it now has data to send (unblocks it)
    // This MUST happen inside the locks, otherwise it's possibly to consume
    // all messages in the send thread before the singal, and cause the send thread to exit
    this->SendEvent.Signal();
    this->SendLock.Unlock();
  }

  //***************************************************************************
  ThreadedWebSocketConnection::ThreadedWebSocketConnection()
  {
  }

  //***************************************************************************
  ThreadedWebSocketConnection::~ThreadedWebSocketConnection()
  {
    // Closing automatically terminates threads and the socket
    // It's also safe to call more than once
    this->Close();
  }

  //***************************************************************************
  bool ThreadedWebSocketConnection::IsValid()
  {
    return this->BlockingConnection.IsValid();
  }
  
  //***************************************************************************
  void ThreadedWebSocketConnection::Close()
  {
    // If the connection is already closed... early out
    if (this->IsValid() == false)
      return;

    // Shutdown the remote connection, which should signal that we're ending the connection
    WebSocketEvent shutdownEvent;
    shutdownEvent.Connection = this;
    this->BlockingConnection.RemoteSocket.Shutdown(shutdownEvent.ErrorStatus, SocketIo::Both);

    // Close the remote connection
    WebSocketEvent closeEvent;
    closeEvent.Connection = this;
    this->BlockingConnection.RemoteSocket.Close(closeEvent.ErrorStatus);

    // Clear out the messages to be sent
    this->SendLock.Lock();
    this->SendMessages.clear();
    this->SendLock.Unlock();

    // Signal the send event, if it gets signaled and there's no messages, it means we're closing
    this->SendEvent.Signal();
    this->SendThread.WaitForCompletion();
    
    // Wait until the receive thread ends...
    this->ReceiveThread.WaitForCompletion();

    // If the shutdown status failed for any reason, dispatch an event out
    if (shutdownEvent.ErrorStatus.Failed())
      EventSend(this, Events::WebSocketError, &shutdownEvent);

    // If the close status failed for any reason, dispatch an event out
    if (closeEvent.ErrorStatus.Failed())
      EventSend(this, Events::WebSocketError, &closeEvent);

    // After the entire closure of the socket, send out a disconnected event
    WebSocketEvent disconnectEvent;
    disconnectEvent.Connection = this;
    EventSend(this, Events::WebSocketDisconnected, &disconnectEvent);
  }

  //***************************************************************************
  void ThreadedWebSocketConnection::Update()
  {
    // Lock the recieve buffer and bring all messages to the owning recieve message array
    this->IncomingLock.Lock();
    this->OwnerIncomingEvents.swap(this->ThreadIncomingEvents);
    this->IncomingLock.Unlock();
    
    // Walk through all messages and deliver them to the user
    for (size_t i = 0; i < this->OwnerIncomingEvents.size(); ++i)
    {
      // Grab the current message and send out a recieved event
      WebSocketEvent* event = &this->OwnerIncomingEvents[i];

      // Depending on what happened, send out either an error message or a received data message
      // Note: Errors can originate both from the send and receive thread
      if (event->ErrorStatus.Failed())
      {
        // Only send out the error if its a real error (we don't consider receive/close errors as bad errors)
        if (Socket::IsCommonReceiveError(event->ErrorStatus.ExtendedErrorCode) == false)
          EventSend(this, Events::WebSocketError, event);
      }
      else
      {
        // Based on the packet type..
        // Note: We don't currently handle pong because we don't care (nor do we send out pings)
        switch (event->PacketType)
        {
          // If we received either text or binary data, let the user know
          case WebSocketPacketType::Binary:
          case WebSocketPacketType::Text:
            EventSend(this, Events::WebSocketReceivedData, event);
            break;

          // A continuation of a packet is a partial packet...
          case WebSocketPacketType::Continuation:
            Error("WebSocket Continuation packets are not currently handled");
            break;

          // We must respond with a pong
          case WebSocketPacketType::Ping:
            this->SendPacket(event->Data, WebSocketPacketType::Pong);
            break;

          // When the socket is closed, we must send a close response and close our own socket
          case WebSocketPacketType::Close:
            this->SendPacket(event->Data, WebSocketPacketType::Close);
            break;
        }
      }
    }

    // Clear out the owning messages
    this->OwnerIncomingEvents.clear();

    // Now, if we ever experienced a disconnect, either via a non-writable socket or a thread terminates
    // then we'll attempt to close the socket
    // The receive thread can terminate on any error or upon a gracefull disconnect (receives 0 data)
    // The send thread can terminate on any error or upon sending the final web-socket close packet
    if (this->ReceiveThread.IsCompleted() || this->SendThread.IsCompleted())
      this->Close();
  }

  //***************************************************************************
  void ThreadedWebSocketConnection::Initialize()
  {
    // The send event will be used to signal the send thread that we have data outgoing
    this->SendEvent.Initialize();
    
    // Initialize all of our threads
    this->ReceiveThread.Initialize(ReceiveEntryPoint, this, "WebSocketReceive");
    this->SendThread.Initialize(SendEntryPoint, this, "WebSocketSend");

    // Start the send and recieve threads
    this->SendThread.Resume();
    this->ReceiveThread.Resume();
  }

  //***************************************************************************
  OsInt ThreadedWebSocketConnection::ReceiveEntryPoint(void* context)
  {
    // The context we pass in is our 'this' pointer
    ThreadedWebSocketConnection* self = (ThreadedWebSocketConnection*)context;

    // Receive messages until the socket is closed or we disconnect
    ZilchLoop
    {
      // Create an event that we'll queue up for the owning thread to receive
      WebSocketEvent receivedEvent;
      receivedEvent.Connection = self;

      // Receive an entire packet of text, this text should be json data
      receivedEvent.PacketType = self->BlockingConnection.ReceiveFullPacket(receivedEvent.ErrorStatus, receivedEvent.Data);
      
      // Lock the recieve buffer and push the message into it
      // The message may be an actual packet, or an error message
      self->IncomingLock.Lock();
      self->ThreadIncomingEvents.push_back(receivedEvent);
      self->IncomingLock.Unlock();

      // If we failed to for any reason (or disconnected gracefully), exit out of the thread
      if (receivedEvent.PacketType == WebSocketPacketType::Invalid)
        return 0;
    }
  }

  //***************************************************************************
  OsInt ThreadedWebSocketConnection::SendEntryPoint(void* context)
  {
    // The context we pass in is our 'this' pointer
    ThreadedWebSocketConnection* self = (ThreadedWebSocketConnection*)context;

    // We pull messages from the debugger's owning thread into our thread
    Array<WebSocketEvent> messageQueue;

    ZilchLoop
    {
      // Wait for any messages to be put on the queue
      self->SendEvent.Wait();

      // Make sure OUR message queue is empty (this is safe to do outside the lock)
      ErrorIf(messageQueue.empty() == false,
        "We should have sent all messages before attempting to swap with the main thread");

      // We got some messages, lock and swap with our own message buffer
      self->SendLock.Lock();

      // If we have no messages but the send event was signaled
      if (self->SendMessages.empty())
      {
        // Make sure to unlock and early return out
        self->SendLock.Unlock();
        return 0;
      }

      // Very quickly swap our entire send messages array with theirs
      // Note: This should always clear our their array because ours should be empty
      messageQueue.swap(self->SendMessages);

      // Due to a race condition that can happen where the main thread queues up
      // a message between the Wait and the Lock, then we will have the event set in the next loop,
      // yet we will have cleared all the messages (swapped)
      self->SendEvent.Reset();

      // We're done, that was fast!
      self->SendLock.Unlock();

      // Send every message we have
      for (size_t i = 0; i < messageQueue.size(); ++i)
      {
        // Grab the current message
        WebSocketEvent& message = messageQueue[i];

        // This is only queued up in the case that an error occurs
        WebSocketEvent errorEvent;
        errorEvent.Connection = self;

        // Send the full packet over
        self->BlockingConnection.SendFullPacket(errorEvent.ErrorStatus, (const byte*)message.Data.data(), message.Data.size(), message.PacketType);

        // If we encountered an error when sending...
        if (errorEvent.ErrorStatus.Failed())
        {
          // Lock the recieve buffer and push the error into it
          self->IncomingLock.Lock();
          self->ThreadIncomingEvents.push_back(errorEvent);
          self->IncomingLock.Unlock();

          // We always exit the send thread in the event of an error
          return 0;
        }

        // If the last packet was a close packet, we must not send any more data, as per the web-socket RFC
        if (message.PacketType == WebSocketPacketType::Close)
          return 0;
      }

      // Clear out the queue
      messageQueue.clear();
    }
  }

  
  //***************************************************************************
  ThreadedWebSocketListener::ThreadedWebSocketListener() :
    AcceptingConnection(nullptr)
  {
  }
  
  //***************************************************************************
  ThreadedWebSocketListener::~ThreadedWebSocketListener()
  {
    this->Close();
  }
  
  //***************************************************************************
  void ThreadedWebSocketListener::Initialize(int port)
  {
    // Starts listening on the given port
    WebSocketEvent hostEvent;
    this->BlockingListener.Initialize(hostEvent.ErrorStatus, port);

    // If the hosting status failed for any reason, dispatch an event out
    if (hostEvent.ErrorStatus.Failed())
      EventSend(this, Events::WebSocketError, &hostEvent);

    // Create the web socket accepting thread
    this->AcceptThread.Initialize(AcceptEntryPoint, this, "WebSocketAccept");

    // Start the accepting thread
    this->AcceptThread.Resume();
  }

  //***************************************************************************
  bool ThreadedWebSocketListener::IsValid()
  {
    return this->BlockingListener.IsValid();
  }

  //***************************************************************************
  void ThreadedWebSocketListener::Close()
  {
    // If the connection is already closed... early out
    if (this->BlockingListener.ListenerSocket.IsOpen() == false)
      return;

    // We only want to terminate the accepting listener socket while inside the lock, to prevent a race condition
    // We also want to terminate the socket for any connection that is currently being accepted (if it exists)
    this->AcceptingConnectionLock.Lock();
    
    // Close the remote connection, which should signal that we're ending the connection
    WebSocketEvent listenerCloseEvent;
    this->BlockingListener.ListenerSocket.Close(listenerCloseEvent.ErrorStatus);
    
    // Blocking connection close event
    WebSocketEvent acceptingCloseEvent;

    // If the accepting connection is valid (we have one that is currently being accepted
    if (this->AcceptingConnection != nullptr && this->AcceptingConnection->BlockingConnection.IsValid())
      this->AcceptingConnection->BlockingConnection.RemoteSocket.Close(acceptingCloseEvent.ErrorStatus);

    // Let the accepting thread resume
    this->AcceptingConnectionLock.Unlock();

    // The accept thread should encounter an error (accept will unblock)
    // and then because the listener descriptor was closed and made invalid by calling 'Close', the thread should terminate
    // Wait until the accept thread ends...
    this->AcceptThread.WaitForCompletion();

    // If the listener close status failed for any reason, dispatch an event out
    if (listenerCloseEvent.ErrorStatus.Failed())
      EventSend(this, Events::WebSocketError, &listenerCloseEvent);

    // If the accepting connection's close status failed for any reason, dispatch an event out
    if (acceptingCloseEvent.ErrorStatus.Failed())
      EventSend(this, Events::WebSocketError, &acceptingCloseEvent);
  }
  
  //***************************************************************************
  void ThreadedWebSocketListener::Update()
  {
    // Lock the recieve buffer and bring all messages to the owning recieve message array
    this->IncomingLock.Lock();
    this->OwnerIncomingEvents.swap(this->ThreadIncomingEvents);
    this->IncomingLock.Unlock();
    
    // Walk through all messages and deliver them to the user
    for (size_t i = 0; i < this->OwnerIncomingEvents.size(); ++i)
    {
      // Grab the current message and send out a recieved event
      WebSocketEvent* event = &this->OwnerIncomingEvents[i];

      // Depending on what happened, send out either an error message or a accepted connection message
      if (event->Connection != nullptr)
        EventSend(this, Events::WebSocketAcceptedConnection, event);
      else
        EventSend(this, Events::WebSocketError, event);
    }

    // Clear out the owning messages
    this->OwnerIncomingEvents.clear();

    // Now, if we ever experienced a disconnect, either via a non-writable socket or a thread terminates
    // Then we'll attempt to close the socket
    if (this->AcceptThread.IsCompleted())
      this->Close();
  }

  //***************************************************************************
  OsInt ThreadedWebSocketListener::AcceptEntryPoint(void* context)
  {
    // The context we pass in is our 'this' pointer
    ThreadedWebSocketListener* self = (ThreadedWebSocketListener*)context;

    ZilchLoop
    {
      // An event we send out if an error occurs
      WebSocketEvent acceptEvent;

      // Before accepting any connections, we need to check if we're terminating, and also let the owning
      // thread know the current connection we're accepting (so if the owning thread destructs this object, it
      // can also close the accepting connection)
      self->AcceptingConnectionLock.Lock();

      // If we no longer have a valid blocking listener, just exit out
      if (self->BlockingListener.IsValid() == false)
      {
        // Make sure to unlock, and terminate this thread
        self->AcceptingConnectionLock.Unlock();
        return 0;
      }
      
      // Create a new connection that can be accepted, and let the owning thread know what it is
      // Again, this is so the owning thread can cancel both the listening and accepting sockets so we don't deadlock on receieve
      ThreadedWebSocketConnection* connection = new ThreadedWebSocketConnection();
      self->AcceptingConnection = connection;

      // Let the owning thread resume
      self->AcceptingConnectionLock.Unlock();

      // Accept an incoming connection (blocks until the connection is fully acked according to web-sockets)
      // Will unblock if the sockets are terminated by the owning thread
      self->BlockingListener.Accept(acceptEvent.ErrorStatus, connection->BlockingConnection);
      
      // Now that we've finished accepting (could have failed, or could be a valid connection)
      // we are no longer accepting this 'connection'
      self->AcceptingConnectionLock.Lock();

      // Clear out the accepting connection so the owning thread won't try and close it
      self->AcceptingConnection = nullptr;

      // Let the owning thread resume
      self->AcceptingConnectionLock.Unlock();

      // If we didn't fail to accept a connection, then tell the main thread about the connection
      if (acceptEvent.ErrorStatus.Succeeded())
      {
        // This is an accepted connection with no errors!
        acceptEvent.Connection = connection;

        // Initialize the connection, which generally spins up the send/receive threads
        connection->Initialize();
      
        // Lock the recieve buffer and push the connection into it
        self->IncomingLock.Lock();
        self->ThreadIncomingEvents.push_back(acceptEvent);
        self->IncomingLock.Unlock();
      }
      else
      {
        // Any failure to connect should destroy the connection
        delete connection;

        // If the extended error code was set, it means we ran into a true socket error (or the socket was closed) so terminate the connection
        if (acceptEvent.ErrorStatus.ExtendedErrorCode != 0 && Socket::IsCommonAcceptError(acceptEvent.ErrorStatus.ExtendedErrorCode) == false)
        {
          // We only dispatch the error message if it's not a close event
          if (Socket::IsCommonReceiveError(acceptEvent.ErrorStatus.ExtendedErrorCode) == false)
          {
            // Lock the recieve buffer and push the error into it
            self->IncomingLock.Lock();
            self->ThreadIncomingEvents.push_back(acceptEvent);
            self->IncomingLock.Unlock();
          }

          // We always exit the send thread in the event of an error
          return 0;
        }
      }
    }
  }

  //***************************************************************************
  ThreadedWebSocketServer::ThreadedWebSocketServer(size_t maxConnections) :
    MaximumConnections(maxConnections)
  {
    // We want to know when connections are accepted, and when errors occur with the listener
    EventConnect(&this->Listener, Events::WebSocketAcceptedConnection, &ThreadedWebSocketServer::OnAcceptedConnection, this);
    EventForward(&this->Listener, Events::WebSocketError, this);
  }

  //***************************************************************************
  ThreadedWebSocketServer::~ThreadedWebSocketServer()
  {
    // Loop through all the connections we have and update them
    for (size_t i = 0; i < this->Connections.size(); ++i)
    {
      // Grab the current connection
      ThreadedWebSocketConnection* connection = this->Connections[i];
      delete connection;
    }
  }

  //***************************************************************************
  void ThreadedWebSocketServer::Host(int port)
  {
    this->Listener.Initialize(port);
  }
  
  //***************************************************************************
  bool ThreadedWebSocketServer::IsValid()
  {
    return this->Listener.IsValid();
  }

  //***************************************************************************
  void ThreadedWebSocketServer::Update()
  {
    // Update the listener, which will dispatch events
    this->Listener.Update();

    // Loop through all the connections we have and update them
    for (size_t i = 0; i < this->Connections.size();)
    {
      // Grab the current connection
      ThreadedWebSocketConnection* connection = this->Connections[i];

      // Update the connection, which could actually close the socket
      connection->Update();

      // If the connection is closed, we should remove it!
      if (connection->IsValid() == false)
      {
        // Swap with the last connection and then pop the back
        this->Connections[i] = this->Connections.back();
        this->Connections.pop_back();
      }
      else
      {
        // Otherwise, the connection was fine so just walk to the next one
        ++i;
      }
    }
  }

  //***************************************************************************
  void ThreadedWebSocketServer::SendPacketToAll(StringParam message, WebSocketPacketType::Enum packetType)
  {
    // Loop through all the connections and send the message to each
    for (size_t i = 0; i < this->Connections.size(); ++i)
    {
      // Grab the current connection and send the message
      ThreadedWebSocketConnection* connection = this->Connections[i];
      connection->SendPacket(message, packetType);
    }
  }
  
  //***************************************************************************
  void ThreadedWebSocketServer::OnAcceptedConnection(WebSocketEvent* event)
  {
    // If we're already at (or exceeded) our max connections...
    if (this->Connections.size() >= this->MaximumConnections)
    {
      // Terminate the accepted connection immediately (don't add it to our list)
      delete event->Connection;
      event->Connection = nullptr;
      return;
    }

    // Add the connection to our own tracked list
    this->Connections.push_back(event->Connection);

    // Forward the event on us, so anyone listening can see we got a new connection
    EventSend(this, event->EventName, event);

    // Forward all the errors, disconnect, and receive data events
    EventForward(event->Connection, Events::WebSocketError, this);
    EventForward(event->Connection, Events::WebSocketDisconnected, this);
    EventForward(event->Connection, Events::WebSocketReceivedData, this);
  }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Includes











namespace Zilch
{
  //***************************************************************************
  ZilchSetup* ZilchSetup::Instance = nullptr;

  //***************************************************************************
  ZilchSetup::ZilchSetup(StartupFlags::Type flags)
  {
    Instance = this;

    // Make sure the jump table is initialized
    VirtualMachine::InitializeJumpTable();

    // The user can disable runtime documentation processing by passing in a flag to ZilchStartup
    // However, if the user defines 'ZilchNoDocumentation', this will completely disable
    // both compile-time and runtime documentation processing
#if defined(ZilchNoDocumentation)
    flags |= StartupFlags::NoDocumentationStrings;
#endif

    // Store the flags for later use (eg in the destructor)
    this->Flags = (StartupFlags::Enum)flags;

    // Make sure all of our statics are initialized (guarantees thread safety)
    Grammar::GetUsedKeywords();
    Grammar::GetReservedKeywords();
    Grammar::GetSpecialKeywords();
    IEncoding::GetAscii();
    IEncoding::GetUtf8();

    // Make sure to initialize all the compilation errors
    ErrorDatabase::GetInstance();

    // If the user wants us to, we'll use our own custom error handler,
    // Otherwise we'll use our own error handler
    bool useZilchErrorHandler = !(flags & StartupFlags::CustomAssertHandlerOrNoAsserts);
    if (useZilchErrorHandler)
    {
      ErrorSignaler::SetErrorHandler(DebugErrorHandler);
    }

    // Register the command handle managers we use
    ZilchRegisterUniqueHandleManager(HeapManager);
    ZilchRegisterUniqueHandleManager(StackManager);
    ZilchRegisterSharedHandleManager(PointerManager);
    ZilchRegisterSharedHandleManager(StringManager);

    // Lock any future handle managers from being added
    HandleManagers::GetInstance().Lock();

    // Everyone depends on the Core library, so build it first
    Core::GetInstance().BuildLibrary();
    Syntax::GetInstance().BuildLibrary();
    WebSockets::GetInstance().BuildLibrary();

    // Finally, after everything else is built, make the shared library
    Shared::GetInstance();
  }
  
  //***************************************************************************
  template <typename T>
  void ReconstructSingleton()
  {
    // Explicitly destructs a singleton then uses placement new to create it again (should be reset)
    ZilchTodo("Make singletons into pointers so we don't have to do this silly stuff");
    T* singleton = &T::GetInstance();
    singleton->~T();
    new (singleton) T();
  }
  
  //***************************************************************************
  ZilchSetup::~ZilchSetup()
  {
    // If the user specified to not run shutdown code, then early out here
    if (this->Flags & StartupFlags::DoNotShutdown)
      return;

    // Manaully invoke destructors on static objects and in place construct them again (so they can be used again)
    // Static shutdown will properly take care of removing them (these should probably be changed to allocated pointers)
    ReconstructSingleton<HandleManagers>();
    ReconstructSingleton<Shared>();

    // Shutdown the memory manager
    Shutdown();

    Instance = nullptr;
  }

  //***************************************************************************
  bool MainArguments::HasCommand(StringParam command)
  {
    return this->CommandToValues.containsKey(command);
  }
  
  //***************************************************************************
  String MainArguments::GetCommandValue(StringParam command)
  {
    String* value = this->GetCommandValuePointer(command);
    if (value != nullptr)
      return *value;

    // If we didn't get a valid pointer back, then return an empty string
    return String();
  }
  
  //***************************************************************************
  String* MainArguments::GetCommandValuePointer(StringParam command)
  {
    // Look for the commands
    Array<String>* values = this->CommandToValues.findPointer(command);
    if (values == nullptr)
      return nullptr;

    // If there are no values under the array, then return an empty string
    if (values->empty())
      return nullptr;

    // We always return the last input value for that command
    return &values->back();
  }
  
  //***************************************************************************
  Array<String>& MainArguments::GetCommandValues(StringParam command)
  {
    return this->CommandToValues[command];
  }
  
  //***************************************************************************
  void ZilchParseMainArguments(int argc, char* argv[], MainArguments& argumentsOut)
  {
    static const String CommandDash('-');
    String lastCommand;

    // Get the executable path from the first argument
    if (argc >= 1)
      argumentsOut.ExecutablePath = argv[0];

    // Walk through all arguments storing commands as we find them
    for (int i = 1; i <= argc; ++i)
    {
      // Get the current argument (let the last one be an empty string)
      String argument;
      if (i < argc)
        argument = argv[i];

      // If we found a new command...
      if (argument.StartsWith(CommandDash))
      {
        // If we already had a previous command, then the previous one did not have a value
        if (lastCommand.empty() == false)
        {
          // Give the last command an empty value
          argumentsOut.CommandToValues[lastCommand].push_back(String());
        }
        
        // Store the new command...
        lastCommand = argument;
      }
      else
      {
        // If we have a last command, then this argument is its value
        if (lastCommand.empty() == false)
        {
          // Store the command and its argument, then clear it for the next time
          // we come around (so we don't think its an valueless command)
          argumentsOut.CommandToValues[lastCommand].push_back(argument);
          lastCommand.clear();
        }
        else if (argument.empty() == false)
        {
          // We found a value without a command, just add it to the values list
          argumentsOut.InputValues.push_back(argument);
        }
      }
    }
  }
  
  //***************************************************************************
  void GetErrorEvent(ErrorEvent* e, void* userData)
  {
    // Copy the event out
    *((ErrorEvent*)userData) = *e;
  }
  
  //***************************************************************************
  int ZilchMain(int argc, char* argv[])
  {
    int result = 0;

    ZilchSetup setup(StartupFlags::None);

    // Get the arguments in a convenient to query form
    MainArguments arguments;
    ZilchParseMainArguments(argc, argv, arguments);

    // For our own internal use, we may want to attach a debugger to Zilch
    if (arguments.HasCommand("-WaitForDebugger"))
      ZilchWaitForDebugger(true);

    // Hook up the standard write and read callbacks to the console (which allows us to read from stdin and write to stdout)
    EventConnect(&Console::Events, Events::ConsoleWrite, DefaultWriteText);
    EventConnect(&Console::Events, Events::ConsoleRead, DefaultReadText);

    // Create an empty project and listen for compilation errors
    Project project;
    ErrorEvent errorEvent;
    EventConnect(&project, Events::CompilationError, GetErrorEvent, &errorEvent);

    // We always load plugins from the directory next to the executable
    project.PluginDirectories.append(Zero::GetApplicationDirectory());
    
    ZilchForEach(String& pluginDirectory, arguments.GetCommandValues("-PluginDirectory").all())
    {
      project.PluginDirectories.append(pluginDirectory);
    }
    
    ZilchForEach(String& pluginFile, arguments.GetCommandValues("-Plugin").all())
    {
      project.PluginFiles.append(pluginFile);
    }

    // Treat all the stray input values as file names
    ZilchForEach(String& fileName, arguments.InputValues.all())
    {
      // Load the code from a file (and if it fails, error out)
      if (project.AddCodeFromFile(fileName) == false)
      {
        printf("* Unable to open file: '%s'\n", fileName.c_str());
        result = -1;
      }
    }
    
    // If requested, also compile code from a string
    if (String* codeString = arguments.GetCommandValuePointer("-CodeString"))
      project.AddCodeFromString(*codeString, CodeString);

    // If we want to compile the code we added above and report error information (or run the code)
    bool compileAndReport = arguments.HasCommand("-CompileAndReport");
    bool compileOnly = arguments.HasCommand("-CompileOnly");
    bool run = arguments.HasCommand("-Run");
    if (compileAndReport || compileOnly || run)
    {
      Module module;
      LibraryRef library = project.Compile("Main", module, EvaluationMode::Project);

      if (compileAndReport)
      {
        JsonBuilder builder;
        builder.Begin(JsonType::Object);
        {
          builder.Key("IsError");
          builder.Value(library == nullptr);

          builder.Key("StartLine");
          builder.Value(errorEvent.Location.StartLine);
          builder.Key("StartCharacter");
          builder.Value(errorEvent.Location.StartCharacter);

          builder.Key("PrimaryLine");
          builder.Value(errorEvent.Location.PrimaryLine);
          builder.Key("PrimaryCharacter");
          builder.Value(errorEvent.Location.PrimaryCharacter);

          builder.Key("EndLine");
          builder.Value(errorEvent.Location.EndLine);
          builder.Key("EndCharacter");
          builder.Value(errorEvent.Location.EndCharacter);

          builder.Key("Origin");
          builder.Value(errorEvent.Location.Origin);

          builder.Key("Message");
          builder.Value(errorEvent.ExactError);

          builder.Key("FormattedMessage");
          builder.Value(errorEvent.GetFormattedMessage(MessageFormat::Zilch));
        }
        builder.End();

        String json = builder.ToString();
        printf("%s", json.c_str());
      }
      else
      {
        if (library == nullptr)
        {
          // Print out the error message directly
          String errorMessage = errorEvent.GetFormattedMessage(MessageFormat::Zilch);
          printf("* %s\n", errorMessage.c_str());
          result = -1;
        }
        else if (run)
        {
          BoundType* programType = library->BoundTypes.findValue("Program", nullptr);
          if (programType != nullptr)
          {
            Function* mainFunction = programType->FindFunction("Main", Array<Type*>(), ZilchTypeId(int), FindMemberOptions::None);
            if (mainFunction != nullptr)
            {
              Module libraries;
              libraries.push_back(library);
              ExecutableState* state = libraries.Link();
              EventConnect(state, Events::UnhandledException, DefaultExceptionCallback);
              {
                ExceptionReport report;
                Handle programHandle = state->AllocateDefaultConstructedHeapObject(programType, report, HeapFlags::ReferenceCounted);

                if (report.HasThrownExceptions())
                {
                  result = -2;
                }
                else
                {
                  Call call(mainFunction, state);
                  call.Set(Call::This, programHandle);
                  call.Invoke(report);

                  if (report.HasThrownExceptions())
                    result = -2;
                  else
                    result = call.Get<Integer>(Call::Return);
                }
              }
              delete state;
            }
            else
            {
              printf("* Unable to find instance entry-point 'function Main() : Integer' on type 'Program'\n");
              result = -1;
            }
          }
          else
          {
            printf("* Unable to find entry-point type 'Program'\n");
            result = -1;
          }
        }
      }
    }
    else
    {
      // If the user wants auto complete information...
      String* autoCompleteCursor = arguments.GetCommandValuePointer("-AutoCompleteCursor");
      String* autoCompleteOrigin = arguments.GetCommandValuePointer("-AutoCompleteOrigin");
      if (autoCompleteCursor != nullptr && autoCompleteOrigin != nullptr)
      {
        // Read the value the user specified for the cursor position
        long long cursorPosition = 0;
        Zero::ToValue(*autoCompleteCursor, cursorPosition);

        // Attempt to get auto complete information if possible
        AutoCompleteInfo info;
        Module module;
        project.TolerantMode = true;
        project.GetAutoCompleteInfo(module, (size_t)cursorPosition, *autoCompleteOrigin, info);

        String json = info.GetJson();
        printf("%s\n", json.c_str());
      }
      else if (autoCompleteCursor == nullptr && autoCompleteOrigin != nullptr)
      {
        printf("* When specifying 'AutoCompleteOrigin' you must also specify 'AutoCompleteCursor'\n");
        result = -1;
      }
      else if (autoCompleteCursor != nullptr && autoCompleteOrigin == nullptr)
      {
        printf("* When specifying 'AutoCompleteCursor' you must also specify 'AutoCompleteOrigin'\n");
        result = -1;
      }
    }

    // If they passed in the pause command, then we'll wait to exit
    if (arguments.HasCommand("-Pause"))
    {
      printf("Press enter/return to exit...");
      getchar();
    }

    return result;
  }
  
  //***************************************************************************
  void ZilchWaitForDebugger(bool breakpointWhenAttached)
  {
    // Wait until the debugger gets attached by constantly sleeping and checking
    while (Zero::Os::IsDebuggerAttached() == false)
      Zero::Os::Sleep(1);

    // We got here and a debugger is attached, so breakpoint!
    Zero::Os::DebugBreak();
  }
}///////////////////////////////////////////////////////////////////////////////
///
/// \file Time.cpp
/// 
/// Authors: Joshua Davis
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


namespace Zero
{

TimeType Time::GetTime()
{
  return time(0);
}

TimeType Time::Clock()
{
  return clock();
}

TimeType Time::GenerateSeed()
{
  return clock();
}

CalendarDateTime Time::GetLocalTime(const TimeType& timer)
{
  CalendarDateTime result;
  tm* lt = localtime(&timer);

  result.Seconds = lt->tm_sec;
  result.Minutes = lt->tm_min;
  result.Hour = lt->tm_hour;
  result.Day = lt->tm_mday;
  result.Month = lt->tm_mon;
  result.Year = lt->tm_year + 1900;
  result.Weekday = lt->tm_wday;
  result.Yearday = lt->tm_yday;
  result.IsDaylightSavings = lt->tm_isdst;

  return result;
}

TimeType Time::CalendarDateTimeToTimeType(const CalendarDateTime& time)
{
  tm newTime;
  newTime.tm_sec = time.Seconds;
  newTime.tm_min = time.Minutes;
  newTime.tm_hour = time.Hour;
  newTime.tm_mday = time.Day;
  newTime.tm_mon = time.Month;
  newTime.tm_year = time.Year - 1900;
  newTime.tm_wday = time.Weekday;
  newTime.tm_yday = time.Yearday;
  newTime.tm_isdst = time.IsDaylightSavings;

  return mktime(&newTime);
}

TimeType Time::ClocksPerSecond()
{
  return CLOCKS_PER_SEC;
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


// Includes
#include <algorithm>



namespace Zero
{

//---------------------------------------------------------------------------------//
//                                  BitStream                                      //
//---------------------------------------------------------------------------------//

BitStream::BitStream()
{
  Initialize();
}
BitStream::BitStream(const BitStream& rhs)
  : mData(rhs.mByteCapacity ? new byte[rhs.mByteCapacity] : nullptr),
    mByteCapacity(rhs.mByteCapacity),
    mBitsWritten(rhs.mBitsWritten),
    mBitsRead(rhs.mBitsRead),
    mAlignment(rhs.mAlignment)
{
  if(mData)
    memcpy(mData, rhs.mData, rhs.mByteCapacity);
}
BitStream::BitStream(MoveReference<BitStream> rhs)
  : mData(rhs->mData),
    mByteCapacity(rhs->mByteCapacity),
    mBitsWritten(rhs->mBitsWritten),
    mBitsRead(rhs->mBitsRead),
    mAlignment(rhs->mAlignment)
{
  rhs->Initialize();
}

BitStream::~BitStream()
{
  Clear(true);
}

BitStream& BitStream::operator =(const BitStream& rhs)
{
  if(this != &rhs)
  {
    // Capacity too small to fit data?
    if(mByteCapacity < rhs.mByteCapacity)
      Reallocate(rhs.mByteCapacity, false);

    memcpy(mData, rhs.mData, rhs.mByteCapacity);
    mBitsWritten = rhs.mBitsWritten;
    mBitsRead    = rhs.mBitsRead;
    mAlignment   = rhs.mAlignment;
  }
  return *this;
}
BitStream& BitStream::operator =(MoveReference<BitStream> rhs)
{
  if(this != &rhs)
  {
    Clear(true);

    mData         = rhs->mData;
    mByteCapacity = rhs->mByteCapacity;
    mBitsWritten  = rhs->mBitsWritten;
    mBitsRead     = rhs->mBitsRead;
    mAlignment    = rhs->mAlignment;

    rhs->Initialize();
  }
  return *this;
}

bool BitStream::operator ==(const BitStream& rhs) const
{
  return (mByteCapacity == rhs.mByteCapacity)
      && memcmp(this->mData, rhs.mData, mByteCapacity) == 0;
}
bool BitStream::operator !=(const BitStream& rhs) const
{
  return !(*this == rhs);
}
bool BitStream::operator  <(const BitStream& rhs) const
{
  return (mByteCapacity < rhs.mByteCapacity)
      || memcmp(this->mData, rhs.mData, mByteCapacity) < 0;
}

//
// Member Functions
//

void BitStream::Reserve(Bytes capacity)
{
  // Additional space requested?
  if(capacity > mByteCapacity)
    Reallocate(capacity, true);
}

void BitStream::Clear(bool freeMemory)
{
  if(freeMemory)
  {
    // Free memory
    if(mData)
      delete [] mData;
    Initialize();
  }
  else
  {
    // Zero memory
    if(mData)
      memset(mData, 0, mByteCapacity);
    mBitsWritten = 0;
    mBitsRead    = 0;
    mAlignment   = BitAlignment::Bit;
  }
}

//
// Write Operations
//

Bits BitStream::WriteBit(bool value)
{
  // Ensure there's enough space before writing
  ReallocateIfNecessary(1);

  // Get full bytes and remaining bits written
  Bytes fullBytesWritten = DIV8(mBitsWritten);
  Bits  remBitsWritten   = MOD8(mBitsWritten);

  // Write value at cursor
  byte* writeCursor = mData + fullBytesWritten;
  ASSIGN_LBIT(value, writeCursor, remBitsWritten);

  ++mBitsWritten;

  // Success
  return 1;
}
Bits BitStream::WriteBits(const byte* data, Bits dataBits)
{
  // There must be data to write
  Assert(data && dataBits);
  // Data size must not exceed maximum possible BitStream size
  Assert(dataBits <= BYTES_TO_BITS(BITSTREAM_MAX_BYTES));
  // Data must not overlap with internal BitStream memory
  Assert(!MemoryIsOverlapping(mData, mByteCapacity, data, BITS_TO_BYTES(dataBits)));

  // Byte Alignment?
  if(mAlignment == BitAlignment::Byte)
  {
    // Ensure we are byte aligned before continuing
    WriteUntilByteAligned();

    // Ensure the data is byte aligned before continuing
    Bits remDataBits = MOD8(dataBits);
    if(remDataBits) // Not byte aligned?
    {
      // Byte align data
      // (We simply end up writing extra bits from the data to write another full byte)
      dataBits += (8 - remDataBits);

      // Data should now be byte aligned
      Assert(!MOD8(dataBits));
    }
  }

  // Ensure there is enough space before continuing
  ReallocateIfNecessary(dataBits);

  // Get full bytes and remaining bits written
  Bytes fullBytesWritten       = DIV8(mBitsWritten);
  Bits  remBitsWritten         = MOD8(mBitsWritten);
  Bytes fullDataBytes          = DIV8(dataBits);
  Bits  remDataBits            = MOD8(dataBits);
  byte* writeCursor            = mData + fullBytesWritten;
  byte* dataCursor             = (byte*)data;
  bool  writeCursorByteAligned = !remBitsWritten;

  Assert(BYTES_TO_BITS(fullBytesWritten) + remBitsWritten == mBitsWritten
      && BYTES_TO_BITS(fullDataBytes)    + remDataBits    == dataBits);

  // Write full data bytes first (if any)
  if(writeCursorByteAligned && fullDataBytes)
  {
    // Byte aligned?
    // Write bytes using memcpy
    memcpy(writeCursor, dataCursor, fullDataBytes);
    dataCursor       += fullDataBytes;
    fullBytesWritten += fullDataBytes;
    writeCursor      += fullDataBytes;
  }
  else
  {
    // Not byte aligned?
    // Write bytes manually
    for(Bytes k = 0; k < fullDataBytes; ++k)
    {
      //Write a data byte
      for(Bits i = 0; i < 8; ++i)
      {
        // Write value at cursor
        ASSIGN_LBIT(*dataCursor & LBIT(i), writeCursor, remBitsWritten);

        ++remBitsWritten;

        // Write cursor reached a byte boundary?
        if(remBitsWritten == 8)
        {
          remBitsWritten = 0;
          ++fullBytesWritten;
          ++writeCursor;
        }
      }

      ++dataCursor;
    }
  }

  // Write remaining data bits second (if any)
  for(Bits i = 0; i < remDataBits; ++i)
  {
    // Write value at cursor
    ASSIGN_LBIT(*dataCursor & LBIT(i), writeCursor, remBitsWritten);

    ++remBitsWritten;

    // Write cursor reached a byte boundary?
    if(remBitsWritten == 8)
    {
      remBitsWritten = 0;
      ++fullBytesWritten;
      ++writeCursor;
    }
  }

  mBitsWritten += dataBits;

  // Success
  return dataBits;
}

Bits BitStream::WriteByte(uint8 value)
{
  return WriteBits((byte*)&value, BYTES_TO_BITS(1));
}
Bits BitStream::WriteBytes(const byte* data, Bytes dataBytes)
{
  return WriteBits(data, BYTES_TO_BITS(dataBytes));
}

Bits BitStream::Write(const String& value)
{
  return WriteBits((const byte*)value.c_str(), BYTES_TO_BITS(value.size() + 1));
}

Bits BitStream::WriteUntilByteAligned()
{
  // Not byte aligned?
  Bits remBitsWritten = MOD8(mBitsWritten);
  if(remBitsWritten)
  {
    // Write pad bits
    Bits padBits = 8 - remBitsWritten;
    for(Bits i = 0; i < padBits; ++i)
      WriteBit(false);

    // Write cursor should now be byte aligned
    Assert(!MOD8(mBitsWritten));

    // Success
    return padBits;
  }

  // Success
  return 0;
}

Bits BitStream::Append(const BitStream& bitStream, Bits dataBits)
{
  // Reserve space as necessary
  ReallocateIfNecessary(dataBits);

  // Append up to unread bits available
  dataBits = std::min(dataBits, bitStream.GetBitsUnread());
  if(dataBits == 0)
    return 0;
  Bits remAppendBits = dataBits;

  // Append non-byte-aligned bits (if any)
  Bits remBitsRead = MOD8(bitStream.mBitsRead);
  if(remBitsRead) // Not byte aligned?
  {
    // Read/Write bits
    bool value;
    Bits remBits = 8 - remBitsRead;
    for(Bits i = 0; i < remBits && remAppendBits; ++i, --remAppendBits)
    {
      // Read bit value from other bitstream
      if(!bitStream.ReadBit(value)) // Unable?
      {
        // Failure
        Unread(i);
        return 0;
      }

      // Write bit value to our bitstream
      WriteBit(value);
    }
  }

  // Append byte-aligned bits (if any)
  if(remAppendBits)
  {
    // Read cursor should now be byte aligned
    Assert(!MOD8(bitStream.mBitsRead));

    // Write remaining bits from their bitstream to ours
    WriteBits(bitStream.GetData() + DIV8(bitStream.mBitsRead), remAppendBits);
    bitStream.mBitsRead += remAppendBits; // Advance other bitstream's read cursor
    Assert(bitStream.mBitsRead <= bitStream.mBitsWritten);
  }

  // Success
  return dataBits;
}

Bits BitStream::TrimFront(Bits dataBits)
{
  Bits originalSize = GetBitsWritten();

  // Create trimmed copy and overwrite this
  BitStream copy;
  copy.Append(*this, dataBits);
  *this = ZeroMove(copy);

  // Success
  Assert(originalSize >= GetBitsWritten());
  return originalSize - GetBitsWritten();
}

//
// Read Operations
//

Bits BitStream::ReadBit(bool& value) const
{
  // No more bits available to read?
  if(!GetBitsUnread())
    return 0; // Failure

  // Get full bytes and remaining bits read
  Bytes fullBytesRead = DIV8(mBitsRead);
  Bits  remBitsRead   = MOD8(mBitsRead);

  // Read value at cursor
  const byte* readCursor = mData + fullBytesRead;
  value = *readCursor & LBIT(remBitsRead) ? true : false;

  ++mBitsRead;

  // Success
  return 1;
}
Bits BitStream::ReadBits(byte* data, Bits dataBits) const
{
  // There must be data to read
  Assert(data && dataBits);
  // Data size must not exceed maximum possible BitStream size
  Assert(dataBits <= BYTES_TO_BITS(BITSTREAM_MAX_BYTES));
  // Data must not overlap with internal BitStream memory
  Assert(!MemoryIsOverlapping(mData, mByteCapacity, data, BITS_TO_BYTES(dataBits)));

  // Byte Alignment?
  Bits bitsRead1 = 0;
  if(mAlignment == BitAlignment::Byte)
  {
    // Ensure we are byte aligned before continuing
    bitsRead1 = ReadUntilByteAligned();

    // Ensure the data is byte aligned before continuing
    Bits remDataBits = MOD8(dataBits);
    if(remDataBits) // Not byte aligned?
    {
      // Byte align data
      // (We simply end up reading extra bits from the data to read another full byte)
      dataBits += (8 - remDataBits);

      // Data should now be byte aligned
      Assert(!MOD8(dataBits));
    }
  }

  // Ensure there is enough unread data before continuing
  if(dataBits > GetBitsUnread())
  {
    // Failure
    Unread(bitsRead1);
    return 0;
  }

  // Zero data memory
  memset(data, 0, BITS_TO_BYTES(dataBits));

  // Get full bytes and remaining bits read
  Bytes fullBytesRead         = DIV8(mBitsRead);
  Bits  remBitsRead           = MOD8(mBitsRead);
  Bytes fullDataBytes         = DIV8(dataBits);
  Bits  remDataBits           = MOD8(dataBits);
  byte* readCursor            = mData + fullBytesRead;
  byte* dataCursor            = data;
  bool  readCursorByteAligned = !remBitsRead;

  Assert(BYTES_TO_BITS(fullBytesRead) + remBitsRead == mBitsRead
      && BYTES_TO_BITS(fullDataBytes) + remDataBits == dataBits);

  // Read full data bytes first (if any)
  if(readCursorByteAligned && fullDataBytes)
  {
    // Byte aligned?
    // Read bytes using memcpy
    memcpy(dataCursor, readCursor, fullDataBytes);
    dataCursor    += fullDataBytes;
    fullBytesRead += fullDataBytes;
    readCursor    += fullDataBytes;
  }
  else
  {
    // Not byte aligned?
    // Read bytes manually
    for(Bytes k = 0; k < fullDataBytes; ++k)
    {
      // Read a data byte
      for(Bits i = 0; i < 8; ++i)
      {
        // Write value at data cursor
        ASSIGN_LBIT(*readCursor & LBIT(remBitsRead), dataCursor, i);

        ++remBitsRead;

        // Read cursor reached a byte boundary?
        if(remBitsRead == 8)
        {
          remBitsRead = 0;
          ++fullBytesRead;
          ++readCursor;
        }
      }

      ++dataCursor;
    }
  }

  // Read remaining data bits second (if any)
  for(Bits i = 0; i < remDataBits; ++i)
  {
    // Write value at data cursor
    ASSIGN_LBIT(*readCursor & LBIT(remBitsRead), dataCursor, i);

    ++remBitsRead;

    // Read cursor reached a byte boundary?
    if(remBitsRead == 8)
    {
      remBitsRead = 0;
      ++fullBytesRead;
      ++readCursor;
    }
  }

  mBitsRead += dataBits;

  // Success
  return dataBits;
}

Bits BitStream::ReadByte(uint8& value) const
{
  return ReadBits((byte*)&value, BYTES_TO_BITS(1));
}
Bits BitStream::ReadBytes(byte* data, Bytes dataBytes) const
{
  return ReadBits(data, BYTES_TO_BITS(dataBytes));
}

Bits BitStream::Read(String& value) const
{
  // Peek string size
  Bytes stringBytes = PeekStringBytes();
  if(!stringBytes) // Unable?
  {
    // Failure
    return 0;
  }

  // Ignore NULL terminator for String
  --stringBytes;

  // Non-empty string?
  Bits bitsRead1 = 0;
  if(stringBytes)
  {
    // Allocate string node to write string into
    String::StringNode* node = String::allocateNode(stringBytes);

    // Read string
    bitsRead1 = ReadBits((byte*)node->Data, BYTES_TO_BITS(stringBytes));
    if(!bitsRead1)
    {
      // Failure
      node->release();
      return 0;
    }

    // Assign output string
    value = String(node);
  }
  else
  {
    // Clear output string
    value.clear();
  }

  // Skip NULL terminator for String
  Bits bitsRead2 = BYTES_TO_BITS(1);
  mBitsRead += bitsRead2;

  // Success
  return bitsRead1 + bitsRead2;
}

Bytes BitStream::PeekStringBytes() const
{
  // Store original read cursor
  Bits origBitsRead = mBitsRead;

  // Read bytes until NULL
  uint8 value;
  Bytes stringBytes = 0;
  do
  {
    // Unable?
    if(!ReadByte(value))
      return 0; // Failure

    ++stringBytes;

  } while(value);

  // Restore original read cursor
  mBitsRead = origBitsRead;

  // Success
  return stringBytes;
}

Bits BitStream::ReadUntilByteAligned() const
{
  // Not byte aligned?
  Bits remBitsRead = MOD8(mBitsRead);
  if(remBitsRead)
  {
    // Read pad bits
    bool padValue;
    Bits padBits = 8 - remBitsRead;
    for(Bits i = 0; i < padBits; ++i)
    {
      if(!ReadBit(padValue)) // Unable?
      {
        // Failure
        Unread(i);
        return 0;
      }
    }

    // Read cursor should now be byte aligned
    Assert(!MOD8(mBitsRead));

    // Success
    return padBits;
  }

  // Success
  return 0;
}

//
// Helper Functions
//

void BitStream::Initialize()
{
  mData         = nullptr;
  mByteCapacity = 0;
  mBitsWritten  = 0;
  mBitsRead     = 0;
  mAlignment    = BitAlignment::Bit;
}
void BitStream::ReallocateIfNecessary(Bits additionalBits)
{
  // Need to reallocate to fit the additional bits?
  if(BYTES_TO_BITS(mByteCapacity) < mBitsWritten + additionalBits)
  {
    const Bytes growSize = (Bytes)(mByteCapacity * 2) + BITS_TO_BYTES(additionalBits);

    // First allocation?
    if(!mByteCapacity)
      Reallocate(std::max(growSize, (Bytes)BITSTREAM_DEFAULT_RESERVE_BYTES), true); // Use whichever is larger
    else
      Reallocate(growSize, true);
  }
}
void BitStream::Reallocate(Bytes capacity, bool copyData)
{
  Assert(capacity <= BITSTREAM_MAX_BYTES);

  byte* temp         = mData;
  Bytes tempCapacity = GetByteCapacity();
  mData              = new byte[capacity];
  mByteCapacity      = capacity;

  Assert(mByteCapacity > tempCapacity);

  // First allocation?
  if(!temp)
    memset(mData, 0, mByteCapacity); // Zero memory
  // Copying data?
  else if(copyData)
  {
    memcpy(mData, temp, tempCapacity);                             // Copy previous memory space
    memset(mData + tempCapacity, 0, mByteCapacity - tempCapacity); // Zero the rest
  }

  if(temp)
    delete [] temp;
}

String GetBinaryString(const BitStream& bitStream, Bytes bytesPerLine)
{
  StringBuilder result;
  bitStream.ClearBitsRead();

  bool bitSet;
  Bits  bitCount  = 0;
  Bytes byteCount = 0;
  while(bitStream.Read(bitSet))
  {
    // Space every 8 bits
    if(bitCount == 8)
    {
      bitCount = 0;
      ++byteCount;

      // BytesPerLine enabled and has been reached?
      if(bytesPerLine && byteCount == bytesPerLine)
      {
        // Newline
        result += '\n';
        byteCount = 0;
      }
      else // Space
        result += ' ';
    }

    // Output the bit
    result += bitSet ? '1' : '0';
    ++bitCount;
  }

  bitStream.ClearBitsRead();
  return result.ToString();
}

} // namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file ByteBuffer.cpp
/// Definition of ByteBuffer.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


namespace Zero
{

//------------------------------------------------------------ Block Range 

ByteBuffer::BlockRange::BlockRange(ByteBuffer* buffer)
{
  mBlock = buffer->mBlocks.data();
  mLast = buffer->mBlocks.end();
  mBlockSize = buffer->mBlockSize;
  mLastBlockSize = buffer->mCurBlockSize;
}

const ByteBuffer::Block& ByteBuffer::BlockRange::front()
{
  ErrorIf(empty(),"Read empty range.");
  loadBlock();
  return mCurrent;
}

bool ByteBuffer::BlockRange::empty()
{
  return mBlock >= mLast;
}

void ByteBuffer::BlockRange::loadBlock()
{
  mCurrent.Size = mBlock == (mLast-1) ? mLastBlockSize : mBlockSize;
  mCurrent.Data = *mBlock;
}

void ByteBuffer::BlockRange::popFront()
{
  ErrorIf(empty(),"Popped and empty range.");
  ++mBlock;
}

//------------------------------------------------------------ Byte Buffer 

ByteBuffer::ByteBuffer(size_t blockSize)
{
  mTotalSize = 0;
  mCurBlockSize = 0;
  mCurBlockBuffer = NULL;
  mBlockSize = blockSize;
}

ByteBuffer::~ByteBuffer()
{
  Deallocate();
}

ByteBuffer::BlockRange ByteBuffer::Blocks()
{
  return BlockRange(this);
}

size_t ByteBuffer::Tell()
{
  return mTotalSize;
}

void ByteBuffer::Write(const byteType* data, size_t sizeInBytes)
{
  Append(data, sizeInBytes);
}

void ByteBuffer::Append(const byteType* data, size_t sizeInBytes)
{
  if(mCurBlockBuffer==NULL)
  {
    //Allocator more memory
    mCurBlockBuffer = (byteType*)zAllocate(mBlockSize);
    mCurBlockSize = 0;

    //Store the block
    mBlocks.push_back(mCurBlockBuffer);

  }

  while(mCurBlockSize + sizeInBytes > mBlockSize)
  {
    //Partial copy to remaining area of block
    size_t sizeToCopy = mBlockSize - mCurBlockSize;

    //Copy into data block
    memcpy(mCurBlockBuffer + mCurBlockSize, data, sizeToCopy);

    //Allocator more memory
    mCurBlockBuffer = (byteType*)zAllocate(mBlockSize);
    mCurBlockSize = 0;

    //Store the block
    mBlocks.push_back(mCurBlockBuffer);

    //Decrement bytes copied and try again
    sizeInBytes-=sizeToCopy;
    mTotalSize+=sizeToCopy;
    data+=sizeToCopy;
  }

  //Is there any more data to be copied?
  if(sizeInBytes > 0)
  {
    memcpy(mCurBlockBuffer + mCurBlockSize, data, sizeInBytes);
    mCurBlockSize+=sizeInBytes;
    mTotalSize+=sizeInBytes;
  }

}

void ByteBuffer::Backup(size_t sizeInBytes)
{
  ErrorIf(sizeInBytes > mTotalSize, "Attempting to back-up more than the total size of the ByteBuffer");

  mTotalSize -= sizeInBytes;

  while(sizeInBytes > mCurBlockSize)
  {
    delete mBlocks.back();
    mBlocks.pop_back();

    sizeInBytes -= mCurBlockSize;

    mCurBlockBuffer = mBlocks.back();
    mCurBlockSize = mBlockSize;
  }

  mCurBlockSize -= sizeInBytes;
}

byte ByteBuffer::operator[](size_t index) const
{
  return (*(ByteBuffer*)this)[index];
}

byte& ByteBuffer::operator[](size_t index)
{
  ErrorIf(index > mTotalSize, "ByteBuffer index out of bounds");

  size_t outerIndex = index / mBlockSize;
  size_t innerIndex = index % mBlockSize;

  return mBlocks[outerIndex][innerIndex];
}

void ByteBuffer::ExtractInto(byteType* byteBuffer, size_t bufferSizeInBytes) const
{
  ErrorIf(mTotalSize > bufferSizeInBytes, "Buffer is not large enough for data.");
  if(mTotalSize > bufferSizeInBytes)
    return;//Do nothing

  //unreferenced formal parameter in release
  (void)bufferSizeInBytes;

  //Copy over all blocks
  byteType* bufferPosition = byteBuffer;
  Array<byteType*>::range blocks = mBlocks.all();
  for(;!blocks.empty();blocks.popFront())
  {
    size_t blockSize = blocks.front() == mCurBlockBuffer ? mCurBlockSize : mBlockSize;
    memcpy(bufferPosition, blocks.front(), blockSize);
    bufferPosition+=mBlockSize;
  }

}

void ByteBuffer::ExtractInto(ByteBufferBlock& buffer) const
{
  buffer.Deallocate();
  buffer.mSize = mTotalSize;
  buffer.mData = (byte*)zAllocate(mTotalSize);
  buffer.mCurrent = buffer.mData;
  buffer.mOwnsData = true;
  ExtractInto(buffer.mData, buffer.mSize);
};

void ByteBuffer::Deallocate()
{
  //Deallocate all blocks
  Array<byteType*>::range blocks = mBlocks.all();
  for(;!blocks.empty();blocks.popFront())
  {
    zDeallocate(blocks.front());
  }

  mCurBlockSize = 0;
  mCurBlockBuffer = NULL;
  mBlocks.clear();
  mTotalSize = 0;
}

//------------------------------------------------------------ ByteBufferBlock

ByteBufferBlock::ByteBufferBlock()
{
  mData = NULL;
  mCurrent = NULL;
  mSize = 0;
  mOwnsData = false;
}

ByteBufferBlock::ByteBufferBlock(size_t size)
{
  mData = (byte*)zAllocate(size);
  mCurrent = mData;
  mSize = size;
  mOwnsData = true;
}

ByteBufferBlock::ByteBufferBlock(byte* data, size_t size, bool owned)
{
  mData = data;
  mCurrent = data;
  mSize = size;
  mOwnsData = owned;
}

void ByteBufferBlock::SetData(byte* data, size_t size, bool owned)
{
  Deallocate();
  mData = data;
  mCurrent = data;
  mSize = size;
  mOwnsData = owned;
}

void ByteBufferBlock::SetBlock(DataBlock block)
{
  Deallocate();
  mData = block.Data;
  mCurrent = block.Data;
  mSize = block.Size;
  mOwnsData = false;
}

ByteBufferBlock::~ByteBufferBlock()
{
  Deallocate();
}

void ByteBufferBlock::Deallocate()
{
  if(mData && mOwnsData)
    zDeallocate(mData);

  mData = NULL;
  mCurrent = NULL;
  mSize = 0;
  mOwnsData = false;
}

void ByteBufferBlock::Seek(int offset, uint /*origin*/)
{
  mCurrent += offset;
}

size_t ByteBufferBlock::Read(byte* data, size_t sizeInBytes)
{
  ErrorIf(mCurrent + sizeInBytes > mData + mSize, "Buffer Overflow Read");
  memcpy(data, mCurrent, sizeInBytes);
  mCurrent+=sizeInBytes;
  return sizeInBytes;
}

size_t ByteBufferBlock::Write(byte* data, size_t sizeInBytes)
{
  ErrorIf(mCurrent+sizeInBytes > mData+mSize, "Buffer Overflow Write");
  memcpy(mCurrent, data, sizeInBytes);
  mCurrent+=sizeInBytes;
  return sizeInBytes;
}

size_t ByteBufferBlock::Write(byte value)
{
  return Write(&value, 1);
}

size_t ByteBufferBlock::Size()
{
  return mSize;
}

byte* ByteBufferBlock::GetCurrent()
{
  return mCurrent;
}

size_t ByteBufferBlock::Tell()
{
  return mCurrent - mData;
}

byte* ByteBufferBlock::GetBegin()
{
  return mData;
}

String ByteBuffer::ToString() const
{
  size_t bufferSize = GetSize();

  // A string nodes already contains (and sets) the last null terminator
  String::StringNode* node = String::allocateNode(bufferSize);

  //Copy data into buffer
  ExtractInto((byte*)node->Data, bufferSize);

  return String(node);
}

}
///////////////////////////////////////////////////////////////////////////////
///
/// \file Console.cpp
/// Implementation of the Console
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <stdarg.h>



namespace Zero
{

ConsoleListener::~ConsoleListener()
{
  Console::Remove(this);
};

Array<ConsoleListener*> ConsoleListeners;

void Console::PrintVa(Filter::Enum filter, cstr format, va_list args)
{
  //Get the number of characters needed
  int bufferSize;
  ZeroVSPrintfCount(format, args, 1, bufferSize);

  if(bufferSize > 0)
  {
    char* messageBuffer = (char*)alloca((bufferSize + 1) * sizeof(char));
    ZeroVSPrintf(messageBuffer, bufferSize, format, args);

    PrintRaw(filter, messageBuffer);
  }
}

void Console::Print(Filter::Enum filter, cstr format, ...)
{
  va_list args;
  va_start(args, format);
  PrintVa(filter, format, args);
  va_end(args);
}

void Console::PrintRaw(Filter::Enum filter, cstr messageBuffer)
{
  forRange(ConsoleListener* listener, ConsoleListeners.all())
    listener->Print(filter, messageBuffer);
}

void Console::FlushAll()
{
  forRange(ConsoleListener* listener, ConsoleListeners.all())
    listener->Flush();
}

void Console::Add(ConsoleListener* listener)
{
  ConsoleListeners.push_back(listener);
}

void Console::Remove(ConsoleListener* listener)
{
  size_t index = ConsoleListeners.findIndex(listener);
  if(index < ConsoleListeners.size())
    ConsoleListeners.eraseAt(index);
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Diagnostic.cpp
/// Implementation of the basic debug diagnostic functions.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <stdarg.h>

namespace Zero
{

const int cDebugBufferLength = 1024;

bool DefaultErrorHandler(ErrorSignaler::ErrorData& errorData)
{
  char buffer[cDebugBufferLength];
  ZeroSPrintf(buffer, cDebugBufferLength, "%s(%d) : %s %s\n", errorData.File, 
            errorData.Line, errorData.Message, errorData.Expression);
  Console::Print(Filter::ErrorFilter, buffer);
  return true;
}

ErrorSignaler::ErrorHandler ErrorSignaler::activeErrorHandler = DefaultErrorHandler;

bool ErrorSignaler::SignalError(SignalErrorType signalType, cstr exp,
                               cstr file, int line, bool& ignore, 
                               cstr msgFormat, ...)
{
  if(ignore)
    return false;

  ErrorData errorData;
  errorData.Line = line;
  errorData.File = file;
  errorData.Expression = exp;
  errorData.ErrorType = signalType;
  errorData.Message = NULL;
  errorData.IgnoreFutureAssert = false;

  if(msgFormat != NULL)
  {
    va_list args;
    va_start(args, msgFormat);
    //Get the number of characters needed for message
    int bufferSize;
    ZeroVSPrintfCount(msgFormat, args, 1, bufferSize);

    char* messageBuffer = (char*)alloca((bufferSize+1)*sizeof(char));
    ZeroVSPrintf(messageBuffer, bufferSize+1, msgFormat, args);
    va_end(args);
    errorData.Message = messageBuffer;
  }

  bool result = (*activeErrorHandler)(errorData);
  ignore = errorData.IgnoreFutureAssert;
  return result;
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Block.cpp
/// Implementation of the block memory manger and allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{
namespace Memory
{

byte Block::BucketLookUp[cMaxBlockSize+1];
bool Block::SizeTableInitialized = false;

size_t Block::BlockSizes[cBlockCount] = 
{
  16,//[0]
  32,//[1]
  64,//[2]
  96,//[3]
  128,//[4]
  160,//[5]
  192,//[6]
  224,//[7]
  256,//[8]
  320,//[9]
  384,//[10]
  448,//[11]
  512,//[12]
  640,//[13]
};

Block::Block(StringRange name, Graph* parent)
  :Graph(name, parent)
{
  for(size_t i=0;i<cBlockCount;++i)
    mBlockArray[i] = NULL;

  if(!SizeTableInitialized)
  {
    size_t currentBlock = 0;
    for(size_t i=0;i<cMaxBlockSize+1;++i)
    {
      if(i>BlockSizes[currentBlock])
        ++currentBlock;

      BucketLookUp[i] = (byte)currentBlock;
    }

    SizeTableInitialized = true;
  }
}

Block::~Block()
{
  CleanUp();
}

MemPtr Block::Allocate(size_t numberOfBytes)
{
  AddAllocation(numberOfBytes);

  //Determine what bucket to use
  ErrorIf(numberOfBytes > cMaxBlockSize, "Size is larger than max block size. "
    "This allocator can only allocate small objects");

  size_t bucketIndex = BucketLookUp[numberOfBytes];

  return PopOnFreeList(bucketIndex);
}

Block::FreeBlock* Block::PopOnFreeList(size_t blockIndex)
{
  if(mBlockArray[blockIndex]==NULL)
    AllocateBlockPage(blockIndex);

  FreeBlock* block = mBlockArray[blockIndex];
  mBlockArray[blockIndex] = block->NextBlock;

  return block;
}

void Block::Deallocate(MemPtr ptr, size_t numberOfBytes)
{
  RemoveAllocation(numberOfBytes);

  //Determine what bucket to use
  ErrorIf(numberOfBytes > cMaxBlockSize, "Size is larger than max block size. "
    "This allocator can only allocate small objects");

  size_t bucketIndex = BucketLookUp[numberOfBytes];
  PushFreeBlock(bucketIndex, (FreeBlock*)ptr);
}

void Block::PushFreeBlock(size_t blockIndex, FreeBlock* block)
{
  block->NextBlock = mBlockArray[blockIndex];
  mBlockArray[blockIndex] = block;
}

void Block::AllocateBlockPage(size_t blockIndex)
{
  size_t blockSize = BlockSizes[blockIndex];
  size_t blocksOnPage = cPageSize / blockSize;

  byte* memoryPage = (byte*)zAllocate(cPageSize);
  DeltaDedicated(cPageSize);

  for(size_t i=0;i<blocksOnPage;++i)
    PushFreeBlock(blockIndex, (FreeBlock*)(memoryPage+blockSize*i));

  mPageBlocks.push_back(memoryPage);
}

void Block::Print(size_t tabs, size_t flags)
{
  PrintHelper(tabs, flags, "Block");
}

void Block::CleanUp()
{
  Array<MemPtr>::range blocksToFree = mPageBlocks.all();
  while(!blocksToFree.empty())
  {
    zDeallocate(blocksToFree.front());
    blocksToFree.popFront();
  }
  mPageBlocks.clear();
}

}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Graph.cpp
/// Implementation of the Memory Graph.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




#include <stdlib.h>

#ifdef UseMemoryDebugger
#include "Allocations.hpp" //@ignore (for the compactor turning this into a single hpp/cpp)
#endif

#ifdef UseMemoryTracker
#include "Allocations.hpp" //@ignore (for the compactor turning this into a single hpp/cpp)
#endif

namespace Zero
{

void* zAllocate(size_t numberOfBytes)
{
#ifdef UseMemoryDebugger
  return DebugAllocate(numberOfBytes, AllocationType_Direct, 4);
#elif UseMemoryTracker
  return DebugAllocate(numberOfBytes, 4);
#else
  return malloc(numberOfBytes);
#endif
}

void zDeallocate(void* ptr)
{
#ifdef UseMemoryDebugger
  DebugDeallocate(ptr, AllocationType_Direct);
#elif UseMemoryTracker
  return DebugDeallocate(ptr);
#else
  return free(ptr);
#endif
}

const uint cStaticMemoryBufferSize = 5000;
byte StaticMemoryGraphBuffer[cStaticMemoryBufferSize];
byte* BufferLocation = StaticMemoryGraphBuffer;

MemPtr zStaticAllocate(size_t size)
{
  //Static Memory graph nodes and other static objects
  //are allocated from a fixed size buffer this allows them to have controlled 
  //or optional initialization and prevents them from showing up in leaks
  ErrorIf(BufferLocation >= StaticMemoryGraphBuffer + cStaticMemoryBufferSize,
    "Allocated too many memory graph objects. Increase cStaticMemoryBufferSize.");
  byte* current = BufferLocation;
  BufferLocation+=size;
  //DebugPrint("Max Static Memory %d\n", uint(BufferLocation - StaticMemoryGraphBuffer));
  return current;
}

namespace Memory
{
//------------------------------------------------------------------------ Stats
Stats::Stats()
  : Allocations(0),
    Active(0),
    BytesAllocated(0),
    BytesDedicated(0),
    PeakAllocated(0)
{
}

#define VisitByName(name) vistor(#name, name)

template<typename Vistor>
void Stats::Visit(Vistor& vistor, size_t flags)
{
  if(flags & ShowActive)
    VisitByName(Active);

  if(flags & ShowCount)
    VisitByName(Allocations);

  if(flags & ShowBytes)
    VisitByName(BytesAllocated);

  if(flags & ShowDedicated)
    VisitByName(BytesDedicated);

  if(flags & ShowPeak)
    VisitByName(PeakAllocated);
}

#undef VisitByName

void Stats::Accumulate(const Stats& right)
{
  Allocations += right.Allocations;
  Active += right.Active;
  BytesAllocated += right.BytesAllocated;
  BytesDedicated += right.BytesDedicated;
  PeakAllocated += right.PeakAllocated;
}


Root* Root::RootGraph = NULL;
Heap* Root::GloblHeap = NULL;
Heap* Root::StaticHeap = NULL;

void Shutdown()
{
  GetRoot()->CleanUp();
}

void Root::Shutdown()
{
  //Only delete the root
  //the root graph node will delete all child graph
  //nodes and clean up memory.
  if(RootGraph != NULL)
  {
    delete RootGraph;
    RootGraph = NULL;
  }
}

void DumpMemoryDebuggerStats(cstr projectName) 
{
#ifdef UseMemoryDebugger
  BuildVerySleepyStats_ActiveAllocations(projectName);
#elif UseMemoryTracker
  OutputActiveAllocations("MyProject", VerySleepy_0_90);
#endif
}

void Root::Initialize()
{
#ifdef UseMemoryDebugger
  InitializeMemory();
#endif

  if(RootGraph==NULL)
  {
    RootGraph = new Root("Root", NULL);
    StaticHeap = new Heap("Static", RootGraph);
    GloblHeap = new Heap("Global", RootGraph);
  }
}

Root* GetRoot()
{
  Root::Initialize();
  return Root::RootGraph;
}

Heap* GetGlobalHeap()
{
  Root::Initialize();
  return Root::GloblHeap;
}

Heap* GetStaticHeap()
{
  Root::Initialize();
  return Root::StaticHeap;
}

const size_t maxTabs = 10;
const size_t tabSize = 2;

void Root::PrintAll()
{
  if(RootGraph)
    Root::RootGraph->PrintGraph(Stats::ShowBytes | Stats::ShowTotal | Stats::ShowActive);
}

class VistPrinter
{
public:
  void operator()(cstr /*name*/, MemCounterType var)
  {
    DebugPrint("%16u", var);
  }
};

class VistNamePrinter
{
public:
  void operator()(cstr name, MemCounterType /*var*/)
  {
    DebugPrint("%16s", name);
  }
};

Graph::Graph(StringRange name, Graph* parent)
  : Name(name),
  mParent(parent)
{
  if(parent != NULL)
    parent->Children.push_back(this);
}

void Graph::PrintHeader(size_t flags)
{
  //DebugPrint("%-*s", maxTabs*tabSize, "Name" );

  VistNamePrinter p;

  if(flags & Stats::ShowLocal)
    mData.Visit(p, flags);

  if(flags & Stats::ShowTotal)
    mData.Visit(p, flags);

  DebugPrint("\n");
}

void Graph::CleanUp()
{
  InListBaseLink<Graph>::range sub = Children.all();
  while(!sub.empty())
  {
    sub.front().CleanUp();
    sub.popFront();
  }
}

void Graph::PrintHelper(size_t tabs, size_t flags, cstr /*name*/)
{
  size_t tabWidth = tabs * tabSize;
  size_t nameWidth = (maxTabs - tabs) * tabSize;

  Stats total;
  this->Compute(total);

  DebugPrint("%*s%-*s", tabWidth, "", nameWidth, Name.c_str());
  VistPrinter p;

  if(flags & Stats::ShowLocal)
    mData.Visit(p, flags);

  if(flags & Stats::ShowTotal)
    total.Visit(p, flags);

  DebugPrint("\n");

  InListBaseLink<Graph>::range sub = Children.all();
  while(!sub.empty())
  {
    sub.front().Print(tabs+1, flags);
    sub.popFront();
  }
}

void Graph::Compute(Stats& data)
{
  data.Accumulate(mData);
  InListBaseLink<Graph>::range sub = Children.all();
  while(!sub.empty())
  {
    sub.front().Compute(data);
    sub.popFront();
  }
}

void Graph::PrintGraph(size_t flags)
{
  PrintHeader(flags);
  Print(0, flags);
}

void Graph::Print(size_t tabs, size_t flags)
{
  PrintHelper(tabs, flags, "Main");
};

Graph::~Graph()
{
  DeleteObjectsIn(Children);
}

Heap* GetNamedHeap(cstr name)
{
  Root::Initialize();

  StringTokenRange tokens(name, '.');
  Graph* current = Root::RootGraph;
  Graph* parent = NULL;
  StringRange token = StringRange(name);
  while(!tokens.empty() && current!=NULL)
  {
    parent = current;
    current = NULL;

    InListBaseLink<Graph>::range managers = parent->Children.all();

    token = tokens.front();
    while(!managers.empty())
    {
      if(managers.front().Name == token)
        current = &managers.front();
      managers.popFront();
    }

    if(current == NULL)
      current = new Heap(token, parent);

    tokens.popFront();
  }

  return (Heap*)current;
}

}//namespace Memory

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Heap.cpp
/// Implementation of the Heap Allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
namespace Memory
{

//------------------------------------------------------------------------- Heap
Heap::Heap(StringRange name, Graph* parent)
  : Graph(name, parent)
{
  //
}

MemPtr Heap::Allocate(size_t numberOfBytes)
{
  AddAllocation(numberOfBytes);
  MemPtr mem = zAllocate(numberOfBytes);
  return mem;
}

void Heap::Deallocate(MemPtr ptr, size_t numberOfBytes)
{
  RemoveAllocation(numberOfBytes);
  zDeallocate(ptr);
}

void Heap::Print(size_t tabs, size_t flags)
{
  PrintHelper(tabs, flags, "Heap");
}

}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Pool.cpp
/// Implementation of the pool memory manger and allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{
namespace Memory
{

Pool::Pool(StringRange name, Graph* parent, size_t blockSize, size_t blocksPerPage)
  :Graph(name, parent)
{
  //ErrorIf(parent == NULL,"Memory pool needs a parent node "
  //                       "otherwise it will not be deallocated.");
  mNextFreeBlock = NULL;
  mBlockSize = blockSize;
  mBlocksPerPage = blocksPerPage;
  mPageSize = blockSize*blocksPerPage;
}

void Pool::AllocatePage()
{
  //Allocate a new page of memory and 
  //divide it into blocks that are 
  //each placed on the free list.
  DeltaDedicated(mPageSize);
  byte* memoryPage = (byte*)zAllocate(mPageSize);
  mPages.push_back(memoryPage);
  for(unsigned block=0;block<mBlocksPerPage;++block)
    PushOnFreeList(memoryPage+mBlockSize*block);
}

void Pool::CleanUp()
{
  //ErrorIf(mData.BytesAllocated!=0, "Failed to release all memory from pool %s", Name.c_str());
  //Deallocate each page
  for(unsigned i=0;i<mPages.size();++i)
    zDeallocate(mPages[i]);//mPageSize
  mPages.deallocate();
}

Pool::~Pool()
{
  CleanUp();
}

MemPtr Pool::Allocate(size_t numberOfBytes)
{
  //Allocate memory by pop a block off the free list.
  ErrorIf(numberOfBytes > mBlockSize, "Allocation is large than block size.");
  AddAllocation(mBlockSize);
  return PopOnFreeList();
}

void Pool::Deallocate(MemPtr ptr, size_t /*numberOfBytes*/)
{
  //Deallocate memory by push a block on the free list.
  RemoveAllocation(mBlockSize);
  PushOnFreeList(ptr);
}

MemPtr Pool::PopOnFreeList()
{
  //No blocks left allocate a new page.
  if(mNextFreeBlock==NULL)
    AllocatePage();

  //Pop the block
  FreeBlock* block = (FreeBlock*)mNextFreeBlock;
  mNextFreeBlock = block->NextBlock;
  return block;
}

void Pool::PushOnFreeList(MemPtr ptr)
{
  //Push the block
  FreeBlock* block = (FreeBlock*)ptr;
  block->NextBlock = mNextFreeBlock;
  mNextFreeBlock = block;
}

void Pool::Print(size_t tabs, size_t flags)
{
  PrintHelper(tabs, flags, "Pool");
}

}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Stack.cpp
/// Implementation of the Stack memory allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
namespace Memory
{

Stack::Stack(StringRange name, Graph* parent, size_t stackSize, size_t maxEntries)
  :Graph(name, parent)
{
  mStackSize = stackSize;
  mMaxEntries = maxEntries;

  if(StackDebug)
  {
    mEntries.reserve(maxEntries);
  }

  mStackHeader = (byte*)zAllocate(mStackSize);
  mStackIndex = 0;
  mMaxSizeReached = 0;
}

Stack::~Stack()
{
  CleanUp();
}

void Stack::Print(size_t tabs, size_t flags)
{
  PrintHelper(tabs, flags, "Stack");
}

MemPtr Stack::Allocate(size_t numberOfBytes)
{
  AddAllocation(numberOfBytes);

  if(StackDebug)
  {
    ErrorIf(mEntries.size() == mMaxEntries, "Maximun number of stack entries reached."
           "Expand the max entries.");

    ErrorIf(mStackIndex + numberOfBytes > mStackSize, "All memory used in stack."
            "Expand the starting size.");
  }

  byte* curHead = mStackHeader+mStackIndex;
  mStackIndex += numberOfBytes;

  if(StackDebug)
  {
    if(mMaxSizeReached < mStackIndex)
      mMaxSizeReached = mStackIndex;

    mEntries.push_back(Entry(curHead, numberOfBytes));
  }

  return curHead;
}

void Stack::Deallocate(MemPtr ptr, size_t numberOfBytes)
{
  if(StackDebug)
  {
    Entry& entry = mEntries.back();
    ErrorIf(entry.Ptr != ptr, "Stack deallocation out of order. Stack items"
            " must be deleted in proper stack order, first in last out.");
    ErrorIf(entry.Size != numberOfBytes, "Bad sized passed to deallocate.");
    mEntries.pop_back();
  }

  mStackIndex-=numberOfBytes;
}

void Stack::CleanUp()
{
  zDeallocate(mStackHeader);
}

}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Regex.cpp
/// Implementation of the Regex class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
Matches::Matches()
{
  mPrivate = nullptr;
}

Matches::Matches(const Matches& source)
{
  mPrivate = nullptr;
}

Matches::~Matches()
{
}

void Matches::clear()
{
}

size_t Matches::size() const
{
  return 0;
}

bool Matches::empty() const
{
  return true;
}

StringRange Matches::operator[](size_t index) const
{
  return StringRange();
}

StringRange Matches::front() const
{
  return StringRange();
}

StringRange Matches::back() const
{
  return StringRange();
}

StringRange Matches::Prefix() const
{
  return StringRange();
}

StringRange Matches::Suffix() const
{
  return StringRange();
}

String Matches::Format(StringRange format) const
{
  return String();
}

void Matches::Format(StringRange format, StringBuilder& builder) const
{
}

Regex::Regex()
{
  mPrivate = nullptr;
}

Regex::Regex(StringRange regexStr, RegexFlavor::Enum flavor, bool caseSensitive, bool optimizeForMatching)
{
  mPrivate = nullptr;
}

Regex::Regex(const Regex& source)
{
  mPrivate = nullptr;
}

Regex::~Regex()
{
}

Regex& Regex::operator=(const Regex& source)
{
  return *this;
}

bool Regex::Validate(StringRange regexStr, RegexFlavor::Enum flavor, bool caseSensitive)
{
  return false;
}

void Regex::Search(StringRange text, Matches& matches, RegexFlags::Type flags) const
{
}

String Regex::Replace(StringRange source, StringRange replaceWith) const
{
  return source;
}

String Regex::Escape(StringRange input, EscapeMode::Enum mode, RegexFlavor::Enum flavor)
{
  return input;
}
}///////////////////////////////////////////////////////////////////////////////
///
/// \file CharacterTraits.cpp
/// Used to convert strings into values.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#include <ctype.h>

namespace Zero
{

const uint CharacterTableSize = 128;
typedef int (*ControlFunction)(int c);

class CharacterTable
{
public:
  CharacterTable()
  {
    // clear all states to zero
    for(uint i=0;i<CharacterTableSize;++i)
      CharacterTrait[i] = 0;

    // fill out the state bits
    Annotate(isgraph, CharacterBits::Graphical);
    Annotate(isalpha, CharacterBits::Alpha);
    Annotate(isdigit, CharacterBits::Number);
    Annotate(isspace, CharacterBits::WhiteSpace);
    Annotate(islower, CharacterBits::Lower);
    Annotate(ispunct, CharacterBits::Symbol);
    Annotate(iscntrl, CharacterBits::Control);
  }

  // Get the character state
  int GetTraits(int c)
  {
    if(c >= 0 && c <128)
      return CharacterTrait[c];
    return 0;
  }

private:
  void Annotate(ControlFunction c, u32 bit)
  { 
    for(uint i=0;i<CharacterTableSize;++i)
    {
      if((*c)((int)i))
      {
        CharacterTrait[i] |= bit;
      }
    }
  }

  char CharacterTrait[CharacterTableSize];
};

CharacterTable t;
int IsSpace(int c){ return t.GetTraits(c) & CharacterBits::WhiteSpace; }
int IsGraph(int c){ return t.GetTraits(c) & CharacterBits::Graphical; }
int IsGraphOrSpace(int c){return t.GetTraits(c) & (CharacterBits::Graphical | CharacterBits::WhiteSpace);}
int IsAlpha(int c){ return t.GetTraits(c) & CharacterBits::Alpha; }
int IsDigit(int c){ return t.GetTraits(c) & CharacterBits::Number; }
int IsNumber(int c){ return t.GetTraits(c) & CharacterBits::Number; }
int IsAlphaNumeric(int c){ return t.GetTraits(c) & (CharacterBits::Alpha | CharacterBits::Number); }
int IsLower(int c){ return t.GetTraits(c) & CharacterBits::Lower; }
int IsUpper(int c){ return !(t.GetTraits(c) & CharacterBits::Lower); }
int IsSymbol(int c){ return t.GetTraits(c) & CharacterBits::Symbol; }
int IsControl(int c){ return t.GetTraits(c) & CharacterBits::Control; }
int GetTrait(int c){ return t.GetTraits(c); }
int ToLower(int c){ return tolower(c); }
int ToUpper(int c){ return toupper(c); }

};
///////////////////////////////////////////////////////////////////////////////
///
/// \file String.cpp
/// Implementation of the referenced string class.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////





namespace Zero
{

size_t HashString(const char* str, size_t l)
{
  size_t h = l;
  // if string is too long, don't hash all its chars
  size_t step = (l >> 5) + 1;
  size_t l1;
  for (l1 = l; l1 >= step; l1 -= step)  /* compute hash */
    h = h ^ ((h << 5) + (h >> 2) + byte(str[l1 - 1]));
  return h;
}

bool CaseSensitiveCompare(char a, char b)
{
  return a == b;
}

bool CaseInsensitiveCompare(char a, char b)
{
  return tolower(a) == tolower(b);
}


String::String()
{
  initializeToDefault();
}

void String::initializeToDefault()
{
  static StringNode node = { 1, 0, 0, {0} };
  assign(&node);
}

void String::assign(const_pointer data, size_type size)
{
  StringNode* node = allocateNode(size);
  memcpy(node->Data, data, size);
  node->HashCode = HashString(data, size);
  //Assign value
  mNode = node;
}

void String::assign(StringNode* node)
{
  mNode = node;
  addRef();
}


void String::StringNode::addRef()
{
  AtomicPreIncrement(&RefCount);
}

void String::StringNode::release()
{
  if(AtomicPreDecrement(&RefCount) == 0)
    zDeallocate(this);
}

bool String::StringNode::isEqual(StringNode* l, StringNode* r)
{
  if(!(l == r))
  {
    if(l->Size == r->Size &&
        l->HashCode == r->HashCode && 
        strcmp(l->Data, r->Data) == 0)
    {
      return true;
    }
    else
    {
      return false;
    }
  }
  else
  {
    return true;
  }
}

void String::addRef()
{
  mNode->addRef();
}

void String::release()
{
  if(mNode)
    mNode->release();
}

String::StringNode* String::allocateNode(size_type size)
{
  const size_type nodeSize = 
                             sizeof(StringNode) //size of the string node
                           - sizeof(value_type);//remove the extra

  //size of buffer is string size plus once extra buffer
  //for null terminator '\0'
  const size_type bufferSize = size + sizeof(value_type);

  //Make new string node
  StringNode* newNode = (StringNode*)zAllocate(nodeSize + bufferSize);
  newNode->RefCount = 1;
  newNode->Size = size;
  newNode->HashCode = 0;
  newNode->Data[size] = '\0';

  return newNode;
}

//--------------------------------------------------------------- String Helpers
String String::Format(cstr format, ...)
{
  va_list va;
  va_start(va, format);
  String result = String::FormatArgs(format, va);
  va_end(va);
  return result;
}

String String::FormatArgs(cstr format, va_list args)
{
  //Get the number of characters needed for message
  int bufferSize;
  ZeroVSPrintfCount(format, args, 1, bufferSize);
  char* stringBuffer = (char*)alloca((bufferSize+1)*sizeof(char));
  stringBuffer[bufferSize] = '\0';
  ZeroVSPrintf(stringBuffer, bufferSize, format, args);
  return String(stringBuffer);
}

String String::ReplaceSub(StringRange source, StringRange text,
                                size_type start, size_type end)
{
  size_type sizeToRemove = end - start;
  size_type sizeToAdd = text.size();

  //time to build the new string
  size_type newSize = source.size() - sizeToRemove + sizeToAdd;

  char* buffer = (char*)alloca(newSize + 1);//one for the null terminator
  char* bufferPos = buffer;
  char* bufferEnd = bufferPos + newSize + 1;

  //Copy over the front if there is anything to copy
  if(start > 0)
  {
    ZeroCStringCopy(bufferPos, bufferEnd - bufferPos, source.data(), start);
    bufferPos += start;
  }

  if(sizeToAdd != 0)
  {
    ZeroCStringCopy(bufferPos, bufferEnd - bufferPos, text.data(), sizeToAdd);
    bufferPos += sizeToAdd;
  }

  size_type sizeOfEndText = source.size() - end;
  if(sizeOfEndText)
  {
    ZeroCStringCopy(bufferPos, bufferEnd - bufferPos, source.data() + end, 
                sizeOfEndText);
    bufferPos += sizeOfEndText;
  }

  bufferPos[0] = '\0';

  return String(buffer);
}

String String::Join(StringRangeParam separator, StringRangeParam string1, StringRangeParam string2)
{
  StringRange values[2] = {string1, string2};
  return JoinInternal(separator, values, 2);
}

String String::Join(StringRangeParam separator, StringRangeParam string1, StringRangeParam string2, StringRangeParam string3)
{
  StringRange values[3] = {string1, string2, string3};
  return JoinInternal(separator, values, 3);
}

String String::Join(StringRangeParam separator, StringRangeParam string1, StringRangeParam string2, StringRangeParam string3, StringRangeParam string4)
{
  StringRange values[4] = {string1, string2, string3, string4};
  return JoinInternal(separator, values, 4);
}

String String::Join(StringRangeParam separator, const Array<String>& strings)
{
  StringRange* values = (StringRange*)alloca(sizeof(StringRange) * strings.size());
  for(size_t i = 0; i < strings.size(); ++i)
    values[i] = strings[i].all();
  
  return JoinInternal(separator, values, strings.size());
}

String String::JoinInternal(StringRangeParam separator, const StringRange* values, size_t count)
{
  if(count == 0)
    return String();

  //count the total size needed (don't include an extra for the null as the string constructor adds the null)
  size_t separatorSize = separator.sizeInBytes();
  size_t totalSize = separatorSize * (count - 1);
  for(size_t i = 0; i < count; ++i)
    totalSize += values[i].sizeInBytes();

  //allocate the entire buffer
  char* data = (char*)alloca(totalSize);
  char* current = data;
  //append item + separator for all but the last item
  for(size_t i = 0; i < count - 1; ++i)
  {
    StringRangeParam value = values[i];
    size_t valueSize = value.sizeInBytes();
    memcpy(current, value.data(), valueSize);
    current += valueSize;

    memcpy(current, separator.data(), separatorSize);
    current += separatorSize;
  }

  //add the last item
  StringRangeParam lastValue = values[count - 1];
  size_t lastValueSize = lastValue.sizeInBytes();
  memcpy(current, lastValue.data(), lastValueSize);
  current += lastValueSize;

  return String(data, totalSize);
}

//----------------------------------------------------------- String Token Range
StringTokenRange::StringTokenRange(StringRange string, char delim)
  : internalRange(string)
{
  mDelim = delim;
  popFront();
}

StringRange StringTokenRange::front()
{
  return curRange;
}

void StringTokenRange::popFront()
{
  cstr start = internalRange.begin;
  cstr current = start;

  //scan until delim or end
  while(current != internalRange.end && *current != mDelim)
    ++current;

  cstr end = current;
  while(current != internalRange.end && *current == mDelim)
  {
    ++current;
  }

  curRange = StringRange(start,end);
  internalRange.begin = current;
}

bool StringTokenRange::empty()
{
  return curRange.empty() && internalRange.empty();
}

//------------------------------------------------------------- Global Functions
String ToLower(StringParam str)
{
  size_t size = str.size();
  char* buffer = (char*)alloca(size + 1);

  for(size_t i = 0; i < str.size(); ++i)
  {
    buffer[i] = (char)tolower(str[i]);
  }
  buffer[size] = '\0';

  return buffer;
}

size_t GetNextWhitespace(StringRange input)
{
  for(size_t i = 0; i < input.size(); ++i)
  {
    if (isspace(input[i]))
      return i;
  }
  return input.size();
}

String WordWrap(StringRange input, size_t maxLineLength)
{
  StringBuilder builder;
  
  size_t lineLength = 0;
  
  while(!input.empty())
  {
    char c = input.front();
    input.popFront();
    
    ++lineLength;
    
    if(c == '\n' || c == '\r')
    {
      lineLength = 0;
      builder.Append(c);
      continue;
    }
    else if(!isspace(c))
    {
      size_t wordLength = GetNextWhitespace(input);
      bool isWordShort = wordLength < maxLineLength;
      bool doesWordMakeLineTooLong = lineLength + wordLength >= maxLineLength;
      if(isWordShort && doesWordMakeLineTooLong)
      {
        lineLength = 0;
        builder.Append("\n");
      }
    }
    
    if(lineLength >= maxLineLength)
    {
      lineLength = 0;
      builder.Append("\n");
    }

    // Eat any whitespace at the beginning of the line
    if(lineLength == 0 && isspace(c))
      continue;
    
    builder.Append(c);
  }

  return builder.ToString();
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file String.cpp
/// Implementation of the StringBuilder and ByteBuffer.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#include <stdio.h>
#include <stdarg.h>

namespace Zero
{
char* AppendRange(char* bufferPos, char* bufferEnd, StringRange& b)
{
  ZeroCStringCopy(bufferPos, bufferEnd-bufferPos, b.begin, b.size());
  bufferPos+=b.size();
  return bufferPos;
}

String BuildString(StringRange a, StringRange b)
{
  //+1 extra for null terminator
  const size_t bufferSize = a.size() + b.size() + 1;
  char* buffer = (char*)alloca(bufferSize);
  char* bufferPos = buffer;
  char* bufferEnd = buffer + bufferSize;

  bufferPos = AppendRange(bufferPos, bufferEnd, a);
  bufferPos = AppendRange(bufferPos, bufferEnd, b);
  *bufferPos = '\0';

  return String(buffer);
}

String BuildString(StringRange a, StringRange b, StringRange c)
{
  StringRange* strings[] = {&a, &b, &c};
  return BuildString(strings, 3);
}

String BuildString(StringRange a, StringRange b, StringRange c, StringRange d)
{
  StringRange* strings[] = {&a, &b, &c, &d};
  return BuildString(strings, 4);
}

String BuildString(StringRange a, StringRange b, StringRange c, StringRange d, StringRange e)
{
  StringRange* strings[] = {&a, &b, &c, &d, &e};
  return BuildString(strings, 5);
}

String BuildString(StringRange** ranges, uint count)
{
  //+1 extra for null terminator
  size_t bufferSize = 1;
  for(size_t i=0;i<count;++i)
    bufferSize += ranges[i]->size();

  char* buffer = (char*)alloca(bufferSize);
  char* bufferPos = buffer;
  char* bufferEnd = buffer + bufferSize;

  for(size_t i=0;i<count;++i)
    bufferPos = AppendRange(bufferPos, bufferEnd, *ranges[i]);

  *bufferPos = '\0';

  return String(buffer);
}

String StringJoin(Array<String>& strings, StringParam joinToken)
{
  //join together all of the strings with the join token in between
  if(strings.size() == 0)
    return String();

  if(strings.size() == 1)
    return strings[0];

  StringBuilder builder;
  builder.Append(strings[0]);
  for(uint i = 1; i < strings.size(); ++i)
  {
    builder.Append(joinToken);
    builder.Append(strings[i]);
  }
  return builder.ToString();
}


void StringBuilder::Append(StringRange range)
{
  ByteBuffer::Append((byteType*)range.data(), range.size());
}

void StringBuilder::Append(char character)
{
  ByteBuffer::Append((const byte*)&character, sizeof(character));
}

char& StringBuilder::operator[](size_t index)
{
  ErrorIf(index >= mTotalSize, "Index is out of bounds");

  size_t blockIndex = index / mBlockSize;

  byteType* block = mBlocks[blockIndex];

  ErrorIf(block == NULL, "The block should be filled out");

  return (char&)block[index %  mBlockSize];
}

void StringBuilder::Repeat(size_t count, StringParam str)
{
  for(size_t i = 0; i < count; ++i)
    Append(str);
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file StringConversion.cpp
/// Used to convert strings into values.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#include <stdio.h>
#include <stdlib.h>

namespace Zero
{

u64 ReadHexString(StringRange range)
{
  size_t size = range.size();
  u64 result = 0;
  for(size_t i = 0; i < size; ++i)
  {
    // process the string in reverse
    char c = range[size - i -1];
    u64 val = 0;
    if('0' <= c && c <= '9')
      val = c - '0';
    else if('a' <= c && c <= 'f')
      val = c-'a'+10;
    else if('A' <= c && c <= 'F')
      val = c-'A'+10;
    result += val << i*4;
  }
  return result;
}

uint WriteToHexSize(char* buffer, uint bufferSize, uint places, u64 integerValue)
{
  if(bufferSize < places+1)
    return 0;

  for(uint i = 0; i < places; ++i)
  {
    uint indexVal = uint(integerValue % 16);
    uint charVal = 0;
    if(indexVal <= 9)
      charVal = indexVal + '0';
    else if(10 <= indexVal && indexVal <= 16)
      charVal = indexVal + ('a'-10);
    buffer[places-1-i] = (char)charVal;
    integerValue = integerValue >> 4;
  }
  buffer[places] = '\0';
  return places;
}

uint WriteToHex(char* buffer, uint bufferSize, u64 integerValue)
{
  return WriteToHexSize(buffer, bufferSize, 16, integerValue);
}

uint WriteToHex(char* buffer, uint bufferSize, u32 integerValue)
{
  return WriteToHexSize(buffer, bufferSize, 8, (u64)integerValue);
}

//Max 4294967295
const uint cMaxIntSize = 12;

void ReverseString(char* start, char* end)
{
  --end;
  while(start<end)
  {
    Swap(*start, *end);
    ++start;
    --end;
  }
}

String ReverseString(StringParam string)
{
  size_t size = string.size();

  // Allocate a buffer on the stack
  char* reverseString = (char*)alloca(size * sizeof(char));

  // Null terminate the buffer
  reverseString[size] = '\0';

  // Copy the string into the reverse string
  memcpy(reverseString, (void*)string.data(), size * sizeof(char));

  // Reverse the string
  ReverseString(reverseString, reverseString + size);

  return String(reverseString);
}

uint ToString(char* buffer, uint bufferSize, s64 value)
{
  if(bufferSize < cMaxIntSize)
    return 0;

  bool valueIsNegative = false;
  if(value < 0)
  {
    value = -value;
    valueIsNegative = true;
  }

  uint index = 0;
  do 
  {
    char c = value % 10 + '0';
    buffer[index] = c;
    ++index;
    value /= 10;
  } while (value!=0);

  if(valueIsNegative)
  {
    buffer[index] = '-';
    ++index;
  }

  buffer[index] = '\0';
  ReverseString(buffer, buffer+index);
  return index;
}

void ToValue(StringRange range, float& value)
{
  value = (float)atof(range.begin);
}

void ToValue(StringRange range, double& value)
{
  value = atof(range.begin);
}

void ToValue(StringRange range, int& value)
{
  value = atoi(range.begin);
}

void ToValue(StringRange range, unsigned int& value)
{
  value = strtoul(range.begin, NULL, 0);
}

void ToValue(StringRange range, u64& value)
{
  value = ReadHexString(range);
}

void ToValue(StringRange range, s64& value)
{
#ifdef _MSC_VER
  value = _strtoui64(range.begin, nullptr, 10);
#else
  value = strtoull(range.begin, nullptr, 10);
#endif
}

void ToValue(StringRange range, String& value)
{
  value = range;
}

void ToValue(StringRange token, StringRange& range)
{
  range = token;
}

bool IsCharacter(char c, cstr search)
{
  while(*search!=0)
  {
    if(c == *search)
      return true;
    ++search;
  }
  return false;
}

void ToValue(StringRange token, bool& value)
{
  //true, True, on , On , 1
  if (IsCharacter(token.front(),"tToO1")) 
    value = true;
  else
    value = false;
}

uint ToBuffer(char* buffer, uint bufferSize, u64 value, bool shortFormat)
{
  ErrorIf(bufferSize < 16, "Buffer is not large enought for hex value.");
  if(bufferSize > 16)
    return WriteToHex(buffer, bufferSize, value);
  else
    return 0;
}

uint ToBuffer(char* buffer, uint bufferSize, int value, bool shortFormat)
{
  return ToString(buffer, bufferSize, value);
}

uint ToBuffer(char* buffer, uint bufferSize, unsigned int value, bool shortFormat)
{
  return ToString(buffer, bufferSize, value);
}

uint ToBuffer(char* buffer, uint bufferSize, float value, bool shortFormat)
{
  if(shortFormat)
    return ZeroSPrintf(buffer, bufferSize, "%g", value);
  else
    return ZeroSPrintf(buffer, bufferSize, "%.9g", value);
}

uint ToBuffer(char* buffer, uint bufferSize, double value, bool shortFormat)
{
  if(shortFormat)
    return ZeroSPrintf(buffer, bufferSize, "%f", value);
  else
    return ZeroSPrintf(buffer, bufferSize, "%.9f", value);
}

#define TextTrue "true"
#define  TextFalse "false"

uint ToBuffer(char* buffer, uint bufferSize, bool value, bool shortFormat)
{
  if(value)
  {
    ZeroStrCpy(buffer, bufferSize, TextTrue);
    return sizeof(TextTrue) - 1;
  }
  else
  {
    ZeroStrCpy(buffer, bufferSize, TextFalse);
    return sizeof(TextFalse) - 1;
  }
}


//Basic conversion function (input must be UTF-16/2) DestAscii must be unicodeLength +1
void ConvertUnicodeToAscii(char* destAscii, uint bufferSize, 
                           const wchar_t* unicodeData, size_t unicodeLength)
{
  if(bufferSize < unicodeLength +1)
  {
    ErrorIf(true, "Ascii Buffer is not large enough.");
    destAscii[0] = '\0';
  }
  else
  {
    for(uint i=0;i<unicodeLength;++i)
    {
      if(unicodeData[i] > 128)
      {
        //Can not be display in ascii
        destAscii[i] = '?';
      }
      else
      {
        destAscii[i] = (char)unicodeData[i];
      }
    }
    destAscii[unicodeLength] = '\0';
  }

}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file StringRange.cpp
///
/// Authors: Chris Peters, Joshua Davis
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////





namespace Zero
{

//-------------------------------------------------------------------StringRange

StringRange::StringRange()
  : begin(cEmpty), end(cEmpty)
{
}

StringRange::StringRange(iterator cstring)
{
  begin = cstring;

  if(cstring != nullptr)
    end = cstring + strlen(begin);
  else
    end = nullptr;
}

StringRange::StringRange(iterator pbegin, iterator pend)
  : begin(pbegin), end(pend)
{
}

StringRange::StringRange(iterator pbegin, size_t len)
  : begin(pbegin), end(pbegin + len)
{
}

const char& StringRange::front() const
{
  return *begin;
}

const char& StringRange::back() const
{
  return *(end - 1);
}

void StringRange::popFront()
{
  ErrorIf(empty(), "Popped empty range.");
  ++begin;
}

void StringRange::popFront(size_t n)
{
  ErrorIf(size() < n, "Popped too many elements.");
  begin+=n;
}

void StringRange::popBack()
{
  ErrorIf(empty(), "Popped empty range.");
  --end;
}

bool StringRange::contains(iterator pos)
{
  return pos >= begin && pos < end;
}

int StringRange::CompareTo(const StringRange& right) const
{
  size_t leftSize = sizeInBytes();
  size_t rightSize = right.sizeInBytes();

  size_t min = leftSize < rightSize ? leftSize : rightSize;
  int result = strncmp(begin, right.begin, min);
  if(result != 0)
    return result;

  //if the sizes were actually equal then the strings were equal
  if(leftSize == rightSize)
    return 0;
  //otherwise determine which string is shorter
  else if(leftSize < rightSize)
    return -1;
  return 1;
}

bool StringRange::operator==(const StringRange& right) const
{
  return size() == right.size() &&
          strncmp(begin, right.begin, size()) == 0;
}

bool StringRange::operator<(const StringRange& right) const
{
  size_t min = size() < right.size() ? size() : right.size();
  int result = strncmp(begin, right.begin, min);
  if (result == 0)
    return size() < right.size();
  else
    return result < 0;
}

bool StringRange::operator==(char c) const
{
  ErrorIf(empty(), "No elements in range.");
  return *begin == c;
}

bool StringRange::operator!=(char c) const
{
  ErrorIf(empty(), "No elements in range.");
  return *begin != c;
}

char StringRange::operator[](size_t index)
{
  ErrorIf(index >= size(), "Invalid index out of range.");
  return begin[index];
}

uint StringRange::FindFirstOf(byte value)
{
  for (uint i = 0; i < size(); ++i)
  {
    if (begin[i] == value)
      return i;
  }

  return InvalidIndex;
}

uint StringRange::FindFirstOf(StringRangeParam value) const
{
  size_t rangeSize = size();
  size_t valueSize = value.size();

  if (!valueSize || valueSize > rangeSize)
    return InvalidIndex;

  for (uint i = 0; i <= rangeSize - valueSize; ++i)
  {
    uint j;
    for (j = 0; j < valueSize; ++j)
    {
      if (begin[i + j] != value.begin[j])
        break;
    }

    if (j == valueSize)
      return i;
  }

  return InvalidIndex;
}

uint StringRange::FindLastOf(byte value) const
{
  if(size() == 0)
    return InvalidIndex;

  size_t last = size() - 1;

  for (size_t i = 0; i <= last; ++i)
  {
    if (begin[last - i] == value)
      return (uint)(last - i);
  }

  return InvalidIndex;
}

uint StringRange::FindLastOf(StringRangeParam value) const
{
  size_t rangeSize = size();
  size_t valueSize = value.size();

  if (!valueSize || valueSize > rangeSize)
    return InvalidIndex;

  size_t last = rangeSize - valueSize;

  for (size_t i = 0; i <= last; ++i)
  {
    size_t j;
    for (j = 0; j < valueSize; ++j)
    {
      if (begin[last - i + j] != value.begin[j])
        break;
    }

    if (j == valueSize)
      return (uint)(last - i);
  }

  return InvalidIndex;
}

uint StringRange::FindFirstNonWhitespaceCharIndex() const
{
  for (uint i = 0; i < size(); ++i)
  {
    if (!isspace(begin[i]))
      return i;
  }

  return InvalidIndex;
}

uint StringRange::FindLastNonWhitespaceCharIndex() const
{
  size_t last = size() - 1;

  for (size_t i = 0; i <= last; ++i)
  {
    if (!isspace(begin[last - i]))
      return (uint)(last - i);
  }

  return InvalidIndex;
}

StringRange::value_type StringRange::FindFirstNonWhitespaceChar() const
{
  uint i = FindFirstNonWhitespaceCharIndex();
  if (i != InvalidIndex)
    return begin[i];
  else
    return '\0';
}

StringRange::value_type StringRange::FindLastNonWhitespaceChar() const
{
  uint i = FindLastNonWhitespaceCharIndex();
  if (i != InvalidIndex)
    return begin[i];
  else
    return '\0';
}

bool StringRange::Contains(StringRangeParam value) const
{
  return FindFirstRangeOf(value).empty() == false;
}

bool StringRange::EndsWith(StringRangeParam value) const
{
  //the substring is larger than our entire string, we can't possibly end with it
  size_t size = sizeInBytes();
  size_t subStrSize = value.sizeInBytes();
  if(subStrSize > size)
    return false;

  //form the substring at the end of the same size of the passed in 
  StringRange endSubString = sub_string(size - subStrSize, subStrSize);
  return endSubString == value;
}

StringRange StringRange::FindFirstRangeOf(StringRangeParam value) const
{
  size_t byteIndex = FindFirstOf(value);
  if(byteIndex == InvalidIndex)
    return StringRange();
  return sub_string(byteIndex, value.sizeInBytes());
}

StringRange StringRange::FindLastRangeOf(StringRangeParam value) const
{
  size_t byteIndex = FindLastOf(value);
  if(byteIndex == InvalidIndex)
    return StringRange(end, end);
  return sub_string(byteIndex, value.sizeInBytes());
}

StringRange StringRange::FindRangeExclusive(StringRangeParam startRange, StringRangeParam endRange) const
{
  StringRange inclusiveRange = FindRangeInclusive(startRange, endRange);
  if(!inclusiveRange.empty())
  {
    //shrink the range in by the size of the search ranges
    inclusiveRange.begin += startRange.sizeInBytes();
    inclusiveRange.end -= endRange.sizeInBytes();
  }
  return inclusiveRange;
}

StringRange StringRange::FindRangeInclusive(StringRangeParam startRange, StringRangeParam endRange) const
{
  size_t index = FindFirstOf(startRange);
  if(index == InvalidIndex)
    return StringRange(end, end);

  StringRange subRange = sub_string(index, sizeInBytes() - index);
  index = subRange.FindFirstOf(endRange);
  if(index == InvalidIndex)
    return StringRange(end, end);

  return subRange.sub_string(0, index + endRange.sizeInBytes());
}

String StringRange::Replace(StringRangeParam oldValue, StringRangeParam newValue) const
{
  StringBuilder newString;

  StringRange currentRange = *this;
  while(!currentRange.empty())
  {
    //find the old value in the string
    StringRange valueRange = currentRange.FindFirstRangeOf(oldValue);
    //if we didn't find anything we're done (and we have to append what was left of the string)
    if(valueRange.empty())
    {
      newString.Append(currentRange);
      break;
    }

    //otherwise break the string into the part before and after the old value
    StringRange firstPart(currentRange.begin, valueRange.begin);
    StringRange secondPart(valueRange.end, currentRange.end);
    //add the first part and the new value
    newString.Append(firstPart);
    newString.Append(newValue);
    //then continue the search with the remaining part of the string
    currentRange = secondPart;
  }

  return newString.ToString();
}

StringSplitRange StringRange::Split(StringRangeParam separator) const
{
  return StringSplitRange(*this, separator);
}

bool StringRange::StartsWith(StringRangeParam value) const
{
  StringRange startSubString = sub_string(0, value.sizeInBytes());
  return startSubString == value;
}

StringRange StringRange::Trim() const
{
  uint startIndex = FindFirstNonWhitespaceCharIndex();
  if(startIndex == InvalidIndex)
    return StringRange(end, end);

  uint endIndex = FindLastNonWhitespaceCharIndex();

  return sub_string(startIndex, endIndex + 1 - startIndex);
}

StringRange StringRange::TrimEnd() const
{
  uint endIndex = FindLastNonWhitespaceCharIndex();
  return sub_string(0, endIndex + 1);
}

StringRange StringRange::TrimStart() const
{
  uint startIndex = FindFirstNonWhitespaceCharIndex();
  if(startIndex == InvalidIndex)
    return StringRange(end, end);
  return sub_string(startIndex, size() - startIndex);
}

String StringRange::ToUpper() const
{
  size_t size = sizeInBytes();
  char* result = (char*)alloca(size);
  for(size_t i = 0; i < size; ++i)
    result[i] = (char)toupper(begin[i]);

  return String(result, size);
}

String StringRange::ToLower() const
{
  size_t size = sizeInBytes();
  char* result = (char*)alloca(size);
  for(size_t i = 0; i < size; ++i)
    result[i] = (char)tolower(begin[i]);

  return String(result, size);
}

bool StringRange::IsAllUpper() const
{
  for (uint i = 0; i < size(); ++i)
  {
    if (!isupper(begin[i]))
      return false;
  }

  return true;
}

bool StringRange::IsAllWhitespace() const
{
  for (uint i = 0; i < size(); ++i)
  {
    if (!isspace(begin[i]))
      return false;
  }

  return true;
}

StringRange StringRange::sub_string_unsafe(size_t offset, size_t length) const
{
  return StringRange(begin + offset, length);
}

StringRange StringRange::sub_string(size_t offset, size_t length) const
{
  iterator b = begin + offset;

  if (b > end)
  {
    b = end;
  }
  else if (b < begin)
  {
    b = begin;
  }

  iterator e = b + length;

  if (e > end)
  {
    e = end;
  }
  else if (e < begin)
  {
    e = begin;
  }

  if (e < b)
  {
    e = b;
  }

  return StringRange(b, e);
}

//-------------------------------------------------------------------StringSplitRange
StringSplitRange::StringSplitRange(StringRange range, StringRange separator)
{
  mRemainingRange = range;
  mSeparator = separator;

  SkipNext();
}

StringRange StringSplitRange::front()
{
  return mCurrentRange;
}

void StringSplitRange::popFront()
{
  SkipNext();
}

bool StringSplitRange::empty()
{
  return mCurrentRange.empty() && mRemainingRange.empty();
}

void StringSplitRange::SkipNext()
{
  //if there's nothing left to search then clear out the current range
  if(mRemainingRange.empty())
  {
    mCurrentRange = StringRange();
    return;
  }

  //find the first range of the separator
  StringRange separatorRange = mRemainingRange.FindFirstRangeOf(mSeparator);
  //if we didn't find the separator then just set the current range to
  //what was left and clear out the remaining range
  if(separatorRange.empty())
  {
    mCurrentRange = mRemainingRange;
    mRemainingRange = StringRange();
    return;
  }

  //break the range into the part before and after the separator
  mCurrentRange = StringRange(mRemainingRange.begin, separatorRange.begin);
  mRemainingRange = StringRange(separatorRange.end, mRemainingRange.end);
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file StringUtility.cpp
///
/// 
/// Authors: Chris Peters
/// Copyright 2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#include <ctype.h>



namespace Zero
{

//---------------------------------------------------------------------- Strings
bool CaseInsensitiveStringLess(String a, String b)
{
  StringRange achars = a.all();
  StringRange bchars = b.all();

  while(!achars.empty() && !bchars.empty())
  {
    char aChar = (char)tolower(achars.front());
    char bChar = (char)tolower(bchars.front());

    if(aChar < bChar)
      return true;

    if(aChar > bChar)
      return false;

    achars.popFront();
    bchars.popFront();
  }

  if(achars.empty() && !bchars.empty())
    return true;

  return false;
}
Pair<StringRange,StringRange> SplitOnLast(StringRange input, char delimiter)
{
  //With empty just return empty String
  if(input.empty())
    return Pair<StringRange,StringRange>(input, input);

  uint size = input.size();

  uint position = input.FindLastOf(delimiter);

  // Delim found return string and empty
  if(position == String::InvalidIndex)
    return Pair<StringRange,StringRange>(input, StringRange());

  if(position == 0)
    return Pair<StringRange, StringRange>(StringRange(), input.sub_string(1, size - 1));

  if(position == size - 1)
    return Pair<StringRange, StringRange>(input.sub_string(0, size - 1), StringRange());

  return Pair<StringRange, StringRange>(input.sub_string(0, position), input.sub_string(position + 1, size - position - 1));
  
}

Pair<StringRange,StringRange> SplitOnFirst(StringRange input, char delimiter)
{
  StringTokenRange tokenRange(input, delimiter);
  StringRange left =  tokenRange.front();
  StringRange right = StringRange(left.end, input.end);
  return Pair<StringRange, StringRange>(left, right);
}

StringRange StripBeforeLast(StringRange input, char delimiter)
{
  Pair<StringRange, StringRange> split = SplitOnLast(input, delimiter);

  // If the delimiter was not found the second will be empty
  if(split.second.empty())
    return input;
  else
    return split.second;
}

String JoinStrings(const Array<String>& strings, StringParam delimiter)
{
  StringBuilder builder;

  for (size_t i = 0; i < strings.size(); ++i)
  {
    const String& string = strings[i];

    builder.Append(string);

    bool isNotLast = (i + 1 != strings.size());

    if (isNotLast)
    {
      builder.Append(delimiter);
    }
  }

  return builder.ToString();
}

char OnlyAlphaNumeric(char c)
{
  if (!isalnum(c))
    return '_';
  else
    return c;
}

//******************************************************************************
// Recursive helper for global string Permute below
static void PermuteRecursive(char *src, uint start, uint end, Array<String>& perms)
{
  // finished a permutation, add it to the list
  if (start == end)
  {
    perms.push_back(src);
    return;
  }

  for (uint i = start; i < end; ++i)
  {
    // swap to get new head
    Swap(src[start], src[i]);
    // permute
    PermuteRecursive(src, start + 1, end, perms);
    // backtrack
    Swap(src[start], src[i]);
  }

}

//******************************************************************************
void Permute(StringParam src, Array<String>& perms)
{
  // convert to std string which is char writeable
  uint srclen = src.size();
  const char *csrc = src.c_str();

  // create a temp buffer on the stack to manipulate src
  char *buf = (char *)alloca(srclen + 1);
  memset(buf, 0, srclen + 1);

  // recursively calculate permutations
  PermuteRecursive(buf, 0, srclen, perms);
}

//******************************************************************************
void SuperPermute(StringParam src, Array<String>& perms)
{
  // convert to std string which is char writeable
  uint srclen = src.size();
  const char *csrc = src.c_str();

  // create a temp buffer on the stack to manipulate src
  char *buf = (char *)alloca(srclen + 1);
  memset(buf, 0, srclen + 1);

  // push the individual elements of the source
  for (uint i = 0; i < srclen; ++i)
    perms.push_back(src.sub_string(i, 1));

  for (uint l = 1; l < srclen; ++l)
  {
    for (uint i = 0; i + l < srclen; ++i)
    {
      // initialize buffer
      memcpy(buf, csrc + i, l);
      for (uint j = i + l; j < srclen; ++j)
      {
        buf[l] = csrc[j];
        PermuteRecursive(buf, 0, l + 1, perms);
        buf[l] = '\0';
      }
    }
  }

}


}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file ToString.cpp
/// Conversion to and from strings.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{
const int cBufferSize = 256;

String ToString(const int& value, bool shortFormat)
{
  char buffer[cBufferSize];
  ToBuffer(buffer, cBufferSize, value, shortFormat);
  return buffer;
}

String ToString(const uint& value, bool shortFormat)
{
  char buffer[cBufferSize];
  ToBuffer(buffer, cBufferSize, value, shortFormat);
  return buffer;
}

String ToString(const float& value, bool shortFormat)
{
  char buffer[cBufferSize];
  ToBuffer(buffer, cBufferSize, value, shortFormat);
  return buffer;
}

String ToString(const double& value, bool shortFormat)
{
  char buffer[cBufferSize];
  ToBuffer(buffer, cBufferSize, value, shortFormat);
  return buffer;
}

String ToString(const bool& value, bool shortFormat)
{
  char buffer[cBufferSize];
  ToBuffer(buffer, cBufferSize, value, shortFormat);
  return buffer;
}

String ToString(const u64& value, bool shortFormat)
{
  char buffer[cBufferSize];
  ToBuffer(buffer, cBufferSize, value, shortFormat);
  return buffer;
}

}
///////////////////////////////////////////////////////////////////////////////
///
/// \file Atomic.cpp
/// Implementation of the atomic functions.
///
/// Authors: Chris Peters, Andrew Colean
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

// Includes



namespace Zero
{

// AtomicStore
void AtomicStore(volatile s8*  target, s8  value)
{
  AtomicExchange(target, value);
}
void AtomicStore(volatile s16* target, s16 value)
{
  AtomicExchange(target, value);
}
void AtomicStore(volatile s32* target, s32 value)
{
  AtomicExchange(target, value);
}
void AtomicStore(volatile s64* target, s64 value)
{
  AtomicExchange(target, value);
}

// AtomicLoad
s8  AtomicLoad(volatile s8*  target)
{
  return AtomicCompareExchange(target, s8(0), s8(0));
}
s16 AtomicLoad(volatile s16* target)
{
  return AtomicCompareExchange(target, s16(0), s16(0));
}
s32 AtomicLoad(volatile s32* target)
{
  return AtomicCompareExchange(target, s32(0), s32(0));
}
s64 AtomicLoad(volatile s64* target)
{
  return AtomicCompareExchange(target, s64(0), s64(0));
}

} // namespace Zero

// Microsoft Visual C++ Compiler
#if defined(COMPILER_MICROSOFT)

// Note: The following interlocked functions are unavailable as intrinsics,
//       hence why we need to include the Windows header for replacement functions:
//       _InterlockedExchange64
//       _InterlockedExchangeAdd64
//       _InterlockedIncrement8
//       _InterlockedIncrement64
//       _InterlockedDecrement8
//       _InterlockedDecrement64
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>

//
// Intrinsic Declarations
//

extern "C"
{

// InterlockedExchange
char    __cdecl _InterlockedExchange8 (char volatile*    target, char    value);
short   __cdecl _InterlockedExchange16(short volatile*   target, short   value);
long    __cdecl _InterlockedExchange  (long volatile*    target, long    value);
//__int64 __cdecl _InterlockedExchange64(__int64 volatile* target, __int64 value);

// InterlockedCompareExchange
char    __cdecl _InterlockedCompareExchange8 (char volatile*    target, char    value, char    comparison);
short   __cdecl _InterlockedCompareExchange16(short volatile*   target, short   value, short   comparison);
long    __cdecl _InterlockedCompareExchange  (long volatile*    target, long    value, long    comparison);
__int64 __cdecl _InterlockedCompareExchange64(__int64 volatile* target, __int64 value, __int64 comparison);

// InterlockedExchangeAdd
char    __cdecl _InterlockedExchangeAdd8 (char volatile*    target, char    value);
short   __cdecl _InterlockedExchangeAdd16(short volatile*   target, short   value);
long    __cdecl _InterlockedExchangeAdd  (long volatile*    target, long    value);
//__int64 __cdecl _InterlockedExchangeAdd64(__int64 volatile* target, __int64 value);

// InterlockedIncrement
//char    __cdecl _InterlockedIncrement8 (char volatile*    target);
short   __cdecl _InterlockedIncrement16(short volatile*   target);
long    __cdecl _InterlockedIncrement  (long volatile*    target);
//__int64 __cdecl _InterlockedIncrement64(__int64 volatile* target);

// InterlockedDecrement
//char    __cdecl _InterlockedDecrement8 (char volatile*    target);
short   __cdecl _InterlockedDecrement16(short volatile*   target);
long    __cdecl _InterlockedDecrement  (long volatile*    target);
//__int64 __cdecl _InterlockedDecrement64(__int64 volatile* target);

} // extern "C"

//
// Intrinsic Directives
//

// InterlockedExchange
#pragma intrinsic (_InterlockedExchange8 )
#pragma intrinsic (_InterlockedExchange16)
#pragma intrinsic (_InterlockedExchange  )
//#pragma intrinsic (_InterlockedExchange64)

// InterlockedCompareExchange
#pragma intrinsic (_InterlockedCompareExchange8 )
#pragma intrinsic (_InterlockedCompareExchange16)
#pragma intrinsic (_InterlockedCompareExchange  )
#pragma intrinsic (_InterlockedCompareExchange64)

// InterlockedExchangeAdd
#pragma intrinsic (_InterlockedExchangeAdd8 )
#pragma intrinsic (_InterlockedExchangeAdd16)
#pragma intrinsic (_InterlockedExchangeAdd  )
//#pragma intrinsic (_InterlockedExchangeAdd64)

// InterlockedIncrement
//#pragma intrinsic (_InterlockedIncrement8 )
#pragma intrinsic (_InterlockedIncrement16)
#pragma intrinsic (_InterlockedIncrement  )
//#pragma intrinsic (_InterlockedIncrement64)

// InterlockedDecrement
//#pragma intrinsic (_InterlockedDecrement8 )
#pragma intrinsic (_InterlockedDecrement16)
#pragma intrinsic (_InterlockedDecrement  )
//#pragma intrinsic (_InterlockedDecrement64)

namespace Zero
{

// AtomicExchange
s8  AtomicExchange(volatile s8*  target, s8  value)
{
  return (s8)::_InterlockedExchange8((char volatile*)target, (char)value);
}
s16 AtomicExchange(volatile s16* target, s16 value)
{
  return (s16)::_InterlockedExchange16((short volatile*)target, (short)value);
}
s32 AtomicExchange(volatile s32* target, s32 value)
{
  return (s32)::_InterlockedExchange((long volatile*)target, (long)value);
}
s64 AtomicExchange(volatile s64* target, s64 value)
{
  return (s64)::InterlockedExchange64((__int64 volatile*)target, (__int64)value); // _InterlockedExchange64 Unavailable
}

// AtomicCompareExchange
s8  AtomicCompareExchange(volatile s8*  target, s8  value, s8  comparison)
{
  return (s8)::_InterlockedCompareExchange8((char volatile*)target, (char)value, (char)comparison);
}
s16 AtomicCompareExchange(volatile s16* target, s16 value, s16 comparison)
{
  return (s16)::_InterlockedCompareExchange16((short volatile*)target, (short)value, (short)comparison);
}
s32 AtomicCompareExchange(volatile s32* target, s32 value, s32 comparison)
{
  return (s32)::_InterlockedCompareExchange((long volatile*)target, (long)value, (long)comparison);
}
s64 AtomicCompareExchange(volatile s64* target, s64 value, s64 comparison)
{
  return (s64)::_InterlockedCompareExchange64((__int64 volatile*)target, (__int64)value, (__int64)comparison);
}

// AtomicCompareExchangeBool
bool AtomicCompareExchangeBool(volatile s8*  target, s8  value, s8  comparison)
{
  return (s8)::_InterlockedCompareExchange8((char volatile*)target, (char)value, (char)comparison) == comparison;
}
bool AtomicCompareExchangeBool(volatile s16* target, s16 value, s16 comparison)
{
  return (s16)::_InterlockedCompareExchange16((short volatile*)target, (short)value, (short)comparison) == comparison;
}
bool AtomicCompareExchangeBool(volatile s32* target, s32 value, s32 comparison)
{
  return (s32)::_InterlockedCompareExchange((long volatile*)target, (long)value, (long)comparison) == comparison;
}
bool AtomicCompareExchangeBool(volatile s64* target, s64 value, s64 comparison)
{
  return (s64)::_InterlockedCompareExchange64((__int64 volatile*)target, (__int64)value, (__int64)comparison) == comparison;
}

// AtomicFetchAdd
s8  AtomicFetchAdd(volatile s8*  target, s8  value)
{
  return (s8)::_InterlockedExchangeAdd8((char volatile*)target, (char)value);
}
s16 AtomicFetchAdd(volatile s16* target, s16 value)
{
  return (s16)::_InterlockedExchangeAdd16((short volatile*)target, (short)value);
}
s32 AtomicFetchAdd(volatile s32* target, s32 value)
{
  return (s32)::_InterlockedExchangeAdd((long volatile*)target, (long)value);
}
s64 AtomicFetchAdd(volatile s64* target, s64 value)
{
  return (s64)::InterlockedExchangeAdd64((__int64 volatile*)target, (__int64)value); // _InterlockedExchangeAdd64 Unavailable
}

// AtomicFetchSubtract
s8  AtomicFetchSubtract(volatile s8*  target, s8  value)
{
  return (s8)::_InterlockedExchangeAdd8((char volatile*)target, -((char)value));
}
s16 AtomicFetchSubtract(volatile s16* target, s16 value)
{
  return (s16)::_InterlockedExchangeAdd16((short volatile*)target, -((short)value));
}
s32 AtomicFetchSubtract(volatile s32* target, s32 value)
{
  return (s32)::_InterlockedExchangeAdd((long volatile*)target, -((long)value));
}
s64 AtomicFetchSubtract(volatile s64* target, s64 value)
{
  return (s64)::InterlockedExchangeAdd64((__int64 volatile*)target, -((__int64)value)); // _InterlockedExchangeAdd64 Unavailable
}

// AtomicPreIncrement
s8  AtomicPreIncrement(volatile s8*  target)
{
  return AtomicPostIncrement(target) + s8(1); // _InterlockedIncrement8 Unavailable
}
s16 AtomicPreIncrement(volatile s16* target)
{
  return (s16)::_InterlockedIncrement16((short volatile*)target);
}
s32 AtomicPreIncrement(volatile s32* target)
{
  return (s32)::_InterlockedIncrement((long volatile*)target);
}
s64 AtomicPreIncrement(volatile s64* target)
{
  return (s64)::InterlockedIncrement64((__int64 volatile*)target); // _InterlockedIncrement64 Unavailable
}

// AtomicPostIncrement
s8  AtomicPostIncrement(volatile s8*  target)
{
  return AtomicFetchAdd(target, s8(1));
}
s16 AtomicPostIncrement(volatile s16* target)
{
  return AtomicFetchAdd(target, s16(1));
}
s32 AtomicPostIncrement(volatile s32* target)
{
  return AtomicFetchAdd(target, s32(1));
}
s64 AtomicPostIncrement(volatile s64* target)
{
  return AtomicFetchAdd(target, s64(1));
}

// AtomicPreDecrement
s8  AtomicPreDecrement(volatile s8*  target)
{
  return AtomicPostDecrement(target) - s8(1); // _InterlockedDecrement8 Unavailable
}
s16 AtomicPreDecrement(volatile s16* target)
{
  return (s16)::_InterlockedDecrement16((short volatile*)target);
}
s32 AtomicPreDecrement(volatile s32* target)
{
  return (s32)::_InterlockedDecrement((long volatile*)target);
}
s64 AtomicPreDecrement(volatile s64* target)
{
  return (s64)::InterlockedDecrement64((__int64 volatile*)target); // _InterlockedDecrement64 Unavailable
}

// AtomicPostDecrement
s8  AtomicPostDecrement(volatile s8*  target)
{
  return AtomicFetchSubtract(target, s8(1));
}
s16 AtomicPostDecrement(volatile s16* target)
{
  return AtomicFetchSubtract(target, s16(1));
}
s32 AtomicPostDecrement(volatile s32* target)
{
  return AtomicFetchSubtract(target, s32(1));
}
s64 AtomicPostDecrement(volatile s64* target)
{
  return AtomicFetchSubtract(target, s64(1));
}

} // namespace Zero

/// GNU Compiler Collection
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG)

namespace Zero
{

// AtomicExchange
s8  AtomicExchange(volatile s8*  target, s8  value)
{
  return __sync_lock_test_and_set(target, value);
}
s16 AtomicExchange(volatile s16* target, s16 value)
{
  return __sync_lock_test_and_set(target, value);
}
s32 AtomicExchange(volatile s32* target, s32 value)
{
  return __sync_lock_test_and_set(target, value);
}
s64 AtomicExchange(volatile s64* target, s64 value)
{
  return __sync_lock_test_and_set(target, value);
}

// AtomicCompareExchange
s8  AtomicCompareExchange(volatile s8*  target, s8  value, s8  comparison)
{
  return __sync_val_compare_and_swap(target, comparison, value);
}
s16 AtomicCompareExchange(volatile s16* target, s16 value, s16 comparison)
{
  return __sync_val_compare_and_swap(target, comparison, value);
}
s32 AtomicCompareExchange(volatile s32* target, s32 value, s32 comparison)
{
  return __sync_val_compare_and_swap(target, comparison, value);
}
s64 AtomicCompareExchange(volatile s64* target, s64 value, s64 comparison)
{
  return __sync_val_compare_and_swap(target, comparison, value);
}

// AtomicCompareExchangeBool
bool AtomicCompareExchangeBool(volatile s8*  target, s8  value, s8  comparison)
{
  return __sync_bool_compare_and_swap(target, comparison, value);
}
bool AtomicCompareExchangeBool(volatile s16* target, s16 value, s16 comparison)
{
  return __sync_bool_compare_and_swap(target, comparison, value);
}
bool AtomicCompareExchangeBool(volatile s32* target, s32 value, s32 comparison)
{
  return __sync_bool_compare_and_swap(target, comparison, value);
}
bool AtomicCompareExchangeBool(volatile s64* target, s64 value, s64 comparison)
{
  return __sync_bool_compare_and_swap(target, comparison, value);
}

// AtomicFetchAdd
s8  AtomicFetchAdd(volatile s8*  target, s8  value)
{
  return __sync_fetch_and_add(target, value);
}
s16 AtomicFetchAdd(volatile s16* target, s16 value)
{
  return __sync_fetch_and_add(target, value);
}
s32 AtomicFetchAdd(volatile s32* target, s32 value)
{
  return __sync_fetch_and_add(target, value);
}
s64 AtomicFetchAdd(volatile s64* target, s64 value)
{
  return __sync_fetch_and_add(target, value);
}

// AtomicFetchSubtract
s8  AtomicFetchSubtract(volatile s8*  target, s8  value)
{
  return __sync_fetch_and_sub(target, value);
}
s16 AtomicFetchSubtract(volatile s16* target, s16 value)
{
  return __sync_fetch_and_sub(target, value);
}
s32 AtomicFetchSubtract(volatile s32* target, s32 value)
{
  return __sync_fetch_and_sub(target, value);
}
s64 AtomicFetchSubtract(volatile s64* target, s64 value)
{
  return __sync_fetch_and_sub(target, value);
}

// AtomicPreIncrement
s8  AtomicPreIncrement(volatile s8*  target)
{
  return __sync_add_and_fetch(target, s8(1));
}
s16 AtomicPreIncrement(volatile s16* target)
{
  return __sync_add_and_fetch(target, s16(1));
}
s32 AtomicPreIncrement(volatile s32* target)
{
  return __sync_add_and_fetch(target, s32(1));
}
s64 AtomicPreIncrement(volatile s64* target)
{
  return __sync_add_and_fetch(target, s64(1));
}

// AtomicPostIncrement
s8  AtomicPostIncrement(volatile s8*  target)
{
  return __sync_fetch_and_add(target, s8(1));
}
s16 AtomicPostIncrement(volatile s16* target)
{
  return __sync_fetch_and_add(target, s16(1));
}
s32 AtomicPostIncrement(volatile s32* target)
{
  return __sync_fetch_and_add(target, s32(1));
}
s64 AtomicPostIncrement(volatile s64* target)
{
  return __sync_fetch_and_add(target, s64(1));
}

// AtomicPreDecrement
s8  AtomicPreDecrement(volatile s8*  target)
{
  return __sync_sub_and_fetch(target, s8(1));
}
s16 AtomicPreDecrement(volatile s16* target)
{
  return __sync_sub_and_fetch(target, s16(1));
}
s32 AtomicPreDecrement(volatile s32* target)
{
  return __sync_sub_and_fetch(target, s32(1));
}
s64 AtomicPreDecrement(volatile s64* target)
{
  return __sync_sub_and_fetch(target, s64(1));
}

// AtomicPostDecrement
s8  AtomicPostDecrement(volatile s8*  target)
{
  return __sync_fetch_and_sub(target, s8(1));
}
s16 AtomicPostDecrement(volatile s16* target)
{
  return __sync_fetch_and_sub(target, s16(1));
}
s32 AtomicPostDecrement(volatile s32* target)
{
  return __sync_fetch_and_sub(target, s32(1));
}
s64 AtomicPostDecrement(volatile s64* target)
{
  return __sync_fetch_and_sub(target, s64(1));
}

} // namespace Zero

#endif
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

// Includes


namespace Zero
{

/// Converts a guid to a hexadecimal string
String GuidToString(Guid guid)
{
  // Convert guid to string
  char result[32];
  // Have to use the format specifyer llX for a long long hex value otherwise we may get warnings
  if(ZeroSPrintf(result, sizeof(result), "%llX", guid) <= 0) // Unable?
    return String();

  // Success
  return String(result);
}

} // namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Misc.cpp
/// Miscellaneous functions.
///
/// Authors: 
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#if _MSC_VER
#include <intrin.h>
#endif

namespace Zero
{

namespace Z
{
static u32 gLexicographicMask = 0xffffffff;
static u64 gLexicographicUpperMask = static_cast<u64>(gLexicographicMask) << 32;
static u64 gLexicographicLowerMask = static_cast<u64>(gLexicographicMask);
}//namespace Z

u64 GetLexicographicId(u32 id1, u32 id2)
{
  u64 id = 0;

  //put the smaller number in the top 32 bits and the larger in the bottom 16
  if(id1 < id2)
  {
    id |= (static_cast<u64>(id1) & Z::gLexicographicMask) << 32;
    id |= (static_cast<u64>(id2) & Z::gLexicographicMask);
  }
  else
  {
    id |= (static_cast<u64>(id2) & Z::gLexicographicMask) << 32;
    id |= (static_cast<u64>(id1) & Z::gLexicographicMask);
  }

  /*could also do
  u32* start = reinterpret_cast<u32*>(&id);
  if(id1 < id2)
  {
    start[0] = id2;
    start[1] = id1;
  }
  else
  {
    start[0] = id1;
    start[1] = id2;
  }
  although endianess matters, which would only screw up if
  sending a pair id from one machine to another
  */

  return id;
}

void UnPackLexicographicId(u32& id1, u32& id2, u64 pairId)
{
  id1 = static_cast<u32>(pairId & Z::gLexicographicLowerMask);
  id2 = static_cast<u32>((pairId & Z::gLexicographicUpperMask) >> 32);

  /*could also do 
  u32* start = reinterpret_cast<u32*>(&pairId);
  id1 = *start;
  id2 = *(start + 1);*/
}

bool IsBigEndian()
{
  int i = 1;
  byte* lowByte = (byte*)&i;

  return (*lowByte == 0);
}

#if _MSC_VER

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)

u32 CountTrailingZeros(u32 x)
{
  unsigned long ret = 32;
  _BitScanForward(&ret, x);
  return ret;
}

u32 CountLeadingZeros(u32 x)
{
  unsigned long ret = 32;
  _BitScanReverse(&ret, x);
  return 31 - ret;
}

#else

static const u32 CtzLookupTable[] =
{
  8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
  4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
};

u32 CountTrailingZeros(u32 x)
{
  u32 n = 0;
  if ((x & 0x0000FFFF) == 0) { n += 16; x >>= 16; }
  if ((x & 0x000000FF) == 0) { n +=  8; x >>=  8; }
  // if ((x & 0x0000000F) == 0) { n +=  4; x >>=  4; }
  // if ((x & 0x00000003) == 0) { n +=  2; x >>=  2; }
  // if ((x & 0x00000001) == 0) { n +=  1; }
  return n + CtzLookupTable[x & 0xFF];
}

u32 CountLeadingZeros(u32 x)
{
  u32 n = 0;
  if ((x & 0xFFFF0000) == 0) { n += 16; x <<= 16; }
  if ((x & 0xFF000000) == 0) { n +=  8; x <<=  8; }
  if ((x & 0xF0000000) == 0) { n +=  4; x <<=  4; }
  if ((x & 0xC0000000) == 0) { n +=  2; x <<=  2; }
  if ((x & 0x80000000) == 0) { n +=  1; }
  return n;
}

#endif

u32 NextPowerOfTwo(u32 x)
{
  u32 leadingZeros = CountLeadingZeros(x);
  return 1 << (32 - leadingZeros);
}

}//namespace Zero

// Used for counting printf statement lengths
char gDiscardBuffer[2] = {0};
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Math
{

uint BlockVector3::GetSize() const
{
  return mBlocks.size();
}

void BlockVector3::SetSize(uint size)
{
  mBlocks.resize(size,Vector3::cZero);
}

Vector3& BlockVector3::operator[](uint index)
{
  ErrorIf(index > mBlocks.size(), "Math::BlockVector3 - Subscript out of range.");
  return mBlocks[index];
}

Vector3 BlockVector3::operator[](uint index) const
{
  ErrorIf(index > mBlocks.size(), "Math::BlockVector3 - Subscript out of range.");
  return mBlocks[index];
}

real& BlockVector3::GlobalIndex(uint index)
{
  int blockIndex = index / 3;
  int finalIndex = index % 3;

  return mBlocks[blockIndex][finalIndex];
}

void BlockVector3::operator*=(real rhs)
{
  for(uint i = 0; i < mBlocks.size(); ++i)
    mBlocks[i] *= rhs;
}

void BlockVector3::operator+=(const BlockVector3& rhs)
{
  ErrorIf(rhs.mBlocks.size() != mBlocks.size(),
          "Cannot add two block vectors of different dimensions");

  for(uint i = 0; i < mBlocks.size(); ++i)
    mBlocks[i] += rhs.mBlocks[i];
}

void BlockVector3::operator-=(const BlockVector3& rhs)
{
  ErrorIf(rhs.mBlocks.size() != mBlocks.size(),
          "Cannot subtract two block vectors of different dimensions");

  for(uint i = 0; i < mBlocks.size(); ++i)
    mBlocks[i] -= rhs.mBlocks[i];
}

real BlockVector3::Dot(const BlockVector3& rhs) const
{
  ErrorIf(rhs.mBlocks.size() != mBlocks.size(),
          "Cannot perform the dot product between two block "
          "vectors of different dimensions");

  real result = real(0.0);
  for(uint i = 0; i < mBlocks.size(); ++i)
    result += Math::Dot(mBlocks[i], rhs.mBlocks[i]);
  return result;
}

void BlockVector3::Scale(const BlockVector3& rhs, BlockVector3& out) const
{
  ErrorIf(rhs.mBlocks.size() != mBlocks.size(),
          "Cannot perform vector scale between two block "
          "vectors of different dimensions");

  for(uint i = 0; i < mBlocks.size(); ++i)
    out[i] = mBlocks[i] * rhs[i];
}

uint BlockMatrix3::GetSize() const
{
  return mBlocks.size();
}

void BlockMatrix3::SetSize(uint size)
{
  mBlocks.resize(size);

  Matrix3 zero;
  zero.ZeroOut();
  for(uint i = 0; i < size; ++i)
    mBlocks[i].resize(size,zero);
}

Matrix3 BlockMatrix3::operator()(uint row, uint col) const
{
  ErrorIf(row > mBlocks.size() || col > mBlocks.size(),
          "Math::BlockMatrix3 - Subscript out of range.");
  
  return mBlocks[row][col];
}

Matrix3& BlockMatrix3::operator()(uint row, uint col)
{
  ErrorIf(row > mBlocks.size() || col > mBlocks.size(),
          "Math::BlockMatrix3 - Subscript out of range.");

  return mBlocks[row][col];
}

real& BlockMatrix3::GlobalIndex(uint row, uint col)
{
  uint size = mBlocks.size() * 3;
  ErrorIf(row > size || col > size,
    "Math::BlockMatrix3 - Subscript out of range.");

  int blockRow = row / 3;
  int blockCol = col / 3;
  int finalRow = row % 3;
  int finalCol = col % 3;
  return mBlocks[blockRow][blockCol](finalRow,finalCol);
}

BlockMatrix3 BlockMatrix3::Transposed() const
{
  uint size = mBlocks.size();
  BlockMatrix3 result;
  result.SetSize(size);
  for(uint j = 0; j < size; ++j)
  {
    for(uint i = 0; i < size; ++i)
    {
      result(i,j) = (*this)(j,i).Transposed();
    }
  }
  return result;
}

BlockMatrix3 BlockMatrix3::Transform(const BlockMatrix3& rhs) const
{
  uint size = mBlocks.size();
  BlockMatrix3 result;
  result.SetSize(size);
  for(uint j = 0; j < size; ++j)
  {
    for(uint i = 0; i < size; ++i)
    {
      for(uint x = 0; x < size; ++x)
      {
        Matrix3 left = (*this)(i,x);
        Matrix3 right = rhs(x,j);
        result(i,j) += left * right;
      }
    }
  }
  return result;
}

void BlockMatrix3::Transform(const BlockVector3& rhs, BlockVector3& out) const
{
  out.SetSize(rhs.GetSize());

  for(uint i = 0; i < mBlocks.size(); ++i)
  {
    const Cells& cell = mBlocks[i];
    Vector3 sum = Vector3::cZero;
    
    for(uint j = 0; j < cell.size(); ++j)
    {
      Matrix3 m = cell[j];
      Vector3 v = rhs[j];
      sum += Math::Transform(m,v);
    }

    out[i] = sum;
  }
}

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file BoolVector2.cpp
///  Implementation of the BoolVector2 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Math
{

const BoolVector2 BoolVector2::cZero(false, false);
const BoolVector2 BoolVector2::cXAxis(true, false);
const BoolVector2 BoolVector2::cYAxis(false, true);


BoolVector2::BoolVector2(bool x_, bool y_)
{
  x = x_;
  y = y_;
}

bool& BoolVector2::operator[](uint index)
{
  ErrorIf(index > 1, "Math::BoolVector2 - Subscript out of range.");
  return array[index];
}

bool BoolVector2::operator[](uint index) const
{
  ErrorIf(index > 1, "Math::BoolVector2 - Subscript out of range.");
  return array[index];
}

BoolVector2 BoolVector2::operator!(void) const
{
  return BoolVector2(!x, !y);
}

bool BoolVector2::operator==(BoolVec2Param rhs) const
{
  return x == rhs.x && y == rhs.y;
}

bool BoolVector2::operator!=(BoolVec2Param rhs) const
{
  return !((*this) == rhs);
}

void BoolVector2::Set(bool x_, bool y_)
{
  x = x_;
  y = y_;
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file BoolVector3.cpp
///  Implementation of the BoolVector3 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Math
{

const BoolVector3 BoolVector3::cZero(false, false, false);
const BoolVector3 BoolVector3::cXAxis(true, false, false);
const BoolVector3 BoolVector3::cYAxis(false, true, false);
const BoolVector3 BoolVector3::cZAxis(false, false, true);


BoolVector3::BoolVector3(bool x_, bool y_, bool z_)
{
  x = x_;
  y = y_;
  z = z_;
}

bool& BoolVector3::operator[](uint index)
{
  ErrorIf(index > 2, "Math::BoolVector3 - Subscript out of range.");
  return array[index];
}

bool BoolVector3::operator[](uint index) const
{
  ErrorIf(index > 2, "Math::BoolVector3 - Subscript out of range.");
  return array[index];
}

BoolVector3 BoolVector3::operator!(void) const
{
  return BoolVector3(!x, !y, !z);
}

bool BoolVector3::operator==(BoolVec3Param rhs) const
{
  return x == rhs.x && y == rhs.y && z == rhs.z;
}

bool BoolVector3::operator!=(BoolVec3Param rhs) const
{
  return !((*this) == rhs);
}

void BoolVector3::Set(bool x_, bool y_, bool z_)
{
  x = x_;
  y = y_;
  z = z_;
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file BoolVector4.cpp
///  Implementation of the BoolVector4 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Math
{

const BoolVector4 BoolVector4::cZero(false, false, false, false);
const BoolVector4 BoolVector4::cXAxis(true, false, false, false);
const BoolVector4 BoolVector4::cYAxis(false, true, false, false);
const BoolVector4 BoolVector4::cZAxis(false, false, true, false);
const BoolVector4 BoolVector4::cWAxis(false, false, false, true);


BoolVector4::BoolVector4(bool x_, bool y_, bool z_, bool w_)
{
  x = x_;
  y = y_;
  z = z_;
  w = w_;
}

bool& BoolVector4::operator[](uint index)
{
  ErrorIf(index > 2, "Math::BoolVector4 - Subscript out of range.");
  return array[index];
}

bool BoolVector4::operator[](uint index) const
{
  ErrorIf(index > 2, "Math::BoolVector4 - Subscript out of range.");
  return array[index];
}

BoolVector4 BoolVector4::operator!(void) const
{
  return BoolVector4(!x, !y, !z, !w);
}

bool BoolVector4::operator==(BoolVec4Param rhs) const
{
  return x == rhs.x && y == rhs.y && z == rhs.z && w == rhs.w;
}

bool BoolVector4::operator!=(BoolVec4Param rhs) const
{
  return !((*this) == rhs);
}

void BoolVector4::Set(bool x_, bool y_, bool z_, bool w_)
{
  x = x_;
  y = y_;
  z = z_;
  w = w_;
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Curve.cpp
/// Implementation of the Curve class.
///
/// Authors: Joshua Davis
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Math
{

static const Mat4 CatmullBasis = Mat4(Vec4(0,-1, 2,-1) / real(2.0),
                                      Vec4(2, 0,-5, 3) / real(2.0),
                                      Vec4(0, 1, 4,-3) / real(2.0),
                                      Vec4(0, 0,-1, 1) / real(2.0));

static const Mat4 BSplineBasis = Mat4(Vec4(-1, 3,-3, 1) / real(6.0),
                                      Vec4( 3,-6, 0, 4) / real(6.0),
                                      Vec4(-3, 3, 3, 1) / real(6.0),
                                      Vec4( 1, 0, 0, 0) / real(6.0));

//------------------------------------------------------------------------ Curve
SplineCurve::SplineCurve()
{
  mCurveType = CurveType::CatmulRom;
  mClosed = false;
}

void SplineCurve::AddControlPoint(Vec3Param controlPoint)
{
  ControlPoints.push_back(controlPoint);
}

void SplineCurve::RemovePointAtIndex(uint index)
{
  if(index >= ControlPoints.size())
    return;

  ControlPoints.eraseAt(index);
}

void SplineCurve::AddControlPoints(const Vec3Array& controlPoints)
{
  ControlPoints.insert(ControlPoints.end(), controlPoints.begin(), controlPoints.end());
}

void SplineCurve::SetControlPoints(const Vec3Array& controlPoints)
{
  ControlPoints = controlPoints;
}

void SplineCurve::GetPoints(Vec3Array& results, uint resolution) const
{
  if(resolution == 0)
    return;

  Vec3Array points;
  GetSmoothPoints(points);
  if(points.size() < 4)
  {
    results = points;
    return;
  }

  //generate the points for the given curve type
  uint curveType = mCurveType;
  if(curveType == CurveType::Linear)
    results = points;
  else if(curveType == CurveType::BSpline)
    GetPoints<BSplinePolicy>(points,results,resolution);
  else if(curveType == CurveType::CatmulRom)
    GetPoints<CatmullRomPolicy>(points,results,resolution);
}

void SplineCurve::BakeAdaptive(Vec3Array& results, real error) const
{
  Vec3Array points;
  GetSmoothPoints(points);
  if(points.size() < 4)
  {
    results = points;
    return;
  }

  //generate the points for the given curve type
  uint curveType = mCurveType;
  if(curveType == CurveType::Linear)
    results = points;
  if(curveType == CurveType::BSpline)
    GetPoints<BSplinePolicy>(points,results,error);
  else if(curveType == CurveType::CatmulRom)
    GetPoints<CatmullRomPolicy>(points,results,error);
}

Vec3Array& SplineCurve::GetControlPoints()
{
  return ControlPoints;
}

void SplineCurve::Clear(void)
{
  ControlPoints.clear();
}

bool SplineCurve::GetClosed()
{
  return mClosed;
}

void SplineCurve::SetClosed(bool state)
{
  mClosed = state;
}

uint SplineCurve::GetCurveType()
{
  return mCurveType;
}

void SplineCurve::SetCurveType(uint curveType)
{
  mCurveType = curveType;
}

bool SplineCurve::DistanceSq(Vec3 point, uint resolution, real& distSq) const
{
  Vec3Array points;
  GetPoints(points, resolution);

  if (points.size() < 2)
    return false;

  real minDistSq1 = Math::PositiveMax(); // smallest distance
  real minDistSq2 = Math::PositiveMax(); // second smallest distance
  int idx1 = 0; // index of the point with the smallest distance
  int idx2 = 0; // index of the point with the second smallest distance

  for (uint i = 0; i < points.size(); ++i)
  {
    float currDistSq = (points[i] - point).LengthSq();
    if (currDistSq < minDistSq2)
    {
      minDistSq2 = currDistSq;
      idx2 = i;
    }
    if (currDistSq < minDistSq1)
    {
      minDistSq2 = minDistSq1;
      idx2 = idx1;
      minDistSq1 = currDistSq;
      idx1 = i;
    }
  }

  if (idx1 == 0 && idx2 == 0)
    return false;

  distSq = Math::DistanceToLineSq(points[idx1], points[idx2], point);
  return true;
}

void SplineCurve::GetSmoothPoints(Vec3Array& pts) const
{
  pts = ControlPoints;
  //if we have no points, just do nothing...
  if(pts.size() == 0)
    return;

  //if we have less than 4 points, we can't make a curve,
  //so just switch to linear mode
  uint curveType = mCurveType;
  if(pts.size() < 3)
    curveType = CurveType::Linear;

  //if we are in linear mode, just push back the control points
  //(and take into account the curve being closed)
  if(curveType == CurveType::Linear)
  {
    if(mClosed)
      pts.push_back(ControlPoints[0]);
    return;
  }

  //Fix the curve to be either closed or continuous
  if(mClosed)
    MakeClosed(pts);
  else
  {
    //deal with only having 3 control points by pushing the last point on again
    //don't need to do this when the curve is closed though.
    if(pts.size() == 3)
    {
      Vec3 point = pts.back();
      pts.push_back(point);
    }
    MakeContinuous(pts);
  }
}

void SplineCurve::MakeContinuous(Vec3Array& points) const
{
  //to make a curve continuous, we need an extra control point that keeps
  //the same direction. Therefore, compute a new point at both the
  //beginning and end that keeps the correct direction.
  Vec3 ab = points[0] - points[1];
  points.insert(points.begin(),points[0] + ab);

  uint size = points.size();
  Vec3 cd = points[size - 1] - points[size - 2];
  points.push_back(points[size - 1] + cd);
}

void SplineCurve::MakeClosed(Vec3Array& points) const
{
  //to make a curve closed, we have to duplicate 2 points at the other end
  //of the curve
  Vec3 end = points[points.size() - 1];
  Vec3 secondEnd = points[points.size() - 2];
  points.insert(points.begin(),end);
  points.insert(points.begin(),secondEnd);

  points.push_back(points[2]);
  points.push_back(points[3]);
}

template <typename Policy>
void SplineCurve::GetPoints(const Vec3Array& points, Vec3Array& results, uint resolution) const
{
  real t = real(0.0);
  uint start = 0;
  uint end = resolution;
  uint countControlPoints = uint(points.size() - 3);

  real step = real(1.0) / static_cast<real>(resolution);

  for(uint i = mClosed ? 1 : 0; i < countControlPoints; ++i)
  {
    t = real(0.0);
    end = resolution;

    if(i == countControlPoints - 1)
      ++end;

    Vec3Param cp0 = points[i];
    Vec3Param cp1 = points[i + 1];
    Vec3Param cp2 = points[i + 2];
    Vec3Param cp3 = points[i + 3];

    for(uint j = start; j < end; ++j)
    {
      PointData data = ComputePointData<Policy>(t,cp0,cp1,cp2,cp3);
      Vec3 point = data.Point;
      results.push_back(point);
      t += step;
    }
  }
}

template <typename Policy>
void SplineCurve::GetPoints(const Vec3Array& points, Vec3Array& results, real error) const
{
  uint countControlPoints = uint(points.size() - 3);

  Vec3 veryLastPoint;
  for(uint i = mClosed ? 1 : 0; i < countControlPoints; ++i)
  {
    Vec3Param cp0 = points[i];
    Vec3Param cp1 = points[i + 1];
    Vec3Param cp2 = points[i + 2];
    Vec3Param cp3 = points[i + 3];

    //add the start, mid and last point to the stack (need the middle point
    //since the spline is cubic, this "approximates" each sub-section as a quadratic)
    Zero::Array<PointData> stack;
    PointData firstPoint = ComputePointData<Policy>(real(0.0), cp0, cp1, cp2, cp3);
    PointData centerPoint = ComputePointData<Policy>(real(0.5), cp0, cp1, cp2, cp3);
    PointData lastPoint = ComputePointData<Policy>(real(1.0), cp0, cp1, cp2, cp3);
    stack.push_back(lastPoint);
    stack.push_back(centerPoint);
    stack.push_back(firstPoint);
    veryLastPoint = lastPoint.Point;
    
    while(stack.size() != 1)
    {
      uint size = stack.size();

      PointData data0 = stack[size - 1];
      PointData data1 = stack[size - 2];

      Vec3 movement = data1.Point - data0.Point;
      //calculate the point half-way in-between the two points on the stack
      real midT = (data0.T + data1.T) * real(0.5);
      PointData midData = ComputePointData<Policy>(midT, cp0, cp1, cp2, cp3);
      Vec3 midPoint = midData.Point;

      //calculate the distance of this point from the line
      //(aka, calculate the height of the triangle)
      real doubleArea = (Math::Cross(midPoint - data0.Point, midPoint - data1.Point)).Length();

      real base = movement.Length();
      real height = doubleArea / base;

      //if the height of the triangle is too large then we need to
      //subdivide more to get a better approximation of the curve
      if(height > error)
      {
        stack[size - 1] = midData;
        stack.push_back(data0);
      }
      else
      {
        results.push_back(data0.Point);
        results.push_back(midPoint);
        stack.pop_back();
      }
    }
  }
  results.push_back(veryLastPoint);
}

template <typename Policy>
Vec3 SplineCurve::ComputePoint(real t, Vec3Param a, Vec3Param b, Vec3Param c, Vec3Param d) const
{
  Vec4 param = Policy::GetParam(t);
  const Mat4& basis = Policy::GetBasis();

  Vec4 x(a.x,b.x,c.x,d.x);
  x = Math::Transform(basis,x);

  Vec4 y(a.y,b.y,c.y,d.y);
  y = Math::Transform(basis,y);

  Vec4 z(a.z,b.z,c.z,d.z);
  z = Math::Transform(basis,z);

  return Vec3(Math::Dot(param,x),Math::Dot(param,y),Math::Dot(param,z));
}

template <typename Policy>
SplineCurve::PointData SplineCurve::ComputePointData(real t, Vec3Param a, Vec3Param b, Vec3Param c, Vec3Param d) const
{
  PointData data;

  data.Point = ComputePoint<Policy>(t, a, b, c, d);
  data.T = t;
  return data;
}

//-------------------------------------------------------------- B-Spline Policy
const Mat4& SplineCurve::BSplinePolicy::GetBasis()
{
  return BSplineBasis;
}

Vec4 SplineCurve::BSplinePolicy::GetParam(real t)
{
  return Vec4(t*t*t,t*t,t,1);
}

//----------------------------------------------------------- Catmull-Rom Policy
const Mat4& SplineCurve::CatmullRomPolicy::GetBasis()
{
  return CatmullBasis;
}

Vec4 SplineCurve::CatmullRomPolicy::GetParam(real t)
{
  return Vec4(1,t,t*t,t*t*t);
}

//-------------------------------------------------------------------BakedCurve
void BakedCurve::Bake(const SplineCurve& curve, real error)
{
  //get all of the baked points from the curve (right now allocate a
  //temp array for this, maybe figure something better out later)
  Vec3Array pts;
  curve.BakeAdaptive(pts, error);
  if(pts.size() == 0)
    return;

  float totalLength = 0.0f;
  
  mArcLengthTable.resize(pts.size());
  //the 1st point is at length 0, 
  mArcLengthTable[0].ArcLength = 0.0f;
  mArcLengthTable[0].Position = pts[0];

  //now compute the rest of the points
  for(uint i = 1; i < pts.size(); ++i)
  {
    Vec3 oldPos = pts[i - 1];
    Vec3 curPos = pts[i];

    //get the vector from the previous point to the current point
    Vec3 dir = curPos - oldPos;
    //now increase the total arc length by this distance vector
    float length = dir.Length();
    totalLength += length;

    //make sure to set the position and arc length of this point
    mArcLengthTable[i].ArcLength = totalLength;
    mArcLengthTable[i].Position = pts[i];
  }
}

uint BakedCurve::Size() const
{
  return mArcLengthTable.size();
}

real BakedCurve::GetTotalArcLength() const
{
  uint tableSize = Size();
  if(tableSize == 0)
    return real(0.0);

  return mArcLengthTable[tableSize - 1].ArcLength;
}

BakedCurve::BakedData BakedCurve::GetPoint(uint index)
{
  if(index >= mArcLengthTable.size())
    return BakedData();

  return mArcLengthTable[index];
}

void BakedCurve::SetPoint(uint index, Vec3Param pos)
{
  if(index < mArcLengthTable.size())
    mArcLengthTable[index].Position = pos;
}

Vec3 BakedCurve::SampleTable(float distance, Vec3* tangent) const
{
  //handle the two special cases where we can't interpolate between two points
  if(mArcLengthTable.size() == 0)
    return Vec3::cZero;
  if(mArcLengthTable.size() == 1)
    return mArcLengthTable[0].Position;
  //there is no curve (the only points are on top of each other)
  if(GetTotalArcLength() == real(0.0))
    return mArcLengthTable[0].Position;

  real oldDistance = distance;
  distance = Math::FMod(distance, GetTotalArcLength());
  //If the user passes in the total arc-length, fmod will return the start point
  //not the end point. To fix this if fmod returns 0 but our original value
  //wasn't zero then instead use the total arc-length.
  if(distance == real(0.0) && oldDistance != real(0.0))
    distance = GetTotalArcLength();
  //fmod can still return negative numbers so convert to positive
  if(distance < real(0.0))
    distance += GetTotalArcLength();

  //get the indices of the two baked point we're between
  uint lowerBound = SampleLowerBound(distance);
  uint upperBound = lowerBound + 1;

  const BakedData& lowerBoundData = mArcLengthTable[lowerBound];
  const BakedData& upperBoundData = mArcLengthTable[upperBound];

  float d0 = lowerBoundData.ArcLength;
  float d1 = upperBoundData.ArcLength;
  //compute how far in-between these two points we are
  float t = (distance - d0) / (d1 - d0);

  Vec3 p0 = lowerBoundData.Position;
  Vec3 p1 = upperBoundData.Position;
  Vec3 samplePoint = Math::Lerp(p0, p1, t);

  //if the user wants a tangent, compute it simply as the vector from the first to
  //second point, where we are on this linear segment doesn't matter
  if(tangent != NULL)
  {
    Vec3 tangentDir = p1 - p0;
    *tangent = tangentDir.AttemptNormalized();
  }

  return samplePoint;
}

uint BakedCurve::SampleLowerBound(real distance) const
{
  //binary search for the lower bound
  uint begin = 0;
  uint end = mArcLengthTable.size() - 1;

  while(begin < end)
  {
    uint mid = (begin + end) / 2;
    if(mArcLengthTable[mid].ArcLength <= distance)
      begin = mid + 1;
    else
      end = mid;
  }

  //this binary search actually produced the upper bound,
  //the lower bound is the previous index
  return begin - 1;
}

//----------------------------------------------------------- Piecewise Function
/// Used to sort the control points by the x-position.
struct SortByX
{
  bool operator()(PiecewiseFunction::ControlPoint& left,
                  PiecewiseFunction::ControlPoint& right)
  {
    // We never want two control points to have the same Time,
    // so every time they're sorted, check and move one slightly
    if(left.Position.x == right.Position.x)
      right.Position.x += 0.0001f;
    return left.Position.x < right.Position.x;
  }
};

//******************************************************************************
PiecewiseFunction::PiecewiseFunction()
{
  mCurveType = CurveType::BSpline;
  mError = real(0.05);
}

//******************************************************************************
void PiecewiseFunction::Clear()
{
  // Clear all the control points
  mControlPoints.clear();

  // The baked curve is no longer valid
  mBakedCurve.clear();
}

//******************************************************************************
void PiecewiseFunction::AddControlPoint(Vec2Param pos, Vec2Param tanIn, 
                                        Vec2Param tanOut)
{
  ControlPoint cp;
  cp.Position = pos;
  cp.TangentIn = tanIn;
  cp.TangentOut = tanOut;
  mControlPoints.push_back(cp);

  // Sort the control points along the x
  sort(mControlPoints.all(), SortByX());

  // The baked curve is no longer valid
  mBakedCurve.clear();
}

//******************************************************************************
void PiecewiseFunction::SetControlPoints(Zero::Array<ControlPoint>& controlPoints)
{
  mControlPoints.assign(controlPoints.all());

  // Sort the control points along the x
  sort(mControlPoints.all(), SortByX());

  // The baked curve is no longer valid
  mBakedCurve.clear();
}

//******************************************************************************
float PiecewiseFunction::Sample(real x)
{
  // Default case
  if(mControlPoints.empty())
    return 0.0f;

  // If it's to the left of the left most control point, return its y
  if(x <= mControlPoints.front().Position.x)
    return mControlPoints.front().Position.y;
  // If it's to the right of the right most control point, return its y
  else if(x >= mControlPoints.back().Position.x)
    return mControlPoints.back().Position.y;

  // Make sure the curve is baked
  if(!IsBaked())
    Bake();

  // Binary search to find the location of the sample
  int begin = 0;
  int end = (int)mBakedCurve.size();

  while(begin < end)
  {
    int mid = (begin + end) / 2;
    if(mBakedCurve[mid].x < x)
      begin = mid + 1;
    else
      end = mid;
  }

  // Interpolate between the two points in the baked curve
  Vec3 p0 = mBakedCurve[begin - 1];
  Vec3 p1 = mBakedCurve[begin];
  real localT = (x - p0.x) / (p1.x - p0.x);
  return Math::Lerp(p0.y, p1.y, localT);
}

//******************************************************************************
void PiecewiseFunction::Bake()
{
  mBakedCurve.clear();

  // Can't do anything with 0 control points
  if(mControlPoints.empty())
    return;

  // With just one point, any sample value will result in the single point
  if(mControlPoints.size() == 1)
  {
    mBakedCurve.push_back(ToVector3(mControlPoints.front().Position));
    return;
  }

  // We are going to use this to generate curves between control points
  static SplineCurve sCurve;
  sCurve.SetClosed(false);
  sCurve.mCurveType = mCurveType;

  // Walk through each set of control points
  for(uint i = 0; i < mControlPoints.size() - 1; ++i)
  {
    // Get the two control points
    ControlPoint& cp0 = mControlPoints[i];
    ControlPoint& cp1 = mControlPoints[i + 1];

    // Clear the old curve
    sCurve.ControlPoints.clear();

    // If it is discontinuous, 
    if(cp0.TangentOut.x == 0.0f || cp1.TangentIn.x == 0.0f)
    {
      // Only on the first iteration is the left control point not added
      if(i == 0)
        mBakedCurve.push_back(Vec3(cp0.Position));
      mBakedCurve.push_back(Vec3(Vec2(cp1.Position.x, cp0.Position.y)));
      mBakedCurve.push_back(Vec3(cp1.Position));
      continue;
    }

    // It's a function, so we must clamp the tangent at the midway
    // point on the x-axis
    Vec2 halfWay = (cp0.Position + cp1.Position) * 0.5f;

    // Clamp the out tangent of the first control point
    float maxExtent = (halfWay.x - cp0.Position.x);
    float tangentScalar = maxExtent / cp0.TangentOut.x;
    tangentScalar = Math::Min(tangentScalar, 1.0f);

    // The newly clamped tangent
    Vec2 tangentOutClamped = cp0.Position + cp0.TangentOut * tangentScalar;

    // Add the first control point and clamped tangent out
    sCurve.AddControlPoint(Vec3(cp0.Position));
    sCurve.AddControlPoint(Vec3(tangentOutClamped));

    // Now do the same for the tangentIn on the second control point
    maxExtent = (halfWay.x - cp1.Position.x);
    tangentScalar = maxExtent / cp1.TangentIn.x;
    tangentScalar = Math::Min(tangentScalar, 1.0f);
    Vec2 tangentInClamped = cp1.Position + cp1.TangentIn * tangentScalar;

    // Add the clamped tangent in and the second control point
    sCurve.AddControlPoint(Vec3(tangentInClamped));
    sCurve.AddControlPoint(Vec3(cp1.Position));

    // Add the points of the curve
    sCurve.BakeAdaptive(mBakedCurve, mError);
  }
}

//******************************************************************************
bool PiecewiseFunction::IsBaked()
{
  return !mBakedCurve.empty();
}

//******************************************************************************
Vec3Array::range PiecewiseFunction::GetBakedCurve()
{
  return mBakedCurve.all();
}

//******************************************************************************
bool PiecewiseFunction::empty()
{
  return mBakedCurve.empty();
}

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file DecomposedMatrix4.cpp
/// Implementation of the DecomposedMatrix4 structure.
/// 
/// Authors: Joshua Davis
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////








namespace Math
{

DecomposedMatrix4::DecomposedMatrix4()
{
  Translation.ZeroOut();
  Scale.Splat(real(1.0));
  Rotation.SetIdentity();
}

DecomposedMatrix4::DecomposedMatrix4(Mat4Param transform)
{
  Set(transform);
}

void DecomposedMatrix4::Set(Mat4Param transform)
{
  transform.Decompose(&Scale,&Rotation,&Translation);
}

Vector3 DecomposedMatrix4::TransformNormal(Vec3Param normal)
{
  Vector3 result = normal * Scale;
  return Math::Transform(Rotation,result);
}

Vector3 DecomposedMatrix4::InverseTransformNormal(Vec3Param normal)
{
  Vector3 result = Math::TransposedTransform(Rotation,normal);
  return result / Scale;
}

Vector3 DecomposedMatrix4::TransformSurfaceNormal(Vec3Param direction)
{
  Vector3 result = Math::Transform(Rotation, direction);
  return result / Scale;
}

Vector3 DecomposedMatrix4::InverseTransformSurfaceNormal(Vec3Param direction)
{
  Vector3 result = Math::TransposedTransform(Rotation, direction);
  return result * Scale;
}

Vector3 DecomposedMatrix4::TransformPoint(Vec3Param point)
{
  Vector3 result = point * Scale;
  result = Math::Transform(Rotation,result);
  return result + Translation;
}

Vector3 DecomposedMatrix4::InverseTransformPoint(Vec3Param point)
{
  Vector3 result = point - Translation;
  result = Math::TransposedTransform(Rotation,result);
  return result / Scale;
}

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file EulerAngles.cpp
///  Implementation of the EulerAngle structure, design referenced from
///  Insomniac Games.
///  
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Math
{
//----------------------------------------------------------------- Euler Angles
EulerAngles::EulerAngles(EulerOrderParam order)
  : Order(order)
{
  //
}

EulerAngles::EulerAngles(Vec3Param xyzRotation, EulerOrderParam order)
  : Angles(xyzRotation), Order(order)
{
  //
}

EulerAngles::EulerAngles(real xRotation, real yRotation, real zRotation, 
                         EulerOrderParam order)
  : Angles(xRotation, yRotation, zRotation), Order(order)
{
  //
}

EulerAngles::EulerAngles(Mat3Param matrix, EulerOrderParam order)
  : Order(order)
{
  Math::ToEulerAngles(matrix, this);
}

EulerAngles::EulerAngles(Mat4Param matrix, EulerOrderParam order)
  : Order(order)
{
  Math::ToEulerAngles(matrix, this);
}

EulerAngles::EulerAngles(QuatParam quaternion, EulerOrderParam order)
  : Order(order)
{
  Math::ToEulerAngles(quaternion, this);
}

real EulerAngles::operator [] (uint index) const
{
  return Angles[index];
}

real& EulerAngles::operator [] (uint index)
{
  return Angles[index];
}

real EulerAngles::I(void) const
{
  return Angles[Order.I()];
}

real EulerAngles::J(void) const
{
  return Angles[Order.J()];
}

real EulerAngles::K(void) const
{
  return Angles[Order.K()];
}

real EulerAngles::H(void) const
{
  return Angles[Order.H()];
}

void EulerAngles::I(real i)
{
  Angles[Order.I()] = i;
}

void EulerAngles::J(real j)
{
  Angles[Order.J()] = j;
}

void EulerAngles::K(real k)
{
  Angles[Order.K()] = k;
}

void EulerAngles::H(real h)
{
  Angles[Order.H()] = h;
}

void EulerAngles::Reorder(EulerOrderParam newOrder)
{
  Order = newOrder;
}
}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file EulerOrder.cpp
///  Implementation of the Euler angles order as described in Graphic Gems IV,
///  EulerOrder design referenced from Insomniac Games.
///  
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Math
{

EulerOrder::EulerOrder(EulerOrders::Enum eulerOrder)
  : Order(eulerOrder)
{
  //
}

EulerOrder& EulerOrder::operator = (EulerOrderParam rhs)
{
  Order = rhs.Order;
  return *this;
}

bool EulerOrder::operator == (EulerOrderParam rhs)
{
  return Order == rhs.Order;
}

bool EulerOrder::operator != (EulerOrderParam rhs)
{
  return Order != rhs.Order;
}

uint EulerOrder::I(void) const
{
  return EulerOrders::Safe[((uint(Order) >> 3) & 3)];
}

uint EulerOrder::J(void) const
{
  return EulerOrders::Next[I() + (OddParity() ? 1 : 0)];
}

uint EulerOrder::K(void) const
{
  return EulerOrders::Next[I() + (OddParity() ? 0 : 1)];
}

uint EulerOrder::H(void) const
{
  return RepeatingAngles() == EulerOrders::No ? K() : I();
}

bool EulerOrder::RepeatingAngles(void) const
{
  return ((uint(Order) >> 1) & 1) == EulerOrders::Yes;
}

bool EulerOrder::RotatingFrame(void) const
{
  return (uint(Order) & 1) == EulerOrders::Rotated;
}

bool EulerOrder::OddParity(void) const
{
  return ((uint(Order) >> 2) & 1) == EulerOrders::Odd;
}

void EulerOrder::GetOrder(EulerOrder order, uint& i, uint& j, uint& k, uint& h,
                          uint& parity, uint& repeated, uint& frame)
{
  uint orderValue = uint(order.Order);
  
  frame = orderValue & 1;
  orderValue >>= 1;
  
  repeated = orderValue & 1;
  orderValue >>= 1;      
  
  parity = orderValue & 1;
  orderValue >>= 1;      
  
  i = EulerOrders::Safe[orderValue & 3];      
  
  j = EulerOrders::Next[i + parity];      
  
  k = EulerOrders::Next[i + 1 - parity];  
  
  h = repeated ? k : i;           
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file ExtendableMath.cpp
/// 
/// Authors: Joshua Davis
/// Copyright 2014, DigiPen Institute of Technology
///
//////////////////////////////////////////////////////////////////////////////




namespace Math
{

//-------------------------------------------------------------------ExtendableVector
void ExtendableVector::resize(uint size)
{
  mSize = size;
  mData.resize(mSize);
}

real& ExtendableVector::operator[](uint index)
{
  return mData[index];
}

real ExtendableVector::operator[](uint index) const
{
  return mData[index];
}

uint ExtendableVector::GetSize() const
{
  return mSize;
}

//-------------------------------------------------------------------ExtendableMatrix
void ExtendableMatrix::resize(uint sizeX, uint sizeY)
{
  mSizeX = sizeX;
  mSizeY = sizeY;
  mData.resize(mSizeX * mSizeY);
}

real& ExtendableMatrix::operator()(uint y, uint x)
{
  return mData[x + mSizeX * y];
}

real ExtendableMatrix::operator()(uint y, uint x) const
{
  return mData[x + mSizeX * y];
}

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file IntVector2.cpp
///  Implementation of the IntVector2 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Math
{

const IntVector2 IntVector2::cZero(0, 0);
const IntVector2 IntVector2::cXAxis(1, 0);
const IntVector2 IntVector2::cYAxis(0, 1);


IntVector2::IntVector2(int x_, int y_)
{
  x = x_;
  y = y_;
}

int& IntVector2::operator[](uint index)
{
  ErrorIf(index > 1, "Math::IntVector2 - Subscript out of range.");
  return array[index];
}

int IntVector2::operator[](uint index) const
{
  ErrorIf(index > 1, "Math::IntVector2 - Subscript out of range.");
  return array[index];
}


////////// Unary Operators /////////////////////////////////////////////////////

IntVector2 IntVector2::operator-(void) const
{
  return IntVector2(-x, -y);
}


////////// Binary Assignment Operators (reals) /////////////////////////////////

void IntVector2::operator*=(int rhs)
{
  x *= rhs;
  y *= rhs;
}

void IntVector2::operator/=(int rhs)
{
  ErrorIf(rhs == 0, "Math::IntVector2 - Division by zero.");
  x /= rhs;
  y /= rhs;
}


////////// Binary Operators (reals) ////////////////////////////////////////////

IntVector2 IntVector2::operator*(int rhs) const
{
  return IntVector2(x * rhs, y * rhs);
}

IntVector2 IntVector2::operator/(int rhs) const
{
  ErrorIf(rhs == 0, "Math::IntVector2 - Division by zero.");
  return IntVector2(x / rhs, y / rhs);
}


IntVector2 IntVector2::operator%(int rhs) const
{
  ErrorIf(rhs == 0, "Math::IntVector2 - Mod by zero.");
  return IntVector2(x % rhs, y % rhs);
}

IntVector2& IntVector2::operator++()
{
  ++x;
  ++y;
  return *this;
}

IntVector2& IntVector2::operator--()
{
  --x;
  --y;
  return *this;
}


////////// Binary Assignment Operators (Vectors) ///////////////////////////////

void IntVector2::operator+=(IntVec2Param rhs)
{
  x += rhs.x;
  y += rhs.y;
}

void IntVector2::operator-=(IntVec2Param rhs)
{
  x -= rhs.x;
  y -= rhs.y;
}

void IntVector2::operator*=(IntVec2Param rhs)
{
  x *= rhs.x;
  y *= rhs.y;
}

void IntVector2::operator/=(IntVec2Param rhs)
{
  ErrorIf(rhs.x == 0 || rhs.y == 0, 
          "IntVector2 - Division by zero.");
  x /= rhs.x;
  y /= rhs.y;
}


////////// Binary Operators (Vectors) //////////////////////////////////////////

IntVector2 IntVector2::operator+(IntVec2Param rhs) const
{
  return IntVector2(x + rhs.x, y + rhs.y);
}

IntVector2 IntVector2::operator-(IntVec2Param rhs) const
{
  return IntVector2(x - rhs.x, y - rhs.y);
}


////////// Binary Vector Comparisons ///////////////////////////////////////////

bool IntVector2::operator==(IntVec2Param rhs) const
{
  return x == rhs.x && y == rhs.y;
}

bool IntVector2::operator!=(IntVec2Param rhs) const
{
  return !(*this == rhs);
}

BoolVec2 IntVector2::operator< (IntVec2Param rhs) const
{
  return BoolVec2(x < rhs.x,
                  y < rhs.y);
}

BoolVec2 IntVector2::operator<=(IntVec2Param rhs) const
{
  return BoolVec2(x <= rhs.x,
                  y <= rhs.y);
}

BoolVec2 IntVector2::operator> (IntVec2Param rhs) const
{
  return BoolVec2(x > rhs.x,
                  y > rhs.y);
}

BoolVec2 IntVector2::operator>=(IntVec2Param rhs) const
{
  return BoolVec2(x >= rhs.x,
                  y >= rhs.y);
}


void IntVector2::Set(int x_, int y_)
{
  x = x_;
  y = y_;
}

void IntVector2::ZeroOut(void)
{
  x = 0;
  y = 0;
}


IntVector2 IntVector2::operator/(IntVec2Param rhs) const
{
  ErrorIf(rhs.x == 0 || rhs.y == 0, 
          "IntVector2 - Division by zero.");
  return IntVector2(x / rhs.x, y / rhs.y);
}

IntVector2 IntVector2::operator*(IntVec2Param rhs) const
{
  return IntVector2(x * rhs.x, y * rhs.y);
}

IntVector2 IntVector2::operator%(IntVec2Param rhs) const
{
  ErrorIf(rhs.x == 0 || rhs.y == 0, 
          "IntVector2 - Mod by zero.");
  return IntVector2(x % rhs.x, y % rhs.y);
}

IntVector2 operator*(int lhs, IntVec2Param rhs)
{
  return rhs * lhs;
}

IntVector2 Abs(IntVec2Param vec)
{
  return IntVector2(Math::Abs(vec.x), Math::Abs(vec.y));
}

IntVector2 Min(IntVec2Param lhs, IntVec2Param rhs)
{
  return IntVector2(Math::Min(lhs.x, rhs.x),
                    Math::Min(lhs.y, rhs.y));
}

IntVector2 Max(IntVec2Param lhs, IntVec2Param rhs)
{
  return IntVector2(Math::Max(lhs.x, rhs.x),
                    Math::Max(lhs.y, rhs.y));
}

IntVector2  IntVector2::operator~() const
{
  return IntVector2(~x,
                    ~y);
}

IntVector2  IntVector2::operator<< (IntVec2Param rhs) const
{
  return IntVector2(x << rhs.x,
                    y << rhs.y);
}

IntVector2  IntVector2::operator>> (IntVec2Param rhs) const
{
  return IntVector2(x >> rhs.x,
                    y >> rhs.y);
}

IntVector2  IntVector2::operator|  (IntVec2Param rhs) const
{
  return IntVector2(x | rhs.x,
                    y | rhs.y);
}

IntVector2  IntVector2::operator^  (IntVec2Param rhs) const
{
  return IntVector2(x ^ rhs.x,
                    y ^ rhs.y);
}

IntVector2  IntVector2::operator&  (IntVec2Param rhs) const
{
  return IntVector2(x & rhs.x,
                    y & rhs.y);
}

IntVector2& IntVector2::operator<<=(IntVec2Param rhs)
{
  x <<= rhs.x;
  y <<= rhs.y;
  return *this;
}

IntVector2& IntVector2::operator>>=(IntVec2Param rhs)
{
  x >>= rhs.x;
  y >>= rhs.y;
  return *this;
}

IntVector2& IntVector2::operator|= (IntVec2Param rhs)
{
  x |= rhs.x;
  y |= rhs.y;
  return *this;
}

IntVector2& IntVector2::operator^= (IntVec2Param rhs)
{
  x ^= rhs.x;
  y ^= rhs.y;
  return *this;
}

IntVector2& IntVector2::operator&= (IntVec2Param rhs)
{
  x &= rhs.x;
  y &= rhs.y;
  return *this;
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file IntVector3.cpp
///  Implementation of the IntVector3 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Math
{

const IntVector3 IntVector3::cZero(0, 0, 0);
const IntVector3 IntVector3::cXAxis(1, 0, 0);
const IntVector3 IntVector3::cYAxis(0, 1, 0);
const IntVector3 IntVector3::cZAxis(0, 0, 1);


IntVector3::IntVector3(int x_, int y_, int z_)
{
  x = x_;
  y = y_;
  z = z_;
}

int& IntVector3::operator[](uint index)
{
  ErrorIf(index > 2, "IntVector3 - Subscript out of range.");
  return array[index];
}

int IntVector3::operator[](uint index) const
{
  ErrorIf(index > 2, "IntVector3 - Subscript out of range.");
  return array[index];
}


////////// Unary Operators /////////////////////////////////////////////////////

IntVector3 IntVector3::operator-(void) const
{
  return IntVector3(-x, -y, -z);
}


////////// Binary Assignment Operators (reals) /////////////////////////////////

void IntVector3::operator*=(int rhs)
{
  x *= rhs;
  y *= rhs;
  z *= rhs;
}

void IntVector3::operator/=(int rhs)
{
  ErrorIf(rhs == 0, "IntVector3 - Division by zero.");
  x /= rhs;
  y /= rhs;
  z /= rhs;
}


////////// Binary Operators (reals) ////////////////////////////////////////////

IntVector3 IntVector3::operator*(int rhs) const
{
  return IntVector3(x * rhs, y * rhs, z * rhs);
}

IntVector3 IntVector3::operator/(int rhs) const
{
  ErrorIf(rhs == 0, "IntVector3 - Division by zero.");
  return IntVector3(x / rhs, y / rhs, z / rhs);
}

IntVector3 IntVector3::operator%(int rhs) const
{
  ErrorIf(rhs == 0, "IntVector3 - Mod by zero.");
  return IntVector3(x % rhs, y % rhs, z % rhs);
}

IntVector3& IntVector3::operator++()
{
  ++x;
  ++y;
  ++z;
  return *this;
}

IntVector3& IntVector3::operator--()
{
  --x;
  --y;
  --z;
  return *this;
}

////////// Binary Assignment Operators (Vectors) ///////////////////////////////

void IntVector3::operator+=(IntVec3Param rhs)
{
  x += rhs.x;
  y += rhs.y;
  z += rhs.z;
}

void IntVector3::operator-=(IntVec3Param rhs)
{
  x -= rhs.x;
  y -= rhs.y;
  z -= rhs.z;
}

void IntVector3::operator*=(IntVec3Param rhs)
{
  x *= rhs.x;
  y *= rhs.y;
  z *= rhs.z;
}

void IntVector3::operator/=(IntVec3Param rhs)
{
  ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0, 
          "Vector2 - Division by zero.");
  x /= rhs.x;
  y /= rhs.y;
  z /= rhs.z;
}


////////// Binary Operators (Vectors) //////////////////////////////////////////

IntVector3 IntVector3::operator+(IntVec3Param rhs) const
{
  return IntVector3(x + rhs.x, y + rhs.y, z + rhs.z);
}

IntVector3 IntVector3::operator-(IntVec3Param rhs) const
{
  return IntVector3(x - rhs.x, y - rhs.y, z - rhs.z);
}


////////// Binary Vector Comparisons ///////////////////////////////////////////

bool IntVector3::operator==(IntVec3Param rhs) const
{
  return x == rhs.x && y == rhs.y && z == rhs.z;
}

bool IntVector3::operator!=(IntVec3Param rhs) const
{
  return !(*this == rhs);
}


BoolVec3 IntVector3::operator< (IntVec3Param rhs) const
{
  return BoolVec3(x < rhs.x,
                  y < rhs.y,
                  z < rhs.z);
}

BoolVec3 IntVector3::operator<=(IntVec3Param rhs) const
{
  return BoolVec3(x <= rhs.x,
                  y <= rhs.y,
                  z <= rhs.z);
}

BoolVec3 IntVector3::operator> (IntVec3Param rhs) const
{
  return BoolVec3(x > rhs.x,
                  y > rhs.y,
                  z > rhs.z);
}

BoolVec3 IntVector3::operator>=(IntVec3Param rhs) const
{
  return BoolVec3(x >= rhs.x,
                  y >= rhs.y,
                  z >= rhs.z);
}

void IntVector3::Set(int x_, int y_, int z_)
{
  x = x_;
  y = y_;
  z = z_;
}

void IntVector3::ZeroOut(void)
{
  x = 0;
  y = 0;
  z = 0;
}


IntVector3 IntVector3::operator/(IntVec3Param rhs) const
{
  ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0, 
          "IntVector3 - Division by zero.");
  return IntVector3(x / rhs.x, y / rhs.y, z / rhs.z);
}

IntVector3 IntVector3::operator*(IntVec3Param rhs) const
{
  return IntVector3(x * rhs.x, y * rhs.y, z * rhs.z);
}

IntVector3 IntVector3::operator%(IntVec3Param rhs) const
{
  ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0, 
          "IntVector3 - Mod by zero.");
  return IntVector3(x % rhs.x, y % rhs.y, z % rhs.z);
}

IntVector3 operator*(int lhs, IntVec3Param rhs)
{
  return rhs * lhs;
}

IntVector3 Abs(IntVec3Param vec)
{
  return IntVector3(Math::Abs(vec.x), Math::Abs(vec.y), Math::Abs(vec.z));
}

IntVector3 Min(IntVec3Param lhs, IntVec3Param rhs)
{
  return IntVector3(Math::Min(lhs.x, rhs.x),
                    Math::Min(lhs.y, rhs.y),
                    Math::Min(lhs.z, rhs.z));
}

IntVector3 Max(IntVec3Param lhs, IntVec3Param rhs)
{
  return IntVector3(Math::Max(lhs.x, rhs.x),
                    Math::Max(lhs.y, rhs.y),
                    Math::Max(lhs.z, rhs.z));
}

IntVector3  IntVector3::operator~() const
{
  return IntVector3(~x,
                    ~y,
                    ~z);
}

IntVector3  IntVector3::operator<< (IntVec3Param rhs) const
{
  return IntVector3(x << rhs.x,
                    y << rhs.y,
                    z << rhs.z);
}

IntVector3  IntVector3::operator>> (IntVec3Param rhs) const
{
  return IntVector3(x >> rhs.x,
                    y >> rhs.y,
                    z >> rhs.z);
}

IntVector3  IntVector3::operator|  (IntVec3Param rhs) const
{
  return IntVector3(x | rhs.x,
                    y | rhs.y,
                    z | rhs.z);
}

IntVector3  IntVector3::operator^  (IntVec3Param rhs) const
{
  return IntVector3(x ^ rhs.x,
                    y ^ rhs.y,
                    z ^ rhs.z);
}

IntVector3  IntVector3::operator&  (IntVec3Param rhs) const
{
  return IntVector3(x & rhs.x,
                    y & rhs.y,
                    z & rhs.z);
}

IntVector3& IntVector3::operator<<=(IntVec3Param rhs)
{
  x <<= rhs.x;
  y <<= rhs.y;
  z <<= rhs.z;
  return *this;
}

IntVector3& IntVector3::operator>>=(IntVec3Param rhs)
{
  x >>= rhs.x;
  y >>= rhs.y;
  z >>= rhs.z;
  return *this;
}

IntVector3& IntVector3::operator|= (IntVec3Param rhs)
{
  x |= rhs.x;
  y |= rhs.y;
  z |= rhs.z;
  return *this;
}

IntVector3& IntVector3::operator^= (IntVec3Param rhs)
{
  x ^= rhs.x;
  y ^= rhs.y;
  z ^= rhs.z;
  return *this;
}

IntVector3& IntVector3::operator&= (IntVec3Param rhs)
{
  x &= rhs.x;
  y &= rhs.y;
  z &= rhs.z;
  return *this;
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file IntVector4.cpp
///  Implementation of the IntVector4 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Math
{

const IntVector4 IntVector4::cZero(0, 0, 0, 0);
const IntVector4 IntVector4::cXAxis(1, 0, 0, 0);
const IntVector4 IntVector4::cYAxis(0, 1, 0, 0);
const IntVector4 IntVector4::cZAxis(0, 0, 1, 0);
const IntVector4 IntVector4::cWAxis(0, 0, 0, 1);


IntVector4::IntVector4(int x_, int y_, int z_, int w_)
{
  x = x_;
  y = y_;
  z = z_;
  w = w_;
}

int& IntVector4::operator[](uint index)
{
  ErrorIf(index > 3, "IntVector4 - Subscript out of range.");
  return array[index];
}

int IntVector4::operator[](uint index) const
{
  ErrorIf(index > 3, "IntVector4 - Subscript out of range.");
  return array[index];
}


////////// Unary Operators /////////////////////////////////////////////////////

IntVector4 IntVector4::operator-(void) const
{
  return IntVector4(-x, -y, -z, -w);
}


////////// Binary Assignment Operators (reals) /////////////////////////////////

void IntVector4::operator*=(int rhs)
{
  x *= rhs;
  y *= rhs;
  z *= rhs;
  w *= rhs;
}

void IntVector4::operator/=(int rhs)
{
  ErrorIf(rhs == 0, "IntVector4 - Division by zero.");
  x /= rhs;
  y /= rhs;
  z /= rhs;
  w /= rhs;
}


////////// Binary Operators (reals) ////////////////////////////////////////////

IntVector4 IntVector4::operator*(int rhs) const
{
  return IntVector4(x * rhs, y * rhs, z * rhs, w * rhs);
}

IntVector4 IntVector4::operator/(int rhs) const
{
  ErrorIf(rhs == 0, "IntVector4 - Division by zero.");
  return IntVector4(x / rhs, y / rhs, z / rhs, w / rhs);
}

IntVector4 IntVector4::operator%(int rhs) const
{
  ErrorIf(rhs == 0, "IntVector4 - Mod by zero.");
  return IntVector4(x % rhs, y % rhs, z % rhs, w % rhs);
}

IntVector4& IntVector4::operator++()
{
  ++x;
  ++y;
  ++z;
  ++w;
  return *this;
}

IntVector4& IntVector4::operator--()
{
  --x;
  --y;
  --z;
  --w;
  return *this;
}

////////// Binary Assignment Operators (Vectors) ///////////////////////////////

void IntVector4::operator+=(IntVec4Param rhs)
{
  x += rhs.x;
  y += rhs.y;
  z += rhs.z;
  w += rhs.w;
}

void IntVector4::operator-=(IntVec4Param rhs)
{
  x -= rhs.x;
  y -= rhs.y;
  z -= rhs.z;
  w -= rhs.w;
}

void IntVector4::operator*=(IntVec4Param rhs)
{
  x *= rhs.x;
  y *= rhs.y;
  z *= rhs.z;
  w *= rhs.w;
}

void IntVector4::operator/=(IntVec4Param rhs)
{
  ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0 || rhs.w == 0, 
          "Vector2 - Division by zero.");
  x /= rhs.x;
  y /= rhs.y;
  z /= rhs.z;
  w /= rhs.w;
}


////////// Binary Operators (Vectors) //////////////////////////////////////////

IntVector4 IntVector4::operator+(IntVec4Param rhs) const
{
  return IntVector4(x + rhs.x, y + rhs.y, z + rhs.z, w + rhs.w);
}

IntVector4 IntVector4::operator-(IntVec4Param rhs) const
{
  return IntVector4(x - rhs.x, y - rhs.y, z - rhs.z, w - rhs.w);
}


////////// Binary Vector Comparisons ///////////////////////////////////////////

bool IntVector4::operator==(IntVec4Param rhs) const
{
  return x == rhs.x && y == rhs.y && z == rhs.z && w == rhs.w;
}

bool IntVector4::operator!=(IntVec4Param rhs) const
{
  return !(*this == rhs);
}


BoolVec4 IntVector4::operator< (IntVec4Param rhs) const
{
  return BoolVec4(x < rhs.x,
                  y < rhs.y,
                  z < rhs.z,
                  w < rhs.w);
}

BoolVec4 IntVector4::operator<=(IntVec4Param rhs) const
{
  return BoolVec4(x <= rhs.x,
                  y <= rhs.y,
                  z <= rhs.z,
                  w <= rhs.w);
}

BoolVec4 IntVector4::operator> (IntVec4Param rhs) const
{
  return BoolVec4(x > rhs.x,
                  y > rhs.y,
                  z > rhs.z,
                  w > rhs.w);
}

BoolVec4 IntVector4::operator>=(IntVec4Param rhs) const
{
  return BoolVec4(x >= rhs.x,
                  y >= rhs.y,
                  z >= rhs.z,
                  w >= rhs.w);
}

void IntVector4::Set(int x_, int y_, int z_, int w_)
{
  x = x_;
  y = y_;
  z = z_;
  w = w_;
}

void IntVector4::ZeroOut(void)
{
  x = 0;
  y = 0;
  z = 0;
  w = 0;
}


IntVector4 IntVector4::operator/(IntVec4Param rhs) const
{
  ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0 || rhs.w == 0, 
          "IntVector4 - Division by zero.");
  return IntVector4(x / rhs.x, y / rhs.y, z / rhs.z, w / rhs.w);
}

IntVector4 IntVector4::operator*(IntVec4Param rhs) const
{
  return IntVector4(x * rhs.x, y * rhs.y, z * rhs.z, w * rhs.w);
}

IntVector4 IntVector4::operator%(IntVec4Param rhs) const
{
  ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0 || rhs.w == 0, 
          "IntVector4 - Mod by zero.");
  return IntVector4(x % rhs.x, y % rhs.y, z % rhs.z, w % rhs.w);
}

IntVector4 operator*(int lhs, IntVec4Param rhs)
{
  return rhs * lhs;
}

IntVector4 Abs(IntVec4Param vec)
{
  return IntVector4(Math::Abs(vec.x), Math::Abs(vec.y), Math::Abs(vec.z), Math::Abs(vec.w));
}

IntVector4 Min(IntVec4Param lhs, IntVec4Param rhs)
{
  return IntVector4(Math::Min(lhs.x, rhs.x),
                    Math::Min(lhs.y, rhs.y),
                    Math::Min(lhs.z, rhs.z),
                    Math::Min(lhs.w, rhs.w));
}

IntVector4 Max(IntVec4Param lhs, IntVec4Param rhs)
{
  return IntVector4(Math::Max(lhs.x, rhs.x),
                    Math::Max(lhs.y, rhs.y),
                    Math::Max(lhs.z, rhs.z),
                    Math::Max(lhs.w, rhs.w));
}

IntVector4  IntVector4::operator~() const
{
  return IntVector4(~x,
                    ~y,
                    ~z,
                    ~w);
}

IntVector4  IntVector4::operator<< (IntVec4Param rhs) const
{
  return IntVector4(x << rhs.x,
                    y << rhs.y,
                    z << rhs.z,
                    w << rhs.w);
}

IntVector4  IntVector4::operator>> (IntVec4Param rhs) const
{
  return IntVector4(x >> rhs.x,
                    y >> rhs.y,
                    z >> rhs.z,
                    w >> rhs.w);
}

IntVector4  IntVector4::operator|  (IntVec4Param rhs) const
{
  return IntVector4(x | rhs.x,
                    y | rhs.y,
                    z | rhs.z,
                    w | rhs.w);
}

IntVector4  IntVector4::operator^  (IntVec4Param rhs) const
{
  return IntVector4(x ^ rhs.x,
                    y ^ rhs.y,
                    z ^ rhs.z,
                    w ^ rhs.w);
}

IntVector4  IntVector4::operator&  (IntVec4Param rhs) const
{
  return IntVector4(x & rhs.x,
                    y & rhs.y,
                    z & rhs.z,
                    w & rhs.w);
}

IntVector4& IntVector4::operator<<=(IntVec4Param rhs)
{
  x <<= rhs.x;
  y <<= rhs.y;
  z <<= rhs.z;
  w <<= rhs.w;
  return *this;
}

IntVector4& IntVector4::operator>>=(IntVec4Param rhs)
{
  x >>= rhs.x;
  y >>= rhs.y;
  z >>= rhs.z;
  w >>= rhs.w;
  return *this;
}

IntVector4& IntVector4::operator|= (IntVec4Param rhs)
{
  x |= rhs.x;
  y |= rhs.y;
  z |= rhs.z;
  w |= rhs.w;
  return *this;
}

IntVector4& IntVector4::operator^= (IntVec4Param rhs)
{
  x ^= rhs.x;
  y ^= rhs.y;
  z ^= rhs.z;
  w ^= rhs.w;
  return *this;
}

IntVector4& IntVector4::operator&= (IntVec4Param rhs)
{
  x &= rhs.x;
  y &= rhs.y;
  z &= rhs.z;
  w &= rhs.w;
  return *this;
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Math.cpp
/// Central location for all the math used by the Zero engine.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#include <cfloat>

namespace Math
{
typedef Vector2    Vec2;
typedef Vector3    Vec3;
typedef Vector4    Vec4;
typedef Matrix3    Mat3;
typedef Matrix4    Mat4;
typedef Quaternion Quat;

namespace
{
const uint I = 0; 
const uint J = 1; 
const uint H = 2;

void ClampAngle(real* angle)
{
  while(*angle < -Math::cPi)
  {
    *angle += Math::cTwoPi;
  }
  while(*angle > Math::cPi)
  {
    *angle -= Math::cTwoPi;
  }
}

} // namespace

///Creates a skew symmetric matrix from the given 3D vector. Multiplying a 
///vector by this matrix is equivalent to the cross product using the input 
///vector.
Matrix3 SkewSymmetric(Vec3Param vec3)
{
  Matrix3 mtx;
  mtx.m22 = mtx.m11 = mtx.m00 = real(0.0);
  mtx.m01 = -vec3[2];
  mtx.m02 =  vec3[1];
  mtx.m10 =  vec3[2];
  mtx.m12 = -vec3[0];
  mtx.m20 = -vec3[1];
  mtx.m21 =  vec3[0];
  return mtx;
}

Vector2 ProjectOnVector(Vec2Param input, Vec2Param normalizedVector)
{
  return input.ProjectOnVector(normalizedVector);
}

Vector3 ProjectOnVector(Vec3Param input, Vec3Param normalizedVector)
{
  return input.ProjectOnVector(normalizedVector);
}

Vector4 ProjectOnVector(Vec4Param input, Vec4Param normalizedVector)
{
  return input.ProjectOnVector(normalizedVector);
}

Vector2 ProjectOnPlane(Vec2Param input, Vec2Param planeNormal)
{
  return input.ProjectOnPlane(planeNormal);
}

Vector3 ProjectOnPlane(Vec3Param input, Vec3Param planeNormal)
{
  return input.ProjectOnPlane(planeNormal);
}

Vector4 ProjectOnPlane(Vec4Param input, Vec4Param planeNormal)
{
  return input.ProjectOnPlane(planeNormal);
}

Vector2 ReflectAcrossVector(Vec2Param input, Vec2Param normalizedVector)
{
  return input.ReflectAcrossPlane(normalizedVector);
}

Vector3 ReflectAcrossVector(Vec3Param input, Vec3Param normalizedVector)
{
  return input.ReflectAcrossPlane(normalizedVector);
}

Vector4 ReflectAcrossVector(Vec4Param input, Vec4Param normalizedVector)
{
  return input.ReflectAcrossPlane(normalizedVector);
}

Vector2 ReflectAcrossPlane(Vec2Param input, Vec2Param planeNormal)
{
  return input.ReflectAcrossPlane(planeNormal);
}

Vector3 ReflectAcrossPlane(Vec3Param input, Vec3Param planeNormal)
{
  return input.ReflectAcrossPlane(planeNormal);
}

Vector4 ReflectAcrossPlane(Vec4Param input, Vec4Param planeNormal)
{
  return input.ReflectAcrossPlane(planeNormal);
}

Vector2 Refract(Vec2Param input, Vec2Param planeNormal, real refractionIndex)
{
  return input.Refract(planeNormal, refractionIndex);
}

Vector3 Refract(Vec3Param input, Vec3Param planeNormal, real refractionIndex)
{
  return input.Refract(planeNormal, refractionIndex);
}

Vector4 Refract(Vec4Param input, Vec4Param planeNormal, real refractionIndex)
{
  return input.Refract(planeNormal, refractionIndex);
}

///Converts a quaternion to an axis-angle pair (in radians). Axis is stored in 
///the Vector4's xyz and the angle is stored in the w.
Vector4 ToAxisAngle(QuatParam quaternion)
{
  Vector4 axisAngle;
  ToAxisAngle(quaternion, &axisAngle);
  return axisAngle;
}

void ToAxisAngle(QuatParam quaternion, Vec4Ptr axisAngle)
{
  ErrorIf(axisAngle == NULL, "Math - Null pointer passed for axis-angle pair.");
  Quat tempQuat(Normalized(quaternion));

  axisAngle->w = real(2.0) * Math::ArcCos(tempQuat.w);
  real invSinAngle = Math::Sqrt(real(1.0) - tempQuat.w * tempQuat.w);

  if(Math::Abs(invSinAngle) < real(0.0005))
  {
    invSinAngle = real(1.0);
  }
  else
  {
    invSinAngle = real(1.0) / invSinAngle;
  }
  axisAngle->x = tempQuat.x * invSinAngle;
  axisAngle->y = tempQuat.y * invSinAngle;
  axisAngle->z = tempQuat.z * invSinAngle;
}

///Converts a quaternion to an axis-angle pair (in radians).
void ToAxisAngle(QuatParam quaternion, Vec3Ptr axis, real* radians)
{
  ErrorIf(axis == NULL, "Math - Null pointer passed for axis.");
  ErrorIf(radians == NULL, "Math - Null pointer passed for radians.");
  Quat tempQuat(Normalized(quaternion));

  *radians = real(2.0) * Math::ArcCos(tempQuat.w);
  real invSinAngle = Math::Sqrt(real(1.0) - tempQuat.w * tempQuat.w);

  if(Math::Abs(invSinAngle) < real(0.0005))
  {
    invSinAngle = real(1.0);
  }
  else
  {
    invSinAngle = real(1.0) / invSinAngle;
  }
  axis->x = tempQuat.x * invSinAngle;
  axis->y = tempQuat.y * invSinAngle;
  axis->z = tempQuat.z * invSinAngle;
}

///Convert a 3x3 matrix to a set of Euler angles (in radians). The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(Mat3Param matrix, EulerOrders::Enum order)
{
  EulerAngles eulerAngles(order);
  ToEulerAngles(matrix, &eulerAngles);
  return eulerAngles;
}

void ToEulerAngles(Mat3Param matrix, EulerAnglesPtr eulerAngles)
{
  ErrorIf(eulerAngles == NULL, "Math - Null pointer passed for Euler angles.");
  uint i, j, k, h, parity, repeated, frame;
  EulerOrder::GetOrder(eulerAngles->Order, i, j, k, h, parity, repeated, frame);
  if(EulerOrders::Yes == repeated)
  {
    real sy = Math::Sqrt(matrix(i, j) * matrix(i, j) + 
                         matrix(i, k) * matrix(i, k));
    if(sy > real(16.0) * real(FLT_EPSILON))
    {
      (*eulerAngles)[cX] = Math::ArcTan2(matrix(i, j), matrix(i, k));
      (*eulerAngles)[cY] = Math::ArcTan2(sy, matrix(i, i));
      (*eulerAngles)[cZ] = Math::ArcTan2(matrix(j, i), -matrix(k, i));
    }
    else
    {
      (*eulerAngles)[cX] = Math::ArcTan2(-matrix(j, k), matrix(j, j));
      (*eulerAngles)[cY] = Math::ArcTan2(sy, matrix(i, i));
      (*eulerAngles)[cZ] = real(0.0);
    }
  }
  else
  {
    real cy = Math::Sqrt(matrix(i, i) * matrix(i, i) + 
                         matrix(j, i) * matrix(j, i));
    if(cy > real(16.0) * real(FLT_EPSILON))
    {
      (*eulerAngles)[cX] = Math::ArcTan2(matrix(k, j), matrix(k, k));
      (*eulerAngles)[cY] = Math::ArcTan2(-matrix(k, i), cy);
      (*eulerAngles)[cZ] = Math::ArcTan2(matrix(j, i), matrix(i, i));
    }
    else
    {
      (*eulerAngles)[cX] = Math::ArcTan2(-matrix(j, k), matrix(j, j));
      (*eulerAngles)[cY] = Math::ArcTan2(-matrix(k, i), cy);
      (*eulerAngles)[cZ] = real(0.0);
    }
  }
  if(EulerOrders::Odd == parity)
  {
    (*eulerAngles)[cX] *= real(-1.0);
    (*eulerAngles)[cY] *= real(-1.0);
    (*eulerAngles)[cZ] *= real(-1.0);
  }

  ClampAngle(&((*eulerAngles)[cX]));
  ClampAngle(&((*eulerAngles)[cY]));
  ClampAngle(&((*eulerAngles)[cZ]));

  if(EulerOrders::Rotated == frame)
  {
    Math::Swap((*eulerAngles)[cX], (*eulerAngles)[cZ]);
  }
}

///Convert a 4x4 matrix to a set of Euler angles in radians. The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(Mat4Param matrix, EulerOrders::Enum order)
{
  EulerAngles eulerAngles(order);
  ToEulerAngles(matrix, &eulerAngles);
  return eulerAngles;
}

void ToEulerAngles(Mat4Param matrix, EulerAnglesPtr eulerAngles)
{
  ErrorIf(eulerAngles == NULL, "Math - Null pointer passed for Euler angles.");

  uint i, j, k, h, parity, repeated, frame;
  EulerOrder::GetOrder(eulerAngles->Order, i, j, k, h, parity, repeated, frame);
  if(EulerOrders::Yes == repeated)
  {
    real sy = Math::Sqrt(matrix(i, j) * matrix(i, j) + 
                         matrix(i, k) * matrix(i, k));
    if(sy > real(16.0) * real(FLT_EPSILON))
    {
      (*eulerAngles)[cX] = Math::ArcTan2(matrix(i, j), matrix(i, k));
      (*eulerAngles)[cY] = Math::ArcTan2(sy, matrix(i, i));
      (*eulerAngles)[cZ] = Math::ArcTan2(matrix(j, i), -matrix(k, i));
    }
    else
    {
      (*eulerAngles)[cX] = Math::ArcTan2(-matrix(j, k), matrix(j, j));
      (*eulerAngles)[cY] = Math::ArcTan2(sy, matrix(i, i));
      (*eulerAngles)[cZ] = real(0.0);
    }
  }
  else
  {
    real cy = Math::Sqrt(matrix(i, i) * matrix(i, i) + 
                         matrix(j, i) * matrix(j, i));
    if(cy > real(16.0) * real(FLT_EPSILON))
    {
      (*eulerAngles)[cX] = Math::ArcTan2(matrix(k, j), matrix(k, k));
      (*eulerAngles)[cY] = Math::ArcTan2(-matrix(k, i), cy);
      (*eulerAngles)[cZ] = Math::ArcTan2(matrix(j, i), matrix(i, i));
    }
    else
    {
      (*eulerAngles)[cX] = Math::ArcTan2(-matrix(j, k), matrix(j, j));
      (*eulerAngles)[cY] = Math::ArcTan2(-matrix(k, i), cy);
      (*eulerAngles)[cZ] = real(0.0);
    }
  }
  if(EulerOrders::Odd == parity)
  {
    (*eulerAngles)[cX] *= real(-1.0);
    (*eulerAngles)[cY] *= real(-1.0);
    (*eulerAngles)[cZ] *= real(-1.0);
  }

  ClampAngle(&((*eulerAngles)[cX]));
  ClampAngle(&((*eulerAngles)[cY]));
  ClampAngle(&((*eulerAngles)[cZ]));

  if(EulerOrders::Rotated == frame)
  {
    Math::Swap((*eulerAngles)[cX], (*eulerAngles)[cZ]);
  }
}

///Convert a quaternion to a set of Euler angles (in radians). The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(QuatParam quaternion, EulerOrders::Enum order)
{
  EulerAngles eulerAngles(order);
  ToEulerAngles(quaternion, &eulerAngles);
  return eulerAngles;
}

void ToEulerAngles(QuatParam quaternion, EulerAnglesPtr eulerAngles)
{
  ErrorIf(eulerAngles == NULL, "Math - Null pointer passed for Euler angles.");

  Matrix3 matrix;
  ToMatrix3(quaternion, &matrix);
  ToEulerAngles(matrix, eulerAngles);
}

/// Converts from Vector3 to Vector2, removing the z component of the Vector3.
Vector2 ToVector2(Vec3Param v3)
{
  return Vector2(v3.x, v3.y);
}

/// Converts from Vector2 to Vector3, adding the given z component.
Vector3 ToVector3(Vec2Param v2, real z)
{
  return Vector3(v2.x, v2.y, z);
}

/// Turns the 3d transformation matrix into 2d.
Matrix3 ProjectXY(Mat4Param mat4)
{
  Matrix3 mat3;
  mat3.m00 = mat4.m00; 
  mat3.m01 = mat4.m01;
  mat3.m02 = mat4.m03; // Pull over the x translation

  mat3.m10 = mat4.m10;
  mat3.m11 = mat4.m11; 
  mat3.m12 = mat4.m13; // Pull over the y translation

  mat3.m20 = 0;
  mat3.m21 = 0;
  mat3.m22 = 1;

  return mat3;
}

///Converts an axis-angle pair to a 3x3 (in radians). Axis is stored in the
///Vector4's xyz and the angle is stored in the w. Axis is assumed to be 
///normalized.
Matrix3 ToMatrix3(Vec4Param axisAngle)
{
  Matrix3 matrix;
  ToMatrix3(axisAngle, &matrix);
  return matrix;
}

void ToMatrix3(Vec4Param axisAngle, Mat3Ptr matrix)
{
  ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

  real c0 = Math::Cos(axisAngle.w);
  real n1C0 = real(1.0) - c0;
  real s0 = Math::Sin(axisAngle.w);

  //| x^2(1-c0)+c0  xy(1-c0)-zs0  xz(1-c0)+ys0 |
  //| xy(1-c0)+zs0  y^2(1-c0)+c0  yz(1-c0)-xs0 |
  //| xz(1-c0)-ys0  yz(1-c0)+xs0  z^2(1-c0)+c0 |
  matrix->m00 = axisAngle.x * axisAngle.x * n1C0 + c0;
  matrix->m01 = axisAngle.x * axisAngle.y * n1C0 - axisAngle.z * s0;
  matrix->m02 = axisAngle.x * axisAngle.z * n1C0 + axisAngle.y * s0;

  matrix->m10 = axisAngle.x * axisAngle.y * n1C0 + axisAngle.z * s0;
  matrix->m11 = axisAngle.y * axisAngle.y * n1C0 + c0;
  matrix->m12 = axisAngle.y * axisAngle.z * n1C0 - axisAngle.x * s0;

  matrix->m20 = axisAngle.x * axisAngle.z * n1C0 - axisAngle.y * s0;
  matrix->m21 = axisAngle.y * axisAngle.z * n1C0 + axisAngle.x * s0;
  matrix->m22 = axisAngle.z * axisAngle.z * n1C0 + c0;
}

///Converts an axis-angle pair to a 3x3 matrix (in radians). Axis is assumed to
///be normalized.
Matrix3 ToMatrix3(Vec3Param axis, real radians)
{
  Matrix3 matrix;
  ToMatrix3(axis, radians, &matrix);
  return matrix;
}

void ToMatrix3(Vec3Param axis, real radians, Mat3Ptr matrix)
{
  ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

  real c0 = Math::Cos(radians);
  real n1C0 = real(1.0) - c0;
  real s0 = Math::Sin(radians);

  //| x^2(1-c0)+c0  xy(1-c0)-zs0  xz(1-c0)+ys0 |
  //| xy(1-c0)+zs0  y^2(1-c0)+c0  yz(1-c0)-xs0 |
  //| xz(1-c0)-ys0  yz(1-c0)+xs0  z^2(1-c0)+c0 |
  matrix->m00 = axis.x * axis.x * n1C0 + c0;
  matrix->m01 = axis.x * axis.y * n1C0 - axis.z * s0;
  matrix->m02 = axis.x * axis.z * n1C0 + axis.y * s0;

  matrix->m10 = axis.x * axis.y * n1C0 + axis.z * s0;
  matrix->m11 = axis.y * axis.y * n1C0 + c0;
  matrix->m12 = axis.y * axis.z * n1C0 - axis.x * s0;

  matrix->m20 = axis.x * axis.z * n1C0 - axis.y * s0;
  matrix->m21 = axis.y * axis.z * n1C0 + axis.x * s0;
  matrix->m22 = axis.z * axis.z * n1C0 + c0;
}

///Convert a set of Euler angles to a 3x3 matrix (in radians).
Matrix3 ToMatrix3(EulerAnglesParam eulerAngles)
{
  Matrix3 matrix;
  ToMatrix3(eulerAngles, &matrix);
  return matrix;
}

void ToMatrix3(EulerAnglesParam eulerAngles, Mat3Ptr matrix)
{
  ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

  real angles[3] = { eulerAngles[0], eulerAngles[1], eulerAngles[2] };
  uint i, j, k, h, parity, repeated, frame;
  EulerOrder::GetOrder(eulerAngles.Order, i, j, k, h, parity, repeated, frame);
  if(EulerOrders::Rotated == frame)
  {
    Math::Swap(angles[cX], angles[cZ]);
  }
  if(EulerOrders::Odd == parity)
  {
    angles[cX] *= real(-1.0);
    angles[cY] *= real(-1.0);
    angles[cZ] *= real(-1.0);
  }
  
  real t[3], c[3], s[3];
  t[I] = angles[cX];      t[J] = angles[cY];      t[H] = angles[cZ];
  c[I] = Math::Cos(t[I]); c[J] = Math::Cos(t[J]); c[H] = Math::Cos(t[H]);
  s[I] = Math::Sin(t[I]); s[J] = Math::Sin(t[J]); s[H] = Math::Sin(t[H]);

  const real cc = c[I] * c[H]; 
  const real cs = c[I] * s[H]; 
  const real sc = s[I] * c[H]; 
  const real ss = s[I] * s[H];
  if(EulerOrders::Yes == repeated)
  {
    (*matrix)(i, i) =  c[J];        
    (*matrix)(i, j) =  c[J] * s[I];
    (*matrix)(i, k) =  c[J] * c[I];

    (*matrix)(j, i) =  c[J] * s[H];
    (*matrix)(j, j) = -c[J] * ss + cc;
    (*matrix)(j, k) = -c[J] * cs - sc;

    (*matrix)(k, i) = -c[J] * c[H];
    (*matrix)(k, j) =  c[J] * sc + cs;
    (*matrix)(k, k) =  c[J] * cc - ss;
  } 
  else 
  {
    (*matrix)(i, i) =  c[J] * c[H];
    (*matrix)(j, i) =  c[J] * s[H];
    (*matrix)(k, i) = -s[J];

    (*matrix)(i, j) =  s[J] * sc - cs;
    (*matrix)(j, j) =  s[J] * ss + cc;
    (*matrix)(k, j) =  c[J] * s[I];

    (*matrix)(i, k) =  s[J] * cc + ss;
    (*matrix)(j, k) =  s[J] * cs - sc;
    (*matrix)(k, k) =  c[J] * c[I];
  }
}

///Convert a 4x4 matrix to a 3x3 matrix. Simply copies the 4x4 matrix's upper 
///3x3 matrix (rotation & scale) to the 3x3 matrix.
Matrix3 ToMatrix3(Mat4Param matrix)
{
  Matrix3 mat3;
  ToMatrix3(matrix, &mat3);
  return mat3;
}

void ToMatrix3(Mat4Param mat4, Mat3Ptr mat3)
{
  ErrorIf(mat3 == NULL, "Math - Null pointer passed for matrix.");

  //First "cross" components
  mat3->m00 = mat4.m00; 
  mat3->m01 = mat4.m01;
  mat3->m02 = mat4.m02;

  //Second "cross" components
  mat3->m10 = mat4.m10;
  mat3->m11 = mat4.m11; 
  mat3->m12 = mat4.m12;

  //Third "cross" components
  mat3->m20 = mat4.m20;
  mat3->m21 = mat4.m21;
  mat3->m22 = mat4.m22;
}

///Converts a quaternion to a 3x3 rotation matrix (in radians).
Matrix3 ToMatrix3(QuatParam quaternion)
{
  Matrix3 matrix;
  ToMatrix3(quaternion, &matrix);
  return matrix;
}

void ToMatrix3(QuatParam quaternion, Mat3Ptr matrix)
{
  ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

  //     |       2     2                                |
  //     | 1 - 2Y  - 2Z    2XY - 2ZW      2XZ + 2YW     |
  //     |                                              |
  //     |                       2     2                |
  // M = | 2XY + 2ZW       1 - 2X  - 2Z   2YZ - 2XW     |
  //     |                                              |
  //     |                                      2     2 |
  //     | 2XZ - 2YW       2YZ + 2XW      1 - 2X  - 2Y  |
  //     |                                              |

  real xx = quaternion.x * quaternion.x;
  real xy = quaternion.x * quaternion.y;
  real xz = quaternion.x * quaternion.z;
  real yy = quaternion.y * quaternion.y;
  real yz = quaternion.y * quaternion.z;
  real zz = quaternion.z * quaternion.z;
  real zw = quaternion.z * quaternion.w;
  real yw = quaternion.y * quaternion.w;
  real xw = quaternion.x * quaternion.w;

  matrix->m00 = real(1.0) - real(2.0) * (yy + zz);
  matrix->m01 = real(2.0) * (xy - zw);
  matrix->m02 = real(2.0) * (xz + yw);

  matrix->m10 = real(2.0) * (xy + zw);
  matrix->m11 = real(1.0) - real(2.0) * (xx + zz);
  matrix->m12 = real(2.0) * (yz - xw);

  matrix->m20 = real(2.0) * (xz - yw);
  matrix->m21 = real(2.0) * (yz + xw);
  matrix->m22 = real(1.0) - real(2.0) * (xx + yy);
}

Matrix3 ToMatrix3(Vec3Param facing)
{
  Vec3 up, right;
  Math::GenerateOrthonormalBasis(facing, &right, &up);
  return ToMatrix3(facing, up, right);
}

Matrix3 ToMatrix3(Vec3Param facing, Vec3Param up)
{
  //Get the right vector
  Vec3 right = Math::Cross(facing, up);
  return ToMatrix3(facing, up, right);
}

Matrix3 ToMatrix3(Vec3Param facing, Vec3Param up, Vec3Param right)
{
  Matrix3 mat;
  mat.SetBasis(0, right);
  mat.SetBasis(1, up);
  mat.SetBasis(2, -facing);
  return mat;
}

///Convert a set of Euler angles to a 4x4 matrix (in radians).
Matrix4 ToMatrix4(EulerAnglesParam eulerAngles)
{
  Matrix4 matrix;
  ToMatrix4(eulerAngles, &matrix);
  return matrix;
}

void ToMatrix4(EulerAnglesParam eulerAngles, Mat4Ptr matrix)
{
  ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

  real angles[3] = { eulerAngles[0], eulerAngles[1], eulerAngles[2] };
  uint i, j, k, h, parity, repeated, frame;
  EulerOrder::GetOrder(eulerAngles.Order, i, j, k, h, parity, repeated, frame);
  if(EulerOrders::Rotated == frame)
  {
    Math::Swap(angles[cX], angles[cZ]);
  }
  if(EulerOrders::Odd == parity)
  {
    angles[cX] *= real(-1.0);
    angles[cY] *= real(-1.0);
    angles[cZ] *= real(-1.0);
  }
  real t[3], c[3], s[3];
  t[I] = angles[cX];       t[J] = angles[cY];       t[H] = angles[cZ];
  c[I] = Math::Cos(t[I]); c[J] = Math::Cos(t[J]); c[H] = Math::Cos(t[H]);
  s[I] = Math::Sin(t[I]); s[J] = Math::Sin(t[J]); s[H] = Math::Sin(t[H]);
  real cc = c[I] * c[H]; 
  real cs = c[I] * s[H]; 
  real sc = s[I] * c[H]; 
  real ss = s[I] * s[H];
  if(EulerOrders::Yes == repeated)
  {
    (*matrix)(i, i) =  c[J];        
    (*matrix)(i, j) =  c[J] * s[I];
    (*matrix)(i, k) =  c[J] * c[I];

    (*matrix)(j, i) =  c[J] * s[H];
    (*matrix)(j, j) = -c[J] * ss + cc;
    (*matrix)(j, k) = -c[J] * cs - sc;

    (*matrix)(k, i) = -c[J] * c[H];
    (*matrix)(k, j) =  c[J] * sc + cs;
    (*matrix)(k, k) =  c[J] * cc - ss;
  } 
  else 
  {
    (*matrix)(i, i) =  c[J] * c[H];
    (*matrix)(j, i) =  c[J] * s[H];
    (*matrix)(k, i) = -s[J];

    (*matrix)(i, j) =  s[J] * sc - cs;
    (*matrix)(j, j) =  s[J] * ss + cc;
    (*matrix)(k, j) =  c[J] * s[I];

    (*matrix)(i, k) =  s[J] * cc + ss;
    (*matrix)(j, k) =  s[J] * cs - sc;
    (*matrix)(k, k) =  c[J] * c[I];
  }
  matrix->m03 = real(0.0);  matrix->m13 = real(0.0);  matrix->m23 = real(0.0);
  matrix->m30 = real(0.0);  matrix->m31 = real(0.0);  matrix->m32 = real(0.0);
  matrix->m33 = real(1.0);
}

///Convert a 3x3 matrix to a 4x4 matrix. Simply copies the 3x3 matrix's values
///into the rotational part of the 4x4 matrix.
Matrix4 ToMatrix4(Mat3Param matrix)
{
  Matrix4 matrix4;
  ToMatrix4(matrix, &matrix4);
  return matrix4;
}

void ToMatrix4(Mat3Param mat3, Mat4Ptr mat4)
{
  ErrorIf(mat4 == NULL, "Math - Null pointer passed for matrix.");

  //First "cross" components
  mat4->m00 = mat3.m00;
  mat4->m01 = mat3.m01;   
  mat4->m02 = mat3.m02;
  mat4->m03 = real(0.0);
  
  //Second "cross" components
  mat4->m10 = mat3.m10;
  mat4->m11 = mat3.m11;   
  mat4->m12 = mat3.m12;
  mat4->m13 = real(0.0);
  
  //Third "cross" components
  mat4->m20 = mat3.m20;
  mat4->m21 = mat3.m21;   
  mat4->m22 = mat3.m22;
  mat4->m23 = real(0.0);
  
  //Fourth "cross" components
  mat4->m30 = real(0.0);
  mat4->m31 = real(0.0);  
  mat4->m32 = real(0.0);
  mat4->m33 = real(1.0);
}

///Converts a quaternion to a 4x4 rotation matrix (in radians).
Matrix4 ToMatrix4(QuatParam quaternion)
{
  Matrix4 matrix;
  ToMatrix4(quaternion, &matrix);
  return matrix;
}

void ToMatrix4(QuatParam quaternion, Mat4Ptr matrix)
{
  ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

  //     |       2     2                                |
  //     | 1 - 2Y  - 2Z    2XY - 2ZW      2XZ + 2YW     |
  //     |                                              |
  //     |                       2     2                |
  // M = | 2XY + 2ZW       1 - 2X  - 2Z   2YZ - 2XW     |
  //     |                                              |
  //     |                                      2     2 |
  //     | 2XZ - 2YW       2YZ + 2XW      1 - 2X  - 2Y  |
  //     |                                              |

  real xx = quaternion.x * quaternion.x;
  real xy = quaternion.x * quaternion.y;
  real xz = quaternion.x * quaternion.z;
  real yy = quaternion.y * quaternion.y;
  real yz = quaternion.y * quaternion.z;
  real zz = quaternion.z * quaternion.z;
  real zw = quaternion.z * quaternion.w;
  real yw = quaternion.y * quaternion.w;
  real xw = quaternion.x * quaternion.w;

  matrix->m00 = real(1.0) - real(2.0) * (yy + zz);
  matrix->m01 = real(2.0) * (xy - zw);
  matrix->m02 = real(2.0) * (xz + yw);
  matrix->m03 = real(0.0);

  matrix->m10 = real(2.0) * (xy + zw);
  matrix->m11 = real(1.0) - real(2.0) * (xx + zz);
  matrix->m12 = real(2.0) * (yz - xw);
  matrix->m13 = real(0.0);

  matrix->m20 = real(2.0) * (xz - yw);
  matrix->m21 = real(2.0) * (yz + xw);
  matrix->m22 = real(1.0) - real(2.0) * (xx + yy);
  matrix->m23 = real(0.0);

  matrix->m30 = real(0.0);
  matrix->m31 = real(0.0);
  matrix->m32 = real(0.0);
  matrix->m33 = real(1.0);
}

///Converts an axis-angle pair to a quaternion (in radians). Axis is stored in
///the Vector4's xyz and the angle is stored in the w. Axis is assumed to be 
///normalized.
Quat ToQuaternion(Vec4Param axisAngle)
{
  Quat quaternion;
  ToQuaternion(axisAngle, &quaternion);
  return quaternion;
}

void ToQuaternion(Vec4Param axisAngle, QuatPtr quaternion)
{
  ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

  real alpha = axisAngle.w * real(0.5);
  real sinAlpha = Math::Sin(alpha);

  quaternion->x = axisAngle.x * sinAlpha;
  quaternion->y = axisAngle.y * sinAlpha;
  quaternion->z = axisAngle.z * sinAlpha;
  quaternion->w = Math::Cos(alpha);
}

///Converts an axis-angle pair to a quaternion (in radians). Axis is assumed to
///be normalized.
Quaternion ToQuaternion(Vec3Param axis, real radians)
{
  Quat quaternion;
  ToQuaternion(axis, radians, &quaternion);
  return quaternion;
}

void ToQuaternion(Vec3Param axis, real radians, QuatPtr quaternion)
{
  ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

  real alpha = radians * real(0.5);
  real sinAlpha = Math::Sin(alpha);

  quaternion->x = axis.x * sinAlpha;
  quaternion->y = axis.y * sinAlpha;
  quaternion->z = axis.z * sinAlpha;
  quaternion->w = Math::Cos(alpha);
}

///Convert a set of Euler angles to a quaternion (in radians).
Quat ToQuaternion(EulerAnglesParam eulerAngles)
{
  Quat quaternion;
  ToQuaternion(eulerAngles, &quaternion);
  return quaternion;
}

void ToQuaternion(EulerAnglesParam eulerAngles, QuatPtr quaternion)
{
  ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

  real angles[3] = { eulerAngles[cX], eulerAngles[cY], eulerAngles[cZ] };
  uint i, j, k, h, parity, repeated, frame;
  EulerOrder::GetOrder(eulerAngles.Order, i, j, k, h, parity, repeated, frame);
  if(EulerOrders::Rotated == frame)
  {
    Math::Swap(angles[cX], angles[cZ]);
  }

  if(EulerOrders::Odd == parity)
  {
    angles[cY] *= real(-1.0);
  }

  real t[3], c[3], s[3];
  t[I] = angles[cX] * real(0.5); c[I] = Math::Cos(t[I]); s[I] = Math::Sin(t[I]);
  t[J] = angles[cY] * real(0.5); c[J] = Math::Cos(t[J]); s[J] = Math::Sin(t[J]);
  t[H] = angles[cZ] * real(0.5); c[H] = Math::Cos(t[H]); s[H] = Math::Sin(t[H]);
  
  const real cc = c[I] * c[H];
  const real cs = c[I] * s[H];
  const real sc = s[I] * c[H];
  const real ss = s[I] * s[H];
  if(EulerOrders::Yes == repeated)
  {
    angles[i] = c[J] * (cs + sc);
    angles[j] = s[J] * (cc + ss);
    angles[k] = s[J] * (cs - sc);
    quaternion->w = c[J] * (cc - ss);
  }
  else
  {
    angles[i] = c[J] * sc - s[J] * cs;
    angles[j] = c[J] * ss + s[J] * cc;
    angles[k] = c[J] * cs - s[J] * sc;
    quaternion->w = c[J] * cc + s[J] * ss;
  }
  if(EulerOrders::Odd == parity)
  {
    angles[j] *= real(-1.0);
  }
  quaternion->x = angles[cX];
  quaternion->y = angles[cY];
  quaternion->z = angles[cZ];
}

///Converts a 3x3 matrix to a quaternion (in radians).
Quat ToQuaternion(Mat3Param matrix)
{
  Quat quaternion;
  ToQuaternion(matrix, &quaternion);
  return quaternion;
}

void ToQuaternion(Mat3Param matrix, QuatPtr quaternion)
{
  ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

  if(matrix.m00 + matrix.m11 + matrix.m22 > real(0.0))
  {
    real t = matrix.m00 + matrix.m11 + matrix.m22 + real(1.0);
    real s = Math::Rsqrt(t) * real(0.5);

    (*quaternion)[3] = s * t;
    (*quaternion)[2] = (matrix.m10 - matrix.m01) * s;
    (*quaternion)[1] = (matrix.m02 - matrix.m20) * s;
    (*quaternion)[0] = (matrix.m21 - matrix.m12) * s;
  }
  else if(matrix.m00 > matrix.m11 && matrix.m00 > matrix.m22)
  {
    real t = matrix.m00 - matrix.m11 - matrix.m22 + real(1.0);
    real s = Math::Rsqrt(t) * real(0.5);

    (*quaternion)[0] = s * t;
    (*quaternion)[1] = (matrix.m10 + matrix.m01) * s;
    (*quaternion)[2] = (matrix.m02 + matrix.m20) * s;
    (*quaternion)[3] = (matrix.m21 - matrix.m12) * s;
  }
  else if(matrix.m11 > matrix.m22)
  {
    real t = -matrix.m00 + matrix.m11 - matrix.m22 + real(1.0);
    real s = Math::Rsqrt(t) * real(0.5);
    
    (*quaternion)[1] = s * t;
    (*quaternion)[0] = (matrix.m10 + matrix.m01) * s;
    (*quaternion)[3] = (matrix.m02 - matrix.m20) * s;
    (*quaternion)[2] = (matrix.m21 + matrix.m12) * s;
  }
  else
  {
    real t = -matrix.m00 - matrix.m11 + matrix.m22 + real(1.0);
    real s = Math::Rsqrt(t) * real(0.5);

    (*quaternion)[2] = s * t;
    (*quaternion)[3] = (matrix.m10 - matrix.m01) * s;
    (*quaternion)[0] = (matrix.m02 + matrix.m20) * s;
    (*quaternion)[1] = (matrix.m21 + matrix.m12) * s;
  }
}

///Converts a 4x4 matrix to a quaternion (in radians).
Quat ToQuaternion(Mat4Param matrix)
{
  Quat quaternion;
  ToQuaternion(matrix, &quaternion);
  return quaternion;
}

void ToQuaternion(Mat4Param matrix, QuatPtr quaternion)
{
  ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

  if(matrix.m00 + matrix.m11 + matrix.m22 > real(0.0))
  {
    real t = matrix.m00 + matrix.m11 + matrix.m22 + real(1.0);
    real s = Math::Rsqrt(t) * real(0.5);

    (*quaternion)[3] = s * t;
    (*quaternion)[2] = (matrix.m10 - matrix.m01) * s;
    (*quaternion)[1] = (matrix.m02 - matrix.m20) * s;
    (*quaternion)[0] = (matrix.m21 - matrix.m12) * s;
  }
  else if(matrix.m00 > matrix.m11 && matrix.m00 > matrix.m22)
  {
    real t = matrix.m00 - matrix.m11 - matrix.m22 + real(1.0);
    real s = Math::Rsqrt(t) * real(0.5);

    (*quaternion)[0] = s * t;
    (*quaternion)[1] = (matrix.m10 + matrix.m01) * s;
    (*quaternion)[2] = (matrix.m02 + matrix.m20) * s;
    (*quaternion)[3] = (matrix.m21 - matrix.m12) * s;
  }
  else if(matrix.m11 > matrix.m22)
  {
    real t = -matrix.m00 + matrix.m11 - matrix.m22 + real(1.0);
    real s = Math::Rsqrt(t) * real(0.5);
    
    (*quaternion)[1] = s * t;
    (*quaternion)[0] = (matrix.m10 + matrix.m01) * s;
    (*quaternion)[3] = (matrix.m02 - matrix.m20) * s;
    (*quaternion)[2] = (matrix.m21 + matrix.m12) * s;
  }
  else
  {
    real t = -matrix.m00 - matrix.m11 + matrix.m22 + real(1.0);
    real s = Math::Rsqrt(t) * real(0.5);

    (*quaternion)[2] = s * t;
    (*quaternion)[3] = (matrix.m10 - matrix.m01) * s;
    (*quaternion)[0] = (matrix.m02 + matrix.m20) * s;
    (*quaternion)[1] = (matrix.m21 + matrix.m12) * s;
  }
}

Quaternion ToQuaternion(Vec3Param facing, Vec3Param up)
{
  return ToQuaternion(ToMatrix3(facing, up));
}

Quaternion ToQuaternion(Vec3Param facing, Vec3Param up, Vec3Param right)
{
  return ToQuaternion(ToMatrix3(facing, up, right));
}

Quaternion ToQuaternion(Vec3Param eulerVector)
{
  return ToQuaternion(EulerAngles(eulerVector.x, eulerVector.y, eulerVector.z, Math::EulerOrders::XYZs));
}

Quaternion ToQuaternion(real x, real y, real z)
{
  Mat3 rotMat = ToMatrix3(EulerAngles(x, y, z, Math::EulerOrders::XYZs));
  return ToQuaternion(rotMat);
}

Quaternion RotationQuaternionBetween(Vec3Param start, Vec3Param end)
{
  Vec3 a = start;
  a.AttemptNormalize();
  Vec3 b = end;
  b.AttemptNormalize();
  Vec3 axis = Math::Cross(a, b);
  float length = axis.AttemptNormalize();
  float dot = Dot(a, b);
  float angle = Math::ArcCos(dot);
  if(length == 0)
    return Quat::cIdentity;

  return ToQuaternion(axis, angle);
}

///Generates a set of orthonormal vectors from the given vectors, modifying u 
///and v.
void GenerateOrthonormalBasis(Vec3Param w, Vec3Ptr u, Vec3Ptr v)
{
  ErrorIf(u == NULL, "Math - Null pointer passed for vector U.");
  ErrorIf(v == NULL, "Math - Null pointer passed for vector V.");

  if((Math::Abs(w.x) >= Math::Abs(w.y)) && (Math::Abs(w.x) >= Math::Abs(w.z)))
  {
    u->x = -w.y;
    u->y = w.x;
    u->z = real(0.0);
  }
  else
  {
    u->x = real(0.0);
    u->y = w.z;
    u->z = -w.y;
  }
  Normalize(u);
  *v = Cross(w, *u);
  Normalize(v);
}

///Generates a set of orthonormal vectors from the given vectors while using 
///debug checks, modifies u and v
void DebugGenerateOrthonormalBasis(Vec3Param w, Vec3Ptr u, Vec3Ptr v)
{
  ErrorIf(u == NULL, "Math - Null pointer passed for vector U.");
  ErrorIf(v == NULL, "Math - Null pointer passed for vector V.");

  if((Math::Abs(w.x) >= Math::Abs(w.y)) && (Math::Abs(w.x) >= Math::Abs(w.z)))
  {
    u->x = -w.y;
    u->y = w.x;
    u->z = real(0.0);
  }
  else
  {
    u->x = real(0.0);
    u->y = w.z;
    u->z = -w.y;
  }
  AttemptNormalize(u);
  *v = Cross(w, *u);
  AttemptNormalize(v);
}

///Perform the dot product with the specified basis vector of the 3x3 matrix and
///the given vector.
real BasisNDot(Mat3Param matrix, uint basisIndex, Vec3Param vector)
{
  return Dot(vector, matrix.Basis(basisIndex));
}

///Perform the dot product with the specified basis vector of the 3x3 matrix and
///the given vector.
real BasisNDot(Mat4Param matrix, uint basisIndex, Vec4Param vector)
{
  return Dot(vector, matrix.Basis(basisIndex));
}

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the x-axis (if the matrix is pure rotation) and the given vector.
real BasisXDot(Mat3Param matrix, Vec3Param vector)
{
  return Dot(vector, matrix.BasisX());
}

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the y-axis (if the matrix is pure rotation) and the given vector.
real BasisYDot(Mat3Param matrix, Vec3Param vector)
{
  return Dot(vector, matrix.BasisY());
}

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the z-axis (if the matrix is pure rotation) and the given vector.
real BasisZDot(Mat3Param matrix, Vec3Param vector)
{
  return Dot(vector, matrix.BasisZ());
}

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the x-axis (if the matrix is pure rotation) and the given vector.
real BasisXDot(Mat4Param matrix, Vec4Param vector)
{
  return Dot(vector, matrix.BasisX());
}

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the y-axis (if the matrix is pure rotation) and the given vector.
real BasisYDot(Mat4Param matrix, Vec4Param vector)
{
  return Dot(vector, matrix.BasisY());
}

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the z-axis (if the matrix is pure rotation) and the given vector.
real BasisZDot(Mat4Param matrix, Vec4Param vector)
{
  return Dot(vector, matrix.BasisZ());
}

///Converts a 32-bit float into a compressed 16-bit floating point value;
///referenced from Insomniac Games math library.
half ToHalf(float value)
{
  //------------------------------------------------------------------ Constants
  //Base value for the exponent part of the 32-bit floating point number
  const s32 cFloatExponentBase = 127;

  //Base value for the exponent part of the 16-bit floating point number
  const s32 cHalfExponentBase = 15;

  //Number of bits needed to move the float's sign to the half's sign spot
  const s32 cSignShift = 16;

  //Mask to only have the shifted sign portion of the float
  const s32 cShiftedSignMask = 0x00008000;

  //Number of bits needed to move the float's exponent bits such that they 
  //occupy
  const s32 cExponentShift = 23;

  //Mask to only have the shifted exponent portion of the float
  const s32 cShiftedExponentMask = 0x000000FF;

  //The value to subtract from the exponent portion to map it to the 4-bit 
  //format
  const s32 cExponentBaseChange = cFloatExponentBase - cHalfExponentBase;

  //Mask to only have the mantissa portion of the float
  const s32 cMantissaMask = 0x007FFFFF;

  //Bit that would be set if the mantissa overflowed into the exponent portion
  const s32 cMantissaOverflowBit = 0x00800000;

  //Bit used to check if the mantissa needs to be rounded up or not, checks the
  //least significant bit of the final shifted mantissa
  const s32 cMantissaRoundingBit = 0x00001000;

  //Value used when rounding floating point values up
  const s32 cMantissaRoundingValue = 0x00002000;

  //Number of bits needed to move the mantissa bits in order for them to fit in
  //the half-float format
  const s32 cMantissaShift = 13;

  //Value of the fully shifted exponent bit-combination (all bits are set)
  const s32 cFullShiftedExponent = 0x0000008F;

  //Used to check if a float is set to infinity
  const s32 cInfinityCheck = 0x0000000;

  //Value, for half-floats, of all the exponent bits set
  const s32 cFullExponent = 0x00007C00;

  //Redundant value used for clarification
  const s32 cZeroMantissa = 0x00000000;
  //----------------------------------------------------------------------------

  //Bit interpretation of the floating point value
  s32 v = *reinterpret_cast<s32*>(&value);
  
  //Sign
  s32 s = (v >> cSignShift) & cShiftedSignMask;

  //Exponent
  s32 e = ((v >> cExponentShift) & cShiftedExponentMask) - cExponentBaseChange;

  //Mantissa
  s32 m = v & cMantissaMask;

  //Handle values in the range [0,1] (negative exponent)
  if(e <= 0)
  {
    //If the exponent part is too small then treat value as 0
    if(e < -10)
    {
      return 0;
    }

    //Since the number is so small, attempt to round it
    m = (m | cMantissaOverflowBit) >> (1 - e);

    //Check to see if rounding is needed
    if(m & cMantissaRoundingBit)
    {
      m += cMantissaRoundingValue;
    }

    return static_cast<half>(s | (m >> cMantissaShift));
  }
  //Handle infinity and NaN
  else if(e == cFullShiftedExponent)
  {
    //Result is either positive or negative infinity
    if(m == cInfinityCheck)
    {
      return static_cast<half>(s | cFullExponent | cZeroMantissa);
    }
    //Result is NaN
    else
    {
      return static_cast<half>(s | cFullExponent | (m >> cMantissaShift));
    }
  }
  else
  {
    //Check if rounding is needed
    if(m & cMantissaRoundingBit)
    {
      m += cMantissaRoundingValue;

      //Check if the rounding has overflowed into the exponent part
      if(m & cMantissaOverflowBit)
      {
        m = 0;
        e += 1;
      }
    }

    //Check to see if all of the exponent bits are set
    if(e > 30)
    {
      //Returns a signed infinity
      return static_cast<half>(s | (e << 10) | (m >> cMantissaShift));
    }

    //Normal half
    return static_cast<half>(s | (e << 10) | (m >> cMantissaShift));
  }
}

///Converts a 16-bit compressed floating point value back into a 32-bit float;
///referenced from Insomniac Games math library.
float ToFloat(half value)
{
  //------------------------------------------------------------------ Constants
  //Base value for the exponent part of the 32-bit floating point number
  const s32 cFloatExponentBase = 127;

  //Base value for the exponent part of the 16-bit floating point number
  const s32 cHalfExponentBase = 15;

  //The value to subtract from the exponent portion to map it to the 4-bit 
  //format
  const s32 cExponentBaseChange = cFloatExponentBase - cHalfExponentBase;

  //Bit mask to ensure that the shifted sign is the only value in the bit field
  s32 cShiftedSignMask = 0x00000001;

  //Bit mask to ensure that the shifted exponent is the only value in the bit
  //field
  s32 cShiftedExponentMask = 0x0000001F;

  //Bit mask to ensure that the mantissa is the only value in the bit field
  s32 cMantissaMask = 0x000003FF;

  //Bit mask to check against the most significant bit in the mantissa
  s32 cMantissaMsbMask = 0x00000400;

  //Bit mask to ensure all the exponent bits are set
  s32 cFullExponent = 0x7F800000;
  //----------------------------------------------------------------------------
  
  //Sign
  s32 s = (value >> 15) & cShiftedSignMask;

  //Exponent
  s32 e = (value >> 10) & cShiftedExponentMask;

  //Mantissa
  s32 m = value & cMantissaMask;

  //No exponent, denormalized OR zero
  if(e == 0)
  {
    //Positive or negative zero
    if(m == 0)
    {
      uint result = s << 31;
      return *reinterpret_cast<float*>(&result);
    }
    //Denormalized number
    else
    {
      //Continuously move the mantissa until the most significant bit of the
      //mantissa has been set
      while(!(m & cMantissaMsbMask))
      {
        m <<= 1;
        e -= 1;
      }
      e += 1;

      //Make sure the most significant bit of the mantissa is cleared
      m &= ~cMantissaMsbMask;
    }
  }
  //Full exponent
  else if(e == 31)
  {
    //Positive or negative infinity
    if(m == 0)
    {
      uint result = (s << 31) | cFullExponent;
      return *reinterpret_cast<float*>(&result);
    }
    //NaN
    else
    {
      uint result = (s << 31) | cFullExponent | (m << 13);
      return *reinterpret_cast<float*>(&result);
    }
  }
  
  //Normalized number
  e += cExponentBaseChange;
  m <<= 13;

  //Create the float
  uint result = (s << 31) | (e << 23) | m;
  return *reinterpret_cast<float*>(&result);
}

//----------------------------------------------------------- Rotation Functions
real Angle(Vec2Param a, Vec2Param b)
{
  real dot = Dot(a, b);
  dot = Math::Clamp(dot, real(-1.0), real(1.0));
  return Math::ArcCos(dot);
}

real Angle(Vec3Param a, Vec3Param b)
{
  real dot = Dot(a, b);
  dot = Math::Clamp(dot, real(-1.0), real(1.0));
  return Math::ArcCos(dot);
}

real Angle(QuatParam a, QuatParam b)
{
  real dot = Dot(a, b);
  dot = Math::Clamp(dot, real(-1.0), real(1.0));
  //quaternions are a 2-1 mapping, so we could get a rotation that is 400 degrees
  //instead of 40 degrees, to fix this we can simply abs the dot product. This works
  //out because we convert our initial [0,360] range to [0,180] then scale up by 2 (2-1 mapping).
  real correctedDot = Math::Abs(dot);
  real angle = real(2.0) * Math::ArcCos(correctedDot);
  return angle;
}

real Angle2D(Vec3Param a)
{
  return ArcTan2(a.y, a.x);
}

Vector2 Slerp(Vec2Param start, Vec2Param end, real t)
{
  real dot = Dot(start, end);
  real theta = Math::ArcCos(dot) * t;
  Vector2 relativeVec = end - start * dot;
  relativeVec.Normalize();
  return (start * Math::Cos(theta)) + (relativeVec * Math::Sin(theta));
}

Vector2 SafeSlerp(Vec2Param start, Vec2Param end, real t)
{
  real dot = Dot(start, end);
  real theta = Math::ArcCos(dot) * t;

  Vector2 relativeVec;
  //if end is the negative of start, no direction is better to interpolate than
  //another, so generate a random perpendicular vector to rotate towards
  if(dot == -real(1.0))
    relativeVec = Vec2(-start.y, start.x);
  else
    relativeVec = end - start * dot;
  //attempt normalize (zero vectors and start == end)
  relativeVec.AttemptNormalize();
  return (start * Math::Cos(theta)) + (relativeVec * Math::Sin(theta));
}

Vector3 Slerp(Vec3Param start, Vec3Param end, real t)
{
  real dot = Dot(start, end);
  real theta = Math::ArcCos(dot) * t;
  Vector3 relativeVec = end - start * dot;
  relativeVec.Normalize();
  return (start * Math::Cos(theta)) + (relativeVec * Math::Sin(theta));
}

Vector3 SafeSlerp(Vec3Param start, Vec3Param end, real t)
{
  Vec3 normalizedStart = start.AttemptNormalized();
  Vec3 normalizedEnd = end.AttemptNormalized();

  real dot = Dot(normalizedStart, normalizedEnd);
  //Safeguard for non-normalized and slight floating point errors
  dot = Math::Clamp(dot, real(-1.0), real(1.0));
  real theta = Math::ArcCos(dot) * t;

  Vector3 relativeVec;
  //if end is the negative of start, no direction is better to interpolate than
  //another, so generate a random perpendicular vector to rotate towards
  if(dot == -real(1.0))
  {
    //unfortunately, a 3d perpendicular vector is not as simple, so try doing the 2d
    //perpendicular with [x,y], but if x is zero then switch to [y,z] instead
    if(normalizedStart.x != real(0.0))
      relativeVec = Vec3(-normalizedStart.y, normalizedStart.x, normalizedStart.z);
    else
      relativeVec = Vec3(normalizedStart.x, -normalizedStart.z, normalizedStart.y);
  }
  else
    relativeVec = normalizedEnd - normalizedStart * dot;
  //attempt normalize (zero vectors and start == end)
  relativeVec.AttemptNormalize();
  return (normalizedStart * Math::Cos(theta)) + (relativeVec * Math::Sin(theta));
}

template<typename type>
type GenericTowards(const type& a, const type& b, real maxAngle)
{
  const real cAngleEpsilon = real(0.0000001);

  real angle = Angle(a, b);

  if(angle > Math::cPi)
  {
    angle -= Math::cTwoPi;
  }

  angle = Math::Abs(angle);
  if(angle > cAngleEpsilon)
  {
    real t = maxAngle / angle;
    if(t > real(1.0))
    {
      t = real(1.0);
    }
    return Slerp(a, b, t);
  }
  else
  {
    return b;
  }
}

template<typename type>
type SafeGenericTowards(const type& a, const type& b, real maxAngle)
{
  const real cAngleEpsilon = real(0.0000001);

  real angle = Angle(a, b);

  if(angle > Math::cPi)
  {
    angle -= Math::cTwoPi;
  }

  angle = Math::Abs(angle);
  if(angle > cAngleEpsilon)
  {
    real t = maxAngle / angle;
    if(t > real(1.0))
    {
      t = real(1.0);
    }
    return SafeSlerp(a, b, t);
  }
  else
  {
    return b;
  }
}

Vector2 RotateTowards(Vec2Param a, Vec2Param b, real maxAngle)
{
  Vec2 an = a.Normalized();
  Vec2 bn = b.Normalized();
  return GenericTowards(an, bn, maxAngle);
}

Vector2 SafeRotateTowards(Vec2Param a, Vec2Param b, real maxAngle)
{
  Vec2 an = a;
  Vec2 bn = b;
  an.AttemptNormalize();
  bn.AttemptNormalize();
  return SafeGenericTowards(an, bn, maxAngle);
}

Vector3 RotateTowards(Vec3Param a, Vec3Param b, real maxAngle)
{
  Vec3 an = a.Normalized();
  Vec3 bn = b.Normalized();
  return GenericTowards(an, bn, maxAngle);
}

Vector3 SafeRotateTowards(Vec3Param a, Vec3Param b, real maxAngle)
{
  Vec3 an = a;
  Vec3 bn = b;
  an.AttemptNormalize();
  bn.AttemptNormalize();
  return SafeGenericTowards(an, bn, maxAngle);
}

Quat RotateTowards(QuatParam a, QuatParam b, float maxAngle)
{
  return GenericTowards(a, b, maxAngle);
}

// Get the rotation angle between two vectors (in radians)
real SignedAngle(Vec3Param a, Vec3Param b, Vec3Param up)
{
  // Get the right vector
  Vec3 right = Math::Cross(a, up);
  right.AttemptNormalize();

  // Get the forward and right dot products
  real forwardDot = Math::Clamp(Math::Dot(a, b), real(-1.0), real(1.0));
  real rightDot = Math::Clamp(Math::Dot(right, b), real(-1.0), real(1.0));

  // Get the actual angle from the forward dot product
  real finalAngle = Math::ArcCos(forwardDot);

  // If we're actually on the left side...
  if(rightDot > real(0.0))
  {
    // Compute the real final angle given the quadrant it's in (kinda like atan2)
    finalAngle = -finalAngle;
  }

  // Return the finally computed angle
  return finalAngle;
}

Vector3 RotateVector(Vec3Param a, Vec3Param axis, real radians)
{
  Mat3 rot = Math::ToMatrix3(axis, radians);
  return Math::Transform(rot, a);
}

Quat EulerDegreesToQuat(Vec3Param eulerDegrees)
{
  Math::EulerAngles angle(Math::DegToRad(eulerDegrees[0]), 
                          Math::DegToRad(eulerDegrees[1]), 
                          Math::DegToRad(eulerDegrees[2]), 
                          Math::EulerOrders::XYZs);

  return Math::ToQuaternion(angle);
}

Vector3 QuatToEulerDegrees(QuatParam rotation)
{
  Math::EulerAngles angles(rotation, Math::EulerOrders::XYZs);
  Vector3 newData = Vector3::cZero;
  newData[0] = Math::Round(Math::RadToDeg(angles[0]), -1);
  newData[1] = Math::Round(Math::RadToDeg(angles[1]), -1);
  newData[2] = Math::Round(Math::RadToDeg(angles[2]), -1);
  return newData;
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix2.hpp
/// Implementation of the Matrix 2 structure.
///
/// Authors: Joshua Davis
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#include <cmath>


namespace Math
{

const Matrix2 Matrix2::cIdentity(real(1.0), real(0.0),
                                 real(0.0), real(1.0));

Matrix2::Matrix2(real p00, real p01,
                 real p10, real p11)
{
  m00 = p00; m01 = p01;
  m10 = p10; m11 = p11;
}

Matrix2::Matrix2(ConstRealPointer data_)
{
  m00 = data_[0]; m01 = data_[1];
  m10 = data_[2]; m11 = data_[3];
}

Vec2Ref Matrix2::operator[](uint index)
{
  return ((Vector2*)this)[index];
}

Vec2Param Matrix2::operator[](uint index) const
{
  return ((Vector2*)this)[index];
}

ConstRealPointer Matrix2::Begin() const
{
  return array;
}

ConstRealPointer Matrix2::End() const
{
  return array + 4;
}

RealPointer Matrix2::Begin()
{
  return array;
}

RealPointer Matrix2::End()
{
  return array + 4;
}

//////////////////////////////////////////////////////////////////////////
//BINARY ASSIGNMENT OPERATORS (realS)
//////////////////////////////////////////////////////////////////////////

void Matrix2::operator*=(real rhs)
{
  Matrix2& self = *this;
  self[0] *= rhs;
  self[1] *= rhs;
}

void Matrix2::operator/=(real rhs)
{
  Matrix2& self = *this;
  self[0] /= rhs;
  self[1] /= rhs;
}

//////////////////////////////////////////////////////////////////////////
//BINARY OPERATORS (realS)
//////////////////////////////////////////////////////////////////////////

Matrix2 Matrix2::operator*(real rhs) const
{
  Matrix2 ret = *this;
  ret *= rhs;
  return ret;
}

Matrix2 Matrix2::operator/(real rhs) const
{
  Matrix2 ret = *this;
  ret /= rhs;
  return ret;
}

//////////////////////////////////////////////////////////////////////////
//BINARY ASSIGNMENT OPERATOR (MATRICES)
//////////////////////////////////////////////////////////////////////////

void Matrix2::operator+=(Mat2Param rhs)
{
  Matrix2& self = *this;
  self[0] += rhs[0];
  self[1] += rhs[1];
}

void Matrix2::operator-=(Mat2Param rhs)
{
  Matrix2& self = *this;
  self[0] -= rhs[0];
  self[1] -= rhs[1];
}

//////////////////////////////////////////////////////////////////////////
//BINARY OPERATORS (MATRICES)
//////////////////////////////////////////////////////////////////////////

Matrix2 Matrix2::operator+(Mat2Param rhs) const
{
  Matrix2 ret = *this;
  ret += rhs;
  return ret;
}

Matrix2 Matrix2::operator-(Mat2Param rhs) const
{
  Matrix2 ret = *this;
  ret -= rhs;
  return ret;
}

Matrix2 Matrix2::operator*(Mat2Param rhs) const
{
  return Concat(rhs);
}

//////////////////////////////////////////////////////////////////////////
//BINARY COMPARISONS
//////////////////////////////////////////////////////////////////////////

bool Matrix2::operator==(Mat2Param rhs) const
{
  Mat2Param self = *this;
  return self[0] == rhs[0] &&
         self[1] == rhs[1];
}

bool Matrix2::operator!=(Mat2Param rhs) const
{
  return !(*this == rhs);
}

real Matrix2::operator()(uint r, uint c) const
{
  return array[c + r * 2];
}

real& Matrix2::operator()(uint r, uint c)
{
  return array[c + r * 2];
}


Matrix2 Matrix2::Transposed() const
{
  Matrix2 ret;

  ret.m00 = m00;
  ret.m01 = m10;
  ret.m10 = m01;
  ret.m11 = m11;

  return ret;
}

Matrix2 Matrix2::Inverted()
{
  Matrix2 inverse;
  inverse.m00 = m11;
  inverse.m01 = -m01;
  inverse.m10 = -m10;
  inverse.m11 = m00;
  inverse *= real(1.0) / Determinant();
    
  return inverse;
}

Matrix2 Matrix2::Concat(Mat2Param rhs) const
{
  Matrix2 ret;

  ret.m00 = Dot(Cross(0), Vector2(rhs.m00, rhs.m10));
  ret.m01 = Dot(Cross(0), Vector2(rhs.m01, rhs.m11));

  ret.m10 = Dot(Cross(1), Vector2(rhs.m00, rhs.m10));
  ret.m11 = Dot(Cross(1), Vector2(rhs.m01, rhs.m11));

  return ret;
}

Mat2Ref Matrix2::Identity()
{
  Mat2Ref self = *this;
  self[0].Set(real(1.0), real(0.0));
  self[1].Set(real(0.0), real(1.0));
  return *this;
}

Mat2Ref Matrix2::SetIdentity()
{
  return Identity();
}

Mat2Ref Matrix2::ZeroOut()
{
  Mat2Ref self = *this;
  self[0].ZeroOut();
  self[1].ZeroOut();
  return *this;
}

float Matrix2::Determinant() const
{
  return m00 * m11 - m01 * m10;
}

bool Matrix2::Valid() const
{
  Mat2Param self = *this;
  return self[0].Valid() && self[1].Valid();
}

void Matrix2::Rotate(real radians)
{
  real c0 = Math::Cos(radians);
  real s0 = Math::Sin(radians);
  m00 = c0; m01 = -s0;
  m10 = s0; m11 = c0;
}

void Matrix2::Scale(real x, real y)
{
  m00 = x; m01 = 0;
  m10 = 0; m11 = y;
}

void Matrix2::Scale(Vec2Param rhs)
{
  Scale(rhs[0], rhs[1]);
}

Vector2 Matrix2::Transform(Vec2Param vector) const
{
  real x = Dot(Cross(0), vector);
  real y = Dot(Cross(1), vector);
  return Vector2(x, y);
}

void Matrix2::TransformVector(Vec2Ref vector) const
{
  Vec2 ret = Transform(vector);
  vector = ret;
}

Vector2 Matrix2::BasisVector(u32 index) const
{
  //Could be optimized but I don't want to rely on the order of the elements in 
  //the matrix
  switch(index)
  {
  case 0:
    return Vector2(m00, m10);

  case 1:
    return Vector2(m01, m11);

  default:
    //ErrorIf(index > 2, "Invalid index given, matrix dimension is too low.");
    return Vector2(real(0.0), real(0.0));
  }
}

Vector2 Matrix2::Basis(uint index) const
{
  return BasisVector(index);
}

Vector2 Matrix2::Cross(uint index) const
{
  switch(index)
  {
  case 0:
    return Vector2(m00, m01);

  case 1:
    return Vector2(m10, m11);

  default:
    //ErrorIf(index > 2, "Invalid index given, matrix dimension is too low.");
    return Vector2(real(0.0), real(0.0));
  }
}

Matrix2 operator*(real lhs, Mat2Param rhs)
{
  return rhs * lhs;
}

Matrix2 Concat(Mat2Param lhs, Mat2Param rhs)
{
  return lhs.Concat(rhs);
}

Vector2 Transform(Mat2Param mat, Vec2Param vector)
{
  return mat.Transform(vector);
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix3.cpp
/// Implementation of the Matrix 3 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#include <cmath>


namespace Math
{

const Matrix3 Matrix3::cIdentity(real(1.0), real(0.0), real(0.0),
                                 real(0.0), real(1.0), real(0.0),
                                 real(0.0), real(0.0), real(1.0));

Matrix3::Matrix3(real p00, real p01, real p02, 
                 real p10, real p11, real p12, 
                 real p20, real p21, real p22)
{
  m00 = p00;  m01 = p01;  m02 = p02;
  m10 = p10;  m11 = p11;  m12 = p12; 
  m20 = p20;  m21 = p21;  m22 = p22;
}

Matrix3::Matrix3(ConstRealPointer data_)
{
  m00 = data_[0]; m01 = data_[1]; m02 = data_[2];
  m10 = data_[3]; m11 = data_[4]; m12 = data_[5];
  m20 = data_[6]; m21 = data_[7]; m22 = data_[8];
}

//------------------------------------------ Binary Assignment Operators (reals)

void Matrix3::operator*=(real rhs)
{
  Matrix3& self = *this;
  self[0] *= rhs;
  self[1] *= rhs;
  self[2] *= rhs;
}

void Matrix3::operator/=(real rhs)
{
  Matrix3& self = *this;
  ErrorIf(Math::IsZero(rhs), "Matrix3 - Division by zero.");
  self[0] /= rhs;
  self[1] /= rhs;
  self[2] /= rhs;
}

//----------------------------------------------------- Binary Operators (reals)

Matrix3 Matrix3::operator*(real rhs) const
{
  Matrix3 ret = *this;
  ret *= rhs;
  return ret;
}

Matrix3 Matrix3::operator/(real rhs) const
{
  ErrorIf(Math::IsZero(rhs), "Matrix3 - Division by zero.");
  Matrix3 ret = *this;
  ret /= rhs;
  return ret;
}

//---------------------------------------- Binary Assignment Operator (Matrices)

void Matrix3::operator+=(Mat3Param rhs)
{
  Matrix3& self = *this;
  self[0] += rhs[0];
  self[1] += rhs[1];
  self[2] += rhs[2];
}

void Matrix3::operator-=(Mat3Param rhs)
{
  Matrix3& self = *this;
  self[0] -= rhs[0];
  self[1] -= rhs[1];
  self[2] -= rhs[2];
}

//-------------------------------------------------- Binary Operators (Matrices)

Matrix3 Matrix3::operator+(Mat3Param rhs) const
{
  Matrix3 ret = *this;
  ret += rhs;
  return ret;
}

Matrix3 Matrix3::operator-(Mat3Param rhs) const
{
  Matrix3 ret = *this;
  ret -= rhs;
  return ret;
}

Matrix3 Matrix3::operator*(Mat3Param rhs) const
{
  return Concat(rhs);
}

//----------------------------------------------------------- Binary Comparisons

bool Matrix3::operator==(Mat3Param rhs) const
{
  const Matrix3& self = *this;
  return self[0] == rhs[0] &&
         self[1] == rhs[1] &&
         self[2] == rhs[2];
}

bool Matrix3::operator!=(Mat3Param rhs) const
{
  return !(*this == rhs);
}

real Matrix3::operator()(uint r, uint c) const
{
  ErrorIf(r > 2, "Matrix3 - Index out of range.");
  ErrorIf(c > 2, "Matrix3 - Index out of range.");

#if ColumnBasis == 1
  return array[c + r * 3];
#else
  return array[r + c * 3];
#endif
}

real& Matrix3::operator()(uint r, uint c)
{
  ErrorIf(r > 2, "Matrix3 - Index out of range.");
  ErrorIf(c > 2, "Matrix3 - Index out of range.");

#if ColumnBasis == 1
  return array[c + r * 3];
#else
  return array[r + c * 3];
#endif
}

Vector3& Matrix3::operator[](uint index)
{
  return ((Vector3*)this)[index];
}

const Vector3& Matrix3::operator[](uint index) const
{ 
  return ((Vector3*)this)[index];
}

Matrix3 Matrix3::Transposed(void) const
{
  Matrix3 ret;

  ret.m00 = m00;
  ret.m01 = m10;
  ret.m02 = m20;
  ret.m10 = m01;
  ret.m11 = m11;
  ret.m12 = m21;
  ret.m20 = m02;
  ret.m21 = m12;
  ret.m22 = m22;

  return ret;
}

Mat3Ref Matrix3::Transpose(void)
{
  Math::Swap(m01, m10);
  Math::Swap(m02, m20);
  Math::Swap(m12, m21);
  return *this;
}

Matrix3 Matrix3::Inverted(void) const
{
  Matrix3 result(*this);
  result.Invert();
  return result;
}

Mat3Ref Matrix3::Invert(void)
{
  real determinant = Determinant();
  ErrorIf(determinant == real(0.0), "Matrix3 - Uninvertible matrix.");
  determinant = real(1.0) / determinant;
  real t00 = (m11 * m22 - m12 * m21) * determinant;
  real t01 = (m02 * m21 - m01 * m22) * determinant;
  real t02 = (m01 * m12 - m02 * m11) * determinant;
  real t10 = (m12 * m20 - m10 * m22) * determinant;
  real t11 = (m00 * m22 - m02 * m20) * determinant;
  real t12 = (m02 * m10 - m00 * m12) * determinant;
  real t20 = (m10 * m21 - m11 * m20) * determinant;
  real t21 = (m01 * m20 - m00 * m21) * determinant;
  real t22 = (m00 * m11 - m01 * m10) * determinant;
  
  m00 = t00;  m01 = t01;  m02 = t02;
  m10 = t10;  m11 = t11;  m12 = t12;
  m20 = t20;  m21 = t21;  m22 = t22;
  return *this;
}

Matrix3 Matrix3::SafeInverted() const
{
  Matrix3 result(*this);
  result.SafeInvert();
  return result;
}

void Matrix3::SafeInvert()
{
  real determinant = Determinant();
  if(Math::Abs(determinant) < Math::PositiveMin())
    determinant = Math::PositiveMin();
  else
    determinant = real(1.0) / determinant;

  real t00 = (m11 * m22 - m12 * m21) * determinant;
  real t01 = (m02 * m21 - m01 * m22) * determinant;
  real t02 = (m01 * m12 - m02 * m11) * determinant;
  real t10 = (m12 * m20 - m10 * m22) * determinant;
  real t11 = (m00 * m22 - m02 * m20) * determinant;
  real t12 = (m02 * m10 - m00 * m12) * determinant;
  real t20 = (m10 * m21 - m11 * m20) * determinant;
  real t21 = (m01 * m20 - m00 * m21) * determinant;
  real t22 = (m00 * m11 - m01 * m10) * determinant;

  m00 = t00;  m01 = t01;  m02 = t02;
  m10 = t10;  m11 = t11;  m12 = t12;
  m20 = t20;  m21 = t21;  m22 = t22;
}

Matrix3 Matrix3::Concat(Mat3Param rhs) const
{
  Matrix3 ret;

  ret.m00 = Dot(Cross(0), rhs.Basis(0));
  ret.m01 = Dot(Cross(0), rhs.Basis(1));
  ret.m02 = Dot(Cross(0), rhs.Basis(2));

  ret.m10 = Dot(Cross(1), rhs.Basis(0));
  ret.m11 = Dot(Cross(1), rhs.Basis(1));
  ret.m12 = Dot(Cross(1), rhs.Basis(2));

  ret.m20 = Dot(Cross(2), rhs.Basis(0));
  ret.m21 = Dot(Cross(2), rhs.Basis(1));
  ret.m22 = Dot(Cross(2), rhs.Basis(2));

  return ret;
}

Mat3Ref Matrix3::SetIdentity(void)
{
  Matrix3& self = *this;
  self[0].Set(real(1.0), real(0.0), real(0.0));
  self[1].Set(real(0.0), real(1.0), real(0.0));
  self[2].Set(real(0.0), real(0.0), real(1.0));
  return *this;
}

Mat3Ref Matrix3::ZeroOut(void)
{
  Matrix3& self = *this;
  self[0].ZeroOut();
  self[1].ZeroOut();
  self[2].ZeroOut();
  return *this;
}

real Matrix3::Determinant(void) const
{
  return (m00 * m11 * m22 + m10 * m21 * m02 + m01 * m12 * m20) 
       - (m02 * m11 * m20 + m10 * m01 * m22 + m00 * m21 * m12);
}

bool Matrix3::Valid(void) const
{
  const Matrix3& self = *this;
  return self[0].Valid() && self[1].Valid() && self[2].Valid();
}

void Matrix3::Scale(real x, real y, real z)
{
  SetIdentity();
  m00 = x;
  m11 = y;
  m22 = z;
}

void Matrix3::Scale(Vec3Param rhs)
{
  Scale(rhs[0], rhs[1], rhs[2]);
}

void Matrix3::Rotate(real x, real y, real z, real radian)
{
  real c0 = Math::Cos(radian);
  real n1C0 = real(1.0) - c0;
  real s0 = Math::Sin(radian);

  //| x^2(1-c0)+c0  xy(1-c0)-zs0  xz(1-c0)+ys0 |
  //| xy(1-c0)+zs0  y^2(1-c0)+c0  yz(1-c0)-xs0 |
  //| xz(1-c0)-ys0  yz(1-c0)+xs0  z^2(1-c0)+c0 |
  m00 = x * x * n1C0 + c0;
  m01 = x * y * n1C0 - z * s0;
  m02 = x * z * n1C0 + y * s0;

  m10 = x * y * n1C0 + z * s0;
  m11 = y * y * n1C0 + c0;
  m12 = y * z * n1C0 - x * s0;

  m20 = x * z * n1C0 - y * s0;
  m21 = y * z * n1C0 + x * s0;
  m22 = z * z * n1C0 + c0;
}

void Matrix3::Rotate(Vec3Param rhs, real radian)
{
  Rotate(rhs.x, rhs.y, rhs.z, radian);
}

void Matrix3::Translate(real x, real y)
{
  m00 = real(1.0);  m01 = real(0.0);  m02 = x;
  m10 = real(0.0);  m11 = real(1.0);  m12 = y;
  m20 = real(0.0);  m21 = real(0.0);  m22 = real(1.0);
}

void Matrix3::Translate(Vec2Param rhs)
{
  Translate(rhs.x, rhs.y);
}

void Matrix3::BuildTransform(Vec2Param translate, real radians, Vec2Param scale)
{
  //Translation
  m02 = translate.x;
  m12 = translate.y;
  m22 = real(1.0);

  //Rotation
  m00 = Math::Cos(radians);
  m01 = -Math::Sin(radians);
  m10 = -m01;
  m11 = m00;

  //Scale
  m00 *= scale.x;
  m10 *= scale.x;
  m01 *= scale.y;
  m11 *= scale.y;

  m20 = m21 = real(0.0);
}

void Matrix3::BuildTransform(QuatParam rotate, Vec3Param scale)
{
  //Rotational component
  real xx = rotate.x * rotate.x;
  real xy = rotate.x * rotate.y;
  real xz = rotate.x * rotate.z;
  real yy = rotate.y * rotate.y;
  real yz = rotate.y * rotate.z;
  real zz = rotate.z * rotate.z;
  real zw = rotate.z * rotate.w;
  real yw = rotate.y * rotate.w;
  real xw = rotate.x * rotate.w;

  m00 = real(1.0) - real(2.0) * (yy + zz);
  m01 = real(2.0) * (xy - zw);
  m02 = real(2.0) * (xz + yw);

  m10 = real(2.0) * (xy + zw);
  m11 = real(1.0) - real(2.0) * (xx + zz);
  m12 = real(2.0) * (yz - xw);

  m20 = real(2.0) * (xz - yw);
  m21 = real(2.0) * (yz + xw);
  m22 = real(1.0) - real(2.0) * (xx + yy);

  //Scale component
  m00 *= scale.x;
  m10 *= scale.x;
  m20 *= scale.x;

  m01 *= scale.y;
  m11 *= scale.y;
  m21 *= scale.y;

  m02 *= scale.z;
  m12 *= scale.z;
  m22 *= scale.z;
}

Mat3Ref Matrix3::Orthonormalize(void)
{
  Vector3 basis[3] = { BasisX(), BasisY(), BasisZ() };
  Normalize(&(basis[0]));

  basis[1].AddScaledVector(basis[0], -Dot(basis[1], basis[0]));
  Normalize(&(basis[1]));

  basis[2].AddScaledVector(basis[0], -Dot(basis[2], basis[0]));
  basis[2].AddScaledVector(basis[1], -Dot(basis[2], basis[1]));
  Normalize(&(basis[2]));

  SetBasis(cX, basis[0]);
  SetBasis(cY, basis[1]);
  SetBasis(cZ, basis[2]);
  return *this;
}

Matrix3::BasisVector Matrix3::Basis(uint index) const
{
  ErrorIf(index > 2, "Matrix3 - Index out of range.");
#if ColumnBasis == 1
  return Vector3(array[index], array[3 + index], array[6 + index]);
#else
  const Matrix3& self = *this;
  return self[index];
#endif
}

Matrix3::BasisVector Matrix3::BasisX(void) const
{
#if ColumnBasis == 1
  return Vector3(array[0], array[3], array[6]);
#else
  const Matrix3& self = *this;
  return self[0];
#endif
}

Matrix3::BasisVector Matrix3::BasisY(void) const
{
#if ColumnBasis == 1
  return Vector3(array[1], array[4], array[7]);
#else
  const Matrix3& self = *this;
  return self[1];
#endif
}

Matrix3::BasisVector Matrix3::BasisZ(void) const
{
#if ColumnBasis == 1
  return Vector3(array[2], array[5], array[8]);
#else
  const Matrix3& self = *this;
  return self[2];
#endif
}

Matrix3::CrossVector Matrix3::Cross(uint index) const
{
  ErrorIf(index > 2, "Matrix3 - Index out of range.");
#if ColumnBasis == 1
  Mat3Param self = *this;
  return self[index];
#else
  return Vector3(array[index], array[3 + index], array[6 + index]);
#endif
}

void Matrix3::SetBasis(uint index, Vec3Param basisVector)
{
  SetBasis(index, basisVector[0], basisVector[1], basisVector[2]);
}

void Matrix3::SetBasis(uint index, real x, real y, real z)
{
  ErrorIf(index > 2, "Matrix3 - Index out of range.");
#if ColumnBasis == 1
  array[index] = x;
  array[3 + index] = y;
  array[6 + index] = z;
#else
  Matrix3& self = *this;
  self[index].Set(x, y, z);
#endif
}

void Matrix3::SetCross(uint index, Vec3Param crossVector)
{
  SetCross(index, crossVector[0], crossVector[1], crossVector[2]);
}

void Matrix3::SetCross(uint index, real x, real y, real z)
{
  ErrorIf(index > 2, "Matrix3 - Index out of range.");
#if ColumnBasis == 1
  Matrix3& self = *this;
  self[index].Set(x, y, z);
#else
  array[index] = x;
  array[3 + index] = y;
  array[6 + index] = z;
#endif
}

Matrix3 operator*(real lhs, Mat3Param rhs)
{
  return rhs * lhs;
}

Matrix3 Concat(Mat3Param lhs, Mat3Param rhs)
{
  return lhs.Concat(rhs);
}

Matrix3 BuildTransform(Vec2Param translate, real radians, Vec2Param scale)
{
  Matrix3 matrix;
  matrix.BuildTransform(translate, radians, scale);
  return matrix;
}

Matrix3 BuildTransform(QuatParam rotate, Vec3Param scale)
{
  Matrix3 matrix;
  matrix.BuildTransform(rotate, scale);
  return matrix;
}

Vector3 Transform(Mat3Param matrix, Vec3Param vector)
{
  real x = Dot(matrix.Cross(0), vector);
  real y = Dot(matrix.Cross(1), vector);
  real z = Dot(matrix.Cross(2), vector);
  return Vector3(x, y, z);
}

void Transform(Mat3Param matrix, Vec3Ptr vector)
{
  ErrorIf(vector == NULL, "Matrix3 - Null pointer passed for vector.");
  real x = Dot(matrix.Cross(0), *vector);
  real y = Dot(matrix.Cross(1), *vector);
  real z = Dot(matrix.Cross(2), *vector);
  vector->Set(x, y, z);
}

Vector2 TransformPoint(Mat3Param matrix, Vec2Param vector)
{
  real x = Dot(*(Vector2*)&matrix[0], vector) + matrix[0][2];
  real y = Dot(*(Vector2*)&matrix[1], vector) + matrix[1][2];
  return Vector2(x, y);
}

Vector2 TransformNormal(Mat3Param matrix, Vec2Param normal)
{
  real x = Dot(*(Vector2*)&matrix[0], normal);
  real y = Dot(*(Vector2*)&matrix[1], normal);
  return Vector2(x, y);
}

Vector3 TransposedTransform(Mat3Param matrix, Vec3Param vector)
{
  real x = Dot(matrix.Basis(0), vector);
  real y = Dot(matrix.Basis(1), vector);
  real z = Dot(matrix.Basis(2), vector);
  return Vector3(x, y, z);
}

void TransposedTransform(Mat3Param matrix, Vec3Ptr vector)
{
  ErrorIf(vector == NULL, "Matrix3 - Null pointer passed for vector.");
  real x = Dot(matrix.Basis(0), *vector);
  real y = Dot(matrix.Basis(1), *vector);
  real z = Dot(matrix.Basis(2), *vector);
  vector->Set(x, y, z);
}

real Trace(Mat3Param matrix)
{
  return matrix.m00 + matrix.m11 + matrix.m22;
}

real Cofactor(Mat3Param matrix, uint row, uint column)
{
  ErrorIf(row > 2, "Matrix3 - Row index out of range.");
  ErrorIf(column > 2, "Matrix3 - Column index out of range.");

  //Negative if r+c is odd, positive if even
  real sign = ((row + column) % 2) == 1 ? real(-1.0) : real(1.0);

  real matrix2[4];
  uint i = 0;
  for(uint r = 0; r < 3; ++r)
  {
    if(r != row)
    {
      for(uint c = 0; c < 3; ++c)
      {
        if(c != column)
        {
          matrix2[i] = matrix(r, c);
          ++i;
        }
      }
    }
  }

  return sign * ((matrix2[0] * matrix2[3]) - (matrix2[1] * matrix2[2]));
}

///Diagonalizes a symmetric matrix (M = M^T)
void Diagonalize(Mat3Ptr matrix)
{
  ErrorIf(matrix == NULL, "Matrix3 - Null pointer passed for matrix.");
  
  Matrix3 quatMatrix = ToMatrix3(CreateDiagonalizer(*matrix));
  *matrix = Concat(Concat(quatMatrix, *matrix), quatMatrix.Transposed());
}

Matrix3 Diagonalized(Mat3Param matrix)
{
  Matrix3 newMatrix = matrix;
  Diagonalize(&newMatrix);
  return newMatrix;
}

void Invert(Mat3Ptr matrix)
{
  matrix->Invert();
}

Matrix3 Inverted(Mat3Param matrix)
{
  return matrix.Inverted();
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix4.cpp
/// Implementation of the Matrix 4 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Math
{

const Matrix4 Matrix4::cIdentity(real(1.0), real(0.0), real(0.0), real(0.0),
                                 real(0.0), real(1.0), real(0.0), real(0.0),
                                 real(0.0), real(0.0), real(1.0), real(0.0),
                                 real(0.0), real(0.0), real(0.0), real(1.0));

Matrix4::Matrix4(ConstRealPointer data_)
{
  m00 = data_[ 0];  m01 = data_[ 1];  m02 = data_[ 2];  m03 = data_[ 3]; 
  m10 = data_[ 4];  m11 = data_[ 5];  m12 = data_[ 6];  m13 = data_[ 7];
  m20 = data_[ 8];  m21 = data_[ 9];  m22 = data_[10];  m23 = data_[11]; 
  m30 = data_[12];  m31 = data_[13];  m32 = data_[14];  m33 = data_[15];
}

Matrix4::Matrix4(real p00, real p01, real p02, real p03, real p10, real p11, 
                 real p12, real p13, real p20, real p21, real p22, real p23,
                 real p30, real p31, real p32, real p33)
{
  m00 = p00;  m01 = p01;  m02 = p02;  m03 = p03; 
  m10 = p10;  m11 = p11;  m12 = p12;  m13 = p13; 
  m20 = p20;  m21 = p21;  m22 = p22;  m23 = p23;
  m30 = p30;  m31 = p31;  m32 = p32;  m33 = p33;
}

Matrix4::Matrix4(Vec4Param basisX, Vec4Param basisY,
  Vec4Param basisZ, Vec4Param basisW)
{
  SetBasis(0,basisX);
  SetBasis(1,basisY);
  SetBasis(2,basisZ);
  SetBasis(3,basisW);
}

////////// Binary Assignment Operators (reals) /////////////////////////////////

void Matrix4::operator*=(real rhs)
{
  Matrix4& self = *this;
  self[0] *= rhs;
  self[1] *= rhs;
  self[2] *= rhs;
  self[3] *= rhs;
}

void Matrix4::operator/=(real rhs)
{
  Matrix4& self = *this;
  ErrorIf(Math::IsZero(rhs), "Matrix4 - Division by zero.");
  self[0] /= rhs;
  self[1] /= rhs;
  self[2] /= rhs;
  self[3] /= rhs;
}

////////// Binary Operators (reals) ////////////////////////////////////////////

Matrix4 Matrix4::operator*(real rhs) const
{
  Matrix4 ret = *this;
  ret *= rhs;
  return ret;
}

Matrix4 Matrix4::operator/(real rhs) const
{
  ErrorIf(Math::IsZero(rhs), "Matrix4 - Division by zero.");
  Matrix4 ret = *this;
  ret /= rhs;
  return ret;
}

////////// Binary Assignment Operator (Matrices) ///////////////////////////////

void Matrix4::operator+=(Mat4Param rhs)
{
  Matrix4& self = *this;
  self[0] += rhs[0];
  self[1] += rhs[1];
  self[2] += rhs[2];
  self[3] += rhs[3];
}

void Matrix4::operator-=(Mat4Param rhs)
{
  Matrix4& self = *this;
  self[0] -= rhs[0];
  self[1] -= rhs[1];
  self[2] -= rhs[2];
  self[3] -= rhs[3];
}

////////// Binary Operators (Matrices) /////////////////////////////////////////

Matrix4 Matrix4::operator+(Mat4Param rhs) const
{
  Matrix4 ret = *this;
  ret += rhs;
  return ret;
}

Matrix4 Matrix4::operator-(Mat4Param rhs) const
{
  Matrix4 ret = *this;
  ret -= rhs;
  return ret;
}

Matrix4 Matrix4::operator*(Mat4Param rhs) const
{
  return Concat(rhs);
}

////////// Binary Comparisons //////////////////////////////////////////////////

bool Matrix4::operator==(Mat4Param rhs) const
{
  const Matrix4& self = *this;
  return self[0] == rhs[0] &&
         self[1] == rhs[1] &&
         self[2] == rhs[2] &&
         self[3] == rhs[3];
}

bool Matrix4::operator!=(Mat4Param rhs) const
{
  return !(*this == rhs);
}

real Matrix4::operator()(uint r, uint c) const
{
  ErrorIf(r > 3, "Matrix4 - Index out of range.");
  ErrorIf(c > 3, "Matrix4 - Index out of range.");

#if ColumnBasis == 1
  return array[c + r * 4];
#else
  return array[r + c * 4];
#endif
}

real& Matrix4::operator()(uint r, uint c)
{
  ErrorIf(r > 3, "Matrix4 - Index out of range.");
  ErrorIf(c > 3, "Matrix4 - Index out of range.");

#if ColumnBasis == 1
  return array[c + r * 4];
#else
  return array[r + c * 4];
#endif
}


Matrix4 Matrix4::Transposed(void) const
{
  Matrix4 ret = *this;
  ret.Transpose();
  return ret;
}

Mat4Ref Matrix4::Transpose(void)
{
  Math::Swap(m01, m10);
  Math::Swap(m02, m20);
  Math::Swap(m03, m30);
  Math::Swap(m12, m21);
  Math::Swap(m13, m31);
  Math::Swap(m23, m32);
  return *this;
}

Matrix4 Matrix4::Inverted(void) const
{
  Matrix4 inverted;
  real determinant = Determinant();
  ErrorIf(Math::IsZero(determinant), "Matrix4 - Uninvertible matrix.");
  determinant = real(1.0) / determinant;
  inverted.m00  = m12 * m23 * m31 - m13 * m22 * m31;
  inverted.m00 += m13 * m21 * m32 - m11 * m23 * m32;
  inverted.m00 += m11 * m22 * m33 - m12 * m21 * m33;
  inverted.m00 *= determinant;

  inverted.m01  = m03 * m22 * m31 - m02 * m23 * m31;
  inverted.m01 += m01 * m23 * m32 - m03 * m21 * m32;
  inverted.m01 += m02 * m21 * m33 - m01 * m22 * m33;
  inverted.m01 *= determinant;

  inverted.m02  = m02 * m13 * m31 - m03 * m12 * m31;
  inverted.m02 += m03 * m11 * m32 - m01 * m13 * m32;
  inverted.m02 += m01 * m12 * m33 - m02 * m11 * m33;
  inverted.m02 *= determinant;

  inverted.m03  = m03 * m12 * m21 - m02 * m13 * m21;
  inverted.m03 += m01 * m13 * m22 - m03 * m11 * m22;
  inverted.m03 += m02 * m11 * m23 - m01 * m12 * m23;
  inverted.m03 *= determinant;

  inverted.m10  = m13 * m22 * m30 - m12 * m23 * m30;
  inverted.m10 += m10 * m23 * m32 - m13 * m20 * m32;
  inverted.m10 += m12 * m20 * m33 - m10 * m22 * m33;
  inverted.m10 *= determinant;

  inverted.m11  = m02 * m23 * m30 - m03 * m22 * m30;
  inverted.m11 += m03 * m20 * m32 - m00 * m23 * m32;
  inverted.m11 += m00 * m22 * m33 - m02 * m20 * m33;
  inverted.m11 *= determinant;

  inverted.m12  = m03 * m12 * m30 - m02 * m13 * m30;
  inverted.m12 += m00 * m13 * m32 - m03 * m10 * m32;
  inverted.m12 += m02 * m10 * m33 - m00 * m12 * m33;
  inverted.m12 *= determinant;

  inverted.m13  = m02 * m13 * m20 - m03 * m12 * m20;
  inverted.m13 += m03 * m10 * m22 - m00 * m13 * m22;
  inverted.m13 += m00 * m12 * m23 - m02 * m10 * m23;
  inverted.m13 *= determinant;

  inverted.m20  = m11 * m23 * m30 - m13 * m21 * m30;
  inverted.m20 += m13 * m20 * m31 - m10 * m23 * m31;
  inverted.m20 += m10 * m21 * m33 - m11 * m20 * m33;
  inverted.m20 *= determinant;

  inverted.m21  = m03 * m21 * m30 - m01 * m23 * m30;
  inverted.m21 += m00 * m23 * m31 - m03 * m20 * m31;
  inverted.m21 += m01 * m20 * m33 - m00 * m21 * m33;
  inverted.m21 *= determinant;

  inverted.m22  = m01 * m13 * m30 - m03 * m11 * m30;
  inverted.m22 += m03 * m10 * m31 - m00 * m13 * m31;
  inverted.m22 += m00 * m11 * m33 - m01 * m10 * m33;
  inverted.m22 *= determinant;

  inverted.m23  = m03 * m11 * m20 - m01 * m13 * m20;
  inverted.m23 += m00 * m13 * m21 - m03 * m10 * m21;
  inverted.m23 += m01 * m10 * m23 - m00 * m11 * m23;
  inverted.m23 *= determinant;

  inverted.m30  = m12 * m21 * m30 - m11 * m22 * m30;
  inverted.m30 += m10 * m22 * m31 - m12 * m20 * m31;
  inverted.m30 += m11 * m20 * m32 - m10 * m21 * m32;
  inverted.m30 *= determinant;

  inverted.m31  = m01 * m22 * m30 - m02 * m21 * m30;
  inverted.m31 += m02 * m20 * m31 - m00 * m22 * m31;
  inverted.m31 += m00 * m21 * m32 - m01 * m20 * m32;
  inverted.m31 *= determinant;

  inverted.m32  = m02 * m11 * m30 - m01 * m12 * m30;
  inverted.m32 += m00 * m12 * m31 - m02 * m10 * m31;
  inverted.m32 += m01 * m10 * m32 - m00 * m11 * m32;
  inverted.m32 *= determinant;

  inverted.m33  = m01 * m12 * m20 - m02 * m11 * m20;
  inverted.m33 += m02 * m10 * m21 - m00 * m12 * m21;
  inverted.m33 += m00 * m11 * m22 - m01 * m10 * m22;
  inverted.m33 *= determinant;

  return inverted;
}

Mat4Ref Matrix4::Invert(void)
{
  *this = Inverted(); 
  return *this;
}

Matrix4 Matrix4::Concat(Mat4Param rhs) const
{
  Matrix4 ret;

  ret.m00 = Dot(Cross(0), rhs.Basis(0));
  ret.m01 = Dot(Cross(0), rhs.Basis(1));
  ret.m02 = Dot(Cross(0), rhs.Basis(2));
  ret.m03 = Dot(Cross(0), rhs.Basis(3));

  ret.m10 = Dot(Cross(1), rhs.Basis(0));
  ret.m11 = Dot(Cross(1), rhs.Basis(1));
  ret.m12 = Dot(Cross(1), rhs.Basis(2));
  ret.m13 = Dot(Cross(1), rhs.Basis(3));

  ret.m20 = Dot(Cross(2), rhs.Basis(0));
  ret.m21 = Dot(Cross(2), rhs.Basis(1));
  ret.m22 = Dot(Cross(2), rhs.Basis(2));
  ret.m23 = Dot(Cross(2), rhs.Basis(3));

  ret.m30 = Dot(Cross(3), rhs.Basis(0));
  ret.m31 = Dot(Cross(3), rhs.Basis(1));
  ret.m32 = Dot(Cross(3), rhs.Basis(2));
  ret.m33 = Dot(Cross(3), rhs.Basis(3));

  return ret;
}

Mat4Ref Matrix4::SetIdentity(void)
{
  Matrix4& self = *this;
  self[0].Set(real(1.0), real(0.0), real(0.0), real(0.0));
  self[1].Set(real(0.0), real(1.0), real(0.0), real(0.0));
  self[2].Set(real(0.0), real(0.0), real(1.0), real(0.0));
  self[3].Set(real(0.0), real(0.0), real(0.0), real(1.0));
  return *this;
}

Mat4Ref Matrix4::ZeroOut(void)
{
  Matrix4& self = *this;
  self[0].ZeroOut();
  self[1].ZeroOut();
  self[2].ZeroOut();
  self[3].ZeroOut();
  return *this;
}

real Matrix4::Determinant(void) const
{
  real det  = m03 * m12 * m21 * m30 - m02 * m13 * m21 * m30;
       det += m01 * m13 * m22 * m30 - m03 * m11 * m22 * m30;
       det += m02 * m11 * m23 * m30 - m01 * m12 * m23 * m30;
       det += m02 * m13 * m20 * m31 - m03 * m12 * m20 * m31;
       det += m03 * m10 * m22 * m31 - m00 * m13 * m22 * m31;
       det += m00 * m12 * m23 * m31 - m02 * m10 * m23 * m31;
       det += m03 * m11 * m20 * m32 - m01 * m13 * m20 * m32;
       det += m00 * m13 * m21 * m32 - m03 * m10 * m21 * m32;
       det += m01 * m10 * m23 * m32 - m00 * m11 * m23 * m32;
       det += m01 * m12 * m20 * m33 - m02 * m11 * m20 * m33;
       det += m02 * m10 * m21 * m33 - m00 * m12 * m21 * m33;
       det += m00 * m11 * m22 * m33 - m01 * m10 * m22 * m33;
   return det;
}

bool Matrix4::Valid(void) const
{
  const Matrix4& self = *this;
  return self[0].Valid() && self[1].Valid() && 
         self[2].Valid() && self[3].Valid();
}

void Matrix4::Scale(real x, real y, real z)
{
  m00 = real(x);    m01 = real(0.0);  m02 = real(0.0);  m03 = real(0.0);
  m10 = real(0.0);  m11 = real(y);    m12 = real(0.0);  m13 = real(0.0);
  m20 = real(0.0);  m21 = real(0.0);  m22 = real(z);    m23 = real(0.0);
  m30 = real(0.0);  m31 = real(0.0);  m32 = real(0.0);  m33 = real(1.0);
}

void Matrix4::Scale(Vec3Param axis)
{
  Scale(axis.x, axis.y, axis.z);
}

void Matrix4::Rotate(real x, real y, real z, real radians)
{
  real c0 = Math::Cos(radians);
  real n1C0 = real(1.0) - c0;
  real s0 = Math::Sin(radians);

  //| x^2(1-c0)+c0  xy(1-c0)-zs0  xz(1-c0)+ys0 |
  //| xy(1-c0)+zs0  y^2(1-c0)+c0  yz(1-c0)-xs0 |
  //| xz(1-c0)-ys0  yz(1-c0)+xs0  z^2(1-c0)+c0 |
  SetCross(cX, x*x*n1C0 + c0  , x*y*n1C0 - z*s0, x*z*n1C0 + y*s0, real(0.0));
  SetCross(cY, x*y*n1C0 + z*s0, y*y*n1C0 + c0  , y*z*n1C0 - x*s0, real(0.0));
  SetCross(cZ, x*z*n1C0 - y*s0, y*z*n1C0 + x*s0, z*z*n1C0 + c0  , real(0.0));
  SetCross(cW, real(0.0)      , real(0.0)      , real(0.0)      , real(1.0));
}

void Matrix4::Rotate(Vec3Param axis, real radians)
{
  Rotate(axis.x, axis.y, axis.z, radians);
}

void Matrix4::Translate(real x, real y, real z)
{
  m00 = real(1.0);  m01 = real(0.0);  m02 = real(0.0);  m03 = real(x);
  m10 = real(0.0);  m11 = real(1.0);  m12 = real(0.0);  m13 = real(y);
  m20 = real(0.0);  m21 = real(0.0);  m22 = real(1.0);  m23 = real(z);
  m30 = real(0.0);  m31 = real(0.0);  m32 = real(0.0);  m33 = real(1.0);
}

void Matrix4::Translate(Vec3Param axis)
{
  Translate(axis.x, axis.y, axis.z);
}

void Matrix4::BuildTransform(Vec3Param translate, QuatParam rotate, 
                             Vec3Param scale)
{
  //Translation component
  m03 = translate.x;
  m13 = translate.y;
  m23 = translate.z;
  m33 = real(1.0);

  //Rotational component
  real xx = rotate.x * rotate.x;
  real xy = rotate.x * rotate.y;
  real xz = rotate.x * rotate.z;
  real yy = rotate.y * rotate.y;
  real yz = rotate.y * rotate.z;
  real zz = rotate.z * rotate.z;
  real zw = rotate.z * rotate.w;
  real yw = rotate.y * rotate.w;
  real xw = rotate.x * rotate.w;

  m00 = real(1.0) - real(2.0) * (yy + zz);
  m01 = real(2.0) * (xy - zw);
  m02 = real(2.0) * (xz + yw);

  m10 = real(2.0) * (xy + zw);
  m11 = real(1.0) - real(2.0) * (xx + zz);
  m12 = real(2.0) * (yz - xw);

  m20 = real(2.0) * (xz - yw);
  m21 = real(2.0) * (yz + xw);
  m22 = real(1.0) - real(2.0) * (xx + yy);

  //Scale component
  m00 *= scale.x;
  m10 *= scale.x;
  m20 *= scale.x;

  m01 *= scale.y;
  m11 *= scale.y;
  m21 *= scale.y;

  m02 *= scale.z;
  m12 *= scale.z;
  m22 *= scale.z;

  m30 = m31 = m32 = real(0.0);
}

void Matrix4::BuildTransform(Vec3Param translate, Mat3Param rotate, 
                             Vec3Param scale)
{
  //Translation component
  m03 = translate.x;
  m13 = translate.y;
  m23 = translate.z;
  m33 = real(1.0);

  //Rotational component
  m00 = rotate.m00;   
  m01 = rotate.m01;   
  m02 = rotate.m02;

  m10 = rotate.m10;   
  m11 = rotate.m11;   
  m12 = rotate.m12;

  m20 = rotate.m20;   
  m21 = rotate.m21;   
  m22 = rotate.m22;

  //Scale component
  m00 *= scale.x;     
  m10 *= scale.x;     
  m20 *= scale.x;

  m01 *= scale.y;
  m11 *= scale.y;
  m21 *= scale.y;

  m02 *= scale.z;
  m12 *= scale.z;
  m22 *= scale.z;

  m30 = m31 = m32 = real(0.0);
}

void Matrix4::Decompose(Vec3Ptr scale, Mat3Ptr rotate, Vec3Ptr translate) const
{
  Vector3 shear;
  Decompose(scale, &shear, rotate, translate);
}

//Shear values that are calculated are XY, XZ, and YZ. They are stored as the 
//element their name does not contain, so shear->x would have YZ in it
void Matrix4::Decompose(Vec3Ptr scale, Vec3Ptr shear, Mat3Ptr rotate, 
                        Vec3Ptr translate) const
{
  ErrorIf(scale == NULL, "Matrix4 - Null pointer passed for scale.");
  ErrorIf(shear == NULL, "Matrix4 - Null pointer passed for shear.");
  ErrorIf(rotate == NULL, "Matrix4 - Null pointer passed for rotation.");
  ErrorIf(translate == NULL, "Matrix4 - Null pointer passed for translation.");

  //Translation is the last basis vector
  translate->x = m03;
  translate->y = m13;
  translate->z = m23;

  //X' == first basis vector
  //Y' == second basis vector
  //Z' == third basis vector

  //       X'                  Y'                  Z'
  rotate->m00 = m00;  rotate->m01 = m01;  rotate->m02 = m02;
  rotate->m10 = m10;  rotate->m11 = m11;  rotate->m12 = m12;
  rotate->m20 = m20;  rotate->m21 = m21;  rotate->m22 = m22;

  //ScaleX is the magnitude of X'
  scale->x = Math::Sqrt(Math::Sq(m00) + Math::Sq(m10) + Math::Sq(m20));

  //X' is normalized
  rotate->m00 /= scale->x;
  rotate->m10 /= scale->x;
  rotate->m20 /= scale->x;

  //ShearXY is the dot product of X' and Y'
  shear->z = rotate->m00 * rotate->m01 + 
             rotate->m10 * rotate->m11 + 
             rotate->m20 * rotate->m21;

  //Make Y' orthogonal to X' by " Y' = Y' - (ShearXY * X') "
  rotate->m01 -= shear->z * rotate->m00;
  rotate->m11 -= shear->z * rotate->m10;
  rotate->m21 -= shear->z * rotate->m20;

  //ScaleY is the magnitude of the modified Y'
  scale->y = Math::Sqrt(Math::Sq(m01) + Math::Sq(m11) + Math::Sq(m21));

  //Y' is normalized
  rotate->m01 /= scale->y;
  rotate->m11 /= scale->y;
  rotate->m21 /= scale->y;

  //ShearXY is divided by ScaleY to get it's final value
  shear->z /= scale->y;

  //ShearXZ is the dot product of X' and Z'
  shear->y = rotate->m00 * rotate->m02 +
             rotate->m10 * rotate->m12 +
             rotate->m20 * rotate->m22;

  //ShearYZ is the dot product of Y' and Z'
  shear->x = rotate->m01 * rotate->m02 +
             rotate->m11 * rotate->m12 +
             rotate->m21 * rotate->m22;

  //Make Z' orthogonal to X' by " Z' = Z' - (ShearXZ * X') "
  rotate->m02 -= shear->y * rotate->m00;
  rotate->m12 -= shear->y * rotate->m10;
  rotate->m22 -= shear->y * rotate->m20;

  //Make Z' orthogonal to Y' by " Z' = Z' - (ShearYZ * Y') "
  rotate->m02 -= shear->x * rotate->m01;
  rotate->m12 -= shear->x * rotate->m11;
  rotate->m22 -= shear->x * rotate->m21;

  //ScaleZ is the magnitude of the modified Z'
  scale->z = Math::Sqrt(Math::Sq(m02) + Math::Sq(m12) + Math::Sq(m22));
  
  //Z' is normalized
  rotate->m02 /= scale->z;
  rotate->m12 /= scale->z;
  rotate->m22 /= scale->z;

  //ShearXZ is divided by ScaleZ to get it's final value
  shear->y /= scale->z;

  //ShearYZ is divided by ScaleZ to get it's final value
  shear->x /= scale->z;

  //If the determinant is negative, then the rotation and scale contain a flip
  Vector3 v = Vector3(rotate->m11 * rotate->m22 - rotate->m21 * rotate->m12,
                      rotate->m21 * rotate->m02 - rotate->m01 * rotate->m22,
                      rotate->m01 * rotate->m12 - rotate->m11 * rotate->m02);
  real dot = v.x * rotate->m00 + v.y * rotate->m10 + v.z * rotate->m20;
  if(dot < real(0.0))
  {
    (*rotate) *= real(-1.0);
    Negate(scale);
  }
}

Matrix4::BasisVector Matrix4::Basis(uint index) const
{
  ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
  return Vector4(array[index],     array[4 + index], 
                 array[8 + index], array[12 + index]);
#else
  Mat4Param self = *this;
  return self[index];
#endif
}

Matrix4::BasisVector Matrix4::BasisX(void) const
{
#if ColumnBasis == 1
  return Vector4(array[0], array[4], array[8], array[12]);
#else
  Mat4Param self = *this;
  return self[0];
#endif
}

Matrix4::BasisVector Matrix4::BasisY(void) const
{
#if ColumnBasis == 1
  return Vector4(array[1], array[5], array[9], array[13]);
#else
  Mat4Param self = *this;
  return self[1];
#endif
}

Matrix4::BasisVector Matrix4::BasisZ(void) const
{
#if ColumnBasis == 1
  return Vector4(array[2], array[6], array[10], array[14]);
#else
  Mat4Param self = *this;
  return self[2];
#endif
}

Matrix4::BasisVector Matrix4::BasisW(void) const
{
#if ColumnBasis == 1
  return Vector4(array[3], array[7], array[11], array[15]);
#else
  Mat4Param self = *this;
  return self[3];
#endif
}

Matrix4::CrossVector Matrix4::Cross(uint index) const
{
  ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
  Mat4Param self = *this;
  return self[index];
#else
  return Vector4(array[index],     array[4 + index], 
                 array[8 + index], array[12 + index]);
#endif
}

void Matrix4::SetBasis(uint index, Vec4Param basisVector)
{
  SetBasis(index, basisVector.x, basisVector.y, basisVector.z, basisVector.w);  
}

void Matrix4::SetBasis(uint index, Vec3Param basisVector3, real w)
{
  SetBasis(index, basisVector3.x, basisVector3.y, basisVector3.z, w);  
}

void Matrix4::SetBasis(uint index, real x, Vec3Param basisVector3)
{
  SetBasis(index, x, basisVector3.x, basisVector3.y, basisVector3.z);  
}

void Matrix4::SetBasis(uint index, real x, real y, real z, real w)
{
  ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
  array[index] = x;
  array[4 + index] = y;
  array[8 + index] = z;
  array[12 + index] = w;
#else
  Mat4Param self = *this;
  self[index].Set(x, y, z, w);
#endif
}

void Matrix4::SetCross(uint index, Vec4Param crossVector)
{
  SetCross(index, crossVector.x, crossVector.y, crossVector.z, crossVector.w);
}

void Matrix4::SetCross(uint index, Vec3Param crossVector3, real w)
{
  SetCross(index, crossVector3.x, crossVector3.y, crossVector3.z, w);
}

void Matrix4::SetCross(uint index, real x, real y, real z, real w)
{
  ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
  Mat4Ref self = *this;
  self[index].Set(x, y, z, w);
#else
  array[index] = x;
  array[4 + index] = y;
  array[8 + index] = z;
  array[12 + index] = w;
#endif
}

Vector3 Matrix4::Basis3(uint index) const
{
  ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
  return Vector3(array[index], array[4 + index], array[8 + index]);
#else
  Mat4Param self = *this;
  return Vector3(self[index].x, self[index].y, self[index].z);
#endif
}

Vector3 Matrix4::Basis3X(void) const
{
#if ColumnBasis == 1
  return Vector3(array[0], array[4], array[8]);
#else
  Mat4Param self = *this;
  return Vector3(self[0].x, self[0].y, self[0].z);
#endif
}

Vector3 Matrix4::Basis3Y(void) const
{
#if ColumnBasis == 1
  return Vector3(array[1], array[5], array[9]);
#else
  Mat4Param self = *this;
  return Vector3(self[1].x, self[1].y, self[1].z);
#endif
}

Vector3 Matrix4::Basis3Z(void) const
{
#if ColumnBasis == 1
  return Vector3(array[2], array[6], array[10]);
#else
  Mat4Param self = *this;
  return Vector3(self[2].x, self[2].y, self[2].z);
#endif
}

Vector3 Matrix4::Basis3W(void) const
{
#if ColumnBasis == 1
  return Vector3(array[3], array[7], array[11]);
#else
  Mat4Param self = *this;
  return Vector3(self[3].x, self[3].y, self[3].z);
#endif
}

Vector3 Matrix4::Cross3(uint index) const
{
  ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
  Mat4Param self = *this;
  return Vector3(self[index].x, self[index].y, self[index].z);
#else
  return Vector3(array[index], array[4 + index], array[8 + index]);
#endif
}

Matrix4 operator*(real lhs, Mat4Param rhs)
{
  return rhs * lhs;
}

Matrix4 Concat(Mat4Param lhs, Mat4Param rhs)
{
  return lhs.Concat(rhs);
}

Vector4 Transform(Mat4Param mat, Vec4Param vector)
{
  real x = Dot(mat.Cross(0), vector);
  real y = Dot(mat.Cross(1), vector);
  real z = Dot(mat.Cross(2), vector);
  real w = Dot(mat.Cross(3), vector);
  return Vector4(x, y, z, w);
}

void Transform(Mat4Param mat, Vec4Ptr vector)
{
  ErrorIf(vector == NULL, "Matrix4 - Null pointer passed for vector.");
  real x = Dot(mat.Cross(0), *vector);
  real y = Dot(mat.Cross(1), *vector);
  real z = Dot(mat.Cross(2), *vector);
  real w = Dot(mat.Cross(3), *vector);
  vector->Set(x, y, z, w);
}

Matrix4 BuildTransform(Vec3Param translate, QuatParam rotate, Vec3Param scale)
{
  Matrix4 newMatrix;
  newMatrix.BuildTransform(translate, rotate, scale);
  return newMatrix;
}

Matrix4 BuildTransform(Vec3Param translate, Mat3Param rotate, Vec3Param scale)
{
  Matrix4 newMatrix;
  newMatrix.BuildTransform(translate, rotate, scale);
  return newMatrix;
}

Vector3 TransformPoint(Mat4Param matrix, Vec3Param point)
{
  real x = Dot(*(Vector3*)&matrix[0], point) + matrix[0][3];
  real y = Dot(*(Vector3*)&matrix[1], point) + matrix[1][3];
  real z = Dot(*(Vector3*)&matrix[2], point) + matrix[2][3];
  return Vector3(x, y, z);
}

Vector3 TransformNormal(Mat4Param matrix, Vec3Param normal)
{
  real x = Dot(*(Vector3*)&matrix[0], normal);
  real y = Dot(*(Vector3*)&matrix[1], normal);
  real z = Dot(*(Vector3*)&matrix[2], normal);
  return Vector3(x, y, z);
}

Vector3 TransformPointProjected(Mat4Param matrix, Vec3Param point)
{
  real x = Dot(*(Vector3*)&matrix[0], point) + matrix[3][0];
  real y = Dot(*(Vector3*)&matrix[1], point) + matrix[3][1];
  real z = Dot(*(Vector3*)&matrix[2], point) + matrix[3][2];
  real w = Dot(*(Vector3*)&matrix[3], point) + matrix[3][3];
  return Vector3(x / w, y / w, z / w);
}

Vector3 TransformNormalCol(Mat4Param matrix, Vec3Param normal)
{
  real x = Dot(Vector3(matrix.m00, matrix.m10, matrix.m20), normal);
  real y = Dot(Vector3(matrix.m01, matrix.m11, matrix.m21), normal);
  real z = Dot(Vector3(matrix.m02, matrix.m12, matrix.m22), normal);
  return Vector3(x, y, z);
}

Vector3 TransformPointCol(Mat4Param matrix, Vec3Param point)
{
  real x = Dot(Vector3(matrix.m00, matrix.m10, matrix.m20), point) + matrix[3][0];
  real y = Dot(Vector3(matrix.m01, matrix.m11, matrix.m21), point) + matrix[3][1];
  real z = Dot(Vector3(matrix.m02, matrix.m12, matrix.m22), point) + matrix[3][2];
  return Vector3(x, y, z);
}

Vector3 TransformPointProjectedCol(Mat4Param matrix, Vec3Param point)
{
  real x = Dot(Vector3(matrix.m00, matrix.m10, matrix.m20), point) + matrix[3][0];
  real y = Dot(Vector3(matrix.m01, matrix.m11, matrix.m21), point) + matrix[3][1];
  real z = Dot(Vector3(matrix.m02, matrix.m12, matrix.m22), point) + matrix[3][2];
  real w = Dot(Vector3(matrix.m03, matrix.m13, matrix.m23), point) + matrix[3][3];
  return Vector3(x / w, y / w, z / w);
}

Vector3 TransformPointProjectedCol(Mat4Param matrix, Vec3Param point, real* wOut)
{
  real x = Dot(Vector3(matrix.m00, matrix.m10, matrix.m20), point) + matrix[3][0];
  real y = Dot(Vector3(matrix.m01, matrix.m11, matrix.m21), point) + matrix[3][1];
  real z = Dot(Vector3(matrix.m02, matrix.m12, matrix.m22), point) + matrix[3][2];
  real w = Dot(Vector3(matrix.m03, matrix.m13, matrix.m23), point) + matrix[3][3];
  *wOut = w;
  return Vector3(x / w, y / w, z / w);
}

real Trace(Mat4Param matrix)
{
  return matrix.m00 + matrix.m11 + matrix.m22 + matrix.m33;
}

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
///  \file Numerical.cpp
///  Contains the implementation of the functions that operate on numerical data
///  as functions.
///
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Math
{

namespace
{

const uint cRootIterations = 2;

//------------------------------------------------------------------------------
real Cubed(real x)
{
  return x * x * x;
}

//------------------------------------------------------------------------------
real ToThe4th(real x)
{
  return x * x * x * x;
}

//------------------------------------------------------------------------------
real CubeRoot(real x)
{
  real sign = Math::GetSign(x);
  return sign * Math::Pow(Math::Abs(x), real(1.0 / 3.0));
}

//------------------------------------------------------------------------------
void MinMaxInPlace(real& x, real& y)
{
  if(y < x)
  {
    Swap(x, y);
  }
}

//------------------------------------------------------------------------------
void MinMaxInPlace(real& x, real& y, real& z)
{
  MinMaxInPlace(x, y);
  MinMaxInPlace(x, z);
  MinMaxInPlace(y, z);
}

//------------------------------------------------------------------------------
void MinMaxInPlace(real& x, real& y, real& z, real& w)
{
  MinMaxInPlace(x, y);
  MinMaxInPlace(x, z);
  MinMaxInPlace(x, w);
  MinMaxInPlace(y, z);
  MinMaxInPlace(y, w);
  MinMaxInPlace(z, w);
}

//------------------------------------------------------------------------------
void MinMaxInPlace(uint count, real* values)
{
  switch(count)
  {
    case 2:
    {
      MinMaxInPlace(values[0], values[1]);
    }
    break;

    case 3:
    {
      MinMaxInPlace(values[0], values[1], values[2]);
    }
    break;

    case 4:
    {
      MinMaxInPlace(values[0], values[1], values[2], values[3]);
    }
    break;
  }
}

}// namespace

///Evaluates the quadratic polynomial at the given x-value.
///                          a2 * x^2 + a1 * x + a0
real EvaluateQuadratic(real x, real a0, real a1, real a2)
{
  return a0 + x * (a1 + x * a2);
}

///Evaluates the cubic polynomial at the given x-value.
///                    a3 * x^3 + a2 * x^2 + a1 * x + a0
real EvaluateCubic(real x, real a0, real a1, real a2, real a3)
{
  return a0 + x * (a1 + x * (a2 + x * a3));
}

///Evaluates the quartic polynomial at the given x-value.
///               a4 * x^4 + a3 * x^3 + a2 * x^2 + a1 * x + a0
real EvaluateQuartic(real x, real a0, real a1, real a2, real a3, real a4)
{
  return a0 + x * (a1 + x * (a2 + x * (a3 + x * a4)));
}

///Evaluates the polynomial at the given x-value.
///             a[count] * x^(count) + ... + a[1] * x + a[0]
real EvaluatePolynomial(real x, real* coefficients, uint coefficientCount)
{
  ErrorIf(coefficientCount == 0, "Math - No coefficients passed for the " \
                                 "polynomial.");
  ErrorIf(coefficients == NULL, "Math - No coefficients passed for the "  \
                                "polynomial.");

  uint n = coefficientCount - 1;
  real result = coefficients[n];
  for(int i = n - 1; i > -1; --i)
  {
    result = coefficients[i] + x * result;
  }
  return result;
}

///Solves the quadratic polynomial
///                        a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter. If the last parameter is null, the roots will not be 
///calculated.
uint SolveQuadratic(real a0, real a1, real a2, real* roots)
{
  real p = a1 / (real(2.0) * a2);
  real q = a0 / a2;
  real discr = p * p - q;
  if(Math::IsZero(discr))
  {
    if(roots != NULL)
    {
      roots[0] = -p;
    }    
    return 1;
  }
  else if(discr > real(0.0))
  {
    if(roots != NULL)
    {
      discr = Math::Sqrt(discr);
      roots[0] = -discr - p;
      roots[1] =  discr - p;
    }
    return 2;
  }
  return 0;
}

///Solves the cubic polynomial 
///                 a3 * x^3 + a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter. If the last parameter is null, the roots will not be 
///calculated.
uint SolveCubic(real a0, real a1, real a2, real a3, real* roots)
{
  real r[3] = { real(0.0) };
  uint rootCount = 0;

  //Solve the cubic equation
  if(a3 != real(0.0))
  {
    const real inv3 = real(1.0 / 3.0);
    const real invA = real(1.0) / a3;
    const real s = -a2 * inv3 * invA;
    const real ss = s * s;
    real p = a1 * inv3 * invA - ss;
    p = p * p * p;
    real q = real(0.5) * (real(2.0) * ss * s - (a1 * s + a0) * invA);
    real discr = q * q + p;
    if(discr < real(0.0))
    {
      if(roots == NULL)
      {
        return 3;
      }

      rootCount = 3;
      real arg = q / Math::Sqrt(-p);
      real phi;
      //This can be optimized to remove the trig functions!
      if(arg < real(-1.0))
      {
        phi = cPi * inv3;
      }
      else if(arg > real(1.0))
      {
        phi = real(0.0);
      }
      else
      {
        phi = Math::ArcCos(arg) * inv3;
      }
      p = real(2.0) * Math::Pow(-p, real(1.0 / 6.0));
      r[0] = p * Math::Cos(phi) + s;
      r[1] = p * Math::Cos(phi + real(2.0 / 3.0) * cPi) + s;
      r[2] = p * Math::Cos(phi + real(4.0 / 3.0) * cPi) + s;
    }
    else
    {
      if(roots == NULL)
      {
        return 1;
      }

      rootCount = 1;
      discr = Math::Sqrt(discr);
      r[0] = CubeRoot(q + discr) + CubeRoot(q - discr) + s;
    }
  }
  //Solve the quadratic equation
  else if(a2 != real(0.0))
  {
    real invB = real(1.0) / a2;
    real p = real(0.5) * a1 * invB;
    real discr = p * p - a0 * invB;
    if(discr > real(0.0))
    {
      if(roots == NULL)
      {
        return 2;
      }

      rootCount = 2;
      discr = Sqrt(discr);
      r[0] = -discr - p;
      r[1] =  discr - p;
    }
    else
    {
      return 0;
    }
  }
  //Solve the linear equation
  else if(a1 != real(0.0))
  {
    if(roots == NULL)
    {
      return 1;
    }

    rootCount = 1;
    r[0] = a0 / a1;
  }

  const real two = real(2.0);
  const real three = real(3.0);
  roots[2] = r[2];
  roots[1] = r[1];
  roots[0] = r[0];
  MinMaxInPlace(rootCount, roots);
  //Clean up the roots with one iteration of Newton's method.
  switch(rootCount)
  {
    case 3:
      roots[2] = roots[2] - Math::EvaluateCubic(roots[2], a0, a1, a2, a3) / 
                 Math::EvaluateQuadratic(roots[2], a1, two * a2, three * a3);
    case 2:
      roots[1] = roots[1] - Math::EvaluateCubic(roots[1], a0, a1, a2, a3) /
                 Math::EvaluateQuadratic(roots[1], a1, two * a2, three * a3);
    case 1:
      roots[0] = roots[0] - Math::EvaluateCubic(roots[0], a0, a1, a2, a3) /
                 Math::EvaluateQuadratic(roots[0], a1, two * a2, three * a3);
    case 0:
      break;
  }
  return rootCount;
}

bool NearZero(float value)
{
  return Math::Abs(value) < 0.00001f;
}

///Solves the quartic polynomial 
///             a4 * x^4 + a3 * x^3 + a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter. If the last parameter is null, the roots will not be 
///calculated.
uint SolveQuartic(real a0, real a1, real a2, real a3, real a4, real* roots)
{
  if(a4 == real(0.0))
  {
    return SolveCubic(a0, a1, a2, a3, roots);
  }

  if(a4 != real(1.0))
  {
    a3 /= a4;
    a2 /= a4;
    a1 /= a4;
    a0 /= a4;
  }

  real p = real(-3.0 / 8.0) * Math::Sq(a3) + a2;
  real q = Cubed(a3) / real(8.0) - (a3 * a2) / real(2.0) + a1;
  real r = real(-3.0 / 256.0) * Math::Sq(a3) * Math::Sq(a3) + 
           (Math::Sq(a3) * a2) / real(16.0) - (a3 * a1) / real(4.0) + a0;


  uint rootCount = 0;
  //Find solution to: y^3 - p/2 * y^2 - r * y + (4 * r * p - q^2)/8 = 0
  real c = (real(4.0) * r * p - (q * q)) / real(8.0);
  rootCount = SolveCubic(c, -r, -p / real(2.0), real(1.0), roots);

  //Use the result of the cubic polynomial to solve the two quadratics
  const real z = roots[0];

  real u = z * z - r;
  real v = real(2.0) * z - p;

  if(NearZero(u))
    u = 0.0f;
  else if(u > real(0.0))
    u = Math::Sqrt(u);
  else
    return 0;

  if(NearZero(v))
    v = 0.0f;
  else if(v > real(0.0))
    v = Math::Sqrt(v);
  else
    return 0;

  //Solve the roots for the two quadratic equations
  if(q >= real(0.0))
  {
    rootCount  = SolveQuadratic(z - u,  v, real(1.0), roots);
    rootCount += SolveQuadratic(z + u, -v, real(1.0), 
                                roots + (roots == NULL ? 0 : rootCount));
  }
  else
  {
    rootCount  = SolveQuadratic(z + u,  v, real(1.0), roots);
    rootCount += SolveQuadratic(z - u, -v, real(1.0),
                                roots + (roots == NULL ? 0 : rootCount));
  }
  if(roots == NULL)
  {
    return rootCount;
  }

  //Get the roots in the order of most negative to most positive
  MinMaxInPlace(rootCount, roots);
 
  //Calculate the t-values for the quartic roots
  for(uint i = 0; i < rootCount; ++i)
  {
    roots[i] -= a3 / real(4.0);
  }

  //Clean up the roots with one iteration of Newton's method.
  const real two = real(2.0);
  const real three = real(3.0);
  const real four = real(4.0);
  for(uint i = 0; i < cRootIterations; ++i)
  {
    switch(rootCount)
    {
      case 4:
        roots[3] = roots[3] - 
                   Math::EvaluateQuartic(roots[3], a0, a1, a2, a3, a4) / 
                   Math::EvaluateCubic(roots[3], a1, two * a2, three * a3, 
                                       four * a4);
      case 3:
        roots[2] = roots[2] - 
                   Math::EvaluateQuartic(roots[2], a0, a1, a2, a3, a4) / 
                   Math::EvaluateCubic(roots[2], a1, two * a2, three * a3, 
                                       four * a4);
      case 2:
        roots[1] = roots[1] - 
                   Math::EvaluateQuartic(roots[1], a0, a1, a2, a3, a4) / 
                   Math::EvaluateCubic(roots[1], a1, two * a2, three * a3, 
                                       four * a4);
      case 1:
        roots[0] = roots[0] - 
                   Math::EvaluateQuartic(roots[0], a0, a1, a2, a3, a4) / 
                   Math::EvaluateCubic(roots[0], a1, two * a2, three * a3, 
                                       four * a4);
        break;

      case 0:
        return 0;        
    }
  }
  return rootCount;
}
}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.cpp
/// Generates the precompiled header file.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///
/// \file Quaternion.cpp
/// Implementation of the Quaternion structure.
///
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Math
{
typedef Quaternion Quat;

const Quaternion Quaternion::cIdentity = Quaternion(real(0.0), real(0.0), 
                                                    real(0.0), real(1.0));

Quaternion::Quaternion(real xx, real yy, real zz, real ww)
{
  x = xx;
  y = yy;
  z = zz;
  w = ww;
}

void Quaternion::operator=(QuatParam rhs)
{
  x = rhs.x;
  y = rhs.y;
  z = rhs.z;
  w = rhs.w;
}

void Quaternion::operator+=(QuatParam rhs)
{
  x += rhs.x;
  y += rhs.y;
  z += rhs.z;
  w += rhs.w;
}

void Quaternion::operator-=(QuatParam rhs)
{
  x -= rhs.x;
  y -= rhs.y;
  z -= rhs.z;
  w -= rhs.w;
}

void Quaternion::operator*=(QuatParam rhs)
{
  Quat lhs(*this);
  x = lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y;
  y = lhs.w * rhs.y + lhs.y * rhs.w + lhs.z * rhs.x - lhs.x * rhs.z;
  z = lhs.w * rhs.z + lhs.z * rhs.w + lhs.x * rhs.y - lhs.y * rhs.x;
  w = lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z;
}

void Quaternion::operator*=(real rhs)
{
  x *= rhs;
  y *= rhs;
  z *= rhs;
  w *= rhs;
}

void Quaternion::operator/=(real rhs)
{
  ErrorIf(Math::IsZero(rhs), "Quaternion - Division by zero.");
  real reciprocal = real(1.0) / rhs;
  x *= reciprocal;
  y *= reciprocal;
  z *= reciprocal;
  w *= reciprocal;
}

Quaternion Quaternion::operator-(void) const
{
  return Quaternion(-x, -y, -z, -w);
}

Quaternion Quaternion::operator*(QuatParam quat) const
{
  return Quat(w * quat.x + x * quat.w + y * quat.z - z * quat.y,
              w * quat.y + y * quat.w + z * quat.x - x * quat.z,
              w * quat.z + z * quat.w + x * quat.y - y * quat.x,
              w * quat.w - x * quat.x - y * quat.y - z * quat.z);
}

Quaternion Quaternion::operator+(QuatParam rhs) const
{
  return Quat(x + rhs.x, y + rhs.y, z + rhs.z, w + rhs.w);
}

Quaternion Quaternion::operator-(QuatParam rhs) const
{
  return Quat(x - rhs.x, y - rhs.y, z - rhs.z, w - rhs.w);
}

Quaternion Quaternion::operator*(real rhs) const
{
  return Quat(x * rhs, y * rhs, z * rhs, w * rhs);
}

Quaternion Quaternion::operator/(real rhs) const
{
  ErrorIf(Math::IsZero(rhs), "Quaternion - Division by zero.");
  real reciprocal = real(1.0) / rhs;
  return Quat(x * reciprocal, y * reciprocal, z * reciprocal, w * reciprocal);
}

bool Quaternion::operator==(QuatParam rhs) const
{
  return Equal(x, rhs.x) &&
         Equal(y, rhs.y) &&
         Equal(z, rhs.z) &&
         Equal(w, rhs.w);
}

bool Quaternion::operator!=(QuatParam rhs) const
{
  return !(*this == rhs);
}

real& Quaternion::operator[](uint index)
{
  ErrorIf(index > 3, "Quaternion - Subscript out of range.");
  return V4()[index];
}

real Quaternion::operator[](uint index) const
{
  ErrorIf(index > 3, "Quaternion - Subscript out of range.");
  return V4()[index];
}

void Quaternion::Set(real xx, real yy, real zz, real ww)
{
  x = xx;
  y = yy;
  z = zz;
  w = ww;
}

void Quaternion::Integrate(Vec3Param vector, real scalar)
{
  Quat q(vector.x * scalar, vector.y * scalar, vector.z * scalar, real(0.0));

  q *= *this;

  x += real(0.5) * q.x;
  y += real(0.5) * q.y;
  z += real(0.5) * q.z;
  w += real(0.5) * q.w;
}

real Quaternion::Normalize(void)
{
  real length = LengthSq();

  if(Math::Equal(length, real(0.0)))
  {
    x = real(0.0);
    y = x;
    z = x;
    w = real(1.0);
    return real(0.0);
  }
  else
  {
    length = Math::Rsqrt(length);
    *this *= length;
    return length;
  }
}

Quaternion Quaternion::Normalized(void) const
{
  real length = LengthSq();

  if(Math::Equal(length, real(0.0)))
  {
    return Quat(real(0.0), real(0.0), real(0.0), real(1.0));
  }
  else
  {
    length = Math::Rsqrt(length);
    return (*this) * length;
  }
}

real Quaternion::Dot(QuatParam rhs) const
{
  return V4().Dot(rhs.V4());
}

real Quaternion::Length(void) const
{
  return Math::Sqrt(LengthSq());
}

real Quaternion::LengthSq(void) const
{
  return V4().LengthSq();
}

void Quaternion::Conjugate(void)
{
  x *= -real(1.0);
  y *= -real(1.0);
  z *= -real(1.0);
}

Quaternion Quaternion::Conjugated(void) const
{
  return Quat(-x, -y, -z, w);
}

void Quaternion::Invert(void)
{
  Conjugate();
  real lengthSq = LengthSq();

  ErrorIf(Math::IsZero(lengthSq), "Quaternion - Division by zero.");
  *this /= lengthSq;
}

Quaternion Quaternion::Inverted(void) const
{
  real lengthSq = LengthSq();
  ErrorIf(Math::IsZero(lengthSq), "Quaternion - Division by zero.");
  lengthSq = real(1.0) / lengthSq;
  return Quat(-x * lengthSq, -y * lengthSq, -z * lengthSq, w * lengthSq);
}

Quaternion Quaternion::Exponent(void) const
{
  real angle = V3().Length();
  Quat quaternion(x, y, z, real(0.0));

  if(Math::Abs(angle) > Math::Epsilon())
  {
    quaternion.w = Math::Cos(angle);
    angle = Math::Sin(angle) / angle;
    quaternion.x *= angle;
    quaternion.y *= angle;
    quaternion.z *= angle;
  }
  return quaternion;
}

Quaternion Quaternion::Logarithm(void) const
{
  Quat quaternion(x, y, z, real(0.0));
  real theta = Math::ArcCos(w);
  real sinTheta = Math::Sin(theta);

  if(Math::Abs(sinTheta) > Math::Epsilon())
  {
    theta = theta / sinTheta;
    quaternion.x *= theta;
    quaternion.y *= theta;
    quaternion.z *= theta;
  }
  return quaternion;
}

void Quaternion::RotateVector(Vec3Ptr vector)
{
  Quat tempVec = Quat(vector->x, vector->y, vector->z, real(0.0));
  Quat conjugate(-x, -y, -z, w);
  Quat result(*this);
  result *= tempVec;
  result *= conjugate;
  vector->Set(result.x, result.y, result.z);
}

Vector3 Quaternion::RotatedVector(Vec3Param vector) const
{
  Quat tempVec = Quat(vector.x, vector.y, vector.z, real(0.0));
  Quat conjugate(-x, -y, -z, w);
  Quat result(*this);
  result *= tempVec;
  result *= conjugate;
  return Vector3(result.x, result.y, result.z);
}

void Quaternion::ZeroOut(void)
{
  V3().ZeroOut();
  w = real(1.0);
}

bool Quaternion::Valid(void) const
{
  return Math::IsValid(x) && Math::IsValid(y) && 
         Math::IsValid(z) && Math::IsValid(w);
}

Vector3& Quaternion::V3()
{
  return *(Vector3*)this;
}

Vector4& Quaternion::V4()
{
  return *(Vector4*)this;
}

const Vector3& Quaternion::V3() const
{
  return *(Vector3*)this;
}

const Vector4& Quaternion::V4() const
{
  return *(Vector4*)this;
}

Quaternion operator*(real lhs, QuatParam rhs)
{
  return rhs * lhs;
}

void Normalize(QuatPtr quaternion)
{
  quaternion->Normalize();
}

Quaternion Normalized(QuatParam quaternion)
{
  return quaternion.Normalized();
}

real Dot(QuatParam lhs, QuatParam rhs)
{
  return lhs.Dot(rhs);
}

real Length(QuatParam quaternion)
{
  return quaternion.Length();
}

real LengthSq(QuatParam quaternion)
{
  return quaternion.LengthSq();
}

Quaternion Lerp(QuatParam start, QuatParam end, real tValue)
{
  WarnIf(!Math::InRange(tValue, real(0.0), real(1.0)), 
         "Quaternion - Interpolation value is not in the range of [0, 1]");
  real alpha = tValue;
  real oneMinusAlpha = real(1.0) - alpha;
  Quat quaternion(start.x * oneMinusAlpha + end.x * alpha,
                  start.y * oneMinusAlpha + end.y * alpha,
                  start.z * oneMinusAlpha + end.z * alpha,
                  start.w * oneMinusAlpha + end.w * alpha);
  Normalize(&quaternion);
  return quaternion;
}

Quaternion Slerp(QuatParam start, QuatParam end, real tValue)
{
  WarnIf(!Math::InRange(tValue, real(0.0), real(1.0)), 
         "Quaternion - Interpolation value is not in the range of [0, 1]");

  //
  // Quaternion Interpolation With Extra Spins, pp. 96f, 461f
  // Jack Morrison, Graphics Gems III, AP Professional
  //

  const real cSlerpEpsilon = real(0.00001);

  bool flip;

  real cosTheta = Dot(start, end); 

  //Check to ensure that the shortest path is taken (cosine of the angle between 
  //the two quaternions is positive).
  flip = cosTheta < real(0.0);
  if(flip)
  {
    cosTheta = -cosTheta;
  }

  real startVal, endVal;
  if((real(1.0) - cosTheta) > cSlerpEpsilon)
  {
    real theta = Math::ArcCos(cosTheta);
    real sinTheta = Math::Sin(theta);
    startVal = real(Math::Sin((real(1.0) - tValue) * theta) / sinTheta);
    endVal = real(Math::Sin(tValue * theta) / sinTheta);
  }
  else
  {
    startVal = real(1.0) - tValue;
    endVal = real(tValue);
  }

  if(flip)
  {
    endVal = -endVal;
  }

  return Quaternion(startVal * start.x + endVal * end.x,
                    startVal * start.y + endVal * end.y,
                    startVal * start.z + endVal * end.z,
                    startVal * start.w + endVal * end.w);
}

Quaternion CreateDiagonalizer(Mat3Param matrix)
{
  const uint cMaxSteps = 50;

  Quaternion quat(real(0.0), real(0.0), real(0.0), real(1.0));
  Matrix3 quatMatrix;
  Matrix3 diagMatrix;
  for(uint i = 0; i < cMaxSteps; ++i)
  {
    ToMatrix3(quat, &quatMatrix);
    diagMatrix = Concat(Concat(quatMatrix, matrix), quatMatrix.Transposed());

    //Elements not on the diagonal
    Vector3 offDiag(diagMatrix(1, 2), diagMatrix(0, 2), diagMatrix(0, 1));

    //Magnitude of the off-diagonal elements
    Vector3 magDiag = Abs(offDiag);

    //Index of the largest element 
    uint k = ((magDiag.x > magDiag.y) && (magDiag.x > magDiag.z)) ? 0 :
             ((magDiag.y > magDiag.z) ? 1 : 2);
    uint k1 = (k + 1) % 3;
    uint k2 = (k + 2) % 3;

    //Diagonal already
    if(offDiag[k] == real(0.0))
    {
      break;
    }

    real theta = (diagMatrix(k2, k2) - diagMatrix(k1, k1)) / 
                 (real(2.0) * offDiag[k]);
    real sign = Math::GetSign(theta);
    
    //Make theta positive
    theta *= sign;

    //Large term in T
    real thetaTerm = theta < real(1e6) ? Math::Sqrt(Math::Sq(theta) + real(1.0))
                                       : theta;

    //Sign(T) / (|T| + sqrt(T^2 + 1))
    real t = sign / (theta + thetaTerm);

    //c = 1 / (t^2 + 1)      t = s / c
    real c = real(1.0) / Math::Sqrt(Math::Sq(t) + real(1.0));

    //No room for improvement - reached machine precision.
    if(c == real(1.0))
    {
      break;
    }

    //Jacobi rotation for this iteration
    Quaternion jacobi(real(0.0), real(0.0), real(0.0), real(0.0));

    //Using 1/2 angle identity sin(a/2) = sqrt((1-cos(a))/2)
    jacobi[k] = sign * Math::Sqrt((real(1.0) - c) / real(2.0));

    //Since our quat-to-matrix convention was for v*M instead of M*v
    jacobi.w = Math::Sqrt(real(1.0) - Math::Sq(jacobi[k]));

    //Reached limits of floating point precision
    if(jacobi.w == real(1.0))
    {
      break;
    }

    quat *= jacobi;
    Normalize(&quat);
  }

  return quat;
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file StressRandom.cpp
/// Implementation of the random number and vector generation functions.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
//The following comment is required to use the Mersenne Twister
/* 
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)  
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.                          

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote 
        products derived from this software without specific prior written 
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/






using Zero::String;

namespace Math
{

namespace
{
//----------------------------------------------- Mersenne Twister Magic Numbers
const uint cM = 397;                //Period parameter.
const uint cMatrixA = 0x9908B0DF;   //Constant vector A.
const uint cUpperMask = 0x80000000; //Most significant w-r bits.
const uint cLowerMask = 0x7FFFFFFF; //Least significant r bits.
const uint cAllMask = 0xFFFFFFFF;   //All the bits.
}

//----------------------------------------------------------------------- Random
uint Random::mGlobalSeed = 1299827;

Random::Random(void)
{
  //we need something with higher precision than seconds (such as time(0)),
  //so use clock which is the number of clock ticks since the program was executed.
  mSeed = (uint)Zero::Time::GenerateSeed();
  mSeed ^= mGlobalSeed;

  // Call next once just to jumble it up a bit
  Next();
}

Random::Random(int initialSeed)
  : mSeed(initialSeed)
{
  //
}

uint Random::GetSeed()
{
  return mSeed;
}

void Random::SetSeed(uint seed)
{
  mSeed = seed;
}

uint Random::Next(void)
{
  mSeed = 214013 * mSeed + 2531011;
  mGlobalSeed = mSeed;
  return (mSeed >> 16) & cRandMax;
}

u32 Random::Uint32(void)
{
  return (Next() << 16) | Next();
}

u64 Random::Uint64(void)
{
  u64 a = Uint32();
  a = a << 32;
  a |= Uint32();
  return a;
}

float Random::Float(void)
{
  return Next() / float(cRandMax);
}

bool Random::Bool(void)
{
  return IntRangeInIn(0, 1) == 1;
}

int Random::IntRangeInIn(int min, int max)
{
  if(min > max)
  {
    String msg = String::Format("The min value '%d' must be less than or equal to the max value '%d'", min, max);
    //DoNotifyException("Invalid range", msg);
    return min;
  }

  ErrorIf(min > max, "Invalid range.");
  int range = max - min;
  return int(Uint32() % (range + 1)) + min;
}

int Random::IntRangeInEx(int min, int max)
{
  if(min >= max)
  {
    String msg = String::Format("The min value '%d' must be less than the max value '%d'", min, max);
    //DoNotifyException("Invalid range", msg);
    return min;
  }

  ErrorIf(min > max, "Invalid range.");
  int range = max - min;
  return (Next() % range) + min;
}

int Random::IntVariance(int base, int variance)
{
  if(variance < 0)
  {
    String msg = String::Format("The variance value '%d' cannot be negative.", variance);
    //DoNotifyException("Invalid variance", msg);
    return base;
  }

  return IntRangeInIn(base - variance, base + variance);
}

float Random::FloatRange(float min, float max)
{
  ErrorIf(min > max, "Invalid range.");
  float range = max - min;
  return (Float() * range) + min;
}

float Random::FloatVariance(float base, float variance)
{
  //Map from [0.0f, 1.0f] to [-0.5f, 0.5f]
  float val = Float() - 0.5f;

  //Map from [-0.5f, 0.5f] to [-variance, variance)
  val *= variance * 2.0f;

  //Map from [base - variance, base + variance]
  val += base;
  
  return val;
}

Vector2 Random::PointOnUnitCircle(void)
{
  const float cTwoPi = float(Math::cTwoPi);
  real angle = real(cTwoPi * Float());
  return Vector2(Math::Cos(angle), Math::Sin(angle));
}

//Returns a point on a unit circle with the x-axis going through the center
//of the circle.
Vector3 Random::PointOnUnitCircleX(void)
{
  Vector2 point = PointOnUnitCircle();
  return Vector3(real(0.0), point.y, point.x);
}

//Returns a point on a unit circle with the y-axis going through the center
//of the circle.
Vector3 Random::PointOnUnitCircleY(void)
{
  Vector2 point = PointOnUnitCircle();
  return Vector3(point.x, real(0.0), point.y);
}

//Returns a point on a unit circle with the z-axis going through the center
//of the circle.
Vector3 Random::PointOnUnitCircleZ(void)
{
  Vector2 point = PointOnUnitCircle();
  return Vector3(point.x, point.y, real(0.0));
}

Vector3 Random::PointOnUnitSphere(void)
{
  Vector3 v = Vector3(real(0.0), real(0.0), FloatRange(real(-1.0), real(1.0)));
  const real t = FloatRange(-cPi, cPi);
  const real radius = Sqrt(real(1.0) - (v.z * v.z));
  v.x = Cos(t) * radius;
  v.y = Sin(t) * radius;
  return Normalized(v);
}

Vector3 Random::PointInUnitSphere(void)
{
  real cubeRoot = real(1.0 / 3.0);
  real scalar = Float();
  return PointOnUnitSphere() * Math::Pow(scalar, cubeRoot);
}

//Generate uniform random quaternion
Quaternion Random::RotationQuaternion(void)
{
  //This algorithm generates a Gaussian deviate for each coordinate, so the
  //total effect is to generate a symmetric 4-D Gaussian distribution, by
  //separability. Projecting onto the surface of the hypersphere gives a uniform
  //distribution
  float x = FloatRange(-1.0f, 1.0f);
  float y = FloatRange(-1.0f, 1.0f);
  float z = FloatRange(-1.0f, 1.0f);
  float w = FloatRange(-1.0f, 1.0f);

  float s1;
  while((s1 = x * x + y * y) > 1.0f)
  {
    x = FloatRange(-1.0f, 1.0f);
    y = FloatRange(-1.0f, 1.0f);
  }

  float s2;
  while((s2 = z * z + w * w) > 1.0f)
  {
    z = FloatRange(-1.0f, 1.0f);
    w = FloatRange(-1.0f, 1.0f);
  }

  //Now the point (x, y) is uniformly distributed in the unit disk, so is the 
  //point (z, w), independently
  float num1 = -2.0f * float(Math::Log(s1));
  float num2 = -2.0f * float(Math::Log(s2));

  //Now "x * sqrt(num1 / s2)" is Gaussian distributed, using polar method.
  //Similarly for y, z, and w, and all are independent
  float r = num1 + num2;  //Sum of squares of four Gaussians
  float root1 = float(Math::Sqrt(num1 / (s1 * r)));
  float root2 = float(Math::Sqrt(num2 / (s2 * r)));

  //Normalizing onto unit sphere gives uniform unit quaternion
  return Quaternion(x * root1, y * root1, z * root2, w * root2);
}

Vector2 Random::ScaledVector2(float minLength, float maxLength)
{
  minLength = Math::Abs(minLength);
  maxLength = Math::Abs(maxLength);

  real size = maxLength - minLength;
  real scalar = Float();
  return PointOnUnitCircle() * (minLength + size * Math::Sqrt(scalar));
}

Vector3 Random::ScaledVector3(float minLength, float maxLength)
{
  minLength = Math::Abs(minLength);
  maxLength = Math::Abs(maxLength);

  real cubeRoot = 1.0f / 3.0f;
  real size = maxLength - minLength;
  real scalar = Float();
  return PointOnUnitSphere() * (minLength + size * Math::Pow(scalar, cubeRoot));
}

//Generate uniform random matrix
Matrix3 Random::RotationMatrix(void)
{
  Matrix3 matrix;
  RotationMatrix(&matrix);
  return matrix;
}

void Random::RotationMatrix(Mat3Ptr matrix)
{
  ErrorIf(matrix == NULL, "Invalid matrix provided.");
  Quaternion quat = RotationQuaternion();
  ToMatrix3(quat, matrix);
}

int Random::DieRoll(uint sides)
{
  if(sides == 0)
  {
    //DoNotifyException("Invalid die roll", "Cannot roll a zero sided die");
    return 0;
  }
  return IntRangeInEx(0, sides) + 1;
}

float Random::BellCurve(float center, float range, float standardDeviation)
{
  float randVal = 0.0f;
  do
  {
    //This is the box-muller normal distribution algorithm.
    float u1, u2, s;
    do 
    {
      //get two random floats in the range [-1,1]
      u1 = (Float() - .5f) * 2.0f;
      u2 = (Float() - .5f) * 2.0f;
      s = u1 * u1 + u2 * u2;
    } while (s >= 1.0f || s == 0.0f);

    //this technically generates 2 random for every call but we're only saving one now.
    //the other one generated is u2 * multiplier
    float multiplier = Math::Sqrt(-2.0f * Math::Log(s) / s);
    randVal = u1 * multiplier;

    //alter the standard deviation
    randVal *= standardDeviation;
    //Since the user gave us a range, restart if we don't have a value within
    //the valid range. a normal distribution can return a value at an infinite
    //range technically, and clamping the value will alter our probability.
    //Restarting is the only way to properly deal with this.
  } while(randVal < -3.0f || randVal > 3.0f);

  //shift over to the center and remap the [-3,3] range to [center - range, center + range]
  randVal = randVal * (range / 3.0f) + center;

  return randVal;
}

//------------------------------------------------------------- Mersenne Twister
///Seeds with a call to the "time" function.
MersenneTwister::MersenneTwister(void)
  : mIndex(cN + 1)
{
  Initialize(uint(Zero::Time::GenerateSeed()));
}

///Initializes the internal array with a seed.
MersenneTwister::MersenneTwister(uint seed)
  : mIndex(cN + 1)
{
  Initialize(seed);
}

///Initialize by an array with array-length. "keys" is the array for 
///initializing keys. "keyLength" is its length.
MersenneTwister::MersenneTwister(uint keys[], uint keyLength)
  : mIndex(cN + 1)
{
  Initialize(keys, keyLength);
}

///Initializes the values with a seed.
void MersenneTwister::Initialize(uint seed)
{
  const uint cMultiplier = 1812433253;
  uint& i = mIndex;
  mValues[0] = seed & cAllMask;
  for(i = 1; i < cN; ++i)
  {
    //See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. In the previous 
    //versions, MSBs of the seed affect only MSBs of the array mValues[].
    mValues[i] = cMultiplier * (mValues[i - 1] ^ (mValues[i - 1] >> 30)) + i;
    
    //For >32 bit machines
    mValues[i] &= cAllMask;
  }
}

///Initialize by an array with array-length. "keys" is the array for 
///initializing keys. "keyLength" is its length.
void MersenneTwister::Initialize(uint keys[], uint keyLength)
{
  const uint cInitialSeed = 19650218;

  Initialize(cInitialSeed);
  uint i = 1;
  uint j = 0;
  uint k = cN > keyLength ? cN : keyLength;
  for(/* k */; k != 0; k--)
  {
    const uint h = i - 1;

    //Non-linear
    mValues[i] = (mValues[i] ^ ((mValues[h] ^ (mValues[h] >> 30)) * 1664525)) + 
                 keys[j] + j;
    mValues[i] &= cAllMask; //for WORDSIZE > 32 machines
    ++i;
    ++j;
    if(i >= cN)
    {
      mValues[0] = mValues[cN - 1];
      i = 1;
    }
    if(j >= keyLength)
    {
      j = 0;
    }
  }
  for(k = cN - 1; k != 0; --k)
  {
    const uint h = i - 1;

    //Non-linear
    mValues[i] = (mValues[i] ^ ((mValues[h] ^ (mValues[h] >> 30)) * 1566083941)) - i;
    mValues[i] &= cAllMask; //for WORDSIZE > 32 machines
    ++i;
    if(i >= cN)
    {
      mValues[0] = mValues[cN - 1];
      i = 1;
    }
  }
  mValues[0] = cUpperMask;  //MSB is 1; assuring non-zero initial array.
}

///Generates a random number on the [-2,147,483,648, 2,147,483,648] interval.
int MersenneTwister::Int(void)
{
  uint i = Uint();
  return *reinterpret_cast<int*>(&i);
}

///Generates a random number on the [0, 4,294,967,295] interval.
uint MersenneTwister::Uint(void)
{
  //mag01[x] = x * cMatrixA for x = 0, 1
  static uint mag01[2] = { 0x0, cMatrixA }; 

  //Generate N words at one time.
  if(mIndex >= cN)
  {
    //If "Initialize" has not been called, a default initial seed is used.
    if(mIndex == cN + 1)
    {
      Initialize(5489);
    }

    uint y;
    int kk;
    for(kk = 0; kk < cN - cM; ++kk)
    {
      y = (mValues[kk] & cUpperMask) | (mValues[kk + 1] & cLowerMask);
      mValues[kk] = mValues[kk + cM] ^ (y >> 1) ^ mag01[y & 0x1];
    }
    for(/*kk*/; kk < cN - 1; ++kk)
    {
      y = (mValues[kk] & cUpperMask) | (mValues[kk + 1] & cLowerMask);
      mValues[kk] = mValues[kk + (cM - cN)] ^ (y >> 1) ^ mag01[y & 0x1];
    }
    y = (mValues[cN - 1] & cUpperMask) | (mValues[0] & cLowerMask);
    mValues[cN - 1] = mValues[cM - 1] ^ (y >> 1) ^ mag01[y & 0x1];

    mIndex = 0;
  }

  uint y = mValues[mIndex++];
 
  //Tempering
  y ^= (y >> 11);
  y ^= (y << 7) & 0x9D2C5680;
  y ^= (y << 15) & 0xEFC60000;
  y ^= (y >> 18);
  return y;
}

///Generates a random number on the [0,1)-real-interval.
float MersenneTwister::Float(void)
{
  //Divided by 2^32
  return float(Uint()) * (1.0f / 4294967295.0f);
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Reals.cpp
/// Implementation of the real typedef and utility functions.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#include <cmath>
#include <limits>
#include <cstdio>
#include <cstdlib>
#include <cfloat>

namespace Math
{

namespace
{
const real cTemp     = real(-0.0);
const uint cSignBit  = *reinterpret_cast<uint const*>(&cTemp);
const real cNegative = real(-1.0);
const real cPositive = real(1.0);

real gZeroForInf = real(0.0);
real gInfinite = real(1.0) / gZeroForInf;
}

const real& cInfinite = gInfinite;

real Epsilon(void) 
{
  return real(0.00000001);
}

real PositiveMax(void) 
{
  return FLT_MAX;
}

real PositiveMin()
{
  return FLT_MIN;
}

bool Equal(real lhs, real rhs) 
{
  return Abs(lhs - rhs) <= Epsilon() * (Abs(lhs) + Abs(rhs) + real(1.0));
}

bool Equal(real lhs, real rhs, real epsilon)
{
  return Abs(lhs - rhs) <= epsilon * (Abs(lhs) + Abs(rhs) + real(1.0));
}

bool NotEqual(real lhs, real rhs)
{
  return !Equal(lhs, rhs);
}

bool IsZero(real val) 
{
  return Abs(val) <= Epsilon();
}

bool IsNegative(real number)
{
  return GetSign(number) == cNegative;
}

bool IsPositive(real number)
{
  return GetSign(number) == cPositive;
}

bool LessThan(real lhs, real rhs)
{ 
  return lhs < rhs;
}

bool LessThanOrEqual(real lhs, real rhs)  
{ 
  return lhs <= rhs;
}

bool GreaterThan(real lhs, real rhs)  
{ 
  return lhs > rhs;
}

bool GreaterThanOrEqual(real lhs, real rhs)  
{ 
  return lhs >= rhs;
}

real Sqrt(real val) 
{ 
  return std::sqrt(val);
}

bool SafeSqrt(real val, real& result)
{
  if(val < 0)
    return false;

  result = Sqrt(val);
  return true;
}

real Rsqrt(real val) 
{
  return real(1.0) / std::sqrt(val);
}

real Sq(real sqrt)
{
  return sqrt * sqrt;
}

real Pow(real base, real exp)
{
  return std::pow(base, exp);
}

real Log(real val)
{
  return std::log(val);
}

real Log(real val, real base)
{
  return Log(val) / Log(base);
}

real Log10(real val)
{
  return std::log10(val);
}

real Log2(real val)
{
  //log(2) is a constant (and actually calling log(2.0) caused a linker crash so use the constant)
  real log2 = real(0.693147182);
  return Log(val) / log2;
}

real Exp(real val)
{
  return std::exp(val);
}

real Exp2(real val)
{
  return Pow(2, val);
}

real Abs(real val)
{
  return std::abs(val);
}

int Abs(int val)
{
  return std::abs(val);
}

real FMod(real dividend, real divisor)
{
  return std::fmod(dividend, divisor);
}

bool SafeFMod(real dividend, real divisor, real& result)
{
  if(divisor == 0)
    return false;

  result = FMod(dividend, divisor);
  return true;
}

real GetSign(real val) 
{
  return (*reinterpret_cast<uint*>(&val) & cSignBit) != 0 ? cNegative 
                                                          : cPositive;
  //return lhs >= real(0.0) ? real(1.0) : real(-1.0);
}

int Sign(real val)
{
  if(val < 0)
    return -1;
  return 1;
}

int Sign(int val)
{
  if(val < 0)
    return -1;
  return 1;
}

real Cos(real val)
{
  return std::cos(val);
}

real Sin(real val)
{
  return std::sin(val);
}

real Tan(real angle)
{
  return std::tan(angle);
}

real Cot(real angle)
{
  return std::tan(cPi * 0.5f - angle);
}

real Cosh(real val)
{
  return std::cosh(val);
}

real Sinh(real val)
{
  return std::sinh(val);
}

real Tanh(real angle)
{
  return std::tanh(angle);
}

real ArcCos(real angle)
{
  angle = Math::ClampIfClose(angle, real(-1.0), real(1.0), real(0.00001));
  return std::acos(angle);
}

real ArcSin(real angle)
{
  angle = Math::ClampIfClose(angle, real(-1.0), real(1.0), real(0.00001));
  return std::asin(angle);
}

real ArcTan(real angle)
{
  return std::atan(angle);
}

real ArcTan2(real y, real x)
{
  return std::atan2(y, x);
}

bool SafeArcCos(real radians, real& result)
{
  bool isSafe = Math::TryClampIfClose(radians, -1.0f, 1.0f, 0.00001f);
  if(isSafe)
    result = Math::ArcCos(radians);
  return isSafe;
}

bool SafeArcSin(real radians, real& result)
{
  bool isSafe = Math::TryClampIfClose(radians, -1.0f, 1.0f, 0.00001f);
  if(isSafe)
    result = Math::ArcSin(radians);
  return isSafe;
}

real RadToDeg(real radians)
{
  return (real(180.0) / cPi) * radians;
}

real DegToRad(real degrees)
{
  return (cPi / real(180.0)) * degrees;
}

bool IsValid(real val)
{
#ifdef _MSC_VER
  return _finite(val) != 0;
#else
  return val == val;
#endif
}

int IntegerPositiveMax()
{
  return INT_MAX;
}

int IntegerNegativeMin()
{
  return INT_MIN;
}

real Round(real value)
{
  return std::floor(value + real(0.5));
}

real Round(real value, int places)
{
  return Round(value, places, 10);
}

real Round(real value, int places, int base)
{
  real scale = std::pow(real(base), places);
  return Round(value / scale) * scale;
}

real Truncate(real value)
{
  return (real)(int)value;
}

real Truncate(real value, int places)
{
  return Truncate(value, places, 10);
}

real Truncate(real value, int places, int base)
{
  real scale = std::pow(real(base), places);
  return Truncate(value / scale) * scale;
}

real Fractional(real val)
{
  real signedFrac = val - Truncate(val);
  return Abs(signedFrac);
}

real Ceil(real value)
{
  return std::ceil(value);
}

real Ceil(real value, int places)
{
  return Ceil(value, places, 10);
}

real Ceil(real value, int places, int base)
{
  real scale = std::pow(real(base), places);
  return Ceil(value / scale) * scale;
}

real Floor(real value)
{
  return std::floor(value);
}

real Floor(real value, int places)
{
  return Floor(value, places, 10);
}

real Floor(real value, int places, int base)
{
  real scale = std::pow(real(base), places);
  return Floor(value / scale) * scale;
}

real Step(real y, real x)
{
  return (x >= y) ? real(1.0) : real(0.0);
}

int CountBits(int value)
{
  uint count = 0;
  //trick that is O(k) where k is the number of bits set
  while(value != 0)
  {
    value = (value - 1) & value;
    ++count;
  }
  return count;
}

}// namespace Math

///
///  \file Vector2.cpp
///  Implementation of the Vector 2 structure.
///
///  Authors: Joshua Davis, Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////





namespace Math
{

const Vector2 Vector2::cZero(real(0.0), real(0.0));
const Vector2 Vector2::cXAxis(real(1.0), real(0.0));
const Vector2 Vector2::cYAxis(real(0.0), real(1.0));
const Vector2 Vector2::Axes[] = {Vector2::cXAxis, Vector2::cYAxis};


Vector2::Vector2(real x_, real y_)
{
  x = x_;
  y = y_;
}

Vector2::Vector2(real xy)
{
  x = xy;
  y = xy;
}

Vector2::Vector2(ConstRealPointer data)
{
  array[0] = data[0];
  array[1] = data[1];
}

real& Vector2::operator[](uint index)
{
  ErrorIf(index > 1, "Math::Vector2 - Subscript out of range.");
  return array[index];
}

real Vector2::operator[](uint index) const
{
  ErrorIf(index > 1, "Math::Vector2 - Subscript out of range.");
  return array[index];
}


////////// Unary Operators /////////////////////////////////////////////////////

Vector2 Vector2::operator-(void) const
{
  return Vector2(-x, -y);
}


////////// Binary Assignment Operators (reals) /////////////////////////////////

void Vector2::operator*=(real rhs)
{
  x *= rhs;
  y *= rhs;
}

void Vector2::operator/=(real rhs)
{
  ErrorIf(Math::IsZero(rhs), "Math::Vector2 - Division by zero.");
  x /= rhs;
  y /= rhs;
}


////////// Binary Operators (reals) ////////////////////////////////////////////

Vector2 Vector2::operator*(real rhs) const
{
  return Vector2(x * rhs, y * rhs);
}

Vector2 Vector2::operator/(real rhs) const
{
  ErrorIf(Math::IsZero(rhs), "Math::Vector2 - Division by zero.");
  return Vector2(x / rhs, y / rhs);
}


////////// Binary Assignment Operators (Vectors) ///////////////////////////////

void Vector2::operator+=(Vec2Param rhs)
{
  x += rhs.x;
  y += rhs.y;
}

void Vector2::operator-=(Vec2Param rhs)
{
  x -= rhs.x;
  y -= rhs.y;
}


////////// Binary Operators (Vectors) //////////////////////////////////////////

Vector2 Vector2::operator+(Vec2Param rhs) const
{
  return Vector2(x + rhs.x, y + rhs.y);
}

Vector2 Vector2::operator-(Vec2Param rhs) const
{
  return Vector2(x - rhs.x, y - rhs.y);
}


////////// Binary Vector Comparisons ///////////////////////////////////////////

bool Vector2::operator==(Vec2Param rhs) const
{
  return Equal(x, rhs.x) &&
         Equal(y, rhs.y);
}

bool Vector2::operator!=(Vec2Param rhs) const
{
  return !(*this == rhs);
}

BoolVec2 Vector2::operator< (Vec2Param rhs) const
{
  return BoolVec2(x < rhs.x,
                  y < rhs.y);
}

BoolVec2 Vector2::operator<=(Vec2Param rhs) const
{
  return BoolVec2(x <= rhs.x,
                  y <= rhs.y);
}

BoolVec2 Vector2::operator> (Vec2Param rhs) const
{
  return BoolVec2(x > rhs.x,
                  y > rhs.y);
}

BoolVec2 Vector2::operator>=(Vec2Param rhs) const
{
  return BoolVec2(x >= rhs.x,
                  y >= rhs.y);
}

void Vector2::Set(real x_, real y_)
{
  x = x_;
  y = y_;
}

void Vector2::ZeroOut(void)
{
  array[0] = real(0.0);
  array[1] = real(0.0);
}

Vector2 Vector2::Reflect(Vec2Param rhs) const
{
  Vector2 reflect = rhs;
          reflect *= (*this).Dot(rhs);
          reflect *= real(2.0);
          reflect -= *this;
  return reflect;
}

Vector2 Vector2::ProjectOnVector(Vec2Param normalizedVector) const
{
  return GenericProjectOnVector(*this, normalizedVector);
}

Vector2 Vector2::ProjectOnPlane(Vec2Param planeNormal) const
{
  return GenericProjectOnPlane(*this, planeNormal);
}

Vector2 Vector2::ReflectAcrossVector(Vec2Param normalizedVector) const
{
  return GenericReflectAcrossVector(*this, normalizedVector);
}

Vector2 Vector2::ReflectAcrossPlane(Vec2Param planeNormal) const
{
  return GenericReflectAcrossPlane(*this, planeNormal);
}

Vector2 Vector2::Refract(Vec2Param planeNormal, real refractionIndex) const
{
  return GenericRefract(*this, planeNormal, refractionIndex);
}

void Vector2::AddScaledVector(Vec2Param vector, real scalar)
{
  x += vector.x * scalar;
  y += vector.y * scalar;
}

real Vector2::Dot(Vec2Param rhs) const
{
  return x * rhs.x + y * rhs.y;
}

Vector2 Vector2::operator/(Vec2Param rhs) const
{
  ErrorIf(rhs.x == real(0.0) || rhs.y == real(0.0),
          "Vector2 - Division by zero.");
  return Vector2(x / rhs.x, y / rhs.y);
}

void Vector2::operator*=(Vec2Param rhs)
{
  x *= rhs.x;
  y *= rhs.y;
}

void Vector2::operator/=(Vec2Param rhs)
{
  x /= rhs.x;
  y /= rhs.y;
}

Vector2 Vector2::operator*(Vec2Param rhs) const
{
  return Vector2(x * rhs.x, y * rhs.y);
}

real Vector2::Length(void) const
{
  return Sqrt(LengthSq());
}

real Vector2::LengthSq(void) const
{
  return Dot(*this);
}

Vector2 Vector2::Normalized(void) const
{
  Vector2 ret = *this;
  ret /= Length();
  return ret;
}

real Vector2::Normalize(void)
{
  real length = Length();
  *this /= length;
  return length;
}

real Vector2::AttemptNormalize(void)
{
  real lengthSq = LengthSq();
  if(Math::IsZero(lengthSq) == false)
  {
    lengthSq = Sqrt(lengthSq);
    *this /= lengthSq;
  }
  return lengthSq;
}

Vec2Ref Vector2::Negate(void)
{
  (*this) *= real(-1.0);
  return *this;
}

bool Vector2::Valid(void) const
{
  return IsValid(x) && IsValid(y);
}

void Vector2::Splat(real value)
{
  x = y = value;
}

Vector2 operator*(real lhs, Vec2Param rhs)
{
  return rhs * lhs;
}

real Distance(Vec2Param lhs, Vec2Param rhs)
{
  return (rhs - lhs).Length();
}

real Dot(Vec2Param lhs, Vec2Param rhs)
{
  return lhs.Dot(rhs);
}

real Cross(Vec2Param lhs, Vec2Param rhs)
{
  return lhs.x * rhs.y - rhs.x * lhs.y;
}

real Length(Vec2Param vect)
{
  return vect.Length();
}

real LengthSq(Vec2Param vect)
{
  return vect.LengthSq();
}

Vector2 Normalized(Vec2Param vect)
{
  return vect.Normalized();
}

real Normalize(Vec2Ptr vect)
{
  ErrorIf(vect == NULL, "Vector2 - Null pointer passed for vector.");
  return vect->Normalize();
}

real AttemptNormalize(Vec2Ptr vect)
{
  ErrorIf(vect == NULL, "Vector2 - Null pointer passed for vector.");
  return vect->AttemptNormalize();
}

void Negate(Vec2Ptr vec)
{
  ErrorIf(vec == NULL, "Vector2 - Null pointer passed for vector.");
  *vec *= real(-1.0);
}

Vector2 Negated(Vec2Param vec)
{
  return Vector2(-vec.x, -vec.y);
}

Vector2 Abs(Vec2Param vec)
{
  return Vector2(Math::Abs(vec.x), Math::Abs(vec.y));
}

Vector2 Min(Vec2Param lhs, Vec2Param rhs)
{
  return Vector2(Math::Min(lhs.x, rhs.x),
                 Math::Min(lhs.y, rhs.y));
}

Vector2 Max(Vec2Param lhs, Vec2Param rhs)
{
  return Vector2(Math::Max(lhs.x, rhs.x),
                 Math::Max(lhs.y, rhs.y));
}

Vector2 Lerp(Vec2Param start, Vec2Param end, real tValue)
{
  WarnIf(!Math::InRange(tValue, real(0.0), real(1.0)),
         "Vector2 - Interpolation value is not in the range of [0, 1]");
  return Vector2(start[0] + tValue * (end[0] - start[0]),
                 start[1] + tValue * (end[1] - start[1]));
}

void Clamp(Vec2Ptr vec, real min, real max)
{
  ErrorIf(vec == NULL, "Null pointer passed into function.");
  vec->x = Math::Clamp(vec->x, min, max);
  vec->y = Math::Clamp(vec->y, min, max);
}

Vector2 DebugClamp(Vec2Param vec, real min, real max, bool& wasClamped)
{
  Vector2 result;
  bool xClamped,yClamped;
  result.x = DebugClamp(vec.x,min,max,xClamped);
  result.y = DebugClamp(vec.y,min,max,yClamped);
  wasClamped = xClamped || yClamped;
  return result;
}

Vector2 GetBisector(Vec2Param v0, Vec2Param v1)
{
  // Get the perpendicular of each vector
  Vector2 perp0 = Vector2(v0.y, -v0.x);
  Vector2 perp1 = Vector2(v1.y, -v1.x);

  AttemptNormalize(&perp0);
  AttemptNormalize(&perp1);

  Vector2 dir = (perp0 + perp1) * 0.5f;
  return Normalized(dir);
}

Vector2 GetPerpendicular(Vec2Param vec)
{
  return Vector2(vec.y, -vec.x);
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector3.cpp
/// Implementation of the Vector 3 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Math
{

const Vector3 Vector3::cZero(real(0.0), real(0.0), real(0.0));
const Vector3 Vector3::cXAxis(real(1.0), real(0.0), real(0.0));
const Vector3 Vector3::cYAxis(real(0.0), real(1.0), real(0.0));
const Vector3 Vector3::cZAxis(real(0.0), real(0.0), real(1.0));
const Vector3 Vector3::Axes[] = {Vector3::cXAxis, Vector3::cYAxis, Vector3::cZAxis};

Vector3::Vector3(real xx, real yy, real zz)
{
  x = xx;
  y = yy;
  z = zz;
}

Vector3::Vector3(real xyz)
{
  x = xyz;
  y = xyz;
  z = xyz;
}

Vector3::Vector3(Vec2Param rhs, real zz)
{
  x = rhs.x;
  y = rhs.y;
  z = zz;
}

Vector3::Vector3(ConstRealPointer data)
{
  array[0] = data[0];
  array[1] = data[1];
  array[2] = data[2];
}

real& Vector3::operator[](uint index)
{
  ErrorIf(index > 2, "Math::Vector3 - Subscript out of range.");
  return array[index];
}

real Vector3::operator[](uint index) const
{
  ErrorIf(index > 2, "Math::Vector3 - Subscript out of range.");
  return array[index];
}

//---------------------------------------------------- Binary Vector Comparisons
bool Vector3::operator==(Vec3Param rhs) const
{
  return Math::Equal(x, rhs.x) &&
         Math::Equal(y, rhs.y) &&
         Math::Equal(z, rhs.z);
}

bool Vector3::operator!=(Vec3Param rhs) const
{
  return !(*this == rhs);
}

BoolVec3 Vector3::operator< (Vec3Param rhs) const
{
  return BoolVec3(x < rhs.x,
                  y < rhs.y,
                  z < rhs.z);
}

BoolVec3 Vector3::operator<=(Vec3Param rhs) const
{
  return BoolVec3(x <= rhs.x,
                  y <= rhs.y,
                  z <= rhs.z);
}

BoolVec3 Vector3::operator> (Vec3Param rhs) const
{
  return BoolVec3(x > rhs.x,
                  y > rhs.y,
                  z > rhs.z);
}

BoolVec3 Vector3::operator>=(Vec3Param rhs) const
{
  return BoolVec3(x >= rhs.x,
                  y >= rhs.y,
                  z >= rhs.z);
}


void Vector3::Set(real x_, real y_, real z_)
{
  x = x_;
  y = y_;
  z = z_;
}

void Vector3::Splat(real xyz)
{
  x = y = z = xyz;
}

void Vector3::ScaleByVector(Vec3Param rhs)
{
  x *= rhs.x;
  y *= rhs.y;
  z *= rhs.z;
}

void Vector3::ZeroOut(void)
{
  array[0] = real(0.0);
  array[1] = real(0.0);
  array[2] = real(0.0);
}

void Vector3::AddScaledVector(Vec3Param vector, real scalar)
{
  x += vector.x * scalar;
  y += vector.y * scalar;
  z += vector.z * scalar;
}

Vector3 Vector3::ProjectOnVector(Vec3Param normalizedVector) const
{
  return GenericProjectOnVector(*this, normalizedVector);
}

Vector3 Vector3::ProjectOnPlane(Vec3Param planeNormal) const
{
  return GenericProjectOnPlane(*this, planeNormal);
}

Vector3 Vector3::ReflectAcrossVector(Vec3Param normalizedVector) const
{
  return GenericReflectAcrossVector(*this, normalizedVector);
}

Vector3 Vector3::ReflectAcrossPlane(Vec3Param planeNormal) const
{
  return GenericReflectAcrossPlane(*this, planeNormal);
}

Vector3 Vector3::Refract(Vec3Param planeNormal, real refractionIndex) const
{
  return GenericRefract(*this, planeNormal, refractionIndex);
}

real Vector3::Length(void) const
{
  return Sqrt(LengthSq());
}

real Vector3::LengthSq(void) const
{
  return Dot(*this);
}

Vector3 Vector3::Normalized(void) const
{
  Vector3 ret = *this;;
  ret /= Length();
  return ret;
}

real Vector3::Normalize()
{
  real length = Length();
  *this /= length;
  return length;
}

void Vector3::Ceil(void)
{
  x = Math::Ceil(x);
  y = Math::Ceil(y);
  z = Math::Ceil(z);
}

void Vector3::Floor(void)
{
  x = Math::Floor(x);
  y = Math::Floor(y);
  z = Math::Floor(z);
}

void Vector3::Truncate(void)
{
  x = real(int(x));
  y = real(int(y));
  z = real(int(z));
}

void Vector3::RoundToExtremes()
{
  x = (x > 0) ? Math::Ceil(x) : Math::Floor(x);
  y = (y > 0) ? Math::Ceil(y) : Math::Floor(y);
  z = (z > 0) ? Math::Ceil(z) : Math::Floor(z);
}

void Vector3::Round(void)
{
  x = Math::Round(x);
  y = Math::Round(y);
  z = Math::Round(z);
}

real Vector3::AttemptNormalize(void)
{
  real lengthSq = LengthSq();

  //Although the squared length may not be zero, the sqrt of a small number
  //may be truncated to zero, causing a divide by zero crash.  This is why
  //we check to make sure that it is larger than our epsilon squared.
  if(lengthSq >= Epsilon() * Epsilon())
  {
    lengthSq = Sqrt(lengthSq);
    *this /= lengthSq;
  }
  return lengthSq;
}

Vector3 Vector3::AttemptNormalized() const
{
  Vector3 result = *this;
  result.AttemptNormalize();
  return result;
}

Vec3Ref Vector3::Negate(void)
{
  (*this) *= real(-1.0);
  return *this;
}

bool Vector3::Valid(void) const
{
  return IsValid(x) && IsValid(y) && IsValid(z);
}

Vector3 Vector3::Cross(Vec3Param rhs) const
{
  Vector3 ret;
  ret.x = y * rhs.z - z * rhs.y;
  ret.y = z * rhs.x - x * rhs.z;
  ret.z = x * rhs.y - y * rhs.x;
  return ret;
}

void Vector3::InvertComponents(void)
{
  x = real(1.0) / x;
  y = real(1.0) / y;
  z = real(1.0) / z;
}

//------------------------------------------------------------- Global Functions
Vector3 operator*(real lhs, Vec3Param rhs)
{
  return rhs * lhs;
}

bool Equal(Vec3Param lhs, Vec3Param rhs, real epsilon)
{
  return Math::Equal(lhs.x, rhs.x, epsilon) &&
         Math::Equal(lhs.y, rhs.y, epsilon) &&
         Math::Equal(lhs.z, rhs.z, epsilon);
}

real Distance(Vec3Param lhs, Vec3Param rhs)
{
  return Length(rhs - lhs);
}

Vector3 ScaledByVector(Vec3Param lhs, Vec3Param rhs)
{
  return lhs * rhs;
}

Vector3 DividedByVector(Vec3Param lhs, Vec3Param rhs)
{
  return lhs / rhs;
}

real Length(Vec3Param vect)
{
  return vect.Length();
}

real LengthSq(Vec3Param vect)
{
  return vect.LengthSq();
}

Vector3 Normalized(Vec3Param vect)
{
  return vect.Normalized();
}

real Normalize(Vec3Ptr vect)
{
  ErrorIf(vect == NULL, "Vector3 - Null pointer passed for vector.");
  return vect->Normalize();
}

real AttemptNormalize(Vec3Ptr vect)
{
  ErrorIf(vect == NULL, "Vector3 - Null pointer passed for vector.");
  return vect->AttemptNormalize();
}

Vector3 Cross(Vec3Param lhs, Vec3Param rhs)
{
  return lhs.Cross(rhs);
}

Vector3 Cross2d(Vec3Param lhs, Vec3Param rhs)
{
  Vector3 result = Vector3::cZero;
  result.z = lhs.x * rhs.y - rhs.x * lhs.y;
  return result;
}

void ZeroOut(Vec3Ptr vec)
{
  ErrorIf(vec == NULL, "Vector3 - Null pointer passed for vector.");
  vec->ZeroOut();
}

void Negate(Vec3Ptr vec)
{
  ErrorIf(vec == NULL, "Vector3 - Null pointer passed for vector.");
  *vec *= real(-1.0);
}

Vector3 Negated(Vec3Param vec)
{
  return Vector3(-vec.x, -vec.y, -vec.z);
}

Vector3 Abs(Vec3Param vec)
{
  return Vector3(Math::Abs(vec.x), Math::Abs(vec.y), Math::Abs(vec.z));
}

Vector3 Min(Vec3Param lhs, Vec3Param rhs)
{
  return Vector3(Math::Min(lhs.x, rhs.x),
                 Math::Min(lhs.y, rhs.y),
                 Math::Min(lhs.z, rhs.z));
}

Vector3 Max(Vec3Param lhs, Vec3Param rhs)
{
  return Vector3(Math::Max(lhs.x, rhs.x),
                 Math::Max(lhs.y, rhs.y),
                 Math::Max(lhs.z, rhs.z));
}

Vector3 Lerp(Vec3Param start, Vec3Param end, real tValue)
{
  return Vector3(start[0] + tValue * (end[0] - start[0]),
                 start[1] + tValue * (end[1] - start[1]),
                 start[2] + tValue * (end[2] - start[2]));
}

void Clamp(Vec3Ptr vec, real min, real max)
{
  ErrorIf(vec == NULL, "Vector3 - Null pointer passed for vector.");
  vec->x = Math::Clamp(vec->x, min, max);
  vec->y = Math::Clamp(vec->y, min, max);
  vec->z = Math::Clamp(vec->z, min, max);
}

Vector3 Clamped(Vec3Param vec, real min, real max)
{
  Vector3 results;
  results[0] = Math::Clamp(vec[0], min, max);
  results[1] = Math::Clamp(vec[1], min, max);
  results[2] = Math::Clamp(vec[2], min, max);
  return results;
}

Vector3 DebugClamp(Vec3Param vec, real min, real max, bool& wasClamped)
{
  Vector3 result;
  bool xClamped,yClamped,zClamped;
  result.x = DebugClamp(vec.x,min,max,xClamped);
  result.y = DebugClamp(vec.y,min,max,yClamped);
  result.z = DebugClamp(vec.z,min,max,zClamped);
  wasClamped = xClamped || yClamped || zClamped;
  return result;
}

bool AllLess(Vec3Param lhs, Vec3Param rhs)
{
  return (lhs.x < rhs.x && lhs.y < rhs.y && lhs.z < rhs.z);
}

bool AnyLess(Vec3Param lhs, Vec3Param rhs)
{
  return (lhs.x < rhs.x || lhs.y < rhs.y || lhs.z < rhs.z);
}

bool AllGreater(Vec3Param lhs, Vec3Param rhs)
{
  return (lhs.x > rhs.x && lhs.y > rhs.y && lhs.z > rhs.z);
}

bool AnyGreater(Vec3Param lhs, Vec3Param rhs)
{
  return (lhs.x > rhs.x || lhs.y > rhs.y || lhs.z > rhs.z);
}

real DistanceToLineSq(Vec3Param start, Vec3Param end, Vec3Param point)
{
  // describes the line segment
  Vec3 d = end - start;
  Vec3 n = d.AttemptNormalized();
  // vector from the point to the start of the line
  Vec3 ptoa = start - point;
  // project the point onto the line segment d
  Vec3 proj = ptoa.Dot(n) * n;
  // check to see if the projected point is before start on the line
  if (n.Dot(proj) > 0)
  {
    return ptoa.LengthSq();
  }
  // check to see if the projected point is after end on the line
  if (proj.LengthSq() > d.LengthSq())
  {
    // proj is passed the end so we subtract the length of d
    // since proj is relative to start
    return ptoa.LengthSq() - d.LengthSq();
  }
  // otherwise the projected point is within the line segment d
  return (ptoa - proj).LengthSq();
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector4.cpp
/// Implementation of the Vector 4 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////





namespace Math
{

const Vector4 Vector4::cZero(real(0.0), real(0.0), real(0.0), real(0.0));
const Vector4 Vector4::cXAxis(real(1.0), real(0.0), real(0.0), real(0.0));
const Vector4 Vector4::cYAxis(real(0.0), real(1.0), real(0.0), real(0.0));
const Vector4 Vector4::cZAxis(real(0.0), real(0.0), real(1.0), real(0.0));
const Vector4 Vector4::cWAxis(real(0.0), real(0.0), real(0.0), real(1.0));
const Vector4 Vector4::Axes[] = {Vector4::cXAxis, Vector4::cYAxis, Vector4::cZAxis, Vector4::cWAxis};


Vector4::Vector4(real x_, real y_, real z_, real w_)
{
  x = x_;
  y = y_;
  z = z_;
  w = w_;
}

Vector4::Vector4(ConstRealPointer data)
{
  array[0] = data[0];
  array[1] = data[1];
  array[2] = data[2];
  array[3] = data[3];
}

Vector4::Vector4(real xyzw)
{
  x = y = z = w = xyzw;
}

real& Vector4::operator[](uint index)
{
  ErrorIf(index > 3, "Math::Vector4 - Subscript out of range.");
  return array[index];
}

real Vector4::operator[](uint index) const
{
  ErrorIf(index > 3, "Math::Vector4 - Subscript out of range.");
  return array[index];
}


////////// Unary Operators /////////////////////////////////////////////////////

Vector4 Vector4::operator-(void) const
{
  return Vector4(-x, -y, -z, -w);
}


////////// Binary Assignment Operators (reals) /////////////////////////////////

void Vector4::operator*=(real rhs)
{
  x *= rhs;
  y *= rhs;
  z *= rhs;
  w *= rhs;
}

void Vector4::operator/=(real rhs)
{
  ErrorIf(Math::IsZero(rhs), "Math::Vector4 - Division by zero.");
  x /= rhs;
  y /= rhs;
  z /= rhs;
  w /= rhs;
}


////////// Binary Operators (reals) ////////////////////////////////////////////

Vector4 Vector4::operator*(real rhs) const
{
  return Vector4(x * rhs, y * rhs, z * rhs, w * rhs);
}

Vector4 Vector4::operator/(real rhs) const
{
  ErrorIf(Math::IsZero(rhs), "Math::Vector4 - Division by zero.");
  return Vector4(x / rhs, y / rhs, z / rhs, w / rhs);
}


////////// Binary Assignment Operator (Vectors) ////////////////////////////////

void Vector4::operator+=(Vec4Param rhs)
{
  x += rhs.x;
  y += rhs.y;
  z += rhs.z;
  w += rhs.w;
}

void Vector4::operator-=(Vec4Param rhs)
{
  x -= rhs.x;
  y -= rhs.y;
  z -= rhs.z;
  w -= rhs.w;
}

void Vector4::operator*=(Vec4Param rhs)
{
  x *= rhs.x;
  y *= rhs.y;
  z *= rhs.z;
  w *= rhs.w;
}

void Vector4::operator/=(Vec4Param rhs)
{
  x /= rhs.x;
  y /= rhs.y;
  z /= rhs.z;
  w /= rhs.w;
}

////////// Binary Operators (Vectors) //////////////////////////////////////////

Vector4 Vector4::operator+(Vec4Param rhs) const
{
  return Vector4(x + rhs.x, y + rhs.y, z + rhs.z, w + rhs.w);
}

Vector4 Vector4::operator-(Vec4Param rhs) const
{
  return Vector4(x - rhs.x, y - rhs.y, z - rhs.z, w - rhs.w);
}


///////// Binary Vector Comparisons ////////////////////////////////////////////

bool Vector4::operator==(Vec4Param rhs) const
{
  return Equal(x, rhs.x) && 
         Equal(y, rhs.y) && 
         Equal(z, rhs.z) &&
         Equal(w, rhs.w);
}

bool Vector4::operator!=(Vec4Param rhs) const
{
  return !(*this == rhs);
}


BoolVec4 Vector4::operator< (Vec4Param rhs) const
{
  return BoolVec4(x < rhs.x,
                  y < rhs.y,
                  z < rhs.z,
                  w < rhs.w);
}

BoolVec4 Vector4::operator<=(Vec4Param rhs) const
{
  return BoolVec4(x <= rhs.x,
                  y <= rhs.y,
                  z <= rhs.z,
                  w <= rhs.w);
}

BoolVec4 Vector4::operator> (Vec4Param rhs) const
{
  return BoolVec4(x > rhs.x,
                  y > rhs.y,
                  z > rhs.z,
                  w > rhs.w);
}

BoolVec4 Vector4::operator>=(Vec4Param rhs) const
{
  return BoolVec4(x >= rhs.x,
                  y >= rhs.y,
                  z >= rhs.z,
                  w >= rhs.w);
}


void Vector4::Set(real x_, real y_, real z_, real w_)
{
  x = x_;
  y = y_;
  z = z_;
  w = w_;
}

void Vector4::Splat(real xyzw)
{
  x = y = z = w = xyzw;
}

//Do a component-wise scaling of this vector with the given vector.
void Vector4::ScaleByVector(Vec4Param rhs)
{
  *this *= rhs;
}

Vector4 Vector4::ScaledByVector(Vec4Param rhs) const
{
  return *this * rhs;
}

Vector4 Vector4::operator*(Vec4Param rhs) const
{
  return Vector4(x * rhs.x, y * rhs.y, z * rhs.z, w * rhs.w);
}

Vector4 Vector4::operator/(Vec4Param rhs) const
{
  ErrorIf(rhs.x == real(0.0) || rhs.y == real(0.0) || 
          rhs.z == real(0.0) || rhs.w == real(0.0),
          "Vector4 - Division by Zero.");
  return Vector4(x / rhs.x, y / rhs.y, z / rhs.z, w / rhs.w);
}


void Vector4::ZeroOut(void)
{
  array[0] = real(0.0);
  array[1] = real(0.0);
  array[2] = real(0.0);
  array[3] = real(0.0);
}

void Vector4::AddScaledVector(Vec4Param vector, real scalar)
{
  x += vector.x * scalar;
  y += vector.y * scalar;
  z += vector.z * scalar;
  w += vector.w * scalar;
}

real Vector4::Dot(Vec4Param rhs) const
{
  return x * rhs.x + y * rhs.y + z * rhs.z + w * rhs.w;
}

real Vector4::Length(void) const
{
  return Sqrt(LengthSq());
}

real Vector4::LengthSq(void) const
{
  return Dot(*this);
}

Vector4 Vector4::Normalized(void) const
{
  Vector4 ret = *this;
  ret /= Length();
  return ret;
}

real Vector4::Normalize(void)
{
  real length = Length();
  *this /= length;
  return length;
}

real Vector4::AttemptNormalize(void)
{
  real lengthSq = LengthSq();
  if(Math::IsZero(lengthSq) == false)
  {
    lengthSq = Sqrt(lengthSq);
    *this /= lengthSq;
  }
  return lengthSq;
}

Vec4Ref Vector4::Negate(void)
{
  (*this) *= real(-1.0);
  return *this;
}

bool Vector4::Valid(void) const
{
  return IsValid(x) && IsValid(y) && IsValid(z) && IsValid(w);
}

Vector4 Vector4::ProjectOnVector(Vec4Param normalizedVector) const
{
  return GenericProjectOnVector(*this, normalizedVector);
}

Vector4 Vector4::ProjectOnPlane(Vec4Param planeNormal) const
{
  return GenericProjectOnPlane(*this, planeNormal);
}

Vector4 Vector4::ReflectAcrossPlane(Vec4Param planeNormal) const
{
  return GenericReflectAcrossPlane(*this, planeNormal);
}

Vector4 Vector4::ReflectAcrossVector(Vec4Param normalizedVector) const
{
  return GenericReflectAcrossVector(*this, normalizedVector);
}

Vector4 Vector4::Refract(Vec4Param planeNormal, real refractionIndex) const
{
  return GenericRefract(*this, planeNormal, refractionIndex);
}

Vector4 operator*(real lhs, Vec4Param rhs)
{
  return rhs * lhs;
}

real Dot(Vec4Param lhs, Vec4Param rhs)
{
  return lhs.Dot(rhs);
}

real Length(Vec4Param vect)
{
  return vect.Length();
}

real LengthSq(Vec4Param vect)
{
  return vect.LengthSq();
}

Vector4 Normalized(Vec4Param vect)
{
  return vect.Normalized();
}

real Normalize(Vec4Ptr vect)
{
  ErrorIf(vect == NULL, "Vector4 - Null pointer passed for vector.");
  return vect->Normalize();
}

real AttemptNormalize(Vec4Ptr vect)
{
  ErrorIf(vect == NULL, "Vector4 - Null pointer passed for vector.");
  return vect->AttemptNormalize();
}

void Negate(Vec4Ptr vec)
{
  ErrorIf(vec == NULL, "Vector4 - Null pointer passed for vector.");
  *vec *= real(-1.0);
}

Vector4 Negated(Vec4Param vec)
{
  return Vector4(-vec.x, -vec.y, -vec.z, -vec.w);
}

Vector4 Abs(Vec4Param vec)
{
  return Vector4(Math::Abs(vec.x), Math::Abs(vec.y), 
                 Math::Abs(vec.z), Math::Abs(vec.w));
}

Vector4 Min(Vec4Param lhs, Vec4Param rhs)
{
  return Vector4(Math::Min(lhs.x, rhs.x),
                 Math::Min(lhs.y, rhs.y),
                 Math::Min(lhs.z, rhs.z),
                 Math::Min(lhs.w, rhs.w));
}

Vector4 Max(Vec4Param lhs, Vec4Param rhs)
{
  return Vector4(Math::Max(lhs.x, rhs.x),
                 Math::Max(lhs.y, rhs.y),
                 Math::Max(lhs.z, rhs.z),
                 Math::Max(lhs.w, rhs.w));
}

Vector4 Clamped(Vec4Param vec, real min, real max)
{
  Vector4 results;
  results[0] = Math::Clamp(vec[0], min, max);
  results[1] = Math::Clamp(vec[1], min, max);
  results[2] = Math::Clamp(vec[2], min, max);
  results[3] = Math::Clamp(vec[3], min, max);
  return results;
}

Vector4 Lerp(Vec4Param start, Vec4Param end, real tValue)
{
  return Vector4(start[0] + tValue * (end[0] - start[0]),
                 start[1] + tValue * (end[1] - start[1]),
                 start[2] + tValue * (end[2] - start[2]),
                 start[3] + tValue * (end[3] - start[3]));
}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Claeys
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////






namespace Zero
{

// How long we consider a file as modified (in seconds)
const float cSecondsModified = 0.5f;
const float cCleanTime = 20.0f;
const TimeType cFileIsOpen = 1;

//-------------------------------------------------------------- File Save State
FileModifiedState mInstance;

//******************************************************************************
FileModifiedState::FileModifiedState()
{
  mLastCleanup = Time::Clock();

}
//******************************************************************************
bool FileModifiedState::HasModifiedRecently(StringParam filePath)
{
  return HasModifiedSinceTime(filePath, Time::Clock());
}

//******************************************************************************
bool FileModifiedState::HasModifiedSinceTime(StringParam filePath, TimeType time)
{
  FileModifiedState* instance = GetInstance();
  instance->mThreadLock.Lock();

  String normalizedPath = FilePath::Normalize(filePath);
  String canonicalPath = CanonicalizePath(normalizedPath);
  String fileId = UniqueFileId(filePath);

  // Prefer the fileId over the file path
  TimeType modifiedTime = instance->mFileLastModified.findValue(fileId, instance->mFileLastModified.findValue(canonicalPath, 0));

  instance->mThreadLock.Unlock();

  float seconds = GetSecondsBetween(modifiedTime, time);
  return (modifiedTime == cFileIsOpen) || (seconds < cSecondsModified);
}

//******************************************************************************
void FileModifiedState::BeginFileModified(StringParam filePath)
{
  FileModifiedState* instance = GetInstance();
  instance->mThreadLock.Lock();

  String normalizedPath = FilePath::Normalize(filePath);
  String canonicalPath = CanonicalizePath(normalizedPath);
  String fileId = UniqueFileId(filePath);

  instance->mFileLastModified.insert(fileId, cFileIsOpen);
  instance->mFileLastModified.insert(canonicalPath, cFileIsOpen);

  instance->mThreadLock.Unlock();
}

//******************************************************************************
void FileModifiedState::EndFileModified(StringParam filePath)
{
  FileModifiedState* instance = GetInstance();
  instance->mThreadLock.Lock();

  TimeType currentTime = Time::Clock();
  
  String normalizedPath = FilePath::Normalize(filePath);
  String canonicalPath = CanonicalizePath(normalizedPath);
  String fileId = UniqueFileId(filePath);

  instance->mFileLastModified.insert(fileId, currentTime);
  instance->mFileLastModified.insert(canonicalPath, currentTime);

  instance->Cleanup(currentTime);

  instance->mThreadLock.Unlock();
}

//******************************************************************************
FileModifiedState* FileModifiedState::GetInstance()
{
  return &mInstance;
}

//******************************************************************************
float FileModifiedState::GetSecondsBetween(TimeType begin, TimeType end)
{
  return (end - begin) / float(Time::ClocksPerSecond());
}

//******************************************************************************
void FileModifiedState::Cleanup(TimeType currentTime)
{
  // Just an optimization so we aren't checking every file every time we save
  float secondsSinceLastCleanup = GetSecondsBetween(mLastCleanup, currentTime);
  if(secondsSinceLastCleanup < cCleanTime)
    return;

  mLastCleanup = currentTime;

  // Attempt to clean up every file
  ModifiedMap::range r = mFileLastModified.all();
  while(!r.empty())
  {
    ModifiedMap::value_type current = r.front();
    String path = current.first;
    TimeType modifiedTime = current.second;
    r.popFront();

    // We still need to check the time of each file because the file could
    // have been saved right before the cleanup time was up
    float seconds = GetSecondsBetween(modifiedTime, currentTime);
    if(seconds > cCleanTime)
      mFileLastModified.erase(path);
  }
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file FilePath.cpp
/// Implementation of the FilePath class.
///
/// Authors: Joshua Davis
/// Copyright 2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////






namespace Zero
{

const char cExtensionDelimiter = '.';

String FilePath::Combine(StringRange path0, StringRange path1)
{
  const StringRange* paths[2];
  paths[0] = &path0;
  paths[1] = &path1;
  return Combine(paths, 2, "");
}

String FilePath::Combine(StringRange path0, StringRange path1, StringRange path2)
{
  const StringRange* paths[3];
  paths[0] = &path0;
  paths[1] = &path1;
  paths[2] = &path2;
  return Combine(paths, 3, "");
}

String FilePath::Combine(StringRange path0, StringRange path1, StringRange path2, StringRange path3)
{
  const StringRange* paths[4];
  paths[0] = &path0;
  paths[1] = &path1;
  paths[2] = &path2;
  paths[3] = &path3;
  return Combine(paths, 4, "");
}

String FilePath::Combine(StringRange path0, StringRange path1, StringRange path2, StringRange path3, StringRange path4)
{
  const StringRange* paths[5];
  paths[0] = &path0;
  paths[1] = &path1;
  paths[2] = &path2;
  paths[3] = &path3;
  paths[4] = &path4;
  return Combine(paths, 5, "");
}

String FilePath::CombineWithExtension(StringRange path, StringRange fileName, StringRange ext)
{
  if(!ext.empty())
    ErrorIf(ext.front() != '.', "CombineWithExtension assumes that the passed in extension has the '.'");

  const StringRange* paths[2];
  paths[0] = &path;
  paths[1] = &fileName;
  return Combine(paths, 2, ext);
}

StringRange FilePath::GetExtension(StringRange path)
{
  return GetPathInfo(path).Extension;
}

StringRange FilePath::GetFileName(StringRange path)
{
  uint dirIndex = path.FindLastOf(cDirectorySeparatorChar);
  if(dirIndex == String::InvalidIndex)
    return path;

  return StringRange(path.begin + dirIndex + 1, path.end);
}

StringRange FilePath::GetFileNameWithoutExtension(StringRange path)
{
  return GetPathInfo(path).FileName;
}

StringRange FilePath::GetDirectoryName(StringRange path)
{
  StringRange directoryPath = GetDirectoryPath(path);

  uint dirIndex = directoryPath.FindLastOf(cDirectorySeparatorChar);
  if(dirIndex == String::InvalidIndex)
    return directoryPath;

  return StringRange(directoryPath.begin + dirIndex + 1, directoryPath.end);
}

StringRange FilePath::GetDirectoryPath(StringRange path)
{
  uint dirIndex = path.FindLastOf(cDirectorySeparatorChar);
  if(dirIndex == String::InvalidIndex)
    return StringRange();

  return path.sub_string(0, dirIndex);
}

String FilePath::Normalize(StringRange path)
{
  uint size = path.size();
  char* buffer = (char*)alloca(size + 1);

  // Copy over path data
  uint outIndex = 0;
  for(uint i = 0; i < path.size();)
  {
    char current = path[i];

    // If it's either slash, use the operating system specific slash
    bool isDirectorySeparator = (current == '/' || current == '\\');
    if(isDirectorySeparator)
      buffer[outIndex] = cDirectorySeparatorChar;
    else
      buffer[outIndex] = current;

    ++outIndex;
    ++i;

    // Skip duplicate separators unless it is at the beginning
    // for network paths
    if(isDirectorySeparator && i != 1)
    {
      while(i < path.size() && (path[i] == '/' || path[i] == '\\'))
        ++i;
    }
  }

  // We strip out trailing separators as well
  // (we can only have 1 at the end due to the normalization part of the code)
  if(outIndex > 0 && buffer[outIndex - 1] == cDirectorySeparatorChar)
    --outIndex;

  // Null terminate
  buffer[outIndex] = '\0';

  return buffer;
}

FilePathInfo FilePath::GetPathInfo(StringRange path)
{
  StringRange fileExt;
  FilePathInfo info;

  //find the directory separator
  uint dirIndex = path.FindLastOf(cDirectorySeparatorChar);
  if(dirIndex != String::InvalidIndex)
  {
    //extract the directory
    info.Folder = path.sub_string(0, dirIndex);
    //what's left is the file and extension
    fileExt = path.sub_string(dirIndex + 1, path.size() - dirIndex - 1);
  }
  else
    fileExt = path;

  //now find the extension separator
  uint extIndex = fileExt.FindLastOf('.');
  if(extIndex != String::InvalidIndex)
  {
    info.FileName = StringRange(fileExt.begin, fileExt.begin + extIndex);
    info.Extension = StringRange(fileExt.begin + extIndex + 1, fileExt.end);
  }
  else
    info.FileName = fileExt;

  return info;
}

String FilePath::Combine(const StringRange** paths, uint count, StringRange extension)
{
  if(count == 0)
    return String();

  //count the total size needed to combine these paths
  size_t pathSize = 0;
  for(uint i = 0; i < count; ++i)
    pathSize += paths[i]->length();
  //just assume that no path has the ending separator,
  //then we need extra space for each / and then one for the null
  pathSize += count;
  //also account for the extension's length (assumed it contains the '.')
  pathSize += extension.length();

  char* stringData = (char*)alloca(pathSize);
  size_t currentIndex = 0;
  for(uint i = 0; i < count - 1; ++i)
  {
    const StringRange& path = *paths[i];

    //if this string was empty, don't do anything (don't add extra slashes or anything weird)
    if(path.empty())
      continue;

    //copy the string over
    size_t length = path.length();
    memcpy(stringData + currentIndex, path.data(), length);

    //check the last character in the string, if it
    //is not a / then put one at the last position
    char* separator = stringData + currentIndex + length - 1;
    if(*separator != cDirectorySeparatorChar)
    {
      *(separator + 1) = cDirectorySeparatorChar;
      length += 1;
    }
    currentIndex += length;
  }

  //copy over the last string, but don't put a slash at the end
  const StringRange& path = *paths[count - 1];
  if(!path.empty())
  {
    size_t length = path.length();
    memcpy(stringData + currentIndex, path.data(), length);
    currentIndex += length;
  }
  //if there's an extension append that as well
  if(!extension.empty())
  {
    size_t length = extension.length();
    memcpy(stringData + currentIndex, extension.data(), length);
    currentIndex += length;
  }

  //add the null terminator
  stringData[currentIndex] = 0;

  return String(stringData, currentIndex);
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////






namespace Zero
{

template <typename Function>
bool TryFileOperation(StringRef dest, StringRef source, Function fileOp)
{
  bool result = false;
  // Keep trying to copy the file until we succeed up to some max number of times.
  // This is attempting to deal with random file locks (from anti-virus or something).
  for(size_t i = 0; i < 10; ++i)
  {
    result = fileOp(dest, source);
    if(result == true)
      break;

    Os::Sleep(1);
  }

  // Maybe log some extra error messages here?
  if(result == false)
  {

  }

  return result;
}

bool CopyFile(StringRef dest, StringRef source)
{
  FileModifiedState::BeginFileModified(dest);
  bool result = TryFileOperation(dest, source, CopyFileInternal);
  FileModifiedState::EndFileModified(dest);
  return result;
}

bool MoveFile(StringRef dest, StringRef source)
{
  FileModifiedState::BeginFileModified(dest);
  bool result = TryFileOperation(dest, source, MoveFileInternal);
  FileModifiedState::EndFileModified(dest);
  return result;
}

bool DeleteFile(StringRef dest)
{
  bool result = false;

  FileModifiedState::BeginFileModified(dest);

  // Keep trying to copy the file until we succeed up to some max number of times.
  // This is attempting to deal with random file locks (from anti-virus or something).
  for(size_t i = 0; i < 10; ++i)
  {
    result = DeleteFileInternal(dest);
    if(result == true)
      break;

    Os::Sleep(1);
  }

  FileModifiedState::EndFileModified(dest);

  // Maybe log some extra error messages here?
  if(result == false)
  {

  }

  return result;
}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean, Trevor Sundberg
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{

//---------------------------------------------------------------------------------//
//                                  IpAddress                                      //
//---------------------------------------------------------------------------------//

/// Constants
const IpAddress IpAddress::Invalid;

/// Updates an IP address' numeric "host:port" string
void UpdateHostPortString(Status& status, IpAddress& ipAddress)
{
  ErrorIf(!ipAddress.IsValid());

  // Get host string
  String host;
  switch(ipAddress.GetInternetProtocol())
  {
  case InternetProtocol::V4:
    host = Ipv4AddressToString(ipAddress);
    break;

  case InternetProtocol::V6:
    host = Ipv6AddressToString(ipAddress);
    break;

  default:
  case InternetProtocol::Unspecified:
    break;
  }
  if(host == String()) // Unable?
  {
    status.SetFailed("Unable to convert IP address host to string");
    return;
  }

  // Get port string
  String port = PortToString(ipAddress.GetPort());
  if(port == String()) // Unable?
  {
    status.SetFailed("Unable to convert IP address host to string");
    return;
  }

  // Concatenate host and port strings
  StringBuilder builder;
  builder.Append(host);
  builder.Append(":");
  builder.Append(port);

  // Update IP address string
  ipAddress.mHostPortString = builder.ToString();
}

IpAddress::IpAddress()
  : SocketAddress(),
    mHostPortString()
{
}

IpAddress::IpAddress(Status& status, StringParam host, uint port, InternetProtocol::Enum internetProtocol)
  : SocketAddress(),
    mHostPortString()
{
  SetHost(status, host, internetProtocol);
  if(status.Succeeded())
    SetPort(status, port);
}
IpAddress::IpAddress(Status& status, StringParam host, uint port)
  : SocketAddress(),
    mHostPortString()
{
  SetHost(status, host, InternetProtocol::Unspecified);
  if(status.Succeeded())
    SetPort(status, port);
}
IpAddress::IpAddress(StringParam host, uint port, InternetProtocol::Enum internetProtocol)
  : SocketAddress(),
    mHostPortString()
{
  Status status;
  SetHost(status, host, internetProtocol);
  if(status.Succeeded())
    SetPort(status, port);
  ErrorIf(status.Failed());
}
IpAddress::IpAddress(StringParam host, uint port)
  : SocketAddress(),
    mHostPortString()
{
  Status status;
  SetHost(status, host, InternetProtocol::Unspecified);
  if(status.Succeeded())
    SetPort(status, port);
  ErrorIf(status.Failed());
}

IpAddress::IpAddress(const IpAddress& rhs)
  : SocketAddress(rhs),
    mHostPortString(rhs.mHostPortString)
{
}
IpAddress::IpAddress(const SocketAddress& rhs)
  : SocketAddress(),
    mHostPortString()
{
  *this = rhs;
}

IpAddress& IpAddress::operator =(const IpAddress& rhs)
{
  SocketAddress::operator=(rhs);
  mHostPortString        = rhs.mHostPortString;

  return *this;
}
IpAddress& IpAddress::operator =(const SocketAddress& rhs)
{
  SocketAddress::operator=(rhs);

  if(IsValid())
  {
    Status status;
    UpdateHostPortString(status, *this);
    ErrorIf(status.Failed());
  }
  else if(!SocketAddress::IsEmpty())
  {
    Error("Not an IPv4 or IPv6 socket address");
    Clear();
  }

  return *this;
}

bool IpAddress::IsValid() const
{
  return !SocketAddress::IsEmpty()
  && (SocketAddress::GetAddressFamily() == SocketAddressFamily::InternetworkV4
   || SocketAddress::GetAddressFamily() == SocketAddressFamily::InternetworkV6);
}

InternetProtocol::Enum IpAddress::GetInternetProtocol() const
{
  switch(SocketAddress::GetAddressFamily())
  {
  case SocketAddressFamily::InternetworkV4:
    return InternetProtocol::V4;
  case SocketAddressFamily::InternetworkV6:
    return InternetProtocol::V6;
  default:
    return InternetProtocol::Unspecified;
  }
}

const String& IpAddress::GetString() const
{
  return mHostPortString;
}
size_t IpAddress::GetHash() const
{
  return mHostPortString.hash();
}

void IpAddress::SetHost(Status& status, StringParam host, InternetProtocol::Enum internetProtocol)
{
  uint port = GetPort();

  switch(internetProtocol)
  {
  case InternetProtocol::V4:
    SocketAddress::SetIpv4(status, host, port);
    break;

  case InternetProtocol::V6:
    SocketAddress::SetIpv6(status, host, port);
    break;

  default:
  case InternetProtocol::Unspecified:
    SocketAddress::SetIpv6(status, host, port);
    if(status.Failed())
    {
      status = Status();
      SocketAddress::SetIpv4(status, host, port);
    }
    break;
  }

  if(IsValid())
    UpdateHostPortString(status, *this);
}
void IpAddress::SetHost(Status& status, StringParam host)
{
  SetHost(status, host, InternetProtocol::Unspecified);
}
void IpAddress::SetHost(StringParam host, InternetProtocol::Enum internetProtocol)
{
  Status status;
  SetHost(status, host, internetProtocol);
  ErrorIf(status.Failed());
}
void IpAddress::SetHost(StringParam host)
{
  Status status;
  SetHost(status, host, InternetProtocol::Unspecified);
  ErrorIf(status.Failed());
}
String IpAddress::GetHost() const
{
  if(!IsValid())
    return String();

  size_t separator = mHostPortString.FindLastOf(":");
  return mHostPortString.sub_string(0, separator);
}

void IpAddress::SetPort(Status& status, uint port)
{
  SocketAddress::SetIpPort(status, port);

  if(IsValid())
    UpdateHostPortString(status, *this);
}
void IpAddress::SetPort(uint port)
{
  Status status;
  SetPort(status, port);
  ErrorIf(status.Failed());
}
uint IpAddress::GetPort() const
{
  if(!IsValid())
    return 0;

  Status status;
  uint result = SocketAddress::GetIpPort(status);
  ErrorIf(status.Failed());
  return result;
}
String IpAddress::GetPortString() const
{
  if(!IsValid())
    return String();

  size_t separator = mHostPortString.FindLastOf(":");
  return mHostPortString.sub_string(separator, mHostPortString.size() - 1);
}

void IpAddress::Clear()
{
  SocketAddress::Clear();
  mHostPortString.clear();
}

Bits Serialize(SerializeDirection::Enum direction, BitStream& bitStream, IpAddress& ipAddress)
{
  // Serialize socket address
  Bits result = Serialize(direction, bitStream, static_cast<SocketAddress&>(ipAddress));

  // Read operation?
  if(direction == SerializeDirection::Read)
  {
    // Update internal host port string
    if(ipAddress.IsValid())
    {
      Status status;
      UpdateHostPortString(status, ipAddress);
      if(status.Failed()) // Unable?
      {
        ipAddress.Clear();
        return 0;
      }
    }
    else
    {
      ipAddress.Clear();
      return 0;
    }
  }

  // Success
  return result;
}

} // namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.cpp
/// Generates the precompiled header file.
/// 
/// Authors: Andrew Colean
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file DebugClassMap.cpp
/// Implementation of the file class for Windows.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.hpp
/// Precompiled header for windows library.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////






#ifdef _MSC_VER
#define ZeroCStringCopy(dest, destSize, source, sourceSize) strncpy_s(dest, (destSize), source, sourceSize);
#else 
#define ZeroCStringCopy(dest, destSize, source, sourceSize) strncpy(dest, source, sourceSize);
#endif

//Include the windows header.

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Windows.hpp
/// Includes Windows Header
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#ifdef ZERO
  #pragma message("Including Windows...")
  #ifdef _WINDOWS_
  #error Windows has already been included!
  #else
  #define STRICT
  #endif
#endif

//Prevent including winsock1.
#define _WINSOCKAPI_

//Only include frequently used elements.
#define WIN32_LEAN_AND_MEAN
#define NOCOMM

//Minimum version is Windows XP.
//#define WINVER 0x0501
//#define _WIN32_WINNT 0x0501

//Prevent MIN ans MAX macros from being defined.
#ifndef NOMINMAX
#define NOMINMAX
#endif

// Get rid of an annoying gcc warning that is incorrect
// (complains about winsock being included after windows, it's not)
#ifndef _MSC_VER
#ifdef _WINSOCKAPI_
#undef _WINSOCKAPI_
#endif
#endif
#include <winsock2.h> // Includes windows.h (we get a warning in gcc otherwise)
#include <Ws2tcpip.h>
#include <Wspiapi.h>
#include <Mmsystem.h>
#include <Regstr.h>
#include <WinBase.h>

//Undef windows defines that overlap with core functions
#undef CopyFile
#undef MoveFile
#undef DeleteFile
#undef CreateDirectory

#endif


#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file WindowsError.hpp
/// Declaration of Windows error handling.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




const uint cMaxErrorMessageSize = 1024;
// Convert a windows error code to a human readable string. If the errorCode
// is zero uses the last error.
uint ToErrorString(char* messageBuffer, uint bufferSize, uint errorCode=0);
// Check success and send error on failure.
uint CheckWindowsErrorCode(uint success, ::cstr format=0, ...);
// Get string from exception code. Unknown will return NULL.
cstr GetWindowsExceptionCode(int exceptionCode);

// Windows Error Macros (always output, even in release, so we get error messages in logs).
#define VerifyWin(expression, ...) do { if(!(expression)) CheckWindowsErrorCode(FALSE, ## __VA_ARGS__); } while(gConditionalFalseConstant)
#define CheckWin(expression, ... ) VerifyWin(expression, ## __VA_ARGS__)

#define WinReturnIf(command, ...) \
{ uint success = command;  if(!success) { VerifyWin(success, ## __VA_ARGS__  ); return (uint)-1; } }


#endif

#include <shellapi.h>
#include <shlwapi.h>
#include <direct.h>
#include <stdlib.h>
#include <stdio.h>
#include <shlobj.h>

#include <new>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <cstdio>

#endif

// Only compile this on the MSVC compiler (not supported by other compilers on Windows)
#ifdef _MSC_VER






// Dbghelp has warnings in VS2015 (unnamed typedef)
#pragma warning(disable : 4091)
#define _NO_CVCONST_H
#include <dbghelp.h>

#pragma comment(lib, "dbghelp.lib")

namespace Zero
{

enum DataKind
{
  DataIsUnknown,
  DataIsLocal,
  DataIsStaticLocal,
  DataIsParam,
  DataIsObjectPtr,
  DataIsFileStatic,
  DataIsGlobal,
  DataIsMember,
  DataIsStaticMember,
  DataIsConstant
};

class TypeModule
{
public:
  UINT mModuleBase;
  HANDLE mProcess;

  TypeModule()
  {
    mModuleBase = 0;
    mProcess = GetCurrentProcess();
  }

  String GetSymbolName(uint classIndex)
  {
    wchar_t* text = L"";
    VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)classIndex, TI_GET_SYMNAME, &text));

    char* asciiText = (char*)alloca(MAX_SYM_NAME);
    ConvertUnicodeToAscii(asciiText, MAX_SYM_NAME, text, wcslen(text));

    return asciiText;
  }

  uint GetDataKind(uint classIndex)
  {
    DWORD dataKind = 0;
    VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)classIndex, TI_GET_DATAKIND, &dataKind));
    return dataKind;
  }

  uint GetTag(uint classIndex)
  {
    DWORD tag = 0;
    SymGetTypeInfo(mProcess, mModuleBase, (ULONG)classIndex, TI_GET_SYMTAG, &tag );
    return tag;
  }

  uint GetOffset(uint index)
  {
    DWORD offset;
    VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_OFFSET, &offset));
    return offset;
  }

  uint GetClassParent(uint index)
  {
    DWORD classIndex = 0; 
    VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_CLASSPARENTID, &classIndex ));
    return classIndex;
  }

  uint GetSize(uint index)
  {
    DWORD size;
    VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_LENGTH, &size ));
    return size;
  }

  uint GetType(uint index)
  {
    DWORD typeId;
    VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_TYPEID, &typeId ));
    return typeId;
  }

  uint GetChildCount(uint index)
  {
    DWORD count;
    VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_CHILDRENCOUNT, &count ));
    return count;
  }
};

struct MemberVariable
{
  FixedString<100> Name;
  uint Offset;
  uint String;
  uint Size;
};

struct ClassMap
{
  ClassMap()
    :IsValid(true)
  {
  }

  FixedString<100> Name;
  bool IsValid;
  uint TypeIndex;
  ClassMap* BaseClass;
  Array<MemberVariable> mVariables;
};

//Class used to clean up class maps.
struct ClassStorage
{
  HashMap<String, ClassMap*> Classes;

  ClassStorage()
  {
    AddInvalid("Zero::LinearAxisJoint");
  }

  void AddInvalid(String fullClassName)
  {
    ClassMap* notFound = new ClassMap();
    notFound->IsValid = false;
    Classes.insert(fullClassName, notFound);
  }

  ~ClassStorage()
  {
    DeleteObjectsInContainer(Classes);
  }
} gClassStorage;


ClassMap* BuildMap(TypeModule& types, uint typeIndex)
{
  String name = types.GetSymbolName(typeIndex);

  ClassMap* classMap = gClassStorage.Classes.findValue(name, NULL);

  //Locally cache the class map of members to avoid constanly
  //have to class api functions.
  if(classMap)
    return classMap;

  classMap = new ClassMap();

  classMap->BaseClass = NULL;

  classMap->TypeIndex = typeIndex;

  gClassStorage.Classes.insert(name, classMap);

  classMap->Name = name;

  DWORD childCount = (DWORD)types.GetChildCount(typeIndex);

  DWORD findChildrenSize = sizeof(TI_FINDCHILDREN_PARAMS) + childCount*sizeof(ULONG); 

  TI_FINDCHILDREN_PARAMS* findChildren = (TI_FINDCHILDREN_PARAMS*)alloca(findChildrenSize); 

  memset( findChildren, 0, findChildrenSize ); 

  findChildren->Count = childCount; 

  VerifyWin(SymGetTypeInfo(types.mProcess, types.mModuleBase, (ULONG)typeIndex, TI_FINDCHILDREN, findChildren));

  for(uint i=0;i<childCount;++i)
  {
    uint childTypeIndex = findChildren->ChildId[i];
    DWORD symTag = (DWORD)types.GetTag(childTypeIndex);

    if(symTag == SymTagBaseClass)
    {
      classMap->BaseClass = BuildMap(types, childTypeIndex);
    }
    else if(symTag == SymTagData)
    {
      uint kind = types.GetDataKind(childTypeIndex);
      String symbolName = types.GetSymbolName(childTypeIndex);

      if(kind == DataIsMember)
      {
        uint offset = types.GetOffset(childTypeIndex);

        uint classType = types.GetType(childTypeIndex);

        uint size = types.GetSize(classType);

        MemberVariable& member = classMap->mVariables.push_back();

        member.Name = symbolName;
        member.Offset = offset;
        member.Size = size;
      }
    }
  }

  return classMap;
}

void Check(TypeModule& typeModule, cstr className, byte* classMemory, uint typeIndex)
{ 

  //Get the class map
  ClassMap* classMap = BuildMap(typeModule, typeIndex);

  //Check all member variables for uninitialized memory
  forRange(MemberVariable& var, classMap->mVariables.all())
  {
    const byte DebugByte = 0xCD;
    bool good = false;
    uint dwords = var.Size;
    for(uint i=0;i<var.Size;++i)
    {
      if(classMemory[var.Offset + i] != DebugByte)
      {
        good = true;
        break;
      }
    }

    if(!good)
    {
      ErrorIf(true, "On Class '%s' member '%s::%s' was not initialized ", className, classMap->Name.c_str(), var.Name.c_str());
    }
  }

  if(classMap->BaseClass)
    Check(typeModule, className, classMemory, classMap->BaseClass->TypeIndex);
}

bool SymbolsLoaded = false;
bool CanScanSymbols = true;

void CheckClassMemory(cstr className, byte* classMemory)
{
  if(!CanScanSymbols)
    return;

  HANDLE process = GetCurrentProcess();

  if(!SymbolsLoaded)
  {
    SymbolsLoaded = true;
    DWORD Options = SymGetOptions(); 

    Options |= SYMOPT_DEBUG & SYMOPT_UNDNAME; 

    SymSetOptions( Options ); 

    UINT moduleBase = 0;

    if( !SymInitialize(process, NULL, TRUE ) )
    {
      return; 
    }
  }

  TypeModule typeModule;

  String fullClassName =  BuildString("Zero::", className);
  String constructorFunc = BuildString(fullClassName, "::", className);
  uint moduleBase = 0;

  uint totalSize = sizeof(SYMBOL_INFO) + (MAX_SYM_NAME - 1) * sizeof(CHAR);
  SYMBOL_INFO* symbolInfo = (SYMBOL_INFO*)alloca(totalSize);
  ZeroMemory(symbolInfo, totalSize);
  symbolInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
  symbolInfo->MaxNameLen = MAX_SYM_NAME;

  ClassMap* classMap =  gClassStorage.Classes.findValue(fullClassName, NULL);

  //Check for invalid class to avoid stalls
  if(classMap && !classMap->IsValid)
  {
    SymCleanup(process);
    return;
  }

  //dbghelp used to by only able to look up functions and data so classes can not be looked up (as far as I know)
  //so look up the class by its constructor. Until this is called the class is not around...
  uint success = SymFromName(process, constructorFunc.c_str(), symbolInfo);

  if(!success)
  {
    gClassStorage.AddInvalid(fullClassName);
    ErrorIf(true, "Could not find class %s. This causes a stall on load.", fullClassName.c_str());
    SymCleanup(process);
    return;
  }

  DWORD typeId = 0;
  BOOL test = SymGetTypeInfo(process, moduleBase, symbolInfo->TypeIndex, TI_GET_TYPE, &typeId);

  //It seems that many versions of dbghelp do not work need to investigate why
  if(!test)
  {
    CanScanSymbols = false;
    SymCleanup(process);
    return;
  }

  //With the index of the construtor use the parent id to find is class id;
  DWORD typeIndex = 0; 
  VerifyWin(SymGetTypeInfo(process, moduleBase, symbolInfo->TypeIndex, TI_GET_CLASSPARENTID, &typeIndex));

  String foundClassName = typeModule.GetSymbolName(typeIndex);
  //Now check the classes memory
  Check(typeModule, className, classMemory, typeIndex);
  SymCleanup(process);
}

}
#endif

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




// Dbghelp has warnings in VS2015 (unnamed typedef)
#pragma warning(disable : 4091)
#ifdef _MSC_VER
#include <dbghelp.h>

#pragma comment(lib, "dbghelp.lib")

namespace Zero
{

void GetSymbolInfo(OsInt processHandle, SymbolInfo& symbolInfo)
{
  HANDLE process = (HANDLE)processHandle;

  //fill in all the junk needed for a SYMBOL_INFO structure
  ULONG64 buffer[(sizeof(SYMBOL_INFO) +
    MAX_SYM_NAME * sizeof(TCHAR) +
    sizeof(ULONG64) - 1) /
    sizeof(ULONG64)] = { 0 };
  PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;
  pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
  pSymbol->MaxNameLen = MAX_SYM_NAME;
  //needed so that the line number functions doesn't freak
  DWORD  dwDisplacement;

  IMAGEHLP_LINE line = { 0 };
  line.SizeOfStruct = sizeof(IMAGEHLP_LINE);

  DWORD64 returnAddress = reinterpret_cast<DWORD64>(symbolInfo.mAddress);

  //(these functions annoy me....)
  //get the line from the saved address
  SymGetLineFromAddr(process, static_cast<DWORD>(returnAddress), &dwDisplacement, &line);

  //get the symbol from the address
  SymFromAddr(process, returnAddress, 0, pSymbol);

  // Get the module information
  HMODULE hmodule = NULL;
  ::GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, reinterpret_cast<LPCTSTR>(symbolInfo.mAddress), &hmodule);
  char modulePath[MAX_PATH];
  GetModuleFileName(hmodule, modulePath, MAX_PATH);

  symbolInfo.mLineNumber = line.LineNumber;
  symbolInfo.mSymbolName = pSymbol->Name;
  // The file name could be unknown so check to make sure it's not null
  if(line.FileName != nullptr)
    symbolInfo.mFileName = line.FileName;

  // Get the symbol name by splitting the path (find last '\' and last '.' and take what's in-between)
  symbolInfo.mModulePath = modulePath;
  size_t index = symbolInfo.mModulePath.FindLastOf("\\");
  if(index < symbolInfo.mModulePath.size())
    symbolInfo.mModuleName = symbolInfo.mModulePath.sub_string(index + 1, symbolInfo.mModulePath.size() - index - 1);

  index = symbolInfo.mModuleName.FindLastOf(".");
  if(index < symbolInfo.mModuleName.size())
    symbolInfo.mModuleName = symbolInfo.mModuleName.sub_string(0, index);
}

void SimpleStackWalker::ShowCallstack(void* context, StringParam extraSymbolPaths, int stacksToSkip)
{
  HANDLE process = GetCurrentProcess();
  SymInitialize(process, extraSymbolPaths.c_str(), TRUE);

  // We were not handed a context to walk, capture the current callstack
  if(context == nullptr)
  {
    const int maxStacks = 150;
    void *stacks[maxStacks];
    // This function fills out function pointers for the current stack
    size_t capturedStacks = CaptureStackBackTrace(stacksToSkip, maxStacks, stacks, 0);

    for(size_t i = 0; i < capturedStacks; ++i)
    {
      SymbolInfo symbolInfo;
      symbolInfo.mAddress = stacks[i];
      // Generate the symbol information for each stack entry
      GetSymbolInfo((OsInt)process, symbolInfo);
      
      AddSymbolInformation(symbolInfo);
    }
  }
  // We had a context (most likely from a crash). Unfortunately, there's no super easy way to use
  // CaptureStackBackTrace which is a much nicer function than StalkWalk64.
  // This is a bit hacky but oh-well...
  else
  {
    PCONTEXT pcontext = (PCONTEXT)context;

    STACKFRAME64 stackFrame;
    ZeroMemory(&stackFrame, sizeof(stackFrame));
#if PLATFORM_64
    stackFrame.AddrPC.Offset = pcontext->Rip;
    stackFrame.AddrFrame.Offset = pcontext->Rbp;
    stackFrame.AddrStack.Offset = pcontext->Rsp;
#else
    stackFrame.AddrPC.Offset = pcontext->Eip;
    stackFrame.AddrFrame.Offset = pcontext->Ebp;
    stackFrame.AddrStack.Offset = pcontext->Esp;
#endif
    stackFrame.AddrPC.Mode = AddrModeFlat;
    stackFrame.AddrFrame.Mode = AddrModeFlat;
    stackFrame.AddrStack.Mode = AddrModeFlat;

    int imageType;
#ifdef _M_IX86
    imageType = IMAGE_FILE_MACHINE_I386;
#elif _M_X64
    imageType = IMAGE_FILE_MACHINE_AMD64;
#elif _M_IA64
    imageType = IMAGE_FILE_MACHINE_IA64;
#endif

    while(1)
    {
      int i = 0;
      // Use stackwalk64 to iterate through frames. This modifies stackFrame.AddrPC.Offset each time.
      if(StackWalk64(imageType, process, GetCurrentThread(), &stackFrame, pcontext, NULL, SymFunctionTableAccess64, SymGetModuleBase64, NULL))
      {
        // Skip all of the requested frames
        if(i < stacksToSkip)
          continue;

        ++i;
        SymbolInfo symbolInfo;
        symbolInfo.mAddress = (void*)stackFrame.AddrPC.Offset;
        GetSymbolInfo((OsInt)process, symbolInfo);

        AddSymbolInformation(symbolInfo);
      }
      // We failed to get a stack frame, we must be done
      else
        break;
    }
  }

  // Make sure to clean up!!! (bad things can happen otherwise)
  SymCleanup(process);
}

void SimpleStackWalker::AddSymbolInformation(SymbolInfo& symbolInfo)
{
  if(symbolInfo.mFileName.empty())
  {
    mBuilder.Append(String::Format("%X (%s): (filename not available): %s\n", symbolInfo.mAddress, symbolInfo.mModuleName.c_str(), symbolInfo.mSymbolName.c_str()));
  }
  else
  {
    mBuilder.Append(String::Format("%s (%d): %s\n", symbolInfo.mFileName.c_str(), symbolInfo.mLineNumber, symbolInfo.mSymbolName.c_str()));
  }
}

String SimpleStackWalker::GetFinalOutput()
{
  return mBuilder.ToString();
}

}//namespace Zero

// For non microsoft on windows just stub for now
#else

namespace Zero
{

void GetSymbolInfo(OsInt processHandle, SymbolInfo& symbolInfo)
{
}

void SimpleStackWalker::ShowCallstack(void* context, StringParam extraSymbolPaths, int stacksToSkip)
{
}

void SimpleStackWalker::AddSymbolInformation(SymbolInfo& symbolInfo)
{
}

String SimpleStackWalker::GetFinalOutput()
{
  return String();
}

}//namespace Zero

#endif

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Chris Peters, Joshua Claeys
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadIo.hpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


namespace Zero
{

//Io control structure is used to control
//Overlapped blocking IO. This is a unified
//way of waiting for both the terminate event.
//and for the operation to be complete.
struct IoControl
{
  OVERLAPPED IoOverlap;
  OsHandle TerminateEvent;
  OsHandle IoCompletedEvent;
};

inline void InitIoControl(IoControl& ioControl, OsEvent& terminateEvent)
{
  //Zero the structure
  ZeroMemory(&ioControl,  sizeof(IoControl));
  //Create the event used to signal that the overlapped io is complete.
  ioControl.IoCompletedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
  ioControl.IoOverlap.hEvent = ioControl.IoCompletedEvent;
  //Store the terminate event
  ioControl.TerminateEvent = terminateEvent.GetHandle();
}

inline OVERLAPPED* IoGetOverlap(IoControl& ioControl)
{
  return &ioControl.IoOverlap;
}

inline void IoReset(IoControl& ioControl)
{
  ResetEvent(ioControl.IoCompletedEvent);
}

inline void CleanUpIoControl(IoControl& ioControl)
{
  CloseHandle(ioControl.IoCompletedEvent);
}

const OsInt IoFinished = WAIT_OBJECT_0;
const OsInt IoTerminated = WAIT_OBJECT_0+1;

inline OsInt WaitForIoCompletion(IoControl& ioControl)
{
  OsHandle events[2] = {ioControl.IoOverlap.hEvent, ioControl.TerminateEvent};
  return WaitForMultipleObjects(2, events, FALSE, INFINITE);
}

}//namespace Zero

#endif


namespace Zero
{

DirectoryWatcher::DirectoryWatcher(cstr directoryToWatch, CallbackFunction callback, void* callbackInstance)
{
  ZeroCStringCopy(mDirectoryToWatch, File::MaxPath, directoryToWatch, strlen(directoryToWatch));

  mCallbackInstance = callbackInstance;
  mCallback = callback;

  mWorkThread.Initialize(Thread::ObjectEntryCreator<DirectoryWatcher, &DirectoryWatcher::RunThreadEntryPoint>, this, "DirectoryWatcherWorker");
  mWorkThread.Resume();
  mCancelEvent.Initialize(true, false);
}

DirectoryWatcher::~DirectoryWatcher()
{
  Shutdown();
}

void DirectoryWatcher::Shutdown()
{
  mCancelEvent.Signal();
  mWorkThread.WaitForCompletion();
}

OsInt DirectoryWatcher::RunThreadEntryPoint()
{
  //Do not prevent others from using the directory.
  const OsInt shareAll = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

  //Create a directory handle which in windows is done with CreateFile
  //FILE_LIST_DIRECTORY is an access right required for ReadDirectoryChangesW to operate.
  //FILE_FLAG_OVERLAPPED is required to use overlaps with the handle.
  //FILE_FLAG_BACKUP_SEMANTICS is required to create a directory handle.
  const OsInt flags = FILE_FLAG_OVERLAPPED |FILE_FLAG_BACKUP_SEMANTICS;

  //Create the directory handle
  OsHandle dirHandle = CreateFileA(mDirectoryToWatch, FILE_LIST_DIRECTORY, shareAll, NULL, OPEN_EXISTING,  flags, NULL);
  CheckWin(dirHandle!=INVALID_HANDLE_VALUE,"Failed to create directory handle.");
  if(dirHandle==INVALID_HANDLE_VALUE)
    return (OsInt)-1;

  //4k buffer for directory events.
  const OsInt cBufferSize = 1024 * 4;
  byte fileNotifyBuffer[cBufferSize];

  //Create Io control so the directory watcher can be canceled.
  IoControl readDir;
  InitIoControl(readDir, mCancelEvent);

  //Loop until cancel
  for(;;)
  {
    OsInt bytesReturned = 0;

    //Looking for file updates, additions, and removal.
    OsInt filterFlags = FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_LAST_WRITE;

    ReadDirectoryChangesW(dirHandle, fileNotifyBuffer, cBufferSize, TRUE,  filterFlags,  &bytesReturned, IoGetOverlap(readDir), NULL);
    OsInt result = WaitForIoCompletion(readDir);

    if(result == IoFinished)
    {
      //Overlapped Io has finished process events.
      OsInt overlapResult = GetOverlappedResult(dirHandle, IoGetOverlap(readDir), &bytesReturned, TRUE);

      //Iterate through the directory event buffer.
      byte* buffer = (byte*)fileNotifyBuffer;

      String lastRename;

      for(;;)
      {
        const OsInt cFileNameBufferSize = MAX_PATH;
        char asciFilename[cFileNameBufferSize];
        FILE_NOTIFY_INFORMATION& notify = *(FILE_NOTIFY_INFORMATION*)buffer;

        // FileNameLength is in bytes so divide by size of WCHAR
        uint characterLength = notify.FileNameLength / sizeof(WCHAR);
        WideCharToMultiByte(CP_ACP, 0, notify.FileName, notify.FileNameLength, asciFilename, cFileNameBufferSize, "?", NULL);

        FileOperationInfo info;
        info.FileName = String(asciFilename, characterLength);

        switch(notify.Action)
        {
        case FILE_ACTION_ADDED:
          info.Operation = Added;
          (*mCallback)(mCallbackInstance, info);
          break;
        case FILE_ACTION_REMOVED:
          info.Operation = Removed;
          (*mCallback)(mCallbackInstance, info);
          break;
        case FILE_ACTION_MODIFIED:
          info.Operation = Modified;
          (*mCallback)(mCallbackInstance, info);
          break;
        case FILE_ACTION_RENAMED_OLD_NAME:
          lastRename = info.FileName;
          break;
        case FILE_ACTION_RENAMED_NEW_NAME:
          ErrorIf(lastRename.empty(), "We didn't get an old name event.");
          info.Operation = Modified;
          info.OldFileName = lastRename;
          (*mCallback)(mCallbackInstance, info);
          break;
        }

        if(notify.NextEntryOffset ==0)
        {
          //No more entries in this read.
          break;
        }
        else
        {
          //Move to the next file notification. FILE_NOTIFY_INFORMATION can be variably size
          //due to the filename so the stride between structures is given with the field NextEntryOffset.
          //When the size is zero it is the last message.
          buffer = buffer + notify.NextEntryOffset;
        }
      }
    }
    else if(result == IoTerminated)
    {
      CancelIo(dirHandle);
      CloseHandle(dirHandle);
      CleanUpIoControl(readDir);
      return 0;//Exit the thread
    }
  }
}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ExternalLibrary.cpp
/// Implementation of the ExternalLibrary class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

ExternalLibrary::ExternalLibrary()
{
  mHandle = NULL;
  mUnloadOnDestruction = true;
}

ExternalLibrary::~ExternalLibrary()
{
  if(mUnloadOnDestruction)
    Unload();
}

bool ExternalLibrary::IsValid()
{
  return mHandle != NULL;
}

void ExternalLibrary::Load(cstr filePath)
{
  mHandle = (void*)LoadLibraryA(filePath);
}

void ExternalLibrary::Unload()
{
  if(mHandle == NULL)
    return;
  FreeLibrary((HMODULE)mHandle);
  mHandle = NULL;
}

void* ExternalLibrary::GetFunctionByName(cstr name)
{
  ReturnIf(mHandle == NULL, NULL, "Attempting to get a function from an invalid library");

  return (void*)GetProcAddress((HMODULE)mHandle, name);
}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file File.cpp
/// Implementation of the file class for Windows.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////






namespace Zero
{
const int File::PlatformMaxPath = MAX_PATH;

struct FilePrivateData
{
  HANDLE mHandle;
  long long mFileSize;
};

const DWORD FILE_NO_SHARING = 0;
SECURITY_ATTRIBUTES* NOSECURITY = NULL;

cstr cBadFileMessage = "The file is missing, not in that location, or is protected.";

DataBlock ReadFileIntoDataBlock(cstr path)
{
  DataBlock block;
  block.Data = ReadFileIntoMemory(path, block.Size, 0);
  return block;
}

byte * ReadFileIntoMemory(cstr filePath, size_t& fileSize, size_t extra)
{
  HANDLE fileHandle = ::CreateFileA(filePath, GENERIC_READ, FILE_SHARE_READ, 
                                    NOSECURITY, OPEN_EXISTING, 0, 0);
  
  CheckWin(fileHandle != INVALID_HANDLE_VALUE, "Failed to open file %s.", filePath);

  ReturnIf(fileHandle == INVALID_HANDLE_VALUE, NULL, 
           "Failed to open file '%s'. %s", filePath, cBadFileMessage);

  DWORD fileSizeInBytes = ::GetFileSize(fileHandle, NULL);
  byte* fileBuffer = (byte*)zAllocate(fileSizeInBytes+extra);
  if (fileBuffer == NULL)
  {
    ErrorIf(fileBuffer == NULL, 
            "Could not allocate enough memory for file '%s' into memory.", 
            filePath); 

    delete fileBuffer;
    ::CloseHandle(fileHandle);
    return NULL;
  }
  else
  {
    fileSize = fileSizeInBytes;
    DWORD bytesRead;
    BOOL readResult = ::ReadFile(fileHandle, fileBuffer, (DWORD)fileSize, 
                                 &bytesRead, NULL);
    ErrorIf(!readResult, "Could not Read file '%s'.", filePath); 
  }
  ::CloseHandle(fileHandle);
  return fileBuffer;
}

size_t WriteToFile(cstr filePath, byte * pData, size_t bufferSize)
{
  HANDLE fileHandle = ::CreateFileA(filePath, GENERIC_WRITE, FILE_NO_SHARING,
                                    NOSECURITY, CREATE_ALWAYS, 0, 0); 
  ReturnIf(fileHandle == INVALID_HANDLE_VALUE, 0, "Failed to open destination "
           "file '%s'. %s", filePath, cBadFileMessage);

  FileModifiedState::BeginFileModified(filePath);

  DWORD bytesWritten = 0;
  BOOL writeResult = WriteFile(fileHandle, pData, (DWORD)bufferSize,
                               &bytesWritten, 0);
  ::CloseHandle(fileHandle);

  FileModifiedState::EndFileModified(filePath);

  ReturnIf(writeResult == 0, 0, "Failed to write to destination file '%s'.", 
           filePath);

  return bufferSize;
}

DWORD ToWindowsFileMode(FileMode::Enum mode)
{
  switch(mode)
  {
    case FileMode::Read:
      return GENERIC_READ;

    case FileMode::Append:
    case FileMode::Write: 
      return GENERIC_WRITE;
  
    case FileMode::ReadWrite:
      return GENERIC_READ | GENERIC_WRITE;
  }
  return 0;
}

//Convert File Relative position to windows constant
DWORD ToWindowsRelative(FileOrigin::Enum relative)
{
  switch(relative)
  {
    case FileOrigin::Begin:
      return FILE_BEGIN;

    case FileOrigin::End: 
      return FILE_END;

    case FileOrigin::Current:
      return FILE_CURRENT;
  }
  return FILE_CURRENT;
}

DWORD ToWindowsDisposition(FileMode::Enum mode, FileAccessPattern::Enum pattern)
{
  DWORD disposition = 0;
  if(mode == FileMode::Write)
    disposition = CREATE_ALWAYS;
  else if(mode == FileMode::Append)
    disposition = OPEN_ALWAYS;
  else
    disposition = OPEN_EXISTING;
  return disposition;
}

DWORD ToWindowsFlags(FileMode::Enum mode, FileAccessPattern::Enum pattern)
{
  DWORD flags = 0;
  if(pattern == FileAccessPattern::Sequential)
    flags |= FILE_FLAG_SEQUENTIAL_SCAN;
  else
    flags |= FILE_FLAG_RANDOM_ACCESS;

  return flags;
}

//------------------------------------------------------------------------- File
File::File()
{
  ZeroConstructPrivateData(FilePrivateData);
  self->mHandle = INVALID_HANDLE_VALUE;
  self->mFileSize = -1;
  mFileMode = FileMode::Read;
}

File::~File()
{
  Close();
  ZeroDestructPrivateData(FilePrivateData);
}

size_t File::Size()
{
  ZeroGetPrivateData(FilePrivateData);
  return (size_t)self->mFileSize;
}

long long File::CurrentFileSize()
{
  ZeroGetPrivateData(FilePrivateData);
  // This should be upgraded to support 64 bit file sizes
  LARGE_INTEGER size;
  size.QuadPart = -1;
  ::GetFileSizeEx(self->mHandle, &size);
  return size.QuadPart;
}

bool File::Open(StringParam filePath, FileMode::Enum mode, FileAccessPattern::Enum accessPattern, FileShare::Enum share, Status* status)
{
  ZeroGetPrivateData(FilePrivateData);

  DWORD fileMode = ToWindowsFileMode(mode);
  DWORD flags = ToWindowsFlags(mode, accessPattern);
  DWORD disposition = ToWindowsDisposition(mode, accessPattern);
  DWORD sharingMode = FILE_NO_SHARING;

  if (share & FileShare::Unspecified)
  {
    if(mode == FileMode::Read)
      sharingMode = FILE_SHARE_READ;
  }
  else
  {
    if (share & FileShare::Read)
      sharingMode |= FILE_SHARE_READ;
    if (share & FileShare::Write)
      sharingMode |= FILE_SHARE_WRITE;
    if (share & FileShare::Delete)
      sharingMode |= FILE_SHARE_DELETE;
  }

  self->mHandle = ::CreateFileA(filePath.c_str(), fileMode, sharingMode, NOSECURITY, disposition,
                         flags, NULL);

  if(status == nullptr)
  {
    CheckWin(self->mHandle != INVALID_HANDLE_VALUE, "Failed to open file %s.", filePath.c_str());

    ReturnIf(self->mHandle == INVALID_HANDLE_VALUE, false, 
             "Failed to open file '%s'. %s", filePath.c_str(), cBadFileMessage);
  }
  else if(self->mHandle == INVALID_HANDLE_VALUE)
  {
    char buffer[2048] = {0};
    ToErrorString(buffer, sizeof(buffer));
    status->SetFailed(buffer, GetLastError());
    return false;
  }

  self->mFileSize = CurrentFileSize();
  mFilePath = filePath;

  if(mode == FileMode::Append)
    Seek(self->mFileSize);

  mFileMode = mode;
  if(mode != FileMode::Read)
    FileModifiedState::BeginFileModified(mFilePath);

  return true;
}

bool File::IsOpen()
{
  ZeroGetPrivateData(FilePrivateData);
  return self->mHandle != INVALID_HANDLE_VALUE;
}

void File::Close()
{
  ZeroGetPrivateData(FilePrivateData);
  if(self->mHandle != INVALID_HANDLE_VALUE)
  {
    if(mFileMode != FileMode::Read)
      FileModifiedState::EndFileModified(mFilePath);
    CloseHandle(self->mHandle);
    self->mHandle = INVALID_HANDLE_VALUE;
  }
}

FilePosition File::Tell()
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");

  LARGE_INTEGER move;
  move.QuadPart = 0;

  LARGE_INTEGER newPosition;
  BOOL success = SetFilePointerEx(self->mHandle, move,  &newPosition, FILE_CURRENT);

  return newPosition.QuadPart;
}

bool File::Seek(FilePosition pos, FileOrigin::Enum rel)
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");
  LARGE_INTEGER move;
  move.QuadPart = pos;

  uint winRel = ToWindowsRelative(rel);

  LARGE_INTEGER newPosition;
  BOOL success = SetFilePointerEx(self->mHandle, move,  &newPosition, winRel);
  return (success != 0);
}

size_t File::Write(byte* data, size_t sizeInBytes)
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");
  DWORD bytesWritten = 0;
  WriteFile(self->mHandle, data, sizeInBytes, &bytesWritten, NULL);
  return bytesWritten;
}

size_t File::Read(byte* data, size_t sizeInBytes)
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");
  DWORD bytesRead = 0;
  ReadFile(self->mHandle, data, sizeInBytes, &bytesRead, NULL);
  return bytesRead;
}

void File::Flush()
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");
  FlushFileBuffers(self->mHandle);
}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FileOperations.cpp
/// Implementation of the file system functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////









#pragma comment(lib, "Shell32.lib")
#pragma comment(lib, "Shlwapi.lib")

namespace Zero
{
const char  cDirectorySeparatorChar = '\\';
const char* cDirectorySeparatorCstr = "\\";
bool cFileSystemCaseInsensitive = true;

void InitFileSystem()
{

}

void ShutdownFileSystem()
{

}

String GetWorkingDirectory()
{
  char temp[MAX_PATH+1];
  _getcwd(temp, MAX_PATH);
  ZeroStrCat(temp, MAX_PATH+1, cDirectorySeparatorCstr);
  return String(temp);
}

void SetWorkingDirectory(String path)
{
  _chdir(path.c_str());
}

String GetUserLocalDirectory()
{
  char temp[MAX_PATH+1];
  SHGetSpecialFolderPath(NULL, temp, CSIDL_LOCAL_APPDATA, FALSE);
  return String(temp);
}

String GetUserDocumentsDirectory()
{
  char temp[MAX_PATH+1];
  SHGetSpecialFolderPath(NULL, temp, CSIDL_PERSONAL, FALSE);
  return String(temp);
}

String GetApplicationDirectory()
{
  char temp[MAX_PATH+1];
  GetModuleFileName(NULL, temp, MAX_PATH);
  String fileName = String(temp);

  ///FIX ME LATER!!!
  //return Zero::FilePath::GetDirectoryPath(fileName);
  uint dirIndex = fileName.FindLastOf(cDirectorySeparatorChar);
  if(dirIndex == String::InvalidIndex)
    return StringRange();

  return fileName.sub_string(0, dirIndex);
}

String GetApplication()
{
  char temp[MAX_PATH+1];
  GetModuleFileName(NULL, temp, MAX_PATH);
  return temp;
}

String GetTemporaryDirectory()
{
  char tempPath[MAX_PATH];
  GetTempPath(MAX_PATH, tempPath);
  return tempPath;
}

bool FileExists(StringRef filePath)
{
  DWORD attributes = GetFileAttributes(filePath.c_str());
  return (attributes!=INVALID_FILE_ATTRIBUTES);
}

bool FileWritable(StringRef filePath)
{
  DWORD attributes = GetFileAttributes(filePath.c_str());
  if(attributes == INVALID_FILE_ATTRIBUTES)
    return false;
  else
    return !(attributes & FILE_ATTRIBUTE_READONLY);
}

bool DirectoryExists(StringRef filePath)
{
  DWORD attributes = GetFileAttributes(filePath.c_str());
  return (attributes != INVALID_FILE_ATTRIBUTES);
}

bool IsDirectory(StringRef filePath)
{
  DWORD attributes = GetFileAttributes(filePath.c_str());
  return (attributes & FILE_ATTRIBUTE_DIRECTORY)!=0;
}

String CanonicalizePath(StringRef directoryPath)
{
  char buffer[MAX_PATH];
  if (PathCanonicalize(buffer, directoryPath.c_str()))
    return buffer;
  else
    return directoryPath;
}

void CreateDirectory(StringRef dest)
{
  BOOL success = ::CreateDirectoryA(dest.c_str(), NULL);
  if(!success)
  {
    DWORD lastErr = GetLastError();
    if(lastErr != ERROR_ALREADY_EXISTS)
      VerifyWin(success, "Failed to create the directory '%s'.", dest.c_str());
  }
}

void CreateDirectoryAndParents(StringRef directory)
{
  char directoryPath[MAX_PATH];
  ZeroStrCpy(directoryPath, MAX_PATH, directory.c_str());
  uint size = directory.size();

  for(uint c = 0; c < size; ++c)
  {
    //When there is a directory separator
    if(directoryPath[c] == cDirectorySeparatorChar)
    {
      //Null terminate
      directoryPath[c] = '\0';
      //Create directory
      ::CreateDirectoryA(directoryPath, NULL);
      //remove null terminator
      directoryPath[c] = cDirectorySeparatorChar;
    }
  }

  //directories no longer have a trailing '/' so we have to
  //explicitly create the final directory
  CreateDirectory(directory);
}

bool CopyFileInternal(StringRef dest, StringRef source)
{
  BOOL success = ::CopyFileA(source.c_str(), dest.c_str(), FALSE);
  VerifyWin(success, "Failed to copy file. %s to %s.", source.c_str(), dest.c_str());
  return success!=0;
}

bool MoveFileInternal(StringRef dest, StringRef source)
{
  BOOL success = ::MoveFileEx(source.c_str(), dest.c_str(), MOVEFILE_REPLACE_EXISTING);
  VerifyWin(success, "Failed to move file. %s to %s.", source.c_str(), dest.c_str());
  return success!=0;
}

bool DeleteFileInternal(StringRef file)
{
  BOOL success = ::DeleteFileA(file.c_str());
  VerifyWin(success, "Failed to delete file %s.", file.c_str());
  return success!=0;
}

bool DeleteDirectory(StringRef directory)
{
  FileRange range(directory);
  for(; !range.empty(); range.popFront())
  {
    String name = range.front();
    String fullName = BuildString(directory, cDirectorySeparatorCstr, name);
    if(IsDirectory(fullName))
      DeleteDirectory(fullName);
    else
      DeleteFile(fullName);
  }

  //this is the only part that needs to be updated platform specific
  BOOL success = ::RemoveDirectoryA(directory.c_str());
  VerifyWin(success, "Failed to delete directory %s.", directory.c_str());
  return success != 0;
}

TimeType SystemTimeToTimeType(SYSTEMTIME& systemTime)
{
  //Build a TimeType using mktime and systemTime
  tm newTime;
  memset(&newTime, 0, sizeof(tm));
  //tm_year is based at 1900
  newTime.tm_year = systemTime.wYear - 1900;
  //tm_mday is zero based
  newTime.tm_mon = systemTime.wMonth - 1;
  newTime.tm_mday = systemTime.wDay;
  newTime.tm_hour = systemTime.wHour;
  newTime.tm_min = systemTime.wMinute;
  newTime.tm_sec = systemTime.wSecond;
  return mktime(&newTime);
}

TimeType GetFileModifiedTime(StringRef filename)
{
  WIN32_FILE_ATTRIBUTE_DATA fileInfo;
  BOOL success = GetFileAttributesEx(filename.c_str(), GetFileExInfoStandard, (void*)&fileInfo);
  CheckWin(success, "Failed to get GetFileAttributesEx.");

  // Convert to system time so the time can be parsed
  SYSTEMTIME modifiedSystemTime;
  FileTimeToSystemTime(&fileInfo.ftLastWriteTime, &modifiedSystemTime);

  // Convert and return
  return SystemTimeToTimeType(modifiedSystemTime);
}

int SetFileToCurrentTime(StringRef filename)
{
  // Need a file handle to do file time operations
  StackHandle sourceFile;
  sourceFile = CreateFile(filename.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL,
                           OPEN_EXISTING, 0, NULL);

  FILETIME fileTime;
  SYSTEMTIME systemTime;
  BOOL result;

  // Gets the current system time
  GetSystemTime(&systemTime); 
  // Converts the current system time to file time format
  SystemTimeToFileTime(&systemTime, &fileTime);

  // Sets last-write time of the file 
  // to the converted current system time 
  result = SetFileTime(sourceFile,
    (LPFILETIME) NULL, 
    (LPFILETIME) NULL, 
    &fileTime);

  VerifyWin(result, "Failed to set file time.");

  return result;
}

u32 GetFileSize(StringRef fileName)
{
  WIN32_FILE_ATTRIBUTE_DATA fileInfo;
  BOOL success = GetFileAttributesEx(fileName.c_str(), GetFileExInfoStandard, (void*)&fileInfo);
  CheckWin(success, "Failed to get GetFileAttributesEx.");
  if(!success)
    return 0;
  return (u32)fileInfo.nFileSizeLow;
}

int CheckFileTime(StringRef dest, StringRef source)
{
  // Source should always exist
  WIN32_FILE_ATTRIBUTE_DATA sourceInfo;
  BOOL success = GetFileAttributesEx(source.c_str(), GetFileExInfoStandard, (void*)&sourceInfo);
  // If their was some error still return dest is older
  if(!success) return -1;

  WIN32_FILE_ATTRIBUTE_DATA destInfo;
  success = GetFileAttributesEx(dest.c_str(), GetFileExInfoStandard, (void*)&destInfo);
  // If dest does not exist it is older
  if(!success) return -1;

  // Do file time comparison
  int result = CompareFileTime(&destInfo.ftLastWriteTime, &sourceInfo.ftLastWriteTime);

  return result;
}

bool GetFileDateTime(StringParam filePath, CalendarDateTime& result)
{
  if(!FileExists(filePath))
    return false;

  //get the file time
  WIN32_FILE_ATTRIBUTE_DATA sourceInfo;
  BOOL success = GetFileAttributesEx(filePath.c_str(), GetFileExInfoStandard, (void*)&sourceInfo);

  //convert that to the system time (which has the year, months, day, etc...)
  SYSTEMTIME systemTime;
  FileTimeToSystemTime(&sourceInfo.ftLastWriteTime, &systemTime);

  //gotta convert to the local time zone (should really convert to pacific time, but it's too much work)
  SYSTEMTIME localSystemTime;
  SystemTimeToTzSpecificLocalTime(NULL, &systemTime, &localSystemTime);

  result.Year = localSystemTime.wYear;
  result.Month = localSystemTime.wMonth;
  result.Day = localSystemTime.wDay;
  result.Hour = localSystemTime.wHour;
  result.Minutes = localSystemTime.wMinute;
  result.Seconds = localSystemTime.wSecond;
  
  return true;
}

struct FileRangePrivateData
{
  cstr mCurrent;
  HANDLE mHandle;
  WIN32_FIND_DATA mFindData;
};


FileRange::FileRange(StringRef filePath)
{
  ZeroConstructPrivateData(FileRangePrivateData);
  mPath = filePath;
  if(mPath.empty())
  {
    Error("Cannot create a file range from an empty directory/path string (working directory as empty string not supported)");
    self->mHandle = NULL;
    return;
  }

  // Copy String into temporary
  uint size = mPath.size();
  char path[MAX_PATH];
  ZeroCStringCopy(path, MAX_PATH, mPath.c_str(), mPath.size());

  // Check for trailing slash and add if not there
  if(path[size-1] != '\\')
    ZeroStrCat(path, MAX_PATH, "\\");

  // Add the wildcard to get all files in directory
  ZeroStrCat(path, MAX_PATH, "*");

  // Begin Windows file iteration
  self->mHandle = FindFirstFile(path, &self->mFindData);

  if(self->mHandle == INVALID_HANDLE_VALUE)
  {
    self->mHandle = NULL;
  }
  else
  {
    //Skip rid of "." and ".." directory results.
    if(strcmp(self->mFindData.cFileName,".") == 0)
      this->popFront();
    if(self->mHandle && strcmp(self->mFindData.cFileName,"..") == 0)
      this->popFront();
  }
}

FileRange::~FileRange()
{
  ZeroGetPrivateData(FileRangePrivateData);

  if(self->mHandle)
    FindClose(self->mHandle);

  ZeroDestructPrivateData(FileRangePrivateData);
}

bool FileRange::empty()
{
  ZeroGetPrivateData(FileRangePrivateData);
  return self->mHandle==NULL;
}

cstr FileRange::front()
{
  ZeroGetPrivateData(FileRangePrivateData);
  return self->mFindData.cFileName;
}

FileEntry FileRange::frontEntry()
{
  ZeroGetPrivateData(FileRangePrivateData);

  LARGE_INTEGER largeInt;
  largeInt.LowPart = self->mFindData.nFileSizeLow;
  largeInt.HighPart = self->mFindData.nFileSizeHigh;

  FileEntry entry;
  entry.mFileName = self->mFindData.cFileName;
  entry.mSize = largeInt.QuadPart;
  entry.mPath = mPath;
  return entry;
}

void FileRange::popFront()
{
  ZeroGetPrivateData(FileRangePrivateData);
  BOOL hasNext = FindNextFile(self->mHandle, &self->mFindData);

  if(!hasNext)
  {
    // No more files
    FindClose(self->mHandle);
    self->mHandle = NULL;
  }
}

String UniqueFileId(StringRef fullpath)
{
#ifdef FILE_NAME_NORMALIZED
  StackHandle fileHandle;

  fileHandle = CreateFile(fullpath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL,
    OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

  if(fileHandle == INVALID_HANDLE_VALUE)
  {
    //no file just return path.
    return fullpath;
  }

  char fixedFullPath[MAX_PATH+1] = {0};
  DWORD size = GetFinalPathNameByHandle(fileHandle, fixedFullPath, MAX_PATH, FILE_NAME_NORMALIZED);

  if(size == 0)
    return fullpath;

  return fixedFullPath;
#else
  return fullpath;
#endif
}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FpControl.hpp
/// Implementation of the ScpeFpuExceptions, ScoplessFpuExceptions and
/// FpuControlSystem classes.
///
/// Authors: Joshua Davis
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#include <float.h>

namespace Zero
{

// If this is the Microsoft compiler
#ifdef _MSC_VER

///by default, we want all of the fpu exceptions apart from inexact
///(inexact happens in lots of odd places...) and underflow
uint FpuControlSystem::DefaultMask = _EM_INEXACT | _EM_UNDERFLOW;
///Stores that by default floating point exceptions are enabled
bool FpuControlSystem::Active = true;

ScopeFpuExceptionsEnabler::ScopeFpuExceptionsEnabler()
{
  ///only scope change if the fpu control system is active
  if(FpuControlSystem::Active == false)
    return;

  //*NOTE: _clearfp must be called between _controlfp_s calls. If two
  // _controlfp_s calls are made close to each other then an exception
  //will be thrown. Seemingly, _clearfp clears a busy bit on the cpu
  //which will prevent the cpu from thinking the state is being changed
  //while it is busy.

  unsigned int currState;
  //get the old state so we know what to go back to
  _clearfp();
  _controlfp_s(&mOldState, _MCW_EM, _MCW_EM);
  //set the new state
  _clearfp();
  _controlfp_s(&currState,FpuControlSystem::DefaultMask, _MCW_EM);
}

ScopeFpuExceptionsEnabler::~ScopeFpuExceptionsEnabler()
{
  ///only scope change if the fpu control system is active
  if(FpuControlSystem::Active == false)
    return;

  //set the old state back
  unsigned int currState;
  _clearfp();
  _controlfp_s(&currState,mOldState, _MCW_EM);
}

ScopeFpuExceptionsDisabler::ScopeFpuExceptionsDisabler()
{
  ///only scope change if the fpu control system is active
  if(FpuControlSystem::Active == false)
    return;

  //get the old state
  _controlfp_s(&mOldState, _MCW_EM, _MCW_EM);
  //set all of the exception flags which disables all fp exceptions.
  _controlfp_s(0, _MCW_EM, _MCW_EM);
}

ScopeFpuExceptionsDisabler::~ScopeFpuExceptionsDisabler()
{
  ///only scope change if the fpu control system is active
  if(FpuControlSystem::Active == false)
    return;

  //clear any pending fp exceptions otherwise there may be a
  //'deferred crash' as soon as the exceptions are enabled.
  _clearfp();

  //now reset the exceptions to what they were
  _controlfp_s(0, mOldState, _MCW_EM);
}

// Any other compiler
#else

///the mask is 0 in the generic system since we aren't funning any fp exceptions.
uint FpuControlSystem::DefaultMask = 0;
///The system is not active because we're on some random platform
bool FpuControlSystem::Active = false;

ScopeFpuExceptionsEnabler::ScopeFpuExceptionsEnabler()
{
}

ScopeFpuExceptionsEnabler::~ScopeFpuExceptionsEnabler()
{
}

ScopeFpuExceptionsDisabler::ScopeFpuExceptionsDisabler()
{
}

ScopeFpuExceptionsDisabler::~ScopeFpuExceptionsDisabler()
{
}

#endif

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file OsShared.cpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{

void StackHandle::Close()
{
  if(mHandle!=cInvalidHandle)
    CloseHandle(mHandle);
  mHandle = cInvalidHandle;
}

}


#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.cpp
/// Generates the precompiled header file.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Process.cpp
/// Implementation of the Process class and support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////





// Bring in the Process Status API library for process information parsing
#include <Psapi.h>
#pragma comment(lib, "Psapi.lib")

namespace Zero
{
struct ProcessPrivateData
{
  HANDLE mStdIn;
  HANDLE mStdOut;
  HANDLE mProcess;
};

//---------------------------------------------------------------------- Process
Process::Process()
{
  ZeroConstructPrivateData(ProcessPrivateData);
  self->mProcess = NULL;
  self->mStdOut = NULL;
  self->mStdIn = NULL;
  mTextStream = NULL;
  mDebugName[0] = '\0';
}

Process::~Process()
{
  Shutdown();
  ZeroDestructPrivateData(ProcessPrivateData);
}

//This code is a bit verbose. The purpose is the create a process and redirect its stdio
//to this hosting process. 
//Implementation referenced from
//MSDN http://support.microsoft.com/kb/q190351/
//Code Project http://www.codeproject.com/KB/threads/redir.aspx

uint Process::ExecProcess(cstr debugName, cstr commandLine, 
                          TextStream* textStream, bool showWindow)
{
  ZeroGetPrivateData(ProcessPrivateData);
  ZeroCStringCopy(mDebugName, cDebugNameMax, debugName, strlen(debugName));

  mTextStream = textStream;

  //Error Handling : WinReturnIf macro will signal an error and
  //return if the os call failed. Then  Stack handles will 
  //automatically close all valid handles cleaning up any references.

  StackHandle stdInRead;
  StackHandle stdOutWrite;
  StackHandle stdErrOut;

  StackHandle finalStdInWrite;
  StackHandle finalStdOutRead;
  
  OsHandle currentProcess = GetCurrentProcess();

  {
    SECURITY_ATTRIBUTES security;
    security.nLength = sizeof(SECURITY_ATTRIBUTES);
    security.lpSecurityDescriptor = NULL;
    security.bInheritHandle = TRUE;

    StackHandle stdOutReadTmp;
    StackHandle stdInWriteTmp;

    //Create the child output pipe.
    WinReturnIf(CreatePipe(stdOutReadTmp, stdOutWrite, &security, 0), 
                "Failed to create output pipe for %s", mDebugName);

    // MSDN: Create a duplicate of the output write handle for the std error
    // write handle. This is necessary in case the child application
    // closes one of its std output handles.
    WinReturnIf(DuplicateHandle(currentProcess,
                                stdOutWrite,
                                currentProcess,
                                stdErrOut,
                                0, TRUE,
                                DUPLICATE_SAME_ACCESS));

    //Create the child input pipe.
    WinReturnIf(CreatePipe(stdInRead, stdInWriteTmp, &security, 0),
                "Failed to create input pipe %s", mDebugName);

    // MSDN: Create new output read handle and the input write handles. Set
    // the Properties to FALSE. Otherwise, the child inherits the
    // properties and, as a result, non-closeable handles to the pipes
    // are created.
    WinReturnIf(DuplicateHandle(currentProcess,
                                stdOutReadTmp,
                                currentProcess,
                                finalStdOutRead,
                                0, FALSE,// Make it uninheritable.
                                DUPLICATE_SAME_ACCESS));

     WinReturnIf(DuplicateHandle(currentProcess,
                                 stdInWriteTmp,
                                 currentProcess,
                                 finalStdInWrite,
                                 0, FALSE,// Make it uninheritable.
                                 DUPLICATE_SAME_ACCESS));

    // Close inheritable copies of the handles you do not want to be
    // inherited.
    stdOutReadTmp.Close();
    stdInWriteTmp.Close();
  }

  STARTUPINFO startUpInfo;
  ZeroMemory(&startUpInfo, sizeof(STARTUPINFO));
  startUpInfo.cb = sizeof(STARTUPINFO);
  startUpInfo.hStdOutput =  stdOutWrite;
  startUpInfo.hStdInput = stdInRead;
  startUpInfo.hStdError = stdErrOut;

  if(showWindow)
    startUpInfo.wShowWindow = SW_SHOWDEFAULT;
  else
    startUpInfo.wShowWindow = SW_HIDE;//no window

  startUpInfo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

  PROCESS_INFORMATION processInfo;
  WinReturnIf(CreateProcess(NULL,
                            (LPTSTR)commandLine,
                            NULL, NULL,
                            TRUE,
                            CREATE_NEW_CONSOLE,
                            NULL,
                            NULL,
                            &startUpInfo,
                            &processInfo),
                            "Failed to create process for process %s. \nCommand line '%s'",
                            mDebugName, 
                            commandLine);

  // MSDN: Close pipe handles (do not continue to modify the parent).
  // You need to make sure that no handles to the write end of the
  // output pipe are maintained in this process or else the pipe will
  // not close when the child process exits and the ReadFile will hang.
  stdOutWrite.Close();
  stdInRead.Close();
  stdErrOut.Close();

  //Store the handles that are needed for input and output
  //that are not inheritable
  self->mStdIn = finalStdInWrite.Transfer();
  self->mStdOut = finalStdOutRead.Transfer();

  //Store the process
  self->mProcess = processInfo.hProcess;

  //Close unused thread handle
  CloseHandle(processInfo.hThread);

  //Create a cancel event for reading operations
  //so the hosting process can shutdown the read thread.
  mCancelEvent.Initialize(true, false);

  //Create the thread that will read input.
  mReadThread.Initialize(Thread::ObjectEntryCreator<Process, &Process::ReadThreadEntryPoint>, 
                         this, mDebugName);

  //Starting reading input
  mReadThread.Resume();

  return 0;
}

void Process::WriteToStdIn(cstr text, int size)
{
  ZeroGetPrivateData(ProcessPrivateData);
  OsInt bytesWritten;
  WriteFile(self->mStdIn, (LPCTSTR)text, size, &bytesWritten, NULL);
}

void Process::Shutdown()
{
  ZeroGetPrivateData(ProcessPrivateData);
  //Shutdown read thread with event.
  if(mReadThread.IsValid())
  {
    mCancelEvent.Signal();
    mReadThread.WaitForCompletion();
  }

  if(self->mProcess)
  {
    CloseHandle(self->mProcess);
    CloseHandle(self->mStdOut);
    CloseHandle(self->mStdIn);
  }
  self->mProcess = NULL;
  self->mStdOut = NULL;
  self->mStdIn = NULL;
}

void Process::WaitForClose()
{
  ZeroGetPrivateData(ProcessPrivateData);
  WaitForSingleObject(self->mProcess, INFINITE);
  WaitForSingleObject(mReadThread.GetThreadHandle(), INFINITE);
}

int Process::GetExitCode()
{
  ZeroGetPrivateData(ProcessPrivateData);
  OsInt exitCode = 0;
  GetExitCodeProcess(self->mProcess, &exitCode);
  return exitCode;
}

void Process::Terminate()
{
  ZeroGetPrivateData(ProcessPrivateData);
  TerminateProcess(self->mProcess, (UINT)-1);
}

OsInt Process::ReadThreadEntryPoint()
{
  ZeroGetPrivateData(ProcessPrivateData);
  // For debugging process issues
  const bool PrintDebugProcess = false;

  const OsInt cReadBufferSize = 1024;//1k
  byte readBuffer[cReadBufferSize + 1];//+1 for null terminator

  // Set up overlapped io on std out so reads can be checked with other handles
  // in WaitForMulitipleObjects
  OVERLAPPED readOverlapped;
  ZeroMemory(&readOverlapped, sizeof(readOverlapped));
  readOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

  // Start asynchronous overlapped read on std out
  DWORD bytesRead = 0;
  ReadFile(self->mStdOut, readBuffer, cReadBufferSize, &bytesRead, &readOverlapped);

  // Block until data can be read, the process is terminated or this process
  // is canceled.
  // Note: Check for readOverlapped first to make sure that any
  // std writes that happen at the same time the process is terminated
  // are still read.
  OsHandle waitHandles[] = {readOverlapped.hEvent, self->mProcess, mCancelEvent.GetHandle()};
  for(;;)
  {
    OsInt bytesRead = 0;
    OsInt bytesAvialable = 0;
    OsInt waitResult = WaitForMultipleObjects(3, waitHandles, FALSE, 60000L);

    switch(waitResult)
    {
      case WAIT_OBJECT_0:
      {
        if(PrintDebugProcess)
          ZPrint("%s : StdOut\n", mDebugName);

        // Get the number of bytes that were read
        BOOL success = GetOverlappedResult(self->mStdOut,
                                          &readOverlapped,
                                          &bytesRead,
                                          FALSE);
        if(success && bytesRead)
        {
          // Null terminate
          readBuffer[bytesRead] = '\0';
          // Write them out to the TextConsole interface
          if(mTextStream)
            mTextStream->Write((char*)readBuffer);
        }

        // Start another overlapped read
        ReadFile(self->mStdOut, readBuffer, cReadBufferSize, &bytesRead, &readOverlapped);
      }
      break;

      case WAIT_OBJECT_0 + 1:
      {
        if(PrintDebugProcess)
          DebugPrint("The process %s has terminated.\n", mDebugName);
        return 0;
      }
      break;

      case WAIT_OBJECT_0 + 2:
      {
        if(PrintDebugProcess)
          DebugPrint("Io on Process %s has been canceled.\n", mDebugName);
        return 0;
      }
      break;

      case WAIT_TIMEOUT:
      {
        //On timeout just try again.
        if(PrintDebugProcess)
          DebugPrint("Time out.\n", mDebugName);
      }
      break;

      case WAIT_FAILED:
      {
        VerifyWin(FALSE, "Failed to wait on process %s.", mDebugName);
      }
    }
  }
}

void GetProcessNameAndId(DWORD processID, String& processName, String& processPath)
{
  // We can't retreive info about some processes so default those to some string
  static const String unknownStr = "<unknown>";
  processName = processPath = unknownStr;

  TCHAR szProcessPath[MAX_PATH] = TEXT("<unknown>");

  // Get a handle to the process.
  HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID);

  // Get the process name.
  if(NULL != hProcess)
  {
    HMODULE moduleHandle;
    DWORD resultsBytesNeeded;

    // Gets a handle for each module in the process
    if(EnumProcessModules(hProcess, &moduleHandle, sizeof(moduleHandle), &resultsBytesNeeded))
    {
      // According to the documation of GetModuleBaseName it is preferrable (and faster) to use 
      // GetModuleFileName (which gets the full path) and the parse the text to get the process name
      GetModuleFileNameEx(hProcess, moduleHandle, szProcessPath, sizeof(szProcessPath) / sizeof(TCHAR));

      processPath = String::Format(TEXT("%s"), szProcessPath);
      // Make sure to normalize the path just in-case
      processPath = FilePath::Normalize(processPath);
      // The just the process' name (e.g. ZeroEditor.exe)
      processName = FilePath::GetFileName(processPath);
    }
  }
  
  // Release the handle to the process.
  CloseHandle(hProcess);
}

void GetProcesses(Array<ProcessInfo>& results)
{
  // EnumProcesses requires an array of data to be filled out,
  // currently assume there's not more than 1024 processes running
  const size_t maxProcesses = 1024;
  DWORD processIds[maxProcesses], resultSizeInBytes, numberOfProcesses;
  EnumProcesses(processIds, sizeof(processIds), &resultSizeInBytes);
  numberOfProcesses = resultSizeInBytes / sizeof(DWORD);
  // Fill out information for each process
  for(size_t i = 0; i < numberOfProcesses; ++i)
  {
    // Process id of 0 is invalid
    if(processIds[i] != 0)
    {
      ProcessInfo& info = results.push_back();
      info.mProcessId = processIds[i];
      GetProcessNameAndId(processIds[i], info.mProcessName, info.mProcessPath);
    }
  }
}

void KillProcess(OsInt processId, int exitCode)
{
  // Open the process for termination
  HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processId);
  
  if(hProcess != NULL)
    TerminateProcess(hProcess, exitCode);
  CloseHandle(hProcess);
}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{

bool GetRegistryValue(void* key, StringParam subKey, StringParam value, String& result)
{
  HKEY  hRoot = (HKEY)key;

  // Read OEM Name from the key
  char nameBuffer[256] = { 0 };
  DWORD length = sizeof(nameBuffer);

  HKEY  hKey;
  LONG queryResult = RegOpenKeyEx(hRoot, subKey.c_str(), 0, KEY_QUERY_VALUE, &hKey);
  if(queryResult != ERROR_SUCCESS)
    return false;

  queryResult = RegQueryValueEx(hKey, value.c_str(), 0, 0, (LPBYTE)nameBuffer, &length);
  if(queryResult != ERROR_SUCCESS)
    return false;

  result = nameBuffer;
  return true;
}

bool GetRegistryValueFromCommonInstallPaths(StringParam programGuid, StringParam keyName, String& result)
{
  String path1 = String::Format("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{%s}_is1", programGuid.c_str());
  String path2 = String::Format("SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{%s}}_is1", programGuid.c_str());

  if(GetRegistryValue(HKEY_CURRENT_USER, path1, keyName, result))
    return true;
  if(GetRegistryValue(HKEY_CURRENT_USER, path2, keyName, result))
    return true;
  if(GetRegistryValue(HKEY_LOCAL_MACHINE, path1, keyName, result))
    return true;
  if(GetRegistryValue(HKEY_LOCAL_MACHINE, path2, keyName, result))
    return true;
  return false;
}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Resolution.cpp
/// Resolution support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////





namespace Zero
{

Resolution GetDesktopResolution()
{
  Resolution desktopRes;
  //Enumerate the display settings for the default device so we can
  //get the desktop resolution
  DEVMODE data;
  data.dmSize = sizeof(DEVMODE);
  data.dmDriverExtra = 0;
  EnumDisplaySettings(NULL , ENUM_REGISTRY_SETTINGS , &data);
  desktopRes.Width = data.dmPelsWidth;
  desktopRes.Height = data.dmPelsHeight;
  return desktopRes;
}

void Enumerate(Array<Resolution>& resolutions, uint bitDepth, Resolution aspect)
{
  HashSet<Resolution> ResolutionMap;

  resolutions.clear();
  // Enumerate all display modes for the default display adapter.
  DEVMODE Win32Mode;
  Win32Mode.dmSize = sizeof(DEVMODE);
  for(int index = 0; EnumDisplaySettings(NULL, index, &Win32Mode); ++index)
  {
    Resolution resolution(Win32Mode.dmPelsWidth, Win32Mode.dmPelsHeight);
    // Check bit depth
    if(bitDepth ==0 || Win32Mode.dmBitsPerPel == bitDepth)
      // Check aspect ratio
      if(resolution.SameAspect(aspect))
      {
        ResolutionMap.insert(resolution);
      }
  }

  //push all in array
  PushAll(resolutions, ResolutionMap.all());
  //sort
  sort(resolutions.all());
}


}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean, Trevor Sundberg
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#if defined(COMPILER_GCC) ||  defined(COMPILER_CLANG)
  // This is not at all correct for GCC, but we just want it to
  // compile on GCC for Windows (POSIX takes a different path anyways)
  typedef int socklen_t;
  int inet_pton(int af, const char* src, void* dst)
  {
    return 0;
  }
  const char* inet_ntop(int af, const void* src, char* dst, socklen_t size)
  {
    return nullptr;
  }
#endif

// Include Winsock (nearly POSIX-compliant sockets)

#include <ws2tcpip.h>
#pragma comment(lib, "Ws2_32.lib")

// Platform Conversion Types and Macros
typedef SOCKET           SOCKET_TYPE;
typedef SOCKADDR_STORAGE SOCKET_ADDRESS_STORAGE;
typedef ADDRESS_FAMILY   SOCKET_ADDRESS_FAMILY;
#define TRANSLATE_TO_PLATFORM_ENUM(value)   ((void)0)
#define TRANSLATE_FROM_PLATFORM_ENUM(value) ((void)0)



#define CAST_HANDLE_TO_SOCKET(value) (static_cast<SOCKET_TYPE>(reinterpret_cast<size_t>(value)))
#define CAST_SOCKET_TO_HANDLE(value) (reinterpret_cast<OsHandle>(value))

#define TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(value, whatToReturn) \
        TRANSLATE_TO_PLATFORM_ENUM(value);                                      \
        if(status.Failed())                                                     \
          return whatToReturn

#define TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(value)         \
        TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(value, )

#define TRANSLATE_FROM_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(value, whatToReturn) \
        TRANSLATE_FROM_PLATFORM_ENUM(value);                                      \
        if(status.Failed())                                                       \
          return whatToReturn

#define TRANSLATE_FROM_PLATFORM_ENUM_OR_RETURN_FAILURE(value)         \
        TRANSLATE_FROM_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(value, )

namespace Zero
{

/// Sets the status error code and optional error string
void FailOnError(Status& status, int errorCode, StringParam errorString)
{
  // Set status error code and string
  status.SetFailed(errorString, errorCode);
}
void FailOnError(Status& status, int errorCode)
{
  // Create error string
  char* errorString = NULL;
  FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
                NULL, errorCode,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPSTR)&errorString, 0, NULL);

  // Use error string
  FailOnError(status, errorCode, errorString);

  // Free error string
  LocalFree(errorString);
}

/// Sets the status with the last error code and optional error string
void FailOnLastError(Status& status)
{
  // Get last error code
  FailOnError(status, WSAGetLastError());
}

//---------------------------------------------------------------------------------//
//                                SocketAddress                                    //
//---------------------------------------------------------------------------------//

SocketAddress::SocketAddress()
{
  Clear();
}

SocketAddress::SocketAddress(const SocketAddress& rhs)
{
  Clear();
  *this = rhs;
}

SocketAddress& SocketAddress::operator =(const SocketAddress& rhs)
{
  memcpy(this->mPrivateData, rhs.mPrivateData, sizeof(mPrivateData));
  return *this;
}

bool SocketAddress::operator ==(const SocketAddress& rhs) const
{
  return memcmp(this->mPrivateData, rhs.mPrivateData, sizeof(mPrivateData)) == 0;
}
bool SocketAddress::operator !=(const SocketAddress& rhs) const
{
  return !(*this == rhs);
}
bool SocketAddress::operator  <(const SocketAddress& rhs) const
{
  return memcmp(this->mPrivateData, rhs.mPrivateData, sizeof(mPrivateData)) < 0;
}

SocketAddress::operator bool(void) const
{
  return !IsEmpty();
}

bool SocketAddress::IsEmpty() const
{
  return *this == SocketAddress();
}

SocketAddressFamily::Enum SocketAddress::GetAddressFamily() const
{
  // Get socket address family
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)mPrivateData;
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::Enum(sockAddrStorage->ss_family);

  // Translate platform-specific enum as necessary
  Status status;
  TRANSLATE_FROM_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, SocketAddressFamily::Unspecified);

  // Success
  return addressFamily;
}

void SocketAddress::SetIpv4(Status& status, StringParam host, uint port)
{
  // Resolve IPv4 host
  SetIpv4(status, host, port, SocketAddressFlags::None);
}
void SocketAddress::SetIpv4(Status& status, StringParam host, uint port, SocketAddressFlags::Enum addressFlags)
{
  // Resolve IPv4 host
  Set(status, host, PortToString(port), SocketAddressFamily::InternetworkV4, addressFlags);
}

void SocketAddress::SetIpv6(Status& status, StringParam host, uint port)
{
  // Resolve IPv6 host
  SetIpv6(status, host, port, SocketAddressFlags::None);
}
void SocketAddress::SetIpv6(Status& status, StringParam host, uint port, SocketAddressFlags::Enum addressFlags)
{
  // Resolve IPv6 host
  Set(status, host, PortToString(port), SocketAddressFamily::InternetworkV6, addressFlags);
}

void SocketAddress::Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily)
{
  // Resolve host
  Set(status, host, service, addressFamily, SocketAddressFlags::None);
}
void SocketAddress::Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily,
                        SocketAddressFlags::Enum addressFlags)
{
  // Resolve host
  Set(status, host, service, addressFamily, SocketProtocol::Unspecified, SocketType::Unspecified, addressFlags);
}
void SocketAddress::Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily,
                        SocketProtocol::Enum protocol, SocketType::Enum type, SocketAddressFlags::Enum addressFlags)
{
  bool chooseAnyAddress = (addressFlags & SocketAddressFlags::AnyAddress);

  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(addressFamily);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(protocol);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(type);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(addressFlags);

  // Clear socket address
  Clear();

  // Create socket type hints
  addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_family   = addressFamily;
  hints.ai_protocol = protocol;
  hints.ai_socktype = type;
  hints.ai_flags    = addressFlags;

  // Resolve host list
  addrinfo* hosts = NULL;
  int result = getaddrinfo(chooseAnyAddress ? NULL : host.c_str(),
                           service.c_str(),
                           &hints,
                           &hosts);
  if(result != 0) // Unable?
    return FailOnError(status, result);

  // Set socket address to first host returned in the host list
  memcpy((sockaddr*)mPrivateData, hosts->ai_addr, hosts->ai_addrlen);

  // Free host list
  freeaddrinfo(hosts);
}

void SocketAddress::SetIpPort(Status& status, uint port)
{
  switch(GetAddressFamily())
  {
  // IPv4 socket address family?
  case SocketAddressFamily::InternetworkV4:
    ((sockaddr_in*)mPrivateData)->sin_port = htons((ushort)port);
    return;
  // IPv6 socket address family?
  case SocketAddressFamily::InternetworkV6:
    ((sockaddr_in6*)mPrivateData)->sin6_port = htons((ushort)port);
    return;

  // Other socket address family?
  default:
    FailOnError(status, GetAddressFamily(), "Not an IPv4 or IPv6 socket address");
    return;
  }
}
uint SocketAddress::GetIpPort(Status& status) const
{
  switch(GetAddressFamily())
  {
  // IPv4 socket address family?
  case SocketAddressFamily::InternetworkV4:
    return ntohs(((sockaddr_in*)mPrivateData)->sin_port);
  // IPv6 socket address family?
  case SocketAddressFamily::InternetworkV6:
    return ntohs(((sockaddr_in6*)mPrivateData)->sin6_port);

  // Other socket address family?
  default:
    FailOnError(status, GetAddressFamily(), "Not an IPv4 or IPv6 socket address");
    return 0;
  }
}

void SocketAddress::Clear()
{
  ZeroMemClearPrivateData(SOCKET_ADDRESS_STORAGE);
}

Bits Serialize(SerializeDirection::Enum direction, BitStream& bitStream, SocketAddress& socketAddress)
{
  // Note: Currently only supports IP address serialization (InternetworkV4 and InternetworkV6 socket addresses)

  // Write operation?
  if(direction == SerializeDirection::Write)
  {
    const Bits bitsWrittenStart = bitStream.GetBitsWritten();

    SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)socketAddress.mPrivateData;

    // Get internet protocol version
    InternetProtocol::Enum internetProtocol = InternetProtocol::Unspecified;
    switch(socketAddress.GetAddressFamily())
    {
    case SocketAddressFamily::InternetworkV4:
      internetProtocol = InternetProtocol::V4;
      break;
    case SocketAddressFamily::InternetworkV6:
      internetProtocol = InternetProtocol::V6;
      break;

    default:
      internetProtocol = InternetProtocol::Unspecified;
      break;
    }

    // Write internet protocol version
    bitStream.WriteInRange(internetProtocol, InternetProtocolMin, InternetProtocolMax);

    // Write IP address according to it's IP version
    switch(internetProtocol)
    {
    case InternetProtocol::V4:
      {
        // Write network-order IPv4 host address
        bitStream.Write(((sockaddr_in*)sockAddrStorage)->sin_addr.s_addr);

        // Write network-order IP port
        bitStream.Write(((sockaddr_in*)sockAddrStorage)->sin_port);
      }
      break;

    case InternetProtocol::V6:
      {
        // Write network-order IPv6 host address
        bitStream.Write(((sockaddr_in6*)sockAddrStorage)->sin6_addr.s6_addr);

        // Write network-order IP port
        bitStream.Write(((sockaddr_in6*)sockAddrStorage)->sin6_port);
      }
      break;

    default:
      Assert(false);
    case InternetProtocol::Unspecified:
      // (Either the socket address is empty or not an IP address)
      // (So there's nothing more we will write)
      break;
    }

    // Success
    return bitStream.GetBitsWritten() - bitsWrittenStart;
  }
  // Read operation?
  else
  {
    const Bits bitsReadStart = bitStream.GetBitsRead();

    SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)socketAddress.mPrivateData;

    // Read internet protocol version
    InternetProtocol::Enum internetProtocol = InternetProtocol::Unspecified;
    bitStream.ReadInRange(internetProtocol, InternetProtocolMin, InternetProtocolMax);

    // Translate to socket address family
    SocketAddressFamily::Enum addressFamily = SocketAddressFamily::Unspecified;
    switch(internetProtocol)
    {
    case InternetProtocol::V4:
      addressFamily = SocketAddressFamily::InternetworkV4;
      break;
    case InternetProtocol::V6:
      addressFamily = SocketAddressFamily::InternetworkV6;
      break;

    default:
      addressFamily = SocketAddressFamily::Unspecified;
      break;
    }

    // Translate platform-specific enum as necessary
    Status status;
    TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
    StatusReturnIfFailed(status, 0);

    // Read IP address according to it's IP version
    switch(internetProtocol)
    {
    case InternetProtocol::V4:
      {
        // Set IPv4 address family
        ((sockaddr_in*)sockAddrStorage)->sin_family = (SOCKET_ADDRESS_FAMILY)addressFamily;

        // Read network-order IPv4 host address
        ReturnIf(!bitStream.Read(((sockaddr_in*)sockAddrStorage)->sin_addr.s_addr), 0);

        // Read network-order IPv4 port
        ReturnIf(!bitStream.Read(((sockaddr_in*)sockAddrStorage)->sin_port), 0);
      }
      break;

    case InternetProtocol::V6:
      {
        // Set IPv6 address family
        ((sockaddr_in6*)sockAddrStorage)->sin6_family = (SOCKET_ADDRESS_FAMILY)addressFamily;

        // Read network-order IPv6 host address
        ReturnIf(!bitStream.Read(((sockaddr_in6*)sockAddrStorage)->sin6_addr.s6_addr), 0);

        // Read network-order IPv6 port
        ReturnIf(!bitStream.Read(((sockaddr_in6*)sockAddrStorage)->sin6_port), 0);
      }
      break;

    default:
      Assert(false);
    case InternetProtocol::Unspecified:
      // (Either the socket address is empty or not an IP address)
      // (So there's nothing more we will read)
      break;
    }

    // Success
    return bitStream.GetBitsRead() - bitsReadStart;
  }
}

bool IsValidIpv4Address(const SocketAddress& address)
{
  return Ipv4AddressToString(address) != String();
}
bool IsValidIpv6Address(const SocketAddress& address)
{
  return Ipv6AddressToString(address) != String();
}

bool IsValidIpv4Address(StringParam address)
{
  return StringToIpv4Address(address) != SocketAddress();
}
bool IsValidIpv6Address(StringParam address)
{
  return StringToIpv6Address(address) != SocketAddress();
}

String Ipv4AddressToString(const SocketAddress& address)
{
  // Translate platform-specific enum as necessary
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::InternetworkV4;
  Status status;
  TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, String());

  // Convert IPv4 address to string
  char result[Ipv4StringLength];
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)address.mPrivateData;
  if(!inet_ntop(addressFamily, &((sockaddr_in*)sockAddrStorage)->sin_addr, result, sizeof(result))) // Unable?
    return String();

  // Success
  return String(result);
}
String Ipv6AddressToString(const SocketAddress& address)
{
  // Translate platform-specific enum as necessary
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::InternetworkV6;
  Status status;
  TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, String());

  // Convert IPv6 address to string
  char result[Ipv6StringLength];
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)address.mPrivateData;
  if(!inet_ntop(addressFamily, &((sockaddr_in6*)sockAddrStorage)->sin6_addr, result, sizeof(result))) // Unable?
    return String();

  // Success
  return String(result);
}

String PortToString(uint port)
{
  // Convert port to string
  return String::Format("%u", port);
}

String Ipv4AddressToStringWithPort(const SocketAddress& address)
{
  // Get host
  String hostString = Ipv4AddressToString(address);
  if(hostString == String()) // Unable?
    return String();

  // Get port
  Status status;
  uint port = address.GetIpPort(status);
  if(status.Failed()) // Unable?
    return String();
  String portString = PortToString(port);

  // Concatenate host:port string
  StringBuilder builder;
  builder.Append(hostString);
  builder.Append(":");
  builder.Append(portString);
  return builder.ToString();
}
String Ipv6AddressToStringWithPort(const SocketAddress& address)
{
  // Get host
  String hostString = Ipv6AddressToString(address);
  if(hostString == String()) // Unable?
    return String();

  // Get port
  Status status;
  uint port = address.GetIpPort(status);
  if(status.Failed()) // Unable?
    return String();
  String portString = PortToString(port);

  // Concatenate host:port string
  StringBuilder builder;
  builder.Append(hostString);
  builder.Append(":");
  builder.Append(portString);
  return builder.ToString();
}

SocketAddress StringToIpv4Address(StringParam address)
{
  // Translate platform-specific enum as necessary
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::InternetworkV4;
  Status status;
  TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, SocketAddress());

  // Convert string to IPv4 address
  SocketAddress result;
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
  if(inet_pton(addressFamily, address.c_str(), &((sockaddr_in*)sockAddrStorage)->sin_addr) != 1) // Unable?
    return SocketAddress();

  // Success
  return result;
}
SocketAddress StringToIpv4Address(StringParam address, ushort port)
{
  // Convert string to IPv4 address
  SocketAddress result = StringToIpv4Address(address);
  if(result != SocketAddress()) // Successful?
  {
    // Set port
    SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
    ((sockaddr_in*)sockAddrStorage)->sin_port = htons(port);
  }
  return result;
}

SocketAddress StringToIpv6Address(StringParam address)
{
  // Translate platform-specific enum as necessary
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::InternetworkV6;
  Status status;
  TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, SocketAddress());

  // Convert string to IPv6 address
  SocketAddress result;
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
  if(inet_pton(addressFamily, address.c_str(), &((sockaddr_in6*)sockAddrStorage)->sin6_addr) != 1) // Unable?
    return SocketAddress();

  // Success
  return result;
}
SocketAddress StringToIpv6Address(StringParam address, ushort port)
{
  // Convert string to IPv6 address
  SocketAddress result = StringToIpv6Address(address);
  if(result != SocketAddress()) // Successful?
  {
    // Set port
    SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
    ((sockaddr_in6*)sockAddrStorage)->sin6_port = htons(port);
  }
  return result;
}


















//---------------------------------------------------------------------------------//
//                                    Socket                                       //
//---------------------------------------------------------------------------------//

/// Queries the socket library for the current local socket address associated with the specified socket
SocketAddress QueryLocalSocketAddress(Status& status, const Socket& socket)
{
  // Get local socket address information
  SocketAddress result;
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  if(getsockname(CAST_HANDLE_TO_SOCKET(socket.mHandle), (sockaddr*)sockAddrStorage, &sockAddrLength) == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return SocketAddress();
  }

  // Success
  return result;
}

/// Queries the socket library for the current remote socket address associated with the specified socket
SocketAddress QueryRemoteSocketAddress(Status& status, const Socket& socket)
{
  // Get remote socket address information
  SocketAddress result;
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  if(getpeername(CAST_HANDLE_TO_SOCKET(socket.mHandle), (sockaddr*)sockAddrStorage, &sockAddrLength) == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return SocketAddress();
  }

  // Success
  return result;
}

/// Clears the socket to it's default state
void Clear(Socket& socket)
{
  socket.mHandle        = CAST_SOCKET_TO_HANDLE(INVALID_SOCKET);
  socket.mAddressFamily = SocketAddressFamily::Unspecified;
  socket.mType          = SocketType::Unspecified;
  socket.mProtocol      = SocketProtocol::Unspecified;
  socket.mIsListening   = false;
  socket.mIsBlocking    = false;
  socket.mBoundLocalAddress.Clear();
  socket.mConnectedRemoteAddress.Clear();
}

/// Destroys the socket to it's default state
void Destroy(Socket& socket)
{
  Status status;

  // Socket still open?
  if(socket.IsOpen())
  {
    // Socket still connected?
    if(socket.IsConnected())
    {
      // Shut down connection
      socket.Shutdown(status, SocketIo::Both);
      ErrorIf(status.Failed(), "Error shutting down socket connection: %s", status.Message.c_str());
    }

    // Close socket
    socket.Close(status);
    ErrorIf(status.Failed(), "Error closing socket: %s", status.Message.c_str());
  }
}

/// Initializes Winsock (intended to be called multiple times, internally reference counted)
void InitializeWinsock()
{
  WSADATA winsockData = WSADATA();
  int result = WSAStartup(WINSOCK_VERSION, &winsockData);
  if(result != 0) // Unable?
  {
    Status status;
    FailOnError(status, result);
    Error("WSAStartup failed: %s", status.Message.c_str());
  }
}

/// Uninitializes Winsock (intended to be called multiple times, internally reference counted)
void UninitializeWinsock()
{
  if(WSACleanup() == SOCKET_ERROR) // Unable?
  {
    Status status;
    FailOnLastError(status);
    Error("WSACleanup failed: %s", status.Message.c_str());
  }
}

Socket::Socket()
{
  // Clear this socket
  Clear(*this);

  // Startup Winsock (as needed)
  InitializeWinsock();
}

Socket::~Socket()
{
  // Destroy this socket
  Destroy(*this);

  // Shutdown Winsock (as needed)
  UninitializeWinsock();
}

Socket::Socket(MoveReference<Socket> rhs)
{
  // Clear this socket
  Clear(*this);

  // Move data from rhs
  *this = ZeroMove(rhs);

  // Startup Winsock (as needed)
  InitializeWinsock();
}

Socket& Socket::operator =(MoveReference<Socket> rhs)
{
  // Destroy this socket
  Destroy(*this);

  // Move data from rhs
  mHandle                 = rhs->mHandle;
  mAddressFamily          = rhs->mAddressFamily;
  mType                   = rhs->mType;
  mProtocol               = rhs->mProtocol;
  mIsListening            = rhs->mIsListening;
  mIsBlocking             = rhs->mIsBlocking;
  mBoundLocalAddress      = rhs->mBoundLocalAddress;
  mConnectedRemoteAddress = rhs->mConnectedRemoteAddress;

  // Clear rhs socket
  Clear(*rhs);
  return *this;
}

uint Socket::GetMaxListenBacklog()
{
  return SOMAXCONN;
}

bool Socket::IsCommonReceiveError(uint extendedErrorCode)
{
  switch(extendedErrorCode)
  {
  case WSAENETRESET:
  case WSAECONNABORTED:
  case WSAECONNRESET:
  case WSAEWOULDBLOCK:
    return true;

  default:
    return false;
  }
}

bool Socket::IsCommonAcceptError(uint extendedErrorCode)
{
  switch(extendedErrorCode)
  {
  case WSAECONNRESET:
  case WSAEWOULDBLOCK:
    return true;

  default:
    return false;
  }
}

bool Socket::IsOpen() const
{
  return (mHandle != CAST_SOCKET_TO_HANDLE(INVALID_SOCKET));
}

SocketAddressFamily::Enum Socket::GetAddressFamily() const
{
  return mAddressFamily;
}

SocketType::Enum Socket::GetType() const
{
  return mType;
}

SocketProtocol::Enum Socket::GetProtocol() const
{
  return mProtocol;
}

bool Socket::IsBound() const
{
  return !GetBoundLocalAddress().IsEmpty();
}

SocketAddress Socket::GetBoundLocalAddress() const
{
  return mBoundLocalAddress;
}

bool Socket::IsListening() const
{
  return mIsListening;
}

bool Socket::IsBlocking() const
{
  return mIsBlocking;
}

bool Socket::IsConnected() const
{
  bool isConnected = false;
  switch(GetType())
  {
  // Connectionless socket type?
  case SocketType::Datagram:
  case SocketType::RawDatagram:
  case SocketType::ReliableDatagram:
    // Considered connected if a connect call was previously made
    isConnected = !GetConnectedRemoteAddress().IsEmpty();
    break;

  // Connection-based socket type?
  case SocketType::Stream:
  case SocketType::StreamPacket:
    {
      // Considered connected if the socket is writable
      Status status;
      isConnected = Select(status, SocketSelect::Write, 0.5f);
      ErrorIf(status.Failed());
    }
    break;

  // Unknown socket type?
  default:
    Error("Invalid switch value");
  case SocketType::Unspecified:
    // Unable to be considered connected
    isConnected = false;
    break;
  }

  return isConnected;
}

SocketAddress Socket::GetConnectedRemoteAddress() const
{
  return mConnectedRemoteAddress;
}

void Socket::Open(Status& status, SocketAddressFamily::Enum addressFamily, SocketType::Enum type, SocketProtocol::Enum protocol)
{
  // Translate platform-specific enums as necessary
  SocketAddressFamily::Enum addressFamily_ = addressFamily;
  SocketType::Enum          type_          = type;
  SocketProtocol::Enum      protocol_      = protocol;
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(addressFamily_);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(type_);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(protocol_);

  // Already open?
  if(IsOpen())
  {
    // Close socket
    Close(status);
    if(status.Failed()) // Unable?
      return;
  }

  // Create socket
  mHandle = CAST_SOCKET_TO_HANDLE(socket(addressFamily_, type_, protocol_));
  if(mHandle == CAST_SOCKET_TO_HANDLE(INVALID_SOCKET)) // Unable?
    return FailOnLastError(status);

  // Store values
  mAddressFamily = addressFamily;
  mType          = type;
  mProtocol      = protocol;
}

void Socket::Bind(Status& status, const SocketAddress& localAddress)
{
  // Bind socket to specified local address
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)localAddress.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  if(bind(CAST_HANDLE_TO_SOCKET(mHandle), (sockaddr*)sockAddrStorage, sockAddrLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);

  // Store value
  mBoundLocalAddress = QueryLocalSocketAddress(status, *this);
}

void Socket::Listen(Status& status, uint backlog)
{
  // Set socket listening mode
  if(listen(CAST_HANDLE_TO_SOCKET(mHandle), backlog) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);

  // Store value
  mIsListening = true;
}

void Socket::SetBlocking(Status& status, bool blocking)
{
  // Set socket blocking mode
  ulong blockingMode = blocking ? 0 : 1;
  if(ioctlsocket(CAST_HANDLE_TO_SOCKET(mHandle), FIONBIO, &blockingMode) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);

  // Store value
  mIsBlocking = blocking;
}

void Socket::Accept(Status& status, Socket* connectionOut)
{
  // Output socket already open?
  if(connectionOut->IsOpen())
  {
    // Close output socket
    connectionOut->Close(status);
    if(status.Failed()) // Unable?
      return;
  }

  // Accept incoming connection as a new socket
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)connectionOut->mConnectedRemoteAddress.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  SOCKET_TYPE newSocket = accept(CAST_HANDLE_TO_SOCKET(mHandle), (sockaddr*)sockAddrStorage, &sockAddrLength);
  if(newSocket == INVALID_SOCKET) // Unable?
    return FailOnLastError(status);

  // Store values
  connectionOut->mHandle            = CAST_SOCKET_TO_HANDLE(newSocket);
  connectionOut->mAddressFamily     = GetAddressFamily();
  connectionOut->mType              = GetType();
  connectionOut->mProtocol          = GetProtocol();
  connectionOut->mBoundLocalAddress = QueryLocalSocketAddress(status, *connectionOut);
}

void Socket::Connect(Status& status, const SocketAddress& remoteAddress)
{
  // Connect socket to specified remote address
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)remoteAddress.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  if(connect(CAST_HANDLE_TO_SOCKET(mHandle), (sockaddr*)sockAddrStorage, sockAddrLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);

  // Store value
  mConnectedRemoteAddress = QueryRemoteSocketAddress(status, *this);

  // Connected remote address should match request remote address (this check may be unnecessary)
  Assert(mConnectedRemoteAddress == remoteAddress);
}

void Socket::Shutdown(Status& status, SocketIo::Enum io)
{
  // Shut down socket operation(s)
  if(shutdown(CAST_HANDLE_TO_SOCKET(mHandle), (int)io) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}

void Socket::Close(Status& status)
{
  int result = 0;

  // Close socket
  result = closesocket(CAST_HANDLE_TO_SOCKET(mHandle));

  if(result == SOCKET_ERROR) // Unable?
    FailOnLastError(status);

  // Clear values
  Clear(*this);
}

size_t Socket::Send(Status& status, const byte* data, size_t dataLength, SocketFlags::Enum flags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(flags, 0);

  // Send data over socket to connected remote address
  int result = send(CAST_HANDLE_TO_SOCKET(mHandle), (const char*)data, (int)dataLength, (int)flags);
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return 0;
  }

  // Success
  return result;
}

size_t Socket::SendTo(Status& status, const byte* data, size_t dataLength, const SocketAddress& to, SocketFlags::Enum flags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(flags, 0);

  // Send data over socket to specified remote address
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)to.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  int result = sendto(CAST_HANDLE_TO_SOCKET(mHandle), (const char*)data, (int)dataLength, (int)flags, (sockaddr*)sockAddrStorage, sockAddrLength);
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return 0;
  }

  // Success
  return result;
}

size_t Socket::Receive(Status& status, byte* dataOut, size_t dataLength, SocketFlags::Enum flags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(flags, 0);

  // Receive data over socket from connected remote address
  int result = recv(CAST_HANDLE_TO_SOCKET(mHandle), (char*)dataOut, (int)dataLength, (int)flags);
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return 0;
  }

  // Success
  return result;
}

size_t Socket::ReceiveFrom(Status& status, byte* dataOut, size_t dataLength, SocketAddress& from, SocketFlags::Enum flags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(flags, 0);

  // Receive data over socket from any remote address
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)from.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  int result = recvfrom(CAST_HANDLE_TO_SOCKET(mHandle), (char*)dataOut, (int)dataLength, (int)flags, (sockaddr*)sockAddrStorage, &sockAddrLength);
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return 0;
  }

  // Success
  return result;
}

bool Socket::Select(Status& status, SocketSelect::Enum selectMode, float timeoutSeconds) const
{
  // Configure select timeout
  timeval timeout = {};
  timeout.tv_sec  = (long)timeoutSeconds;
  timeout.tv_usec = (long)((timeoutSeconds - timeout.tv_sec) * 1000000L);

  // Configure select operation
  fd_set socketSet;
  FD_ZERO(&socketSet);
  FD_SET(CAST_HANDLE_TO_SOCKET(mHandle), &socketSet);

  // Query select for specified socket operability status
  int result = 0;
  switch(selectMode)
  {
  case SocketSelect::Read:
    result = select(0, &socketSet, NULL, NULL, &timeout);
    break;
  case SocketSelect::Write:
    result = select(0, NULL, &socketSet, NULL, &timeout);
    break;
  case SocketSelect::Error:
    result = select(0, NULL, NULL, &socketSet, &timeout);
    break;

  default:
    Error("Invalid switch value");
    break;
  }
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return false;
  }

  // Success
  return (result != 0);
}

void Socket::GetSocketOption(Status& status, SocketOption::Enum option, void* value, size_t* valueLength) const
{
  *valueLength = 0;

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), SOL_SOCKET, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::GetSocketOption(Status& status, SocketIpv4Option::Enum option, void* value, size_t* valueLength) const
{
  *valueLength = 0;

  // Wrong socket address family?
  if(GetAddressFamily() != SocketAddressFamily::InternetworkV4)
    return FailOnError(status, option, "Invalid socket option, not an IPv4 socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_IP, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::GetSocketOption(Status& status, SocketIpv6Option::Enum option, void* value, size_t* valueLength) const
{
  *valueLength = 0;

  // Wrong socket address family?
  if(GetAddressFamily() != SocketAddressFamily::InternetworkV6)
    return FailOnError(status, option, "Invalid socket option, not an IPv6 socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_IPV6, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::GetSocketOption(Status& status, SocketTcpOption::Enum option, void* value, size_t* valueLength) const
{
  // Wrong socket protocol?
  if(GetProtocol() != SocketProtocol::Tcp)
    return FailOnError(status, option, "Invalid socket option, not a TCP socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_TCP, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::GetSocketOption(Status& status, SocketUdpOption::Enum option, void* value, size_t* valueLength) const
{
  *valueLength = 0;
  // Wrong socket protocol?
  if(GetProtocol() != SocketProtocol::Udp)
    return FailOnError(status, option, "Invalid socket option, not a UDP socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_UDP, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}

void Socket::SetSocketOption(Status& status, SocketOption::Enum option, const void* value, size_t valueLength)
{
  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), SOL_SOCKET, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::SetSocketOption(Status& status, SocketIpv4Option::Enum option, const void* value, size_t valueLength)
{
  // Wrong socket address family?
  if(GetAddressFamily() != SocketAddressFamily::InternetworkV4)
    return FailOnError(status, option, "Invalid socket option, not an IPv4 socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_IP, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::SetSocketOption(Status& status, SocketIpv6Option::Enum option, const void* value, size_t valueLength)
{
  // Wrong socket address family?
  if(GetAddressFamily() != SocketAddressFamily::InternetworkV6)
    return FailOnError(status, option, "Invalid socket option, not an IPv6 socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_IPV6, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::SetSocketOption(Status& status, SocketTcpOption::Enum option, const void* value, size_t valueLength)
{
  // Wrong socket protocol?
  if(GetProtocol() != SocketProtocol::Tcp)
    return FailOnError(status, option, "Invalid socket option, not a TCP socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_TCP, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::SetSocketOption(Status& status, SocketUdpOption::Enum option, const void* value, size_t valueLength)
{
  // Wrong socket protocol?
  if(GetProtocol() != SocketProtocol::Udp)
    return FailOnError(status, option, "Invalid socket option, not a UDP socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_UDP, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}

} // namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.cpp
/// Implementation of the Thread class.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#ifdef _MSC_VER

///Used to set the thread name in Visual Studio. This raises an exception that 
//Visual Studio catches and then sets the thread name.
typedef struct tagTHREADNAME_INFO
{
  DWORD dwType;     // must be 0x1000
  LPCSTR szName;    // pointer to name (in user addr space)
  DWORD dwThreadID; // thread ID (-1=caller thread)
  DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

inline void SetThreadDebugName(DWORD dwThreadID, LPCSTR szThreadName)
{
  THREADNAME_INFO info;
  info.dwType = 0x1000;
  info.szName = szThreadName;
  info.dwThreadID = dwThreadID;
  info.dwFlags = 0;

  //Yes this looks strange but it works for VS
  __try
  {
    RaiseException(0x406D1388, 0, sizeof(info) / sizeof(DWORD), (CONST ULONG_PTR*)&info);
  }
  __except(EXCEPTION_CONTINUE_EXECUTION)
  {
  }
}

#else

inline void SetThreadDebugName(DWORD dwThreadID, LPCSTR szThreadName)
{
}

#endif

namespace Zero
{
const bool ThreadingEnabled = true;

struct ThreadPrivateData
{
  OsInt mThreadId;
  OsHandle mHandle;
};

Thread::Thread()
{
  ZeroConstructPrivateData(ThreadPrivateData);

  self->mHandle = NULL;
  self->mThreadId = 0;
}

Thread::~Thread()
{
  Close();
  ZeroDestructPrivateData(ThreadPrivateData);
}

OsHandle Thread::GetThreadHandle()
{
  ZeroGetPrivateData(ThreadPrivateData);
  return self->mHandle;
}

bool Thread::Initialize(EntryFunction entry, void* instance, cstr threadName)
{
  ZeroGetPrivateData(ThreadPrivateData);

  ZeroCStringCopy(mThreadName, cDebugNameMax, threadName, strlen(threadName));

  const int cStackSize = 65536;
  self->mHandle = ::CreateThread( NULL, //No Security
                           cStackSize,
                           (LPTHREAD_START_ROUTINE)entry,
                           (LPVOID)instance, 
                           CREATE_SUSPENDED,
                           &self->mThreadId);

  CheckWin(self->mHandle != INVALID_HANDLE_VALUE, 
          "Failed to create thread named %s", threadName);

  if(self->mHandle != INVALID_HANDLE_VALUE)
  {
    SetThreadDebugName(self->mThreadId, threadName);
    return true;
  }
  else
  {
    self->mHandle = NULL;
    return false;
  }
}

bool Thread::IsValid()
{
  ZeroGetPrivateData(ThreadPrivateData);
  return self->mHandle != NULL;
}

void Thread::Resume()
{
  ZeroGetPrivateData(ThreadPrivateData);
  if(IsValid())
    VerifyWin(ResumeThread(self->mHandle), "Failed to resume thread. Thread name: %", 
              mThreadName);
}

void Thread::Suspend()
{
  ZeroGetPrivateData(ThreadPrivateData);
  if(IsValid())
    VerifyWin(SuspendThread(self->mHandle),
              "Failed to suspend thread. Thread name: %", mThreadName);
}

//Close the thread handle. 
void Thread::Close()
{
  ZeroGetPrivateData(ThreadPrivateData);
  if(IsValid())
    VerifyWin(CloseHandle(self->mHandle),
              "Failed to close thread handle. Thread name: %", mThreadName);
  self->mHandle = NULL;
}

OsHandle Thread::Detach()
{
  ZeroGetPrivateData(ThreadPrivateData);
  OsHandle handle = self->mHandle;
  self->mHandle = NULL;
  return handle;
}

OsInt Thread::WaitForCompletion()
{
  ZeroGetPrivateData(ThreadPrivateData);
  if(!IsValid())
    return (OsInt)-1;

  DWORD result = WaitForSingleObject(self->mHandle, INFINITE);
  if(result != WAIT_OBJECT_0)
  {
    DebugPrint("Failed to wait on on thread. Thread name: %s", mThreadName);
    return (OsInt)-1;
  }
  else
  {
    OsInt returnCode;
    GetExitCodeThread(self->mHandle, &returnCode);
    return returnCode;
  }
}

bool Thread::IsCompleted()
{
  ZeroGetPrivateData(ThreadPrivateData);
  if(!IsValid())
    return true;

  OsInt returnCode = 0;
  GetExitCodeThread(self->mHandle, &returnCode);
  bool threadActive = (returnCode == STILL_ACTIVE);
  return !threadActive;
}


}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadSync.cpp
/// Implementation of Thread synchronization classes.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////





namespace Zero
{

ThreadLock::ThreadLock()
{
  ZeroConstructPrivateData(CRITICAL_SECTION);
  ::InitializeCriticalSection(self);
}

ThreadLock::~ThreadLock()
{
  ZeroGetPrivateData(CRITICAL_SECTION);
  ::DeleteCriticalSection(self);
  ZeroDestructPrivateData(CRITICAL_SECTION);
}

void ThreadLock::Lock()
{
  ZeroGetPrivateData(CRITICAL_SECTION);
  ::EnterCriticalSection(self);
}

void ThreadLock::Unlock()
{
  ZeroGetPrivateData(CRITICAL_SECTION);
  ::LeaveCriticalSection(self);
}

OsEvent::OsEvent()
:mHandle(NULL)
{
}

OsEvent::~OsEvent()
{
  Close();
}

void OsEvent::Initialize(bool manualReset, bool startSignaled)
{
  mHandle = CreateEvent(NULL, manualReset, startSignaled, NULL);
  CheckWin(mHandle!=INVALID_HANDLE_VALUE, "Failed to create event.");
}

void OsEvent::Close()
{
  if(mHandle!=NULL)
  {
    VerifyWin(CloseHandle(mHandle), "Failed to close event.");
  }
}

void OsEvent::Signal()
{
  VerifyWin(SetEvent(mHandle), "Failed to Signal event.");
}

void OsEvent::Wait()
{
  DWORD result = WaitForSingleObject(mHandle, INFINITE);
  if(result == WAIT_FAILED)
  {
    VerifyWin(0, "Failed to Signal event.");
  }
}

void OsEvent::Reset()
{
  VerifyWin(ResetEvent(mHandle), "Failed to Reset event.");
}

Semaphore::Semaphore()
{
  mHandle = CreateSemaphore(NULL, 0, MaxSemaphoreCount, NULL);
}

Semaphore::~Semaphore()
{
  VerifyWin(CloseHandle(mHandle),"Failed to close Semaphore handle");
}

void Semaphore::Increment()
{
  VerifyWin(ReleaseSemaphore(mHandle, 1, NULL), "Failed to increment semaphore");
}

void Semaphore::Decrement()
{
  WaitForSingleObject(mHandle, 0);
}

void Semaphore::Reset()
{
  VerifyWin(CloseHandle(mHandle),"Failed to close Semaphore handle");
  mHandle = CreateSemaphore(NULL, 0, MaxSemaphoreCount, NULL);
}

void Semaphore::WaitAndDecrement()
{
  OsInt result = WaitForSingleObject(mHandle, INFINITE);
  if(result != WAIT_OBJECT_0)
  {
  }
}

Mutex::Mutex()
{
  ZeroConstructPrivateData(HANDLE);
}

Mutex::~Mutex()
{
  ZeroGetPrivateData(HANDLE);
  CloseHandle(*self);

  ZeroDestructPrivateData(HANDLE);
}

void Mutex::Initialize(Status& status, const char* mutexName, bool failIfAlreadyExists)
{
  ZeroGetPrivateData(HANDLE);
  *self = CreateMutex(NULL, FALSE, mutexName);

  DWORD error = GetLastError();
  if(*self == nullptr)
    status.SetFailed("Mutex initialization error.", error);
  else if(failIfAlreadyExists && error == ERROR_ALREADY_EXISTS)
    status.SetFailed("The handle already existed", error);
  else
    status.Succeeded();
}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Timer.cpp
/// Implementation of the Os Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

struct TimerPrivateData
{
  long long mStartCount;
  long long mCurrentTickCount;
  long long mCurrentTickDelta;
  double mFrequency;
  double mCurTimeDelta;
  double mCurTime;
};

Timer::Timer()
{
  ZeroConstructPrivateData(TimerPrivateData);

  LARGE_INTEGER  Frequency;
  QueryPerformanceFrequency(&Frequency);
  //mInvFrequency = 1.0 / (double)Frequency.QuadPart;
  self->mFrequency = (double)Frequency.QuadPart;
  Reset();
}

Timer::~Timer()
{
  ZeroDestructPrivateData(TimerPrivateData);
}

void Timer::Reset()
{
  ZeroGetPrivateData(TimerPrivateData);
  LARGE_INTEGER Count;
  QueryPerformanceCounter(&Count);
  self->mStartCount = Count.QuadPart;

  self->mCurrentTickCount = 0;
  self->mCurrentTickDelta = 0;
  self->mCurTimeDelta = 0;
  self->mCurTime = 0;
}

void Timer::Update()
{
  ZeroGetPrivateData(TimerPrivateData);
  TickType lastTickCount = self->mCurrentTickCount;
  LARGE_INTEGER CurrCount;
  QueryPerformanceCounter(&CurrCount);
  self->mCurrentTickCount = (CurrCount.QuadPart - self->mStartCount);
  self->mCurrentTickDelta = self->mCurrentTickCount - lastTickCount;

  //mCurTime =  mCurrentTickCount * mInvFrequency;
  self->mCurTime =  self->mCurrentTickCount / self->mFrequency;
  //mCurTimeDelta = mCurrentTickDelta * mInvFrequency;
  self->mCurTimeDelta = self->mCurrentTickDelta / self->mFrequency;
}

double Timer::Time() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return self->mCurTime;
}

double Timer::TimeDelta() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return self->mCurTimeDelta;
}

double Timer::UpdateAndGetTime()
{
  Update();
  return Time();
}

TimeMs Timer::TimeMilliseconds() const
{
  return TimeMs(Time() * double(1000));
}

TimeMs Timer::TimeDeltaMilliseconds() const
{
  return TimeMs(TimeDelta() * double(1000));
}

TimeMs Timer::UpdateAndGetTimeMilliseconds()
{
  return TimeMs(UpdateAndGetTime() * double(1000));
}

double Timer::TimeNoUpdate() const
{
  ZeroGetPrivateData(TimerPrivateData);
  LARGE_INTEGER CurrCount;
  QueryPerformanceCounter(&CurrCount);
  TickType TempTicks  = (CurrCount.QuadPart - self->mStartCount);
  //return (double)(TempTicks * mInvFrequency);
  return (double)(TempTicks / self->mFrequency);
}

Timer::TickType Timer::GetTickTime() const
{
  ZeroGetPrivateData(TimerPrivateData);
  LARGE_INTEGER CurrCount;
  QueryPerformanceCounter(&CurrCount);
  return CurrCount.QuadPart - self->mStartCount;
}

double Timer::TicksToSeconds(TickType ticks) const
{
  ZeroGetPrivateData(TimerPrivateData);
  //return (double)(ticks* mInvFrequency);
  return (double)(ticks / self->mFrequency);
}

} // namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Utilities.cpp
/// Implementation of the Utilities class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////







#include <Lmcons.h>
#include <shellapi.h>
#include <iptypes.h>
#include <iphlpapi.h>
#pragma comment(lib, "IPHLPAPI.lib")
#pragma comment(lib, "Winmm.lib")
#pragma comment(lib, "Advapi32.lib")

namespace Zero
{

namespace Os
{

void Sleep(uint ms)
{
  ::Sleep(ms);
}

void SetTimerFrequency(uint ms)
{
  ::timeBeginPeriod(ms);
}

String UserName()
{
  char buffer[UNLEN + 1];
  DWORD size = UNLEN + 1;
  GetUserName(buffer, &size);
  return String(buffer);
}

String ComputerName()
{
  char buffer[MAX_COMPUTERNAME_LENGTH + 1];
  DWORD size = MAX_COMPUTERNAME_LENGTH + 1;
  GetComputerName(buffer, &size);
  return String(buffer);
}

#ifndef _MSC_VER
BOOL CheckRemoteDebuggerPresent(HANDLE, PBOOL pbDebuggerPresent)
{
  *pbDebuggerPresent = FALSE;
  return FALSE;
}
#endif

// Check if a debugger is attached
bool IsDebuggerAttached()
{
  return IsDebuggerPresent() == TRUE;
}

u64 GetMacAddress()
{
  static u64 macAddress = 0;

  if(macAddress == 0)
  {
    IP_ADAPTER_INFO adapterInfoBuffer[16];
    OsInt sizeOfBuffer = sizeof(adapterInfoBuffer);
    OsInt status = GetAdaptersInfo(adapterInfoBuffer, &sizeOfBuffer);

    u64 address = 0;
    for(uint i=0;i<5;++i)
    {
      u64 val = adapterInfoBuffer[0].Address[5 - i];
      val = val << i*8;
      address += val;
    }

    macAddress = address;
  }

  return macAddress;
}


// Debug break (only if a debugger is attached)
void DebugBreak()
{
  // If the debugger is attached...
  if (IsDebuggerAttached() == true)
  {
    // Trigger a break point!
    ZERO_DEBUG_BREAK;
  }
}

cstr windowsVerbNames[] = {NULL, "open", "edit", "run"};
void SystemOpenFile(cstr file, uint verb, cstr parameters,
  cstr workingDirectory)
{
  Status status;
  SystemOpenFile(status, file, verb, parameters, workingDirectory);
}

bool SystemOpenFile(Status& status, cstr file, uint verb, cstr parameters, cstr workingDirectory)
{
  HINSTANCE success = ShellExecute(NULL, windowsVerbNames[verb], file, parameters, workingDirectory, TRUE);
  
  const HINSTANCE shellSucceed = (HINSTANCE)32;
  if(success > shellSucceed)
    return true;

  int errorCode = (int)GetLastError();
  char buffer[1024];
  ToErrorString(buffer, 1024, errorCode);
  String message = String::Format("Failed to execute shell command with file '%s'. %s", file, buffer);
  status.SetFailed(message, errorCode);

  return false;
}

String GetEnvironmentalVariable(StringRef variable)
{
  char* envVarValue = getenv(variable.c_str());

  if(envVarValue)
    return envVarValue;
  else
    return String();

}

//---------------------------------------------------------------- Memory Status 
void GetMemoryStatus(MemoryInfo& data)
{
  size_t pageRegion = 0;
  size_t foundPage = 1;
  while (foundPage)
  {
    MEMORY_BASIC_INFORMATION memoryInfo;
    //VirtualQueryEx return the size of the MEMORY_BASIC_INFORMATION if it 
    //succeeds or zero if no more pages are found.
    foundPage = VirtualQueryEx(GetCurrentProcess(), (void*)pageRegion,
      &memoryInfo, sizeof(memoryInfo));
    if(foundPage)
    {
      if(memoryInfo.State & MEM_FREE)
      {
        data.Free += memoryInfo.RegionSize;
      }
      else
      {
        if(memoryInfo.State & MEM_RESERVE)
          data.Reserve += memoryInfo.RegionSize;

        if(memoryInfo.State & MEM_COMMIT)
          data.Commit += memoryInfo.RegionSize;
      }

      //Move past this region to find another page.
      pageRegion += memoryInfo.RegionSize;
    }
  }
}


String TranslateErrorCode(int errorCode)
{
  //Try exception codes
  cstr exceptionCode = GetWindowsExceptionCode(errorCode);
  if(exceptionCode)
    return exceptionCode;

  //Try windows formatting
  char message[MAX_PATH] = {0};
  ToErrorString(message, MAX_PATH, errorCode);
  return message;
}

typedef void (WINAPI *GetNativeSystemInfoPtr)(LPSYSTEM_INFO);

String GetVersionString()
{
  OSVERSIONINFOEX osvi;
  SYSTEM_INFO si;

  ZeroMemory(&si, sizeof(SYSTEM_INFO));
  ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

  // The function 'GetVersionEx' still works on Windows 8.1 but is deprecated, so if the build
  // is made on windows 8.1 this can often cause errors
#pragma warning(push)
#pragma warning(disable: 4996)
  BOOL bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*) &osvi);
#pragma warning(pop)

  StringBuilder builder;

  if(!bOsVersionInfoEx) return String();

  // Call GetNativeSystemInfo if supported or GetSystemInfo otherwise.
  // This gets more information to determine 64bit vs 32bit but
  // is only available on later versions.

  GetNativeSystemInfoPtr pGNSI = (GetNativeSystemInfoPtr) GetProcAddress(
    GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");

  if(pGNSI != NULL)
    pGNSI(&si);
  else 
    GetSystemInfo(&si);

  if (VER_PLATFORM_WIN32_NT==osvi.dwPlatformId && osvi.dwMajorVersion > 4)
  {
    builder << "Microsoft ";

    // Test for the specific product.
    if (osvi.dwMajorVersion == 6)
    {
      if(osvi.dwMinorVersion == 0)
      {
        if(osvi.wProductType == VER_NT_WORKSTATION)
          builder << "Windows Vista ";
        else
          builder << "Windows Server 2008 ";
      }

      if (osvi.dwMinorVersion == 1)
      {
        if(osvi.wProductType == VER_NT_WORKSTATION)
          builder << "Windows 7 ";
        else
          builder << "Windows Server 2008 R2 ";
      }

      if (osvi.dwMinorVersion == 2)
      {
          builder << "Windows 8 ";
      }

    }

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)
    {
      if(GetSystemMetrics(SM_SERVERR2))
        builder << "Windows Server 2003 R2";
      else if (osvi.wSuiteMask & VER_SUITE_STORAGE_SERVER)
        builder << "Windows Storage Server 2003";
      else if (osvi.wSuiteMask & VER_SUITE_WH_SERVER)
        builder << "Windows Home Server";
      else if(osvi.wProductType == VER_NT_WORKSTATION &&
        si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
        builder << "Windows XP Professional x64 Edition";
      else
        builder << "Windows Server 2003";
    }

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
    {
      builder << "Windows XP ";
      if(osvi.wSuiteMask & VER_SUITE_PERSONAL)
        builder <<  "Home Edition";
      else
        builder << "Professional";
    }

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
    {
      builder << "Windows 2000 ";
    }

    // Include service pack (if any) and build number.

    if(strlen(osvi.szCSDVersion) > 0)
    {
      builder << (const char*)osvi.szCSDVersion;
    }

    builder << " (Build " << int(osvi.dwBuildNumber) << ")";

    if (osvi.dwMajorVersion >= 6)
    {
      if (si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
        builder << ", 64-bit";
      else if (si.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_INTEL)
        builder << ", 32-bit";
    }

    return builder.ToString(); 
  }

  else
  {
    return String("Unknown");
  }
}

}

u64 GenerateUniqueId64()
{
  //Get the mac address of the machine
  static u64 cachedMacAdress = (Os::GetMacAddress() << 16);

  u64 newId = cachedMacAdress;

  ///Get the low part of the the performance counter
  LARGE_INTEGER performanceCounter;
  BOOL status = QueryPerformanceCounter(&performanceCounter);
  u64 lowCount = performanceCounter.LowPart;

  //Get the current system time (since 1970)
  time_t systemTimeT;
  time(&systemTimeT);

  u64 systemTime = systemTimeT;

  //combine the two time parts
  u64 lowId =  (u64(systemTime) << 32) | (lowCount);

  //Keep incrementing the low value
  static uint shiftCount = 0;
  ++shiftCount;  
  lowId += shiftCount;

  //Or it with the mac part
  newId ^= lowId;

  return newId;
}
}

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file WindowsError.cpp
/// Implementation of Windows error handling.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#pragma comment(lib, "user32.lib")

uint ToErrorString(char* messageBuffer, uint bufferSize, uint errorCode)
{
  //If no error code was provided default to the last error
  //that occurred.
  DWORD error = errorCode != 0 ? errorCode : GetLastError();

  // Look up windows error string.
  DWORD numberOfChars = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL,
                           error,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           messageBuffer,
                           bufferSize,
                           NULL);

  return numberOfChars;
}

uint CheckWindowsErrorCode(uint success, cstr format, ...)
{
  if(!success)
  {
    char errorMessage[cMaxErrorMessageSize] = {0};
    ToErrorString(errorMessage, cMaxErrorMessageSize, GetLastError());
    char emptyBuffer[1] = {0};
    char* messageBuffer = emptyBuffer;

    if(format)
    {
      //Use va args to print text
      va_list args;
      va_start(args, format);
      //Get the number of characters needed
      int characters;
      ZeroVSPrintfCount(format, args, 1, characters);
      if(characters > 0)
      {
        messageBuffer = (char*)alloca(characters + 1);
        messageBuffer[characters] = '\0';
        ZeroVSPrintf(messageBuffer, characters + 1, format, args);
      }
      va_end(args);
    }

    // Combine both message and windows error into message.
    ZPrint("%s Windows Error: %s", messageBuffer, errorMessage);

    ErrorIf(true, "%s Windows Error: %s", messageBuffer, errorMessage);
  }
  return success;
}


cstr GetWindowsExceptionCode(int exceptionCode)
{
  //take from Bruce Dawson's article http://www.altdevblogaday.com/2012/04/20/exceptional-floating-point/
  switch((DWORD)exceptionCode)
  {
  case STATUS_FLOAT_INVALID_OPERATION:
    return "Float Invalid Operation";
  case STATUS_FLOAT_DIVIDE_BY_ZERO:
    return "Float Divide by Zero";
  case STATUS_FLOAT_OVERFLOW:
    return "Float Overflow";
  case STATUS_FLOAT_MULTIPLE_TRAPS:
    return "Float Multiple Traps (sse float exception)";
  case STATUS_INTEGER_DIVIDE_BY_ZERO:
    return "Integer Division by Zero";
  case STATUS_ACCESS_VIOLATION:
    return "Access Violation";
  case STATUS_STACK_OVERFLOW:
    return "Stack Overflow";
  case STATUS_ILLEGAL_INSTRUCTION:
    return "Illegal Instruction";
  case STATUS_BREAKPOINT:
    return "Debug Breakpoint";
  case STATUS_DATATYPE_MISALIGNMENT:
    return "Data Type Misalignment (likely sse not aligned)";
  case STATUS_PRIVILEGED_INSTRUCTION:
    return "Privileged Instruction";
  default:
    return NULL;
  }
}
#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file DirectoryWatcher.hpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.hpp
/// Precompiled header for posix library.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////







#ifdef __APPLE__
#include <CoreServices/CoreServices.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#endif

#include <new>
#include <cstdlib>
#include <cstdio>
#include <ctime>
#include <cctype>
#include <sys/stat.h>
#include <fcntl.h>
using namespace std;

#endif



namespace Zero
{

DirectoryWatcher::DirectoryWatcher(cstr directoryToWatch, CallbackFunction callback, void* callbackInstance)
{
  ZeroCStringCopy(mDirectoryToWatch, File::MaxPath, directoryToWatch, strlen(directoryToWatch));
  mCallbackInstance = callbackInstance;
  mCallback = callback;
}

DirectoryWatcher::~DirectoryWatcher()
{

}

void DirectoryWatcher::Shutdown()
{

}

OsInt DirectoryWatcher::RunThreadEntryPoint()
{
  return 0;
}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ExternalLibrary.cpp
/// Implementation of the ExternalLibrary class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

ExternalLibrary::ExternalLibrary()
{
  mHandle = nullptr;
  mUnloadOnDestruction = true;
}

ExternalLibrary::~ExternalLibrary()
{
  if(mUnloadOnDestruction)
    Unload();
}

bool ExternalLibrary::IsValid()
{
  return mHandle != nullptr;
}

void ExternalLibrary::Load(cstr filePath)
{
  mHandle = dlopen(filePath, RTLD_LAZY);
}

void ExternalLibrary::Unload()
{
  if(mHandle == nullptr)
    return;
  dlclose(mHandle);
  mHandle = nullptr;
}

void* ExternalLibrary::GetFunctionByName(cstr name)
{
  ReturnIf(mHandle == nullptr, nullptr, "Attempting to get a function from an invalid library");
  return dlsym(mHandle, name);
}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file File.cpp
/// Implementation of the Os file class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#pragma warning(disable: 4996)

namespace Zero
{
struct FilePrivateData
{
  FILE* mHandle;
  uint mFileSize;
};

cstr cBadFileMessage = "The file is missing, not in that location, or is "
  "protected.";

uint GetFileSize(FILE* file)
{
  int fd = fileno(file);
  struct stat st;
  fstat(fd, &st);
  return (uint)st.st_size;
}

DataBlock ReadFileIntoDataBlock(cstr filePath)
{
  FILE* file = fopen (filePath,"rb");
  if(file)
  {
    uint fileSize = GetFileSize(file);
    byte* buffer = (byte*)zAllocate(fileSize);
    fread(buffer, 1, fileSize, file);
    fclose(file);
    return DataBlock(buffer, fileSize);
  }

  return DataBlock();
}

byte * ReadFileIntoMemory(cstr filePath, size_t& fileSize, size_t extra)
{
  FILE* file = fopen (filePath,"rb");
  if(file)
  {
    fileSize = GetFileSize(file);
    byte* buffer = (byte*)zAllocate(fileSize+extra);
    fread(buffer, 1, fileSize, file);
    fclose(file);
    return buffer;
  }
  return NULL;
}

size_t WriteToFile(cstr filePath, byte* buffer, size_t bufferSize)
{
  FILE* file = fopen (filePath,"wb");
  if(file)
  {
    fwrite(buffer, 1, bufferSize,  file);
    fclose(file);
    return bufferSize;
  }
  return 0;
}

cstr ToFileMode(FileMode::Enum mode)
{
  switch(mode)
  {
    case FileMode::Read:
      return "rb";

    case FileMode::Append:
      return "ab";

    case FileMode::Write:
      return "wb";
  
    case FileMode::ReadWrite:
      return "r+b";
  }
  return "";
}

//Convert File Relative position to windows constant
uint ToOrigin(FileOrigin::Enum origin)
{
  switch(origin)
  {
  case FileOrigin::Begin:
    return SEEK_SET;
  case FileOrigin::End: 
    return SEEK_END;
  case FileOrigin::Current:
    return SEEK_CUR;
  }
  return SEEK_CUR;
}

File::File()
{
  ZeroConstructPrivateData(FilePrivateData);
  self->mHandle = NULL;
}

bool File::Open(StringParam filePath, FileMode::Enum mode, FileAccessPattern::Enum accessPattern, FileShare::Enum share, Status* status)
{
  ZeroGetPrivateData(FilePrivateData);
  cstr fmode = ToFileMode(mode);

  self->mHandle = fopen(filePath.c_str(), fmode);
  ReturnIf(self->mHandle == NULL, false, 
           "Failed to open file '%s'. %s", filePath.c_str(), cBadFileMessage);

  self->mFileSize = GetFileSize(self->mHandle);
  mFilePath = filePath;

  if(mode == FileMode::Append)
    Seek(self->mFileSize);
  return true;
}

void File::Close()
{
  ZeroGetPrivateData(FilePrivateData);
  if(self->mHandle != NULL)
  {
    fclose(self->mHandle);
    self->mHandle = NULL;
  }
}
    
bool File::IsOpen()
{
  ZeroGetPrivateData(FilePrivateData);
  return self->mHandle != NULL;
}
    

File::~File()
{
  Close();
}

FilePosition File::Tell()
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == NULL, "File handle is not valid.");
  return ftell(self->mHandle);
}

size_t File::Size()
{
  ZeroGetPrivateData(FilePrivateData);
  return self->mFileSize;  
}

long long File::CurrentFileSize()
{
  ZeroGetPrivateData(FilePrivateData);
  return GetFileSize(self->mHandle);
}

bool File::Seek(FilePosition pos, FileOrigin::Enum origin)
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == NULL, "File handle is not valid.");
  int result = fseek(self->mHandle, (long)pos, ToOrigin(origin) );
  // A result of '0' means success
  return (result == 0);
}

size_t File::Write(byte* data, size_t sizeInBytes)
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == NULL, "File handle is not valid.");
  return fwrite(data, 1, sizeInBytes, self->mHandle);
}

size_t File::Read(byte* data, size_t sizeInBytes)
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == NULL, "File handle is not valid.");
  return fread(data, 1, sizeInBytes, self->mHandle);
}

void File::Flush()
{
  ZeroGetPrivateData(FilePrivateData);
  ErrorIf(self->mHandle == NULL, "File handle is not valid.");
  fflush(self->mHandle);
}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FileSystem.cpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>
#include <errno.h>

namespace Zero
{

const char  cDirectorySeparatorChar = '/';
const char* cDirectorySeparatorCstr = "/";


void InitFileSystem()
{

}

void ShutdownFileSystem()
{

}

bool CopyFileInternal(StringRef dest, StringRef source)
{
  FILE* sourceFile = fopen(source.c_str(), "rb");
  if(sourceFile == NULL)
    return false;

  FILE* destFile = fopen(dest.c_str(), "wb");
  if(destFile == NULL)
  { 
    fclose(sourceFile);
    return false;
  }

  const int bufferSize = 4096;

  char buf[bufferSize];
  for(;;)
  {
    ssize_t bytesRead = fread(buf, 1, bufferSize, sourceFile);
    int written = fwrite(buf, bytesRead, 1, destFile);
    if (bytesRead!=bufferSize) 
      break;
  }

  fclose(sourceFile);
  fclose(destFile);
  return true;
}

bool VerifyPosix(int returnCode, cstr operation)
{
  if(returnCode != 0)
  {
    ZPrint("While: %s Error: %s\n", operation, strerror(errno) );
    return false;
  }
  else
  {
    return true;
  }
}

bool MoveFileInternal(StringRef dest, StringRef source)
{
  return  VerifyPosix(rename(source.c_str(), dest.c_str()), "MoveFile");
}

bool DeleteFileInternal(StringRef filename)
{
  return VerifyPosix(unlink(filename.c_str()), "DeleteFile");
}

bool DeleteDirectory(StringRef name)
{
  return VerifyPosix(rmdir(name.c_str()), "DeleteDirectory");
}

void CreateDirectory(StringRef dest)
{
  int failCode = mkdir(dest.c_str(),
    S_IRUSR | S_IWUSR | S_IXUSR |
    S_IRGRP | S_IWGRP | S_IXGRP |
    S_IROTH | S_IXOTH );

  if(failCode != 0)
  {
    // If the error is anything except already exists
    if(errno != EEXIST)
      ZPrint("Failed to create directory %s Error: %s\n", dest.c_str(), strerror(errno) );
  }
}

void CreateDirectoryAndParents(StringRef directory)
{
  char directoryPath[File::MaxPath];
  ZeroStrCpy(directoryPath, File::MaxPath, directory.c_str());
  uint size = strlen(directoryPath);
  for(uint c=0;c<size;++c)
  {
    //When their is a directory separator
    if(directoryPath[c] == cDirectorySeparatorChar && c > 0)
    {
      //Null terminate
      directoryPath[c] = '\0';
      //Create directory
      CreateDirectory(directoryPath);
      //remove null terminator
      directoryPath[c] = cDirectorySeparatorChar;
    }
  }

  // Finally create the directory
  CreateDirectory(directoryPath);
}


int CheckFileTime(StringRef dest, StringRef source)
{
  struct stat destStat;
  if(stat(dest.c_str(), &destStat)!=0)
    return -1;

  struct stat sourceStat;
  if(stat(source.c_str(), &sourceStat)!=0)
    return 1;

  if(destStat.st_mtime > sourceStat.st_mtime)
    return 1;

  if(destStat.st_mtime == sourceStat.st_mtime)
    return 0;
  else
    return -1;
}

time_t GetFileModifiedTime(StringRef file)
{
  struct stat fileStat;
  if(stat(file.c_str(), &fileStat)!=0)
    return (time_t)fileStat.st_mtime;
  return 0;
}

int SetFileToCurrentTime(StringRef filename)
{
  return VerifyPosix(utimensat(AT_FDCWD, filename.c_str(), NULL, 0), "Updating File Time");
}

u32 GetFileSize(StringRef fileName)
{
  struct stat st;
  stat(fileName.c_str(), &st);
  return (uint)st.st_size;
}

bool FileExists(StringRef filePath)
{
  struct stat st;
  return stat(filePath.c_str(), &st) != -1;
}

bool DirectoryExists(StringRef directoryPath)
{
  struct stat st;
  if(stat(directoryPath.c_str(), &st) == 0 && S_ISDIR(st.st_mode))
    return true;
  return false;
}

// Return true if it is directory path and it exists
bool IsDirectory(StringRef directoryPath)
{
  struct stat st;
  if(stat(directoryPath.c_str(), &st) == 0 && S_ISDIR(st.st_mode))
    return true;
  return false;
}

String CanonicalizePath(StringRef directoryPath)
{
  Error("CanonicalizePath not yet supported"); 
  return directoryPath;
}

bool FileWritable(StringRef filePath)
{
  return access(filePath.c_str(), R_OK) == 0;
}

String UniqueFileId(StringRef fullpath)
{
   char buffer[File::MaxPath] = {0};
   realpath(fullpath.c_str(), buffer);

  //on unix the path is unique
  return fullpath;
}

String GetWorkingDirectory()
{
  char temp[File::MaxPath+1];
  getcwd(temp, File::MaxPath);
  return temp;
}

void SetWorkingDirectory(String path)
{
  chdir(path.c_str());
}

String GetUserLocalDirectory()
{
  // Use the standard ~/.cache location
  char local[File::MaxPath+1] = {0};
  ZeroStrCpy(local, File::MaxPath, getenv("HOME"));
  ZeroStrCat(local, File::MaxPath, "/.cache");
  return local;
}

String GetUserDocumentsDirectory()
{
  return getenv("HOME");
}

String GetTemporaryDirectory()
{
  return "/tmp";
}

String GetApplication()
{
  return String();
}

String GetApplicationDirectory()
{
  return String();
}

struct FileRangePrivateData
{
  DIR* mDir;
  struct dirent* mEntry;
};

FileRange::FileRange(StringRef search)
{ 
  ZeroConstructPrivateData(FileRangePrivateData);
  DIR* dir = opendir(search.c_str());
  if(dir)
  {
    self->mDir = dir;
    self->mEntry = readdir(dir);
  }
  else
  {
    self->mDir = NULL;
    self->mEntry = NULL;
  }
}

FileRange::~FileRange()
{
  ZeroGetPrivateData(FileRangePrivateData);
  closedir(self->mDir);
}

bool FileRange::empty()
{
  ZeroGetPrivateData(FileRangePrivateData);
  return self->mEntry == NULL;
}

cstr FileRange::front()
{
  ZeroGetPrivateData(FileRangePrivateData);
  return self->mEntry->d_name;
}

void FileRange::popFront()
{
  ZeroGetPrivateData(FileRangePrivateData);
  self->mEntry = readdir(self->mDir);

  //Get rid of "." and ".." directory results.
  if(!empty() && strcmp(front(), ".") == 0)
    popFront();

  if(!empty() && strcmp(front(), "..") == 0)
    popFront();
}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FpControl.hpp
/// Implementation of the ScpeFpuExceptions, ScoplessFpuExceptions and
/// FpuControlSystem classes.
///
/// Authors: Joshua Davis
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



#include <float.h>


namespace Zero
{

///the mask is 0 in the generic system since we aren't running any fp exceptions.
uint FpuControlSystem::DefaultMask = 0;
///The system is not active because we're on some random platform
bool FpuControlSystem::Active = false;

ScopeFpuExceptionsEnabler::ScopeFpuExceptionsEnabler()
{
}

ScopeFpuExceptionsEnabler::~ScopeFpuExceptionsEnabler()
{
}

ScopeFpuExceptionsDisabler::ScopeFpuExceptionsDisabler()
{
}

ScopeFpuExceptionsDisabler::~ScopeFpuExceptionsDisabler()
{
}


}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.cpp
/// Generates the precompiled header file.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Process.cpp
///
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

Process::Process()
{
}

Process::~Process()
{
}

uint Process::ExecProcess(cstr debugName, cstr commandLine, TextStream* stream, bool showWindow)
{
  String fullLine = String::Format("wine %s", commandLine);
  int returnCode = system(fullLine.c_str());
  if(returnCode != 0)
  {
      ZERO_DEBUG_BREAK;
  }
  return 0;
}

void Process::WriteToStdIn(cstr text, int size)
{
}

void Process::Shutdown()
{
}

void Process::WaitForClose()
{
}

int Process::GetExitCode()
{
  return 0;
}

OsInt Process::ReadThreadEntryPoint()
{
  return 0;
}

}

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{

bool GetRegistryValue(void* key, StringParam subKey, StringParam value, String& result)
{
  return false;
}

bool GetRegistryValueFromCommonInstallPaths(StringParam programGuid, StringParam keyName, String& result)
{
  return false;
}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Resolution.cpp
/// Resolution support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{


Resolution GetDesktopResolution()
{
  Resolution desktopRes;
  desktopRes.Width = 800;
  desktopRes.Height = 600;
  return desktopRes;
}

void Enumerate(Array<Resolution>& resolutions, int bitDepth, Resolution aspect)
{

}


}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean, Trevor Sundberg
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


// Include POSIX Sockets
#include <errno.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <unistd.h>
#include <sys/un.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <fcntl.h>

// Platform Conversion Types and Macros
typedef int              SOCKET_TYPE;
typedef sockaddr_storage SOCKET_ADDRESS_STORAGE;
typedef ushort           SOCKET_ADDRESS_FAMILY;
#define INVALID_SOCKET   -1
#define SOCKET_ERROR     -1
#define TRANSLATE_TO_PLATFORM_ENUM(value)   TranslateToPosix(status, value)
#define TRANSLATE_FROM_PLATFORM_ENUM(value) TranslateToWinsock(status, value)



#define CAST_HANDLE_TO_SOCKET(value) (static_cast<SOCKET_TYPE>(reinterpret_cast<size_t>(value)))
#define CAST_SOCKET_TO_HANDLE(value) (reinterpret_cast<OsHandle>(value))

#define TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(value, whatToReturn) \
        TRANSLATE_TO_PLATFORM_ENUM(value);                                      \
        if(status.Failed())                                                     \
          return whatToReturn

#define TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(value)         \
        TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(value, )

#define TRANSLATE_FROM_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(value, whatToReturn) \
        TRANSLATE_FROM_PLATFORM_ENUM(value);                                      \
        if(status.Failed())                                                       \
          return whatToReturn

#define TRANSLATE_FROM_PLATFORM_ENUM_OR_RETURN_FAILURE(value)         \
        TRANSLATE_FROM_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(value, )

namespace Zero
{

/// Sets the status error code and optional error string
void FailOnError(Status& status, int errorCode, StringParam errorString)
{
  // Set status error code and string
  status.SetFailed(errorString, errorCode);
}
void FailOnError(Status& status, int errorCode)
{
  // Use error string
  FailOnError(status, errorCode, strerror(errorCode));
}

/// Sets the status with the last error code and optional error string
void FailOnLastError(Status& status)
{
  // Get last error code
  FailOnError(status, errno);
}

//
// Translation Functions
//

/// Translates the POSIX enum to it's Winsock equivalent, else fails on error (unsupported enumeration)
void TranslateToWinsock(Status& status, SocketAddressFamily::Enum& socketAddressFamily)
{
  // TODO: Implement the rest of these
  switch(socketAddressFamily)
  {
  case SocketAddressFamily::Enum(AF_UNSPEC):
    socketAddressFamily = SocketAddressFamily::Unspecified;
    break;
  case SocketAddressFamily::Enum(AF_INET):
    socketAddressFamily = SocketAddressFamily::InternetworkV4;
    break;
  case SocketAddressFamily::Enum(AF_INET6):
    socketAddressFamily = SocketAddressFamily::InternetworkV6;
    break;

  default:
    return FailOnError(status, socketAddressFamily, "Unsupported socket address family enumeration");
  }
}
void TranslateToWinsock(Status& status, SocketProtocol::Enum& socketProtocol)
{
  // TODO: Implement the rest of these
  switch(socketProtocol)
  {
  default:
    return FailOnError(status, socketProtocol, "Unsupported socket protocol enumeration");
  }
}
void TranslateToWinsock(Status&, uint)
{
  // No conversion necessary for the enum type (otherwise it should be explicitly overloaded)
}

/// Translates the Winsock enum to it's POSIX equivalent, else fails on error (unsupported enumeration)
void TranslateToPosix(Status& status, SocketAddressFamily::Enum& socketAddressFamily)
{
  // TODO: Implement the rest of these
  switch(socketAddressFamily)
  {
  case SocketAddressFamily::Unspecified:
    socketAddressFamily = SocketAddressFamily::Enum(AF_UNSPEC);
    break;
  case SocketAddressFamily::InternetworkV4:
    socketAddressFamily = SocketAddressFamily::Enum(AF_INET);
    break;
  case SocketAddressFamily::InternetworkV6:
    socketAddressFamily = SocketAddressFamily::Enum(AF_INET6);
    break;

  default:
    return FailOnError(status, socketAddressFamily, "Unsupported socket address family enumeration");
  }
}
void TranslateToPosix(Status& status, SocketAddressFlags::Enum& socketAddressFlags)
{
  // TODO: Implement the rest of these
  switch(socketAddressFlags)
  {
  default:
    return FailOnError(status, socketAddressFlags, "Unsupported socket address flags enumeration");
  }
}
void TranslateToPosix(Status& status, SocketProtocol::Enum& socketProtocol)
{
  // TODO: Implement the rest of these
  switch(socketProtocol)
  {
  default:
    return FailOnError(status, socketProtocol, "Unsupported socket protocol enumeration");
  }
}
void TranslateToPosix(Status& status, SocketFlags::Enum& socketFlags)
{
  // TODO: Implement the rest of these
  switch(socketFlags)
  {
  default:
    return FailOnError(status, socketFlags, "Unsupported socket flags enumeration");
  }
}
void TranslateToPosix(Status& status, SocketType::Enum& socketType)
{
  // TODO: Implement the rest of these
  switch(socketType)
  {
  default:
    return FailOnError(status, socketType, "Unsupported socket type enumeration");
  }
}
void TranslateToPosix(Status& status, SocketOption::Enum& socketOption)
{
  // TODO: Implement the rest of these
  switch(socketOption)
  {
  default:
    return FailOnError(status, socketOption, "Unsupported socket option enumeration");
  }
}
void TranslateToPosix(Status& status, SocketIpv4Option::Enum& socketIpv4Option)
{
  // TODO: Implement the rest of these
  switch(socketIpv4Option)
  {
  default:
    return FailOnError(status, socketIpv4Option, "Unsupported IPv4 socket option enumeration");
  }
}
void TranslateToPosix(Status& status, SocketIpv6Option::Enum& socketIpv6Option)
{
  // TODO: Implement the rest of these
  switch(socketIpv6Option)
  {
  default:
    return FailOnError(status, socketIpv6Option, "Unsupported IPv6 socket option enumeration");
  }
}
void TranslateToPosix(Status& status, SocketTcpOption::Enum& socketTcpOption)
{
  // TODO: Implement the rest of these
  switch(socketTcpOption)
  {
  default:
    return FailOnError(status, socketTcpOption, "Unsupported TCP socket option enumeration");
  }
}
void TranslateToPosix(Status& status, SocketUdpOption::Enum& socketUdpOption)
{
  // TODO: Implement the rest of these
  switch(socketUdpOption)
  {
  default:
    return FailOnError(status, socketUdpOption, "Unsupported UDP socket option enumeration");
  }
}

//---------------------------------------------------------------------------------//
//                                SocketAddress                                    //
//---------------------------------------------------------------------------------//

SocketAddress::SocketAddress()
{
  Clear();
}

SocketAddress::SocketAddress(const SocketAddress& rhs)
{
  Clear();
  *this = rhs;
}

SocketAddress& SocketAddress::operator =(const SocketAddress& rhs)
{
  memcpy(this->mPrivateData, rhs.mPrivateData, sizeof(mPrivateData));
  return *this;
}

bool SocketAddress::operator ==(const SocketAddress& rhs) const
{
  return memcmp(this->mPrivateData, rhs.mPrivateData, sizeof(mPrivateData)) == 0;
}
bool SocketAddress::operator !=(const SocketAddress& rhs) const
{
  return !(*this == rhs);
}
bool SocketAddress::operator  <(const SocketAddress& rhs) const
{
  return memcmp(this->mPrivateData, rhs.mPrivateData, sizeof(mPrivateData)) < 0;
}

SocketAddress::operator bool(void) const
{
  return !IsEmpty();
}

bool SocketAddress::IsEmpty() const
{
  return *this == SocketAddress();
}

SocketAddressFamily::Enum SocketAddress::GetAddressFamily() const
{
  // Get socket address family
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)mPrivateData;
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::Enum(sockAddrStorage->ss_family);

  // Translate platform-specific enum as necessary
  Status status;
  TRANSLATE_FROM_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, SocketAddressFamily::Unspecified);

  // Success
  return addressFamily;
}

void SocketAddress::SetIpv4(Status& status, StringParam host, uint port)
{
  // Resolve IPv4 host
  SetIpv4(status, host, port, SocketAddressFlags::None);
}
void SocketAddress::SetIpv4(Status& status, StringParam host, uint port, SocketAddressFlags::Enum addressFlags)
{
  // Resolve IPv4 host
  Set(status, host, PortToString(port), SocketAddressFamily::InternetworkV4, addressFlags);
}

void SocketAddress::SetIpv6(Status& status, StringParam host, uint port)
{
  // Resolve IPv6 host
  SetIpv6(status, host, port, SocketAddressFlags::None);
}
void SocketAddress::SetIpv6(Status& status, StringParam host, uint port, SocketAddressFlags::Enum addressFlags)
{
  // Resolve IPv6 host
  Set(status, host, PortToString(port), SocketAddressFamily::InternetworkV6, addressFlags);
}

void SocketAddress::Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily)
{
  // Resolve host
  Set(status, host, service, addressFamily, SocketAddressFlags::None);
}
void SocketAddress::Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily,
                        SocketAddressFlags::Enum addressFlags)
{
  // Resolve host
  Set(status, host, service, addressFamily, SocketProtocol::Unspecified, SocketType::Unspecified, addressFlags);
}
void SocketAddress::Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily,
                        SocketProtocol::Enum protocol, SocketType::Enum type, SocketAddressFlags::Enum addressFlags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(addressFamily);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(protocol);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(type);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(addressFlags);

  // Clear socket address
  Clear();

  // Create socket type hints
  addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_family   = addressFamily;
  hints.ai_protocol = protocol;
  hints.ai_socktype = type;
  hints.ai_flags    = addressFlags;

  // Resolve host list
  addrinfo* hosts = NULL;
  int result = getaddrinfo(host.c_str(),
                           service.c_str(),
                           &hints,
                           &hosts);
  if(result != 0) // Unable?
    return FailOnError(status, result);

  // Set socket address to first host returned in the host list
  memcpy((sockaddr*)mPrivateData, hosts->ai_addr, hosts->ai_addrlen);

  // Free host list
  freeaddrinfo(hosts);
}

void SocketAddress::SetIpPort(Status& status, uint port)
{
  switch(GetAddressFamily())
  {
  // IPv4 socket address family?
  case SocketAddressFamily::InternetworkV4:
    ((sockaddr_in*)mPrivateData)->sin_port = htons((ushort)port);
    return;
  // IPv6 socket address family?
  case SocketAddressFamily::InternetworkV6:
    ((sockaddr_in6*)mPrivateData)->sin6_port = htons((ushort)port);
    return;

  // Other socket address family?
  default:
    FailOnError(status, GetAddressFamily(), "Not an IPv4 or IPv6 socket address");
    return;
  }
}
uint SocketAddress::GetIpPort(Status& status) const
{
  switch(GetAddressFamily())
  {
  // IPv4 socket address family?
  case SocketAddressFamily::InternetworkV4:
    return ntohs(((sockaddr_in*)mPrivateData)->sin_port);
  // IPv6 socket address family?
  case SocketAddressFamily::InternetworkV6:
    return ntohs(((sockaddr_in6*)mPrivateData)->sin6_port);

  // Other socket address family?
  default:
    FailOnError(status, GetAddressFamily(), "Not an IPv4 or IPv6 socket address");
    return 0;
  }
}

void SocketAddress::Clear()
{
  ZeroMemClearPrivateData(SOCKET_ADDRESS_STORAGE);
}

bool IsValidIpv4Address(const SocketAddress& address)
{
  return Ipv4AddressToString(address) != String();
}
bool IsValidIpv6Address(const SocketAddress& address)
{
  return Ipv6AddressToString(address) != String();
}

bool IsValidIpv4Address(StringParam address)
{
  return StringToIpv4Address(address) != SocketAddress();
}
bool IsValidIpv6Address(StringParam address)
{
  return StringToIpv6Address(address) != SocketAddress();
}

String Ipv4AddressToString(const SocketAddress& address)
{
  // Translate platform-specific enum as necessary
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::InternetworkV4;
  Status status;
  TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, String());

  // Convert IPv4 address to string
  char result[Ipv4StringLength];
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)address.mPrivateData;
  if(!inet_ntop(addressFamily, &((sockaddr_in*)sockAddrStorage)->sin_addr, result, sizeof(result))) // Unable?
    return String();

  // Success
  return String(result);
}
String Ipv6AddressToString(const SocketAddress& address)
{
  // Translate platform-specific enum as necessary
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::InternetworkV6;
  Status status;
  TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, String());

  // Convert IPv6 address to string
  char result[Ipv6StringLength];
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)address.mPrivateData;
  if(!inet_ntop(addressFamily, &((sockaddr_in6*)sockAddrStorage)->sin6_addr, result, sizeof(result))) // Unable?
    return String();

  // Success
  return String(result);
}

String PortToString(uint port)
{
  // Convert port to string
  return String::Format("%u", port);
}

String Ipv4AddressToStringWithPort(const SocketAddress& address)
{
  // Get host
  String hostString = Ipv4AddressToString(address);
  if(hostString == String()) // Unable?
    return String();

  // Get port
  Status status;
  uint port = address.GetIpPort(status);
  if(status.Failed()) // Unable?
    return String();
  String portString = PortToString(port);

  // Concatenate host:port string
  StringBuilder builder;
  builder.Append(hostString);
  builder.Append(":");
  builder.Append(portString);
  return builder.ToString();
}
String Ipv6AddressToStringWithPort(const SocketAddress& address)
{
  // Get host
  String hostString = Ipv6AddressToString(address);
  if(hostString == String()) // Unable?
    return String();

  // Get port
  Status status;
  uint port = address.GetIpPort(status);
  if(status.Failed()) // Unable?
    return String();
  String portString = PortToString(port);

  // Concatenate host:port string
  StringBuilder builder;
  builder.Append(hostString);
  builder.Append(":");
  builder.Append(portString);
  return builder.ToString();
}

SocketAddress StringToIpv4Address(StringParam address)
{
  // Translate platform-specific enum as necessary
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::InternetworkV4;
  Status status;
  TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, SocketAddress());

  // Convert string to IPv4 address
  SocketAddress result;
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
  if(inet_pton(addressFamily, address.c_str(), &((sockaddr_in*)sockAddrStorage)->sin_addr) != 1) // Unable?
    return SocketAddress();

  // Success
  return result;
}
SocketAddress StringToIpv4Address(StringParam address, ushort port)
{
  // Convert string to IPv4 address
  SocketAddress result = StringToIpv4Address(address);
  if(result != SocketAddress()) // Successful?
  {
    // Set port
    SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
    ((sockaddr_in*)sockAddrStorage)->sin_port = htons(port);
  }
  return result;
}

SocketAddress StringToIpv6Address(StringParam address)
{
  // Translate platform-specific enum as necessary
  SocketAddressFamily::Enum addressFamily = SocketAddressFamily::InternetworkV6;
  Status status;
  TRANSLATE_TO_PLATFORM_ENUM(addressFamily);
  StatusReturnIfFailed(status, SocketAddress());

  // Convert string to IPv6 address
  SocketAddress result;
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
  if(inet_pton(addressFamily, address.c_str(), &((sockaddr_in6*)sockAddrStorage)->sin6_addr) != 1) // Unable?
    return SocketAddress();

  // Success
  return result;
}
SocketAddress StringToIpv6Address(StringParam address, ushort port)
{
  // Convert string to IPv6 address
  SocketAddress result = StringToIpv6Address(address);
  if(result != SocketAddress()) // Successful?
  {
    // Set port
    SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
    ((sockaddr_in6*)sockAddrStorage)->sin6_port = htons(port);
  }
  return result;
}

//---------------------------------------------------------------------------------//
//                                    Socket                                       //
//---------------------------------------------------------------------------------//

/// Queries the socket library for the current local socket address associated with the specified socket
SocketAddress QueryLocalSocketAddress(Status& status, const Socket& socket)
{
  // Get local socket address information
  SocketAddress result;
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  if(getsockname(CAST_HANDLE_TO_SOCKET(socket.mHandle), (sockaddr*)sockAddrStorage, &sockAddrLength) == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return SocketAddress();
  }

  // Success
  return result;
}

/// Queries the socket library for the current remote socket address associated with the specified socket
SocketAddress QueryRemoteSocketAddress(Status& status, const Socket& socket)
{
  // Get remote socket address information
  SocketAddress result;
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)result.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  if(getpeername(CAST_HANDLE_TO_SOCKET(socket.mHandle), (sockaddr*)sockAddrStorage, &sockAddrLength) == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return SocketAddress();
  }

  // Success
  return result;
}

/// Clears the socket to it's default state
void Clear(Socket& socket)
{
  socket.mHandle        = CAST_SOCKET_TO_HANDLE(INVALID_SOCKET);
  socket.mAddressFamily = SocketAddressFamily::Unspecified;
  socket.mType          = SocketType::Unspecified;
  socket.mProtocol      = SocketProtocol::Unspecified;
  socket.mIsListening   = false;
  socket.mIsBlocking    = false;
  socket.mBoundLocalAddress.Clear();
  socket.mConnectedRemoteAddress.Clear();
}

/// Destroys the socket to it's default state
void Destroy(Socket& socket)
{
  Status status;

  // Socket still open?
  if(socket.IsOpen())
  {
    // Socket still connected?
    if(socket.IsConnected())
    {
      // Shut down connection
      socket.Shutdown(status, SocketIo::Both);
      ErrorIf(status.Failed(), "Error shutting down socket connection: %s", status.Message.c_str());
    }

    // Close socket
    socket.Close(status);
    ErrorIf(status.Failed(), "Error closing socket: %s", status.Message.c_str());
  }
}

Socket::Socket()
{
  // Clear this socket
  Clear(*this);
}

Socket::~Socket()
{
  // Destroy this socket
  Destroy(*this);
}

Socket::Socket(MoveReference<Socket> rhs)
{
  // Clear this socket
  Clear(*this);

  // Move data from rhs
  *this = ZeroMove(rhs);
}

Socket& Socket::operator =(MoveReference<Socket> rhs)
{
  // Destroy this socket
  Destroy(*this);

  // Move data from rhs
  mHandle                 = rhs->mHandle;
  mAddressFamily          = rhs->mAddressFamily;
  mType                   = rhs->mType;
  mProtocol               = rhs->mProtocol;
  mIsListening            = rhs->mIsListening;
  mIsBlocking             = rhs->mIsBlocking;
  mBoundLocalAddress      = rhs->mBoundLocalAddress;
  mConnectedRemoteAddress = rhs->mConnectedRemoteAddress;

  // Clear rhs socket
  Clear(*rhs);
  return *this;
}

uint Socket::GetMaxListenBacklog()
{
  return SOMAXCONN;
}

bool Socket::IsCommonReceiveError(uint extendedErrorCode)
{
  switch(extendedErrorCode)
  {
  case ENETRESET:
  case ECONNABORTED:
  case ECONNRESET:
  case EWOULDBLOCK:
    return true;

  default:
    return false;
  }
}

bool Socket::IsCommonAcceptError(uint extendedErrorCode)
{
  switch(extendedErrorCode)
  {
  case ECONNRESET:
  case EWOULDBLOCK:
    return true;

  default:
    return false;
  }
}

bool Socket::IsOpen() const
{
  return (mHandle != CAST_SOCKET_TO_HANDLE(INVALID_SOCKET));
}

SocketAddressFamily::Enum Socket::GetAddressFamily() const
{
  return mAddressFamily;
}

SocketType::Enum Socket::GetType() const
{
  return mType;
}

SocketProtocol::Enum Socket::GetProtocol() const
{
  return mProtocol;
}

bool Socket::IsBound() const
{
  return !GetBoundLocalAddress().IsEmpty();
}

SocketAddress Socket::GetBoundLocalAddress() const
{
  return mBoundLocalAddress;
}

bool Socket::IsListening() const
{
  return mIsListening;
}

bool Socket::IsBlocking() const
{
  return mIsBlocking;
}

bool Socket::IsConnected() const
{
  bool isConnected = false;
  switch(GetType())
  {
  // Connectionless socket type?
  case SocketType::Datagram:
  case SocketType::RawDatagram:
  case SocketType::ReliableDatagram:
    // Considered connected if a connect call was previously made
    isConnected = !GetConnectedRemoteAddress().IsEmpty();
    break;

  // Connection-based socket type?
  case SocketType::Stream:
  case SocketType::StreamPacket:
    {
      // Considered connected if the socket is writable
      Status status;
      isConnected = Select(status, SocketSelect::Write, 0.5f);
      ErrorIf(status.Failed());
    }
    break;

  // Unknown socket type?
  default:
    Error("Invalid switch value");
  case SocketType::Unspecified:
    // Unable to be considered connected
    isConnected = false;
    break;
  }

  return isConnected;
}

SocketAddress Socket::GetConnectedRemoteAddress() const
{
  return mConnectedRemoteAddress;
}

void Socket::Open(Status& status, SocketAddressFamily::Enum addressFamily, SocketType::Enum type, SocketProtocol::Enum protocol)
{
  // Translate platform-specific enums as necessary
  SocketAddressFamily::Enum addressFamily_ = addressFamily;
  SocketType::Enum          type_          = type;
  SocketProtocol::Enum      protocol_      = protocol;
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(addressFamily_);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(type_);
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(protocol_);

  // Already open?
  if(IsOpen())
  {
    // Close socket
    Close(status);
    if(status.Failed()) // Unable?
      return;
  }

  // Create socket
  mHandle = CAST_SOCKET_TO_HANDLE(socket(addressFamily_, type_, protocol_));
  if(mHandle == CAST_SOCKET_TO_HANDLE(INVALID_SOCKET)) // Unable?
    return FailOnLastError(status);

  // Store values
  mAddressFamily = addressFamily;
  mType          = type;
  mProtocol      = protocol;
}

void Socket::Bind(Status& status, const SocketAddress& localAddress)
{
  // Bind socket to specified local address
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)localAddress.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  if(bind(CAST_HANDLE_TO_SOCKET(mHandle), (sockaddr*)sockAddrStorage, sockAddrLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);

  // Store value
  mBoundLocalAddress = QueryLocalSocketAddress(status, *this);
}

void Socket::Listen(Status& status, uint backlog)
{
  // Set socket listening mode
  if(listen(CAST_HANDLE_TO_SOCKET(mHandle), backlog) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);

  // Store value
  mIsListening = true;
}

void Socket::SetBlocking(Status& status, bool blocking)
{
  // Get socket file descriptor flags
  int flags = fcntl(CAST_HANDLE_TO_SOCKET(mHandle), F_GETFL, 0);
  if(flags == SOCKET_ERROR) // Unable?
    return FailOnError(status, 0, "Unable to get socket flags");

  // Set/clear non-blocking flag
  if(blocking)
    flags &= ~O_NONBLOCK;
  else
    flags |= O_NONBLOCK;

  // Set socket file descriptor flags
  int result = fcntl(CAST_HANDLE_TO_SOCKET(mHandle), F_SETFL, flags);
  if(result == SOCKET_ERROR) // Unable?
    return FailOnError(status, 0, "Unable to set socket flags");

  // Store value
  mIsBlocking = blocking;
}

void Socket::Accept(Status& status, Socket* connectionOut)
{
  // Output socket already open?
  if(connectionOut->IsOpen())
  {
    // Close output socket
    connectionOut->Close(status);
    if(status.Failed()) // Unable?
      return;
  }

  // Accept incoming connection as a new socket
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)connectionOut->mConnectedRemoteAddress.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  SOCKET_TYPE newSocket = accept(CAST_HANDLE_TO_SOCKET(mHandle), (sockaddr*)sockAddrStorage, &sockAddrLength);
  if(newSocket == INVALID_SOCKET) // Unable?
    return FailOnLastError(status);

  // Store values
  connectionOut->mHandle            = CAST_SOCKET_TO_HANDLE(newSocket);
  connectionOut->mAddressFamily     = GetAddressFamily();
  connectionOut->mType              = GetType();
  connectionOut->mProtocol          = GetProtocol();
  connectionOut->mBoundLocalAddress = QueryLocalSocketAddress(status, *connectionOut);
}

void Socket::Connect(Status& status, const SocketAddress& remoteAddress)
{
  // Connect socket to specified remote address
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)remoteAddress.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  if(connect(CAST_HANDLE_TO_SOCKET(mHandle), (sockaddr*)sockAddrStorage, sockAddrLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);

  // Store value
  mConnectedRemoteAddress = QueryRemoteSocketAddress(status, *this);

  // Connected remote address should match request remote address (this check may be unnecessary)
  Assert(mConnectedRemoteAddress == remoteAddress);
}

void Socket::Shutdown(Status& status, SocketIo::Enum io)
{
  // Shut down socket operation(s)
  if(shutdown(CAST_HANDLE_TO_SOCKET(mHandle), (int)io) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}

void Socket::Close(Status& status)
{
  int result = 0;

  // Close socket
  result = close(CAST_HANDLE_TO_SOCKET(mHandle));

  if(result == SOCKET_ERROR) // Unable?
    FailOnLastError(status);

  // Clear values
  Clear(*this);
}

size_t Socket::Send(Status& status, const byte* data, size_t dataLength, SocketFlags::Enum flags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(flags, 0);

  // Send data over socket to connected remote address
  int result = send(CAST_HANDLE_TO_SOCKET(mHandle), (const char*)data, (int)dataLength, (int)flags);
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return 0;
  }

  // Success
  return result;
}

size_t Socket::SendTo(Status& status, const byte* data, size_t dataLength, const SocketAddress& to, SocketFlags::Enum flags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(flags, 0);

  // Send data over socket to specified remote address
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)to.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  int result = sendto(CAST_HANDLE_TO_SOCKET(mHandle), (const char*)data, (int)dataLength, (int)flags, (sockaddr*)sockAddrStorage, sockAddrLength);
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return 0;
  }

  // Success
  return result;
}

size_t Socket::Receive(Status& status, byte* dataOut, size_t dataLength, SocketFlags::Enum flags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(flags, 0);

  // Receive data over socket from connected remote address
  int result = recv(CAST_HANDLE_TO_SOCKET(mHandle), (char*)dataOut, (int)dataLength, (int)flags);
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return 0;
  }

  // Success
  return result;
}

size_t Socket::ReceiveFrom(Status& status, byte* dataOut, size_t dataLength, SocketAddress& from, SocketFlags::Enum flags)
{
  // Translate platform-specific enums as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE_VALUE(flags, 0);

  // Receive data over socket from any remote address
  SOCKET_ADDRESS_STORAGE* sockAddrStorage = (SOCKET_ADDRESS_STORAGE*)from.mPrivateData;
  socklen_t               sockAddrLength  = sizeof(SOCKET_ADDRESS_STORAGE);
  int result = recvfrom(CAST_HANDLE_TO_SOCKET(mHandle), (char*)dataOut, (int)dataLength, (int)flags, (sockaddr*)sockAddrStorage, &sockAddrLength);
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return 0;
  }

  // Success
  return result;
}

bool Socket::Select(Status& status, SocketSelect::Enum selectMode, float timeoutSeconds) const
{
  // Configure select timeout
  timeval timeout = {};
  timeout.tv_sec  = (long)timeoutSeconds;
  timeout.tv_usec = (long)((timeoutSeconds - timeout.tv_sec) * 1000000L);

  // Configure select operation
  fd_set socketSet;
  FD_ZERO(&socketSet);
  FD_SET(CAST_HANDLE_TO_SOCKET(mHandle), &socketSet);

  // Query select for specified socket operability status
  int result = 0;
  switch(selectMode)
  {
  case SocketSelect::Read:
    result = select(0, &socketSet, NULL, NULL, &timeout);
    break;
  case SocketSelect::Write:
    result = select(0, NULL, &socketSet, NULL, &timeout);
    break;
  case SocketSelect::Error:
    result = select(0, NULL, NULL, &socketSet, &timeout);
    break;

  default:
    Error("Invalid switch value");
    break;
  }
  if(result == SOCKET_ERROR) // Unable?
  {
    FailOnLastError(status);
    return false;
  }

  // Success
  return (result != 0);
}

void Socket::GetSocketOption(Status& status, SocketOption::Enum option, void* value, size_t* valueLength) const
{
  *valueLength = 0;

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), SOL_SOCKET, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::GetSocketOption(Status& status, SocketIpv4Option::Enum option, void* value, size_t* valueLength) const
{
  *valueLength = 0;

  // Wrong socket address family?
  if(GetAddressFamily() != SocketAddressFamily::InternetworkV4)
    return FailOnError(status, option, "Invalid socket option, not an IPv4 socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_IP, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::GetSocketOption(Status& status, SocketIpv6Option::Enum option, void* value, size_t* valueLength) const
{
  *valueLength = 0;

  // Wrong socket address family?
  if(GetAddressFamily() != SocketAddressFamily::InternetworkV6)
    return FailOnError(status, option, "Invalid socket option, not an IPv6 socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_IPV6, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::GetSocketOption(Status& status, SocketTcpOption::Enum option, void* value, size_t* valueLength) const
{
  // Wrong socket protocol?
  if(GetProtocol() != SocketProtocol::Tcp)
    return FailOnError(status, option, "Invalid socket option, not a TCP socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_TCP, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::GetSocketOption(Status& status, SocketUdpOption::Enum option, void* value, size_t* valueLength) const
{
  *valueLength = 0;

  // Wrong socket protocol?
  if(GetProtocol() != SocketProtocol::Udp)
    return FailOnError(status, option, "Invalid socket option, not a UDP socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Get socket option
  if(getsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_UDP, (int)option, (char*)value, (socklen_t*)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}

void Socket::SetSocketOption(Status& status, SocketOption::Enum option, const void* value, size_t valueLength)
{
  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), SOL_SOCKET, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::SetSocketOption(Status& status, SocketIpv4Option::Enum option, const void* value, size_t valueLength)
{
  // Wrong socket address family?
  if(GetAddressFamily() != SocketAddressFamily::InternetworkV4)
    return FailOnError(status, option, "Invalid socket option, not an IPv4 socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_IP, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::SetSocketOption(Status& status, SocketIpv6Option::Enum option, const void* value, size_t valueLength)
{
  // Wrong socket address family?
  if(GetAddressFamily() != SocketAddressFamily::InternetworkV6)
    return FailOnError(status, option, "Invalid socket option, not an IPv6 socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_IPV6, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::SetSocketOption(Status& status, SocketTcpOption::Enum option, const void* value, size_t valueLength)
{
  // Wrong socket protocol?
  if(GetProtocol() != SocketProtocol::Tcp)
    return FailOnError(status, option, "Invalid socket option, not a TCP socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_TCP, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}
void Socket::SetSocketOption(Status& status, SocketUdpOption::Enum option, const void* value, size_t valueLength)
{
  // Wrong socket protocol?
  if(GetProtocol() != SocketProtocol::Udp)
    return FailOnError(status, option, "Invalid socket option, not a UDP socket");

  // Translate platform-specific enum as necessary
  TRANSLATE_TO_PLATFORM_ENUM_OR_RETURN_FAILURE(option);

  // Set socket option
  if(setsockopt(CAST_HANDLE_TO_SOCKET(mHandle), IPPROTO_UDP, (int)option, (const char*)value, (int)valueLength) == SOCKET_ERROR) // Unable?
    return FailOnLastError(status);
}

} // namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.cpp
/// Declaration of the Thread class.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

const bool ThreadingEnabled = false;

Thread::Thread()
{
}

Thread::~Thread()
{
}


bool Thread::IsValid()
{
return true;  
}

bool Thread::Initialize(EntryFunction entry, void* instance, cstr threadName)
{
return true;  
}

void Thread::Resume()
{
}


void Thread::Suspend()
{
}


void Thread::Close()
{

}


OsInt Thread::WaitForCompletion()
{
  return 0;
}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadSync.cpp
/// Implementation of Thread synchronization classes.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

ThreadLock::ThreadLock()
{

}

ThreadLock::~ThreadLock()
{

}

void ThreadLock::Lock()
{

}

void ThreadLock::Unlock()
{

}

OsEvent::OsEvent()
{
}

OsEvent::~OsEvent()
{
}

void OsEvent::Initialize(bool manualReset, bool startSignaled)
{

}

void OsEvent::Close()
{

}

void OsEvent::Signal()
{

}

void OsEvent::Reset()
{

}

void OsEvent::Wait()
{

}

Semaphore::Semaphore()
{

}

Semaphore::~Semaphore()
{

}

void Semaphore::Increment()
{

}

void Semaphore::Decrement()
{

}

void Semaphore::Reset()
{

}

void Semaphore::WaitAndDecrement()
{

}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Utilties.cpp
/// Declaration of the Os High precision Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

u64 SecondToNanosecond = 1000000000;
double NanosecondToSecond = 1.0 / double(SecondToNanosecond);

u64 GetTimeNanosecond()
{
// Apple OSes do not implement 'clock_gettime'
#ifdef __APPLE__
  // https://developer.apple.com/library/mac/qa/qa1398/_index.html
  uint64_t time = mach_absolute_time();
  // 'AbsoluteTime' is guaranteed to be a 64 bit wide value, however it's a struct, not a primitive 64 bit value
  Nanoseconds nanoseconds = AbsoluteToNanoseconds(*(AbsoluteTime*)&time);
  return *(uint64_t *)&nanoseconds;
#else
  timespec time;
  clock_gettime(CLOCK_MONOTONIC, &time);
  return ( u64(time.tv_sec) * SecondToNanosecond + time.tv_nsec);
#endif
}

Timer::Timer()
{
  Reset();
}

Timer::~Timer()
{
}

struct TimerPrivateData
{
  Timer::TickType mStart;
  Timer::TickType mLast;
  Timer::TickType mCurrent;
};


void Timer::Reset()
{
  ZeroGetPrivateData(TimerPrivateData);
  self->mStart = GetTimeNanosecond();
  self->mCurrent = self->mStart;
  self->mLast = self->mStart;
}

void Timer::Update()
{
  ZeroGetPrivateData(TimerPrivateData);
  self->mLast = self->mCurrent;
  self->mCurrent = GetTimeNanosecond();
}

double Timer::Time() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return double(self->mCurrent - self->mStart) * NanosecondToSecond;
}

double Timer::TimeDelta() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return double(self->mCurrent - self->mLast) * NanosecondToSecond;
}

double Timer::UpdateAndGetTime()
{
  Update();
  return Time();
}

TimeMs Timer::TimeMilliseconds() const
{
  return TimeMs(Time() * double(1000));
}

TimeMs Timer::TimeDeltaMilliseconds() const
{
  return TimeMs(TimeDelta() * double(1000));
}

TimeMs Timer::UpdateAndGetTimeMilliseconds()
{
  return TimeMs(UpdateAndGetTime() * double(1000));
}

double Timer::TimeNoUpdate() const
{
  ZeroGetPrivateData(TimerPrivateData);
  u64 current = GetTimeNanosecond();
  return double(current - self->mStart) * NanosecondToSecond;
}

Timer::TickType Timer::GetTickTime() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return self->mCurrent;
}

double Timer::TicksToSeconds(TickType ticks) const
{
  return double(ticks) * NanosecondToSecond;
}

} // namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Timer.cpp
/// Declaration of the Os High precision Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////






#include <unistd.h>
#include <pwd.h>

namespace Zero
{

namespace Os
{

void Sleep(uint ms)
{
  usleep (ms * 1000);
}

void DebugBreak()
{
  __builtin_trap();
}

void SystemOpenFile(cstr file, uint verb, cstr workingDirectory)
{
  if(workingDirectory)
    SetWorkingDirectory(workingDirectory);
  system(file);
}

String TranslateErrorCode(int errorCode)
{
  return "None";
}

String GetEnvironmentalVariable(StringRef variable)
{
  return getenv(variable.c_str());
}

bool IsDebuggerAttached()
{
  return true;
}

void SystemOpenFile(cstr file, uint verb, cstr parameters, cstr workingDirectory)
{
    
}

String UserName()
{
  return getlogin();
}

// Get the computer name
String ComputerName()
{
  char hostname[1024];
  hostname[1023] = '\0';
  gethostname(hostname, 1023);
  return hostname;
}

u64 GetMacAddress()
{
  return 0;
}

void SetTimerFrequency(uint ms)
{
  // Not available on linux
}

}//End os

u64 GenerateUniqueId64()
{
  static u64 idGen = 0;
  ++idGen;
  return idGen + rand();
}


void CheckClassMemory(cstr className, byte* classMemory)
{

}

void FatalError(int exitCode)
{
  exit(exitCode);
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file File.cpp
/// Implementation of the Debug class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.hpp
/// Precompiled header for posix library.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////








#include <new>
#include <cstdlib>
#include <cstdio>
#include <ctime>
#include <cctype>
#include <sys/stat.h>
using namespace std;

#endif

///////////////////////////////////////////////////////////////////////////////
///
/// \file Debug.hpp
/// Debug support from the os.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

//Check class for uninitialized memory.
void CheckClassMemory(cstr className, byte* classMemory);

}


namespace Zero
{

void CheckClassMemory(cstr className, byte* classMemory)
{
  Error("Not implemented");
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file File.cpp
/// Implementation of the DirectoryWatcher class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

DirectoryWatcher::DirectoryWatcher(cstr directoryToWatch, CallbackFunction callback, void* callbackInstance)
{
  Error("Not implemented");
}

DirectoryWatcher::~DirectoryWatcher()
{
}

void DirectoryWatcher::Shutdown()
{
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ExternalLibrary.cpp
/// Implementation of the ExternalLibrary class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

ExternalLibrary::ExternalLibrary()
{
  mHandle = nullptr;
  mUnloadOnDestruction = true;
}

ExternalLibrary::~ExternalLibrary()
{
  if(mUnloadOnDestruction)
    Unload();
}

bool ExternalLibrary::IsValid()
{
  return mHandle != nullptr;
}

void ExternalLibrary::Load(cstr filePath)
{
  Error("Not implemented");
}

void ExternalLibrary::Unload()
{
  if(mHandle == nullptr)
    return;
  Error("Not implemented");
  mHandle = nullptr;
}

void* ExternalLibrary::GetFunctionByName(cstr name)
{
  ReturnIf(mHandle == nullptr, nullptr, "Attempting to get a function from an invalid library");
  Error("Not implemented");
  return nullptr;
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file File.cpp
/// Implementation of the Os file class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
//----------------------------------------------------------- File Functions
byte* ReadFileIntoMemory(cstr path, size_t& fileSize, size_t extra)
{
  Error("Not implemented");
  return NULL;
}

DataBlock ReadFileIntoDataBlock(cstr path)
{
  Error("Not implemented");
  return DataBlock();
}

uint WriteToFile(cstr filePath, byte * pData, size_t bufferSize)
{
  Error("Not implemented");
  return 0;
}

//----------------------------------------------------------- File
struct FilePrivateData
{
};

File::File()
{
  Error("Not implemented");
  ZeroConstructPrivateData(FilePrivateData);
}

File::~File()
{
  ZeroGetPrivateData(FilePrivateData);
  // Destruction logic
  ZeroDestructPrivateData(FilePrivateData);
}

bool File::Open(StringParam filePath, FileMode::Enum mode, FileAccessPattern::Enum accessPattern, FileShare::Enum share, Status* status)
{
  ZeroGetPrivateData(FilePrivateData);
  return false;
}

void File::Close()
{
  ZeroGetPrivateData(FilePrivateData);
}

FilePosition File::Tell()
{
  ZeroGetPrivateData(FilePrivateData);
  return 0;
}

bool File::Seek(FilePosition filePosition, FileOrigin::Enum origin)
{
  ZeroGetPrivateData(FilePrivateData);
  return false;
}

size_t File::Write(byte* data, size_t sizeInBytes)
{
  ZeroGetPrivateData(FilePrivateData);
  return 0;
}

size_t File::Read(byte* data, size_t sizeInBytes)
{
  ZeroGetPrivateData(FilePrivateData);
  return 0;
}

size_t File::Size()
{
  ZeroGetPrivateData(FilePrivateData);
  return 0;
}

long long File::CurrentFileSize()
{
  ZeroGetPrivateData(FilePrivateData);
  return 0;
}

bool File::IsOpen()
{
  ZeroGetPrivateData(FilePrivateData);
  return false;
}

void File::Flush()
{
  ZeroGetPrivateData(FilePrivateData);
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FileSystem.cpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
//----------------------------------------------------------- File System Functions
const char  cDirectorySeparatorChar = '/';
const char* cDirectorySeparatorCstr = "/";

bool CopyFileInternal(StringRef dest, StringRef source)
{
  Error("Not implemented");
  return false;
}

bool MoveFileInternal(StringRef dest, StringRef source)
{
  Error("Not implemented");
  return false;
}

bool DeleteFileInternal(StringRef file)
{
  Error("Not implemented");
  return false;
}

void CreateDirectory(StringRef dest)
{
  Error("Not implemented");
}

void CreateDirectoryAndParents(StringRef directory)
{
  Error("Not implemented");
}

int CheckFileTime(StringRef dest, StringRef source)
{
  Error("Not implemented");
  return 0;
}

int SetFileToCurrentTime(StringRef filename)
{
  Error("Not implemented");
  return 0;
}

TimeType GetFileModifiedTime(StringRef filename)
{
  Error("Not implemented");
  return 0;
}

u32 GetFileSize(StringRef fileName)
{
  Error("Not implemented");
  return 0;
}

bool FileExists(StringRef filePath)
{
  Error("Not implemented");
  return false;
}

bool FileWritable(StringRef filePath)
{
  Error("Not implemented");
  return false;
}

bool DirectoryExists(StringRef directoryPath)
{
  Error("Not implemented");
  return false;
}

bool IsDirectory(StringRef directoryPath)
{
  Error("Not implemented");
  return false;
}

String CanonicalizePath(StringRef directoryPath)
{
  Error("Not implemented");
  return directoryPath;
}

String GetWorkingDirectory()
{
  Error("Not implemented");
  return String();
}

void SetWorkingDirectory(String path)
{
  Error("Not implemented");
}

String GetUserLocalDirectory()
{
  Error("Not implemented");
  return String();
}

String GetUserDocumentsDirectory()
{
  Error("Not implemented");
  return String();
}

String GetApplicationDirectory()
{
  Error("Not implemented");
  return String();
}

String GetApplication()
{
  Error("Not implemented");
  return String();
}

String GetTemporaryDirectory()
{
  Error("Not implemented");
  return String();
}

String UniqueFileId(StringRef fullpath)
{
  Error("Not implemented");
  return fullpath;
}

//----------------------------------------------------------- File Range
struct FileRangePrivateData
{
};

FileRange::FileRange(StringRef path)
{
  Error("Not implemented");
  ZeroConstructPrivateData(FileRangePrivateData);
}

FileRange::~FileRange()
{
  ZeroGetPrivateData(FileRangePrivateData);
  // Destructor logic
  ZeroDestructPrivateData(FileRangePrivateData);
}

bool FileRange::empty()
{
  ZeroGetPrivateData(FileRangePrivateData);
  return true;
}

cstr FileRange::front()
{
  ZeroGetPrivateData(FileRangePrivateData);
  return "";
}

void FileRange::popFront()
{
  ZeroGetPrivateData(FileRangePrivateData);
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FpControl.hpp
/// Implementation of the ScpeFpuExceptions, ScoplessFpuExceptions and
/// FpuControlSystem classes.
///
/// Authors: Joshua Davis
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
uint FpuControlSystem::DefaultMask = 0;
bool FpuControlSystem::Active = false;

ScopeFpuExceptionsEnabler::ScopeFpuExceptionsEnabler()
{
  Error("Not implemented");
}

ScopeFpuExceptionsEnabler::~ScopeFpuExceptionsEnabler()
{
}

ScopeFpuExceptionsDisabler::ScopeFpuExceptionsDisabler()
{
  Error("Not implemented");
}

ScopeFpuExceptionsDisabler::~ScopeFpuExceptionsDisabler()
{
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.cpp
/// Generates the precompiled header file.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////


#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Process.cpp
/// Declaration of the Process class.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{

struct ProcessPrivateData
{
};

Process::Process()
{
  Error("Not implemented");
  ZeroConstructPrivateData(ProcessPrivateData);
}

Process::~Process()
{
  ZeroGetPrivateData(ProcessPrivateData);
  // Destruction logic
  ZeroDestructPrivateData(ProcessPrivateData);
}

uint Process::ExecProcess(cstr debugName, cstr commandLine, 
                          TextStream* stream, bool showWindow)
{
  ZeroGetPrivateData(ProcessPrivateData);
  return 0;
}

void Process::WriteToStdIn(cstr text, int size)
{
  ZeroGetPrivateData(ProcessPrivateData);
}

void Process::Shutdown()
{
  ZeroGetPrivateData(ProcessPrivateData);
}

void Process::WaitForClose()
{
  ZeroGetPrivateData(ProcessPrivateData);
}

int Process::GetExitCode()
{
  ZeroGetPrivateData(ProcessPrivateData);
  return 0;
}

void Process::Terminate()
{
  ZeroGetPrivateData(ProcessPrivateData);
}

OsInt Process::ReadThreadEntryPoint()
{
  ZeroGetPrivateData(ProcessPrivateData);
  return 0;
}

}
#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{

bool GetRegistryValue(void* key, StringParam subKey, StringParam value, String& result)
{
  return false;
}

bool GetRegistryValueFromCommonInstallPaths(StringParam programGuid, StringParam keyName, String& result)
{
  return false;
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Resolution.cpp
/// Resolution support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
Resolution GetDesktopResolution()
{
  Error("Not implemented");
  Resolution desktopRes;
  desktopRes.Width = 800;
  desktopRes.Height = 600;
  return desktopRes;
}

void Enumerate(Array<Resolution>& resolutions, int bitDepth, Resolution aspect)
{
  Error("Not implemented");
  resolutions.push_back(GetDesktopResolution());
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.cpp
/// Declaration of the Thread class.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
const bool ThreadingEnabled = false;

struct ThreadPrivateData
{
};

Thread::Thread()
{
  Error("Not implemented");
  ZeroConstructPrivateData(ThreadPrivateData);
}

Thread::~Thread()
{
  ZeroGetPrivateData(ThreadPrivateData);
  // Destruction logic
  ZeroDestructPrivateData(ThreadPrivateData);
}

bool Thread::IsValid()
{
  ZeroGetPrivateData(Thread);
  return false;
}

bool Thread::Initialize(EntryFunction entry, void* instance, cstr threadName)
{
  ZeroGetPrivateData(Thread);
  return false;
}

void Thread::Resume()
{
  ZeroGetPrivateData(Thread);
}

void Thread::Suspend()
{
  ZeroGetPrivateData(Thread);
}

void Thread::Close()
{
  ZeroGetPrivateData(Thread);
}

OsInt Thread::WaitForCompletion()
{
  ZeroGetPrivateData(Thread);
  return 0;
}

bool Thread::IsCompleted()
{
  ZeroGetPrivateData(Thread);
  return true;
}

OsHandle Thread::Detach()
{
  ZeroGetPrivateData(Thread);
  return NULL;
}

OsHandle Thread::GetThreadHandle()
{
  ZeroGetPrivateData(Thread);
  return NULL;
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadSync.cpp
/// Implementation of Thread synchronization classes.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
//----------------------------------------------------------- Thread Lock
struct ThreadLockPrivateData
{
};

ThreadLock::ThreadLock()
{
  Error("Not implemented");
  ZeroConstructPrivateData(ThreadLockPrivateData);
}

ThreadLock::~ThreadLock()
{
  ZeroGetPrivateData(ThreadLockPrivateData);
  // Destruction logic
  ZeroDestructPrivateData(ThreadLockPrivateData);
}

void ThreadLock::Lock()
{
  ZeroGetPrivateData(ThreadLockPrivateData);
}

void ThreadLock::Unlock()
{
  ZeroGetPrivateData(ThreadLockPrivateData);
}


//----------------------------------------------------------- Os Event
OsEvent::OsEvent()
{
  Error("Not implemented");
  mHandle = NULL;
}

OsEvent::~OsEvent()
{
}

void OsEvent::Initialize(bool manualReset, bool startSignaled)
{
}

void OsEvent::Close()
{
}

void OsEvent::Signal()
{
}

void OsEvent::Reset()
{
}

void OsEvent::Wait()
{
}

//----------------------------------------------------------- Semaphore
Semaphore::Semaphore()
{
  Error("Not implemented");
  mHandle = NULL;
}

Semaphore::~Semaphore()
{
}

void Semaphore::Increment()
{
}

void Semaphore::Decrement()
{
}

void Semaphore::Reset()
{
}

void Semaphore::WaitAndDecrement()
{
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Utilties.cpp
/// Declaration of the Os High precision Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////



namespace Zero
{
struct TimerPrivateData
{
};

Timer::Timer()
{
  Error("Not implemented");
  ZeroConstructPrivateData(TimerPrivateData);
}

Timer::~Timer()
{
  ZeroGetPrivateData(TimerPrivateData);
  // Destruction logic
  ZeroDestructPrivateData(TimerPrivateData);
}

void Timer::Reset()
{
  ZeroGetPrivateData(TimerPrivateData);
}

void Timer::Update()
{
  ZeroGetPrivateData(TimerPrivateData);
}

double Timer::Time() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return 0.0;
}

double Timer::TimeDelta() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return 1.0 / 60.0;
}

double Timer::UpdateAndGetTime()
{
  ZeroGetPrivateData(TimerPrivateData);
  return 0.0;
}

TimeMs Timer::TimeMilliseconds() const
{
  return TimeMs(Time() * double(1000));
}

TimeMs Timer::TimeDeltaMilliseconds() const
{
  return TimeMs(TimeDelta() * double(1000));
}

TimeMs Timer::UpdateAndGetTimeMilliseconds()
{
  return TimeMs(UpdateAndGetTime() * double(1000));
}

double Timer::TimeNoUpdate() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return 0.0;
}

Timer::TickType Timer::GetTickTime() const
{
  ZeroGetPrivateData(TimerPrivateData);
  return 0;
}

double Timer::TicksToSeconds(TickType ticks) const
{
  ZeroGetPrivateData(TimerPrivateData);
  return 0.0;
}

}//namespace Zero

#endif

#if defined(PLATFORM_EMSCRIPTEN)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Timer.cpp
/// Declaration of the Os High precision Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////




namespace Zero
{

namespace Os
{

void Sleep(uint ms)
{
  Error("Not implemented");
}

void SetTimerFrequency(uint ms)
{
  Error("Not implemented");
}

String UserName()
{
  return "User";
}

String ComputerName()
{
  return "Computer";
}

u64 GetMacAddress()
{
  Error("Not implemented");
  return 0;
}

bool IsDebuggerAttached()
{
  Error("Not implemented");
  return false;
}

void DebugBreak()
{
  Error("Not implemented");
}

void SystemOpenFile(cstr file, uint verb, cstr parameters, cstr workingDirectory)
{
  Error("Not implemented");
}

void GetMemoryStatus(MemoryInfo& data)
{
  Error("Not implemented");
}

String GetEnvironmentalVariable(StringRef variable)
{
  Error("Not implemented");
  return String();
}

String TranslateErrorCode(int errorCode)
{
  Error("Not implemented");
  return String();
}

String GetVersionString()
{
  Error("Not implemented");
  return String();
}

}

u64 GenerateUniqueId64()
{
  Error("Not implemented");
  return 0;
}


}//namespace Zero

#endif



#if defined(TEMP_DISABLE_UNICODE)
  #define UNICODE
  #undef TEMP_DISABLE_UNICODE
#endif