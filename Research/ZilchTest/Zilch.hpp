/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Note: This header is typically used as a precompiled header

// Include protection
#pragma once
#ifndef ZILCH_COMMON_HPP
#define ZILCH_COMMON_HPP

// This needs to be included before anything else
// since it disables warnings and defines macros we use
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_GENERAL_HPP
#define ZILCH_GENERAL_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_LOCAL_BUILD_HPP
#define ZILCH_LOCAL_BUILD_HPP

// For the published build of Zilch, we remove 'todo' statements as
// they are annoying (and are akin to warnings). For our own local
// build, we enable them by removing the below macro
#define ZilchTodo(text)

// End header protection
#endif


namespace Zilch
{
  // Defines
  #ifndef ZilchLoop
    #define ZilchLoop for (;;)
  #endif

  // Helper macros for stringifiying previous #defines
  #define ZilchStr(Argument) #Argument
  #define ZilchStringify(Argument) ZilchStr(Argument)

  // Don't allow copying of a type
  #define ZilchNoCopy(type)       \
    private:                      \
    type& operator=(const type&); \
    type(const type&);

  // Don't allow copying of a type
  #define ZilchNoDefaultConstructor(type) \
    private:                              \
    type();
  
  // Don't allow destruction of a type
  #define ZilchNoDestructor(type) \
    private:                      \
    ~type();

  // Don't allow instantiations of this type
  #define ZilchNoInstantiations(type) \
    private:                          \
    type();                           \
    ~type();                          \
    type& operator=(const type&);     \
    type(const type&);

  // Helper macros
  #define ZilchStringDeref(text) #text
  #define ZilchStringize(text) ZilchStringDeref(text)

  // Shows a todo message
  #ifndef ZilchTodo
    #define ZilchTodo(text) __pragma(message(__FILE__ "(" ZilchStringize(__LINE__) ") : Todo: " text))
  #endif

  // MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
  // MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
  // MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
  // MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
  // MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
  // MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
  // MSVC++ 7.0  _MSC_VER == 1300
  // MSVC++ 6.0  _MSC_VER == 1200
  // MSVC++ 5.0  _MSC_VER == 1100

  
  // Thread local storage is supported by everything but clang on Windows. Also not supported on some special platforms
  #if !(defined(__clang__) && (defined(_WIN32) || defined(WIN32)) || defined(PLATFORM_3DS))
    #define ZilchSupportsThreadLocalStorage
  #endif

  // If we're running 0x features in gcc, or the C++ version is defined, or we're in VS2010 or later...
  #if defined(__GXX_EXPERIMENTAL_CXX0X__) ||  __cplusplus >= 201103L || _MSC_VER >= 1600
    #define ZilchSupportsDecltypeAuto
    #define ZilchSupportsNullptr
    #define ZilchSupportsStaticAssert
  #endif

  // This just changes how we do auto, theoretically the same (it's all wrapped in a macro anyways...)
  //#define ZilchUseDeclTypeForAuto


  // *************** Compiler Specific Warnings ***************

  // If we're on Clang or Gcc...
  #if defined(__clang__) || defined(__GNUC__)
    #if defined(__clang__)
      // Ignore unknown pragma warnings...
      #pragma clang diagnostic ignored "-Wunknown-pragmas"
    #else
      // Ignore unknown pragma warnings...
      #pragma GCC diagnostic ignored "-Wpragmas"
    #endif

    // We have many valid switch statements that don't handle all values
    #pragma GCC diagnostic ignored "-Wswitch"

    // We use offsetof, which is technically compiler specific and undefined, but works on all supported platforms
    #pragma GCC diagnostic ignored "-Winvalid-offsetof"

    // This should be investigated for a better method (generally it's for shoving values into void* user data)
    #pragma GCC diagnostic ignored "-Wint-to-pointer-cast"

    // When we force inline some functions, gcc has a very complicated way of determining if a function can be inlined or not
    // If it decides the function does not get inlined, and the function was actually implemented in the cpp (not the header, link time code-gen)
    // then it complains about the function being unused (which it's absolutely not, seems like a gcc bug)
    #pragma GCC diagnostic ignored "-Wunused-function"

    // We declare typedefs that may be useful for people using Zilch, but we don't use them ourselves
    #pragma GCC diagnostic ignored "-Wunused-local-typedefs"

  #endif

  // If we're on the Microsoft compiler (MSVC)...
  #ifdef _MSC_VER
    // We don't want to get warned about security
    #ifndef _CRT_SECURE_NO_WARNINGS
      #define _CRT_SECURE_NO_WARNINGS
    #endif

    // We don't consider unreferenced parameters to be an error
    #pragma warning(disable : 4100)

    // Unfortunately, local variable initialized but not referenced is actually a very
    // useful warning, however there are cases where we only initialize variables to be
    // used in debug checks, which this will complain / error in release
    // There are also other cases where we explicitly invoke destructors for class binding
    // and if the destructor is trivial, it complains that the self parameter is not used
    #pragma warning(disable : 4189)

    // We get a warning about an outer structure being padded due to inner members having alignment specifications
    // An example of this is using jmp_buf anywhere (such as in PerFrameData) especially with 64-bit compatability warnings
    #pragma warning(disable : 4324)

    // We really don't care about C++ initializing POD types to zero
    #pragma warning(disable : 4345)

    // Disable the 'this' in base initializer, since we use it to track owners
    #pragma warning(disable : 4355)

    // Ignore the warning about a non-standard extension for 'override'
    // It really is way too useful (both for documentation and error checking)
    #pragma warning(disable : 4481)

    // This is a warning about unused functions being removed, but there is a serious issue with VS2010
    // where it can end up removing a virtual [thunk] function and then it warns you about it
    // (seems to be when combined with SFINAE testing for the virtual member)
    #pragma warning(disable : 4505)

    // Disable the execption handling warning. We don't use exceptions in Zilch
    // because many console and embedded systems do not support them)
    #pragma warning(disable : 4530)

    // For virtual function binding we need to ignore warnings about no constructors
    // being generated, as well as warnings about a class not being able to be instantiated
    #pragma warning(disable : 4510)
    #pragma warning(disable : 4610)

    // Disable "Interaction between '_setjmp' and C++ object destruction is non-portable"
    // We use setjmp / longjmp for exception handling, and we make sure to properly handle
    // destruction of objects
    #pragma warning(disable : 4611)

    // Disable warnings about deprecated function calls (primarily WIN32)
    // It's nice to know these are deprecated, but we'll deal with them when they become actual errors
    #pragma warning(disable : 4996)

    // Static analysis complains about passing a 'char' into isspace and similar functions
    // For some weird reason it requires casting the char to an 'unsigned char', even though isspace is defined to take an int
    // This is well formed C and C++ code, static analysis is complaining about it
    #pragma warning(disable : 6330)

    // Static analysis also complains about the use of alloca, which has a well defined meaning
    // It recommends the usage of _malloca, a completely non-standard MSVC only function which functions EXACTLY the same in Release mode
    #pragma warning(disable : 6255)

    // Disabling the local declaration hiding, for now (this one is the most valid, but we have valid cases for it)
    #pragma warning(disable : 6246)

    // Static analysis also complains about 'Dereferencing NULL pointer' for every single instance we use in-place new, which is simply not correct
    #pragma warning(disable : 6011)

    // Comparing a constant to another constant (not caught by the W4 via templates) is considered bad by static analysis, even though
    // it completly makes sense and will be optimized out if it is in fact a constant
    #pragma warning(disable : 6326)

    // This particular warning complains about the dereferencing a null pointer because it implied
    // that a variable could be null (assigned to another variable, check that variable)
    // The entire warning is fundamentally flawed:
    //  Player* foundPlayer = nullptr;
    //  if (SomeCondition)
    //  {
    //    Player* globalPlayer = GrabGlobalPlayer();
    //    if (globalPlayer->IsAlive()) <--- Here it complains that 'globalPlayer' could be null, simply because of the below line
    //      foundPlayer = globalPlayer;
    //  }
    //  if (foundPlayer != nullptr) <--- It sees that 'foundPlayer' is being checked for null, and because foundPlayer
    //    ...                            is assigned from nearestPlayer, then it thinks 'globalPlayer' could be null
    #pragma warning(disable : 28182)

    // Standard examples (such as setting thread name) from Microsoft's own documentation cause the static analysis to complain
    // about __try and __catch (about continuing from the exception possibly causing an infinite loop, which it does not)
    #pragma warning(disable : 6312)
    #pragma warning(disable : 6322)

    // Disable a warning about doing well defined operations on bools
    #pragma warning(disable : 6323)

    ZilchTodo("These must be fixed / examined");
    #pragma warning(disable : 6201)
    #pragma warning(disable : 6031)

    // These static analysis warnings are literally happening inside Microsoft's own 'wspiapi.h'
    #pragma warning(disable : 6101)
    #pragma warning(disable : 6102)
    #pragma warning(disable : 6387)
    #pragma warning(disable : 6386)
    #pragma warning(disable : 28196)

    // We don't care about using deprecated Windows code, we'll change it later if we care
    #pragma warning(disable : 28159)

  #endif


  // *************** Compiler Specific Macros ***************

  // If we're on the Microsoft compiler...
  #ifdef _MSC_VER
    
    // When we want to declare a thread local variable
    // This must be used in the declaration (after static or extern if applicable)
    // and also in the cpp file before anything
    // Thread locals cannot be initialized
    #define ZilchThreadLocal __declspec(thread)

    // On some compilers we need to define static thread locals (as members of a class)
    // This macro will remove any of its contents for compilers that don't need it
    #define ZilchDefineStaticThreadLocal(StaticVariableDefinition) StaticVariableDefinition
    
    // Atttempts to trigger a breakpoint in the debugger
    #define ZilchDebugBreak() __debugbreak()

    // Converts a string to a double integer
    #define ZilchStrToDoubleInteger(CStr, Base) _strtoui64(CStr, nullptr, Base)

    // Forces a function to be inlined for optimization purposes
    #define ZilchForceInline inline __forceinline

    // Forces a function to not be inlined (only used to debug, and unfortunately to fix true linker bugs)
    #define ZilchNoInline __declspec(noinline)

  #else
    #ifndef override
      // We don't have access to the 'override' keyword
      #define override
    #endif
    
    // When we want to declare a thread local variable
    // This must be used in the declaration (after static or extern if applicable)
    // and also in the cpp file before anything
    // Thread locals cannot be initialized
    #ifdef ZilchSupportsThreadLocalStorage
      #define ZilchThreadLocal __thread
    #else
      #define ZilchThreadLocal
    #endif

    // On some compilers we still need to define static thread locals (as members of a class)
    // This macro will remove any of its contents for compilers that don't need it
    #define ZilchDefineStaticThreadLocal(StaticVariableDefinition)

    // Atttempts to trigger a breakpoint in the debugger
    #define ZilchDebugBreak()

    // Converts a string to a double integer
    #define ZilchStrToDoubleInteger(CStr, Base) strtoull(CStr, nullptr, Base)

    // Forces a function to be inlined for optimization purposes
    // There seems to be issues with __attribute__((always_inline)) wit GCC linking
    #ifdef PLATFORM_3DS
      #define ZilchForceInline
    #else
      #define ZilchForceInline inline
    #endif

    // Forces a function to not be inlined (only used to debug, and unfortunately to fix true linker bugs)
    #define ZilchNoInline

  #endif

  #ifdef ZilchSupportsDecltypeAuto
    // Most modern compilers support decltype...
    #define ZilchTypeOf(Expression) decltype(Expression)

    #ifdef ZilchUseDeclTypeForAuto

      template <typename T>
      class StripRef
      {
      public:
        typedef T Type;
      };

      template <typename T>
      class StripRef<T&>
      {
      public:
        typedef T Type;
      };

      // We can use decltype for auto, but the big issue is that normally auto requires you to specify
      // if it's a reference or not (&). The decltype always infers the reference, so we have to strip it
      #define ZilchAutoVal(VariableName, Expression) StripRef<decltype(Expression)>::Type VariableName = Expression;
      #define ZilchAutoRef(VariableName, Expression)          decltype(Expression)&       VariableName = Expression;

    #else
      // Infer the type of an expression and store within a variable
      // Used for some template situations where determining the expression's type is tedious
      #define ZilchAutoVal(VariableName, Expression) auto  VariableName = Expression;
      #define ZilchAutoRef(VariableName, Expression) auto& VariableName = Expression;
    #endif

  #else
    // A few really really bad/archaic compilers don't (hopefully they have typeof!)
    #define ZilchTypeOf(Expression) typeof(Expression)

    // Infer the type of an expression and store within a variable
    // Used for some template situations where determining the expression's type is tedious
    #define ZilchAutoVal(VariableName, Expression) typeof(Expression)  VariableName = Expression;
    #define ZilchAutoRef(VariableName, Expression) typeof(Expression)& VariableName = Expression;
  #endif

  // Visual Studio 2010's (and maybe other compilers) decltype has an issue with getting the type
  // of the address of a function template instantiation (decltype(Lerp<Real>) for instance).
  // This template and macro are a work around for doing this.
  template <typename T>
  T ZilchFunctionPointerPassThrough(T);
  #define ZilchTypeOfFunctionPointer(FunctionPointer)  ZilchTypeOf(ZilchFunctionPointerPassThrough(FunctionPointer))

  // If we support static assert (otherwise there's an alternative not as clear way)
  #ifdef ZilchSupportsStaticAssert
    #define ZilchStaticAssert(ConstantExpression, StringMessage, OldMessageName)  \
      static_assert(ConstantExpression, StringMessage)
  #else
    #define ZilchStaticAssert(ConstantExpression, StringMessage, OldMessageName)  \
      static const int OldMessageName = (sizeof(char[1 - 2 * !(ConstantExpression)]))
  #endif

  // Macro for figuring out the size of a fixed C-array
  #define ZilchCArrayCount(x) ((sizeof(x) / sizeof(0[x])) / ((size_t)(!(sizeof(x) % sizeof(0[x])))))

  // A class we use when we're either debugging or refactoring
  // This class attempts to act as a placeholder for any other class
  template <typename ToEmulate>
  class DebugPlaceholder
  {
  public:

    DebugPlaceholder()
    {
    }

    template <typename T>
    DebugPlaceholder(const T&)
    {
    }

    operator ToEmulate()
    {
      return ToEmulate();
    }

    template <typename T>
    T& operator=(T& value)
    {
      return value;
    }

    template <typename T>
    const T& operator=(const T& value)
    {
      return value;
    }

    template <typename T>
    bool operator==(const T&) const
    {
      return false;
    }

    template <typename T>
    bool operator!=(const T&) const
    {
      return false;
    }
  };
}

// End header protection
#endif


// C Standard Library
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>
#include <ctime>
#include <limits>

// Zero includes
///////////////////////////////////////////////////////////////////////////////
///
/// \file Standard.hpp
/// Include standard header files.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Make sure the min and max macros aren't defined
#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif

// Compiler Errors / Warnings
#ifdef _MSC_VER
  #define ZNestedTemplate

  #ifndef _DEBUG
  #define _SECURE_SCL 0
  #endif

  // Enable these warnings by setting them to level 3
  // Enable warning function does not override any base class virtual member function
  // this is useful to catch renaming virtual functions
  #pragma warning(3: 4263)

  // Enable warning level 3 Conversion of an Enum to a integral type
  #pragma warning(3: 4239)

  // Ignore the warning about unusual use of type bool
  #pragma warning(disable: 4804)

  // Ignore the warning about forcing value to bool
  #pragma warning(disable: 4800)

  // We don't care about 'behavior change - pod constructors'
  #pragma warning(disable: 4345)

  // Ignore the warning about placement-new for POD data
  #pragma warning(disable: 4345)

  // Constants in 'if' and 'while' are used for debug macros
  #pragma warning(disable: 4127)

  // Disable the warning 'this' in base initializer
  #pragma warning(disable: 4355)

  // We use the nameless struct/union extension and it is legal
  // on other compilers
  #pragma warning(disable: 4201)

  // Disable deprecation warnings
  #pragma warning(disable:4996)

#ifdef WIN64
  // Temporary 64-bit support (ignore size_t conversion warnings)
  #pragma warning(disable: 4244)
  #pragma warning(disable: 4267)
  #pragma warning(disable: 4309)
#endif

#else

  // gcc requires this keyword with a templated class that
  // returns another templated class inside of itself
  #define ZNestedTemplate template

  // Make override empty
  #define override
#endif

// A temporary non-thread safe buffer that is only used for counting the lengths of printfs
extern char gDiscardBuffer[2];

// These functions are specific to all compilers on Windows
#if defined(_WIN32) || defined(WIN32)
  #define ZeroVSPrintfCount(format, pargs, extraSize, resultSize) resultSize = _vscprintf(format, pargs) + extraSize
  #define ZeroSPrintfCount(format, ...) _scprintf(format, __VA_ARGS__)
#endif

// Printing Macros
#ifdef _MSC_VER

  #define ZeroVSPrintf(destination, bufferSizeBytes, format, args) \
    vsprintf_s(destination, bufferSizeBytes, format, args)

  #define ZeroSPrintf(destination, bufferSizeBytes, format, ...) \
    sprintf_s(destination, bufferSizeBytes, format, __VA_ARGS__)

  #define ZeroStrCat(destination, bufferSizeBytes, source) \
    strcat_s(destination, bufferSizeBytes, source)

  #define ZeroStrCpy(destination, bufferSizeBytes, source) \
    strcpy_s(destination, bufferSizeBytes, source)

  #define ZeroCStringCopy(dest, destSize, source, sourceSize) \
    strncpy_s(dest, (destSize), source, sourceSize);

#if _MSC_VER < 1800
  #define va_copy(dest, source) \
    dest = source;
#endif

#else
#include <stdio.h>
// If these functions weren't defined above, define them now
#ifndef ZeroVSPrintfCount
  #define ZeroVSPrintfCount(format, pargs, extraSize, resultSize)             \
  do                                                                          \
  {                                                                           \
    va_list sizeArgs;                                                         \
    va_copy(sizeArgs, pargs);                                                 \
    resultSize = vsnprintf(gDiscardBuffer, 1, format, sizeArgs) + extraSize;  \
  }                                                                           \
  while (false)

  #define ZeroSPrintfCount(format, ...) snprintf(gDiscardBuffer, 1, format, __VA_ARGS__)

#endif

  #define ZeroVSPrintf(destination, bufferSizeBytes, format, args) \
    vsnprintf(destination, bufferSizeBytes, format, args)

  #define ZeroSPrintf(destination, bufferSizeBytes, format, ...) \
    snprintf(destination, bufferSizeBytes, format, __VA_ARGS__)

  #define ZeroStrCat(destination, bufferSizeBytes, source) \
    strncat(destination, source, bufferSizeBytes)

  #define ZeroStrCpy(destination, bufferSizeBytes, source) \
    strncpy(destination, source, bufferSizeBytes)

  #define ZeroCStringCopy(dest, destSize, source, sourceSize) \
    strncpy(dest, source, sourceSize);
#endif

// Includes for alloca
// This behavior changes per platform rather than per compiler (Clang on Windows still uses malloc.h)
#if !defined(WIN64) &&  !defined(WIN32) && !defined(_WIN64) &&  !defined(_WIN32)
#include <alloca.h>
#elif defined(NP2)
#include <alloca.h>
#else
#include <malloc.h>
#endif

#if defined(__GXX_EXPERIMENTAL_CXX0X) ||  __cplusplus >= 201103L || _MSC_VER >= 1600
  #define ZeroSupportsDecltypeAuto 1
  #define ZeroSupportsStaticAssert 1

  #if defined(__GNUC__)
    #if __GNUC__ >= 4 && __GNUC_MINOR__ >= 7
      #define ZeroSupportsNullptr 1
    #endif
  #else
    #define ZeroSupportsNullptr 1
  #endif
#endif

#ifdef ZeroSupportsDecltypeAuto
#define TypeOf(type) decltype(type)
#else
#define TypeOf(type) __typeof__(type)
#endif

#define ZeroCompileTimeTestType(T) T = 0;
#define ZeroCompileTimeTestTypeExpression(Expression) TypeOf(Expression) = 0;

// Visual Studio 2010's (and maybe other compilers) decltype has an issue with getting the type
// of the address of a function template instantiation (decltype(Lerp<Real>) for instance).
// This template and macro are a work around for doing this.
template <typename T>
T FunctionPointerPassThrough(T);
#define TypeOfFunctionPointer(type) TypeOf(FunctionPointerPassThrough(type))

#if _MSC_VER
  #define ZeroHasTypeOf 0
  #if _MSC_VER >= 1600
    #define ZeroHasAuto 1
  #else 
    #define ZeroHasAuto 0
#endif
#else
  #define ZeroHasTypeOf 1
  #define ZeroHasAuto 0
#endif

#if ZeroHasAuto
  #define AutoDeclare(varName, expression) \
    auto varName = expression

  #define AutoDeclareReference(varName, expression) \
    auto& varName = expression
#else
  #define AutoDeclare(varName, expression) \
    TypeOf(expression) varName = expression

  #define AutoDeclareReference(varName, expression) \
    TypeOf(expression)& varName = expression
#endif

#ifdef _MSC_VER
#define SupportsMoveSemantics
#define SupportsStaticAsserts
#elif __cplusplus >= 201103L
#define SupportsMoveSemantics
#define SupportsStaticAsserts
#endif

#ifdef _MSC_VER
  #define ZeroThreadLocal __declspec(thread)
#elif PLATFORM_3DS
  #define ZeroThreadLocal
#else
  #define ZeroThreadLocal __thread
#endif

#ifdef _WIN32
  #define ZeroExport extern "C" __declspec(dllexport)

  #if defined(ZeroImportDll)
    #define ZeroShared __declspec(dllimport)
  #elif defined(ZeroExportDll)
    #define ZeroShared __declspec(dllexport)
  #else
    #define ZeroShared
  #endif
#else
  #define ZeroShared __attribute__((visibility("default")))
  #define ZeroExport extern "C" __attribute__((visibility("default")))
#endif

#if defined(ZeroImportDll)
  #define ZeroSharedTemplate
  #pragma warning(disable: 4251)
#elif defined(ZeroExportDll)
  #define ZeroSharedTemplate ZeroShared
#else
  #define ZeroSharedTemplate
#endif

#ifdef ZeroSharedWarnings
  // We actually want shared warnings (leave this here for debugging)
#else
  #ifndef PLATFORM_3DS
    #pragma warning(disable: 4251)
  #endif
  #undef ZeroSharedTemplate
  #define ZeroSharedTemplate
#endif

///////////////////////////////////////////////////////////////////////////////
///
/// \file Typedefs.hpp
/// Common typedefs used throughout the projects.
///
/// Authors: Benjamin Strukus, Andrew Colean
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Signed Integral Types
typedef signed long long smax;
typedef signed long long slonglong;
typedef signed long      slong;
typedef signed int       sint;
typedef signed short     sshort;
typedef signed char      schar;

// Unsigned Integral Types
typedef unsigned long long umax;
typedef unsigned long long ulonglong;
typedef unsigned long      ulong;
typedef unsigned int       uint;
typedef unsigned short     ushort;
typedef unsigned char      uchar;
typedef unsigned char      byte;

// Fixed-Width Signed Integral Types
typedef signed long long s64;
typedef signed int       s32;
typedef signed short     s16;
typedef signed char      s8;

// Fixed-Width Unsigned Integral Types
typedef unsigned long long u64;
typedef unsigned int       u32;
typedef unsigned short     u16;
typedef unsigned char      u8;

// Floating Point Types
typedef float  f32;
typedef double f64;

// Other Types
typedef const char* cstr;

///////////////////////////////////////////////////////////////////////////////
///
/// \file Console.hpp
/// Declaration of the Console
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <stdarg.h>

namespace Zero
{

//Console Filtering
typedef unsigned int FilterType;
namespace Filter
{
enum Enum
{
  DefaultFilter     = 0x0001, //No filter provided
  UserFilter        = 0x0002, //Filter for object creation.
  ErrorFilter       = 0x0004, //Filter for all Error and warnings
  ResourceFilter    = 0x0008, //Filter for Resource Operations
  EngineFilter      = 0x0010, //Filter for Core Engine Operations
  ActiveFilter      = 0x0020, //Filter for debugging
  PerformanceFilter = 0x0040, //Filter for performance (Framerate, etc)
  PhysicsFilter     = 0x0080 //Filter for Physics
};
}//namespace Filter

//------------------------------------------------------------- Console Listener
//LogFilter Interface
class ConsoleListener
{
public:
  // ConsoleListener Interface

  // Print a null terminated message.
  virtual void Print(FilterType filterType, cstr message) = 0;
  // Flush out output (Called when crashing)
  virtual void Flush(){}
  // Auto remove on destructor
  virtual ~ConsoleListener();
};

//---------------------------------------------------------------------- Console
// The Console for debugging, diagnostic, and displaying engine status.
// Uses C Style output semantics.
// Example: DebugPrint("Finished loading Node %d\n", 56);
class Console
{
public:
  static void Print(Filter::Enum filter, cstr format, ...);
  static void PrintRaw(Filter::Enum filter, cstr data);
  static void Add(ConsoleListener* listener);
  static void Remove(ConsoleListener* lister);
  static void FlushAll();
private:
  static void PrintVa(Filter::Enum, cstr format, va_list va);
};

}//namespace Zero

//Enable print of debug messages to the console
#if !defined(ZERO_ENABLE_DEBUG_CONSOLE) 
#   if defined(_DEBUG)
#       define ZERO_ENABLE_DEBUG_CONSOLE 1
#   else
#       define ZERO_ENABLE_DEBUG_CONSOLE 0
#   endif
#endif

#define ZPrintFilter(filter, ...) ::Zero::Console::Print(filter, __VA_ARGS__)
#define ZPrint(...) ::Zero::Console::Print(Zero::Filter::DefaultFilter, __VA_ARGS__)

// Debug printing functions will only print in debug builds

#if ZERO_ENABLE_DEBUG_CONSOLE

#define DebugPrintFilter(filter, ...) ::Zero::Console::Print(filter, __VA_ARGS__)
#define DebugPrint(...) ::Zero::Console::Print(Zero::Filter::DefaultFilter, __VA_ARGS__)
#define DebugTrace(format, ...) ::Zero::Console::Print(Zero::Filter::DefaultFilter, "%s(%d) : " format , __FILE__ , __LINE__, __VA_ARGS__)

#else

#define DebugPrintFilter(...)  ((void)0)
#define DebugPrint(...) ((void)0)
#define DebugTrace(...) ((void)0)

#endif

///////////////////////////////////////////////////////////////////////////////
///
/// \file Misc.hpp
/// Miscellaneous functions.
///
/// Authors: 
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <stddef.h>
#include <string.h>
#include <limits.h>
///////////////////////////////////////////////////////////////////////////////
///
/// \file Time.hpp
/// 
/// Authors: Joshua Davis
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#ifndef PLATFORM_3DS
#include <time.h>
#endif

namespace Zero
{

#ifdef PLATFORM_3DS
  typedef __int64 TimeType;
#else
  typedef time_t TimeType;
#endif

// Structure to mimick the C-standard tm struct
// Only change is that the year is 0 based instead of 1900
struct CalendarDateTime
{
  int Seconds;
  int Minutes;
  int Hour;
  int Day;
  int Month;
  // Years from year 0
  int Year;
  // Days since Sunday
  int Weekday;
  // Days since January 1
  int Yearday;
  int IsDaylightSavings;
};

class Time
{
public:

  static TimeType GetTime();
  static TimeType Clock();
  static TimeType GenerateSeed();

  static CalendarDateTime GetLocalTime(const TimeType& timer);
  static TimeType CalendarDateTimeToTimeType(const CalendarDateTime& time);
  static TimeType ClocksPerSecond();

  static const char* GetMonthString(int month)
  {
    const char* cDates[] = {"January", "February", "March", "April", "May",
                             "June", "July", "August", "September",
                             "October", "November", "December"};

    return cDates[month];
  }
};

} // namespace Zero


namespace Zero
{

//Smaller of two is put in the top 32 bits.
u64 GetLexicographicId(u32 id1, u32 id2);
//Unpacks the pair id into the two ids. Id1 is the lower 32 bits.
void UnPackLexicographicId(u32& id1, u32& id2, u64 pairId);

template <typename T>
size_t RangeCount(T range)
{
  size_t count = 0;
  while (!range.empty())
  {
    ++count;
    range.popFront();
  }

  return count;
}

template <typename T>
class RecallOnDestruction
{
public:
  T* mVariable;
  T mRecallToValue;

  RecallOnDestruction(T* variable)
  {
    mRecallToValue = *variable;
    mVariable = variable;
  }

  RecallOnDestruction(T* variable, T recallToValue)
  {
    mRecallToValue = recallToValue;
    mVariable = variable;
  }

  ~RecallOnDestruction()
  {
    *mVariable = mRecallToValue;
  }
};

template <typename T>
class SetAndRecallOnDestruction : public RecallOnDestruction<T>
{
public:
  SetAndRecallOnDestruction(T* variable, T setToValue) :
    RecallOnDestruction<T>(variable)
  {
    *variable = setToValue;
  }

  SetAndRecallOnDestruction(T* variable, T setToValue, T recallToValue) :
    RecallOnDestruction<T>(variable, recallToValue)
  {
    *variable = setToValue;
  }
};

template<typename RefType>
void SafeRelease(RefType& interfacePtr)
{
  if(interfacePtr)
    interfacePtr->Release();
  interfacePtr = NULL;
}

template<typename RefType>
void SafeDelete(RefType& objectPtr)
{
  if(objectPtr)
    delete objectPtr;
  objectPtr = NULL;
}

template<typename RefType>
void SafeDeleteArray(RefType& objectPtr)
{
  if(objectPtr)
    delete[] objectPtr;
  objectPtr = NULL;
}

template<typename type>
void SafeDestroy(type*& instance)
{
  if(instance)
    instance->Destroy();
  instance = NULL;
}

template<typename type>
void ZeroClassMemory(type& classRef)
{
  memset(&classRef, 0, sizeof(type));
}

const TimeType cTimeMax = LONG_MAX;

/// Test if the current machine is big or little endian
bool IsBigEndian();

/// Returns number of least significant zeros
/// If x is strictly a power of 2, will result in n where 2^n=x, values [0, 31]
/// More information: http://en.wikipedia.org/wiki/Find_first_set
u32 CountTrailingZeros(u32 x);
/// Returns number of most significant zeros
u32 CountLeadingZeros(u32 x);

/// Will result in zero if most significant bit is set
u32 NextPowerOfTwo(u32 x);

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file NullPtr.hpp
///
/// Authors: Joshua Davis
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#if defined(ZeroSupportsNullptr)

#include <cstddef>

namespace Zero
{
  typedef std::nullptr_t NullPointerType;
}

#else // CAFE and older versions of GCC / Clang

namespace Zero
{
  class __NullPointerType
  {
  };
  
  typedef const __NullPointerType* NullPointerType;
}

#define nullptr NULL

#endif


// Similar to std::declval
template <typename T>
T& DeclVal()
{
  return *(T*)nullptr;
}

///////////////////////////////////////////////////////////////////////////////
///
/// \file String.hpp
/// Declaration of the Referenced counted string class.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file Hashing.hpp
/// HahsedContainer Container used to implement of HashMap and HashSet.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once
///////////////////////////////////////////////////////////////////////////////
///
/// \file ContainerCommon.hpp
/// Container Support.
///
/// Authors: Chris Peters, Andrew Colean
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes

///////////////////////////////////////////////////////////////////////////////
///
/// \file Diagnostic.hpp
/// Declaration of the basic debug diagnostic functions.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once



/*

These macros are only for displaying information to developers. 
For informing a user of errors use the notification system.

Warn/WarnIf: Indicates an problem has occurred but execution will continue
             normally. The problem will be handled locally but may also have 
             to be handled by the caller. By default in a development build this 
             will trigger a debug break but execution can continue.
             Examples: Scripting Errors, File Not Found, Bad Sound Name, etc 

ReturnIf: Operates the same as Warn except that the it will cause the current 
          block to return with the provided parameter if expression if true. 
          Used as a shorthand instead of
          if(a) { Warn(a,"message") return errorCode; }

Error/ErrorIf: Indicates that a problem has occurred and if execution continues 
               it will put the program in a invalid state and most likely crash.
               The equivalent of assert this always triggers a break point expect
               in the final build where the program will crash.

Verify(): Runs the function and generates an error if the function returns non
          zero. When diagnostic disabled the function call will remain but the
          error code will be removed.
*/

#ifdef _MSC_VER
  #define ZERO_DEBUG_BREAK __debugbreak()
#elif PLATFORM_3DS
  #include "DebugBreak.hpp" //@ignore (for the compactor turning this into a single hpp/cpp)
#else
  #define ZERO_DEBUG_BREAK
#endif

namespace Zero
{

//---------------------------------------------------------------- Error Signaler
class ZeroShared ErrorSignaler
{
public:

  enum SignalErrorType { Warning, Error, FileError };

  //--------------------------------------------------------------- Error Data
  struct ErrorData
  {
    int Line;
    cstr Expression;
    cstr File;
    cstr Message;
    bool IgnoreFutureAssert;
    SignalErrorType ErrorType;
  };

  //The error handler can display Ui, filter errors, or other processing
  //Return true to debug break.
  typedef bool (*ErrorHandler)(ErrorData& errorData);
  static void SetErrorHandler(ErrorHandler newHandler){activeErrorHandler = newHandler; }
  static ErrorHandler GetErrorHandler() { return activeErrorHandler; }
  
  static bool SignalError(SignalErrorType erroType, cstr exp, cstr file,
                          int line, bool& ignore, cstr msg = 0, ...);
private:
  static ErrorHandler activeErrorHandler;
};

}//namespace Zeros


#if !defined(ZERO_ENABLE_ERROR) 
#   if defined(_DEBUG)
#       define ZERO_ENABLE_ERROR 1
#   else
#       define ZERO_ENABLE_ERROR 0
#   endif
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1600
  #define StaticAssert(name, Expression, error) \
    static_assert(Expression, error)
#else
  #define StaticAssert(name, Expression, error) \
    static int name = (sizeof(char[1 - 2 * !(Expression)]))
#endif

static int gConditionalFalseConstant = 0;

#if ZERO_ENABLE_ERROR

#define UnusedParameter(param) (void)param

#define WarnIf(Expression, ...) \
  do { static bool __ignore = false; if((Expression) && Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Warning,#Expression, __FILE__, __LINE__, __ignore,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define ErrorIf(Expression, ...) \
  do { static bool __ignore = false; if((Expression) && Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Error,#Expression, __FILE__, __LINE__, __ignore,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define Assert(Expression, ...) \
  do { static bool __ignore = false; if(!(Expression) && Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Error,#Expression, __FILE__, __LINE__, __ignore,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define Error(...)\
  do { static bool __ignore = false; if(Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Error,"", __FILE__, __LINE__, __ignore,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define Warn(...)\
  do { static bool __ignore = false; if(Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Warning,"", __FILE__, __LINE__, __ignore,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define FileErrorIf(Expression, file, Line, ...) \
  do { static bool __ignore = false; if((Expression) && Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::FileError,#Expression, file, Line, __ignore,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalConstant)

#define Verify(funccall) ErrorIf(funcall != 0);

#else

#define UnusedParameter(param)
#define WarnIf(...) ((void)0)
#define ErrorIf(...) ((void)0)
#define Assert(...) ((void)0)
#define Error(...) ((void)0)
#define Warn(...) ((void)0)
#define FileErrorIf(...) ((void)0)
#define Verify(funccall) funccall

#endif

#define ReturnIf(Expression , whatToReturn, ...) \
  do { if(Expression) {                          \
    WarnIf(Expression, __VA_ARGS__);             \
    return whatToReturn;                         \
  } } while(gConditionalFalseConstant)

#define ReturnFileErrorIf(Expression , whatToReturn , file , Line , ...)  \
  do { if(Expression) {                                                   \
    FileErrorIf(Expression, file , Line , __VA_ARGS__);                   \
    return whatToReturn;                                                  \
  } } while(gConditionalFalseConstant)

/// Asserts value is within [min, max]
#define AssertWithinRange(value, min, max) \
  Assert((min) <= (value) && (value) <= (max))
/// Statically asserts value is within [min, max]
#define StaticAssertWithinRange(name, value, min, max) \
  StaticAssert(name, (min) <= (value) && (value) <= (max), "Value outside range")


///////////////////////////////////////////////////////////////////////////////
///
/// \file TypeTraits.hpp
/// Type Traits for containers.
///
/// Authors: Chris Peters, Andrew Colean
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes

#include <utility>
#include <typeinfo>

namespace Zero
{

//
// Integral Constant
//

/// Provides a compile-time integral constant as a templated type
template<typename IntegerType, IntegerType Value>
struct integral_constant
{
  static const IntegerType value = Value;
  typedef IntegerType value_type;
  typedef integral_constant<IntegerType, value> type;
};
/// Static Data Member Instantiation
template<typename IntegerType, IntegerType Value>
const IntegerType integral_constant<IntegerType, Value>::value;

/// Integral constant true type
typedef integral_constant<bool, true>  true_type;
/// Integral constant false type
typedef integral_constant<bool, false> false_type;

//
// Is Same
//

/// is_same helper class, does not use integral_constant
template <typename TypeA, typename TypeB>
struct is_same_helper
{
  static const bool value = false;
};
template <typename TypeA>
struct is_same_helper<TypeA, TypeA>
{
  static const bool value = true;
};

/// Provides a constant defined as true if TypeA and TypeB are the same exact type, else defined as false
template <typename TypeA, typename TypeB>
struct is_same : public integral_constant<bool, (is_same_helper< TypeA, TypeB >::value) > {};

//
// Make Type
//

/// Provides a typedef defined as T (seems pointless but it's actual necessary to use this in some cases)
template <typename T> struct make_type { typedef T type; };

//
// Make Void
//

/// Provides a typedef defined as void (seems pointless but it's actual necessary to use this in some cases)
template <typename> struct make_void { typedef void type; };

//
// Is Class (or Struct)
//

/// is_class helper class, does not use integral_constant
template <typename T, typename = void>
struct is_class_helper
{
  static const bool value = false;
};
template <typename T>
struct is_class_helper<T, typename make_void<int T::*>::type>
{
  static const bool value = true;
};

/// Provides a constant defined as true if T is a class or struct type, else defined as false
template <typename T>
struct is_class : public integral_constant<bool, (is_class_helper< T >::value) > {};

//
// Remove Qualifiers (1)
//

/// Removes the top-most pointer from a given type
template<typename T> struct remove_pointer     { typedef T type; };
template<typename T> struct remove_pointer<T*> { typedef T type; };

/// Removes the top-most const qualifier from a given type
template<typename T> struct remove_const            { typedef T type; };
template<typename T> struct remove_const< const T > { typedef T type; };

/// Removes the top-most volatile qualifier from a given type
template<typename T> struct remove_volatile               { typedef T type; };
template<typename T> struct remove_volatile< volatile T > { typedef T type; };

/// Removes the top-most const and volatile qualifiers from a given type
template<typename T> struct remove_const_and_volatile { typedef typename remove_volatile<typename remove_const< T >::type>::type type; };

//
// Type Traits
//

/// Provides a constant defined as true if T is a pointer type, else defined as false
template<typename T> struct is_pointer     : public false_type {};
template<typename T> struct is_pointer<T*> : public true_type  {};

/// Provides a constant defined as true if T is a reference type, else defined as false
template<typename T> struct is_reference     : public false_type {};
template<typename T> struct is_reference<T&> : public true_type  {};

/// Provides a constant defined as true if T is a floating-point type, else defined as false
template<typename T> struct is_floating_point : public false_type {};
template<> struct is_floating_point<float>    : public true_type  {};
template<> struct is_floating_point<double>   : public true_type  {};

/// Provides a constant defined as true if T is a signed arithmetic type, else defined as false
template<typename T> struct is_signed  : public false_type {};
template<> struct is_signed<slonglong> : public true_type  {};
template<> struct is_signed<slong>     : public true_type  {};
template<> struct is_signed<sint>      : public true_type  {};
template<> struct is_signed<sshort>    : public true_type  {};
template<> struct is_signed<schar>     : public true_type  {};
template<> struct is_signed<float>     : public true_type  {};
template<> struct is_signed<double>    : public true_type  {};

/// Provides a constant defined as true if T is an unsigned arithmetic type, else defined as false
template<typename T> struct is_unsigned  : public false_type {};
template<> struct is_unsigned<ulonglong> : public true_type  {};
template<> struct is_unsigned<ulong>     : public true_type  {};
template<> struct is_unsigned<uint>      : public true_type  {};
template<> struct is_unsigned<ushort>    : public true_type  {};
template<> struct is_unsigned<uchar>     : public true_type  {};

/// Provides a constant defined as true if T is an integral type, else defined as false
template<typename T> struct is_integral  : public false_type {};
template<> struct is_integral<slonglong> : public true_type  {};
template<> struct is_integral<slong>     : public true_type  {};
template<> struct is_integral<sint>      : public true_type  {};
template<> struct is_integral<sshort>    : public true_type  {};
template<> struct is_integral<schar>     : public true_type  {};
template<> struct is_integral<ulonglong> : public true_type  {};
template<> struct is_integral<ulong>     : public true_type  {};
template<> struct is_integral<uint>      : public true_type  {};
template<> struct is_integral<ushort>    : public true_type  {};
template<> struct is_integral<uchar>     : public true_type  {};
template<> struct is_integral<bool>      : public true_type  {};

/// Provides a constant defined as true if T is a bool type, else defined as false
template<typename T> struct is_bool : public false_type {};
template<> struct is_bool<bool>     : public true_type  {};

/// Provides a constant defined as true if T is a void type, else defined as false
template<typename T> struct is_void : public false_type {};
template<> struct is_void<void>     : public true_type  {};

/// Provides a constant defined as true if T is a nullptr_t type, else defined as false
template<typename T> struct is_null_pointer        : public false_type {};
// template<> struct is_null_pointer<NullPointerType> : public true_type  {}; // TODO

/// Provides a constant defined as true if T is a array type, else defined as false
template<typename T> struct is_array                 : public false_type {};
template<typename T> struct is_array<T[]>            : public true_type  {};
template<typename T, size_t N> struct is_array<T[N]> : public true_type  {};

/// is_member_pointer helper class
template<typename T> struct is_member_pointer_helper                     : public false_type {};
template<typename T, typename U> struct is_member_pointer_helper<T U::*> : public true_type {};

/// Provides a constant defined as true if T is a member pointer type, else defined as false
template<typename T>
struct is_member_pointer : public integral_constant<bool, (is_member_pointer_helper< typename remove_const_and_volatile< T >::type >::value) > {};

// These classes are guaranteed to be sizeof() 1 and 2, for use in compile time conditionals
struct yes { char bytes[1]; };
struct no { char bytes[2]; };

/// is_union_or_class_helper helper class
template<typename T>
struct is_union_or_class_helper
{
  template<typename T2>
  static yes Test(int T2::*);
  template<typename T2>
  static no Test(...);

  static const bool value = sizeof((Test<T>(0))) == sizeof(yes);
};

/// Provides a constant defined as true if T is a union or class type, else defined as false
template<typename T>
struct is_union_or_class : public integral_constant<bool, (is_union_or_class_helper<T>::value) > {};

// Using SFINAE we can detect a copy constructor's existance
template <bool statement, typename out>
struct failable
{
  typedef out Type;
};

/// TODO: Update type traits to use compiler intrinsics per compiler
/// TODO: Implement is_function, and exclude function types
/// Provides a constant defined as true if T is an enum type, else defined as false
template<typename T>
struct is_enum : public integral_constant<bool, (!is_void< T >::value
                                              && !is_integral< T >::value
                                              && !is_floating_point< T >::value
                                              && !is_array< T >::value
                                              && !is_pointer< T >::value
                                              && !is_reference< T >::value
                                              && !is_member_pointer< T >::value
                                              && !is_union_or_class< T >::value
                                              /*&& !is_function< T >::value*/) > {};

/// Provides a constant defined as true if T is an enum or integral type, else defined as false
template<typename T>
struct is_enum_or_integral : public integral_constant<bool, (is_enum< T >::value || is_integral< T >::value) > {};

/// Provides a constant defined as true if T is an arithmetic (integral or floating point) type, else defined as false
template<typename T>
struct is_arithmetic : public integral_constant<bool, (is_integral< T >::value || is_floating_point< T >::value) > {};

/// Provides a constant defined as true if T is a fundamental (arithmetic, void, or nullptr_t) type, else defined as false
template<typename T>
struct is_fundamental : public integral_constant<bool, (is_arithmetic< T >::value || is_void< T >::value || is_null_pointer< T >::value) > {};

/// Provides a constant defined as true if T is a scalar (arithmetic, enum, pointer, or nullptr_t) type, else defined as false
template<typename T>
struct is_scalar : public integral_constant<bool, (is_arithmetic< T >::value || is_enum< T >::value || is_pointer< T >::value || is_null_pointer< T >::value) > {};

/// Provides a constant defined as true if T is a POD type, else defined as false
template<typename T>
struct is_pod : public integral_constant<bool, (is_scalar< T >::value) > {};

/// Provides a constant defined as true if T has a trivial constructor, else defined as false
template<typename T> struct has_trivial_constructor : public integral_constant<bool, is_pod< T >::value> {};
/// Provides a constant defined as true if T has a trivial copy constructor, else defined as false
template<typename T> struct has_trivial_copy        : public integral_constant<bool, is_pod< T >::value> {};
/// Provides a constant defined as true if T has a trivial copy assignment operator, else defined as false
template<typename T> struct has_trivial_assign      : public integral_constant<bool, is_pod< T >::value> {};
/// Provides a constant defined as true if T has a trivial destructor, else defined as false
template<typename T> struct has_trivial_destructor  : public integral_constant<bool, is_pod< T >::value> {};

/// Provides standard type traits, provided for convenience
template<typename T>
struct StandardTraits
{
  typedef is_pod< T >                  is_pod_;
  typedef has_trivial_constructor< T > has_trivial_constructor_;
  typedef has_trivial_copy< T >        has_trivial_copy_;
  typedef has_trivial_assign< T >      has_trivial_assign_;
  typedef has_trivial_destructor< T >  has_trivial_destructor_;
};

/// Provides type trait overrides to treat a type as POD, provided for convenience
struct PodOverride
{
  typedef true_type is_pod_;
  typedef true_type has_trivial_copy_;
  typedef true_type has_trivial_assign_;
  typedef true_type has_trivial_constructor_;
  typedef true_type has_trivial_destructor_;
};

//
// Conditional
//

/// Provides a typedef defined as TypeA if Condition is true, else defined as TypeB
template <bool Condition, typename TypeA, typename TypeB>
struct conditional
{
  typedef TypeA type;
};
template <typename TypeA, typename TypeB>
struct conditional<false, TypeA, TypeB>
{
  typedef TypeB type;
};

//
// Enable/Disable If
//

/// Provides a typedef defined as Type if Condition is true
/// This leverages SFINAE to remove functions and classes from overload resolution
template <bool Condition, typename Type = void>
struct enable_if
{
};
template <typename Type>
struct enable_if<true, Type>
{
  typedef Type type;
};

/// Provides a typedef defined as Type if Condition is false
/// This leverages SFINAE to remove functions and classes from overload resolution
template <bool Condition, typename Type = void>
struct disable_if
{
};
template <typename Type>
struct disable_if<false, Type>
{
  typedef Type type;
};

/// Enable If via Default Template Parameter
#define T_ENABLE_IF(Condition)  typename Zero::enable_if<(Condition)>::type
#define T_DISABLE_IF(Condition) typename Zero::disable_if<(Condition)>::type

/// Enable If via Function Return Type
#define R_ENABLE_IF(Condition, ReturnType)  typename Zero::enable_if<(Condition), ReturnType>::type
#define R_DISABLE_IF(Condition, ReturnType) typename Zero::disable_if<(Condition), ReturnType>::type

/// Enable If via Function Parameter Type
#define P_ENABLE_IF(Condition)  typename Zero::enable_if<(Condition)>::type* = 0
#define P_ENABLE_IF_IS_SAME(TypeA, TypeB) typename Zero::enable_if<(Zero::is_same<TypeA, TypeB>::value)>::type* = 0
#define P_DISABLE_IF(Condition) typename Zero::disable_if<(Condition)>::type* = 0
#define P_DISABLE_IF_IS_SAME(TypeA, TypeB) typename Zero::disable_if<(Zero::is_same<TypeA, TypeB>::value)>::type* = 0

//
// Make Signed/Unsigned
//

/// Provides a typedef defined as the signed equivalent of integral Type
template <typename Type> struct make_signed {};
template <> struct make_signed<ulonglong>   { typedef slonglong type; };
template <> struct make_signed<ulong>       { typedef slong     type; };
template <> struct make_signed<uint>        { typedef sint      type; };
template <> struct make_signed<ushort>      { typedef sshort    type; };
template <> struct make_signed<uchar>       { typedef schar     type; };
template <> struct make_signed<slonglong>   { typedef slonglong type; };
template <> struct make_signed<slong>       { typedef slong     type; };
template <> struct make_signed<sint>        { typedef sint      type; };
template <> struct make_signed<sshort>      { typedef sshort    type; };
template <> struct make_signed<schar>       { typedef schar     type; };

/// Provides a typedef defined as the unsigned equivalent of integral Type
template <typename Type> struct make_unsigned {};
template <> struct make_unsigned<slonglong>   { typedef ulonglong type; };
template <> struct make_unsigned<slong>       { typedef ulong     type; };
template <> struct make_unsigned<sint>        { typedef uint      type; };
template <> struct make_unsigned<sshort>      { typedef ushort    type; };
template <> struct make_unsigned<schar>       { typedef uchar     type; };
template <> struct make_unsigned<ulonglong>   { typedef ulonglong type; };
template <> struct make_unsigned<ulong>       { typedef ulong     type; };
template <> struct make_unsigned<uint>        { typedef uint      type; };
template <> struct make_unsigned<ushort>      { typedef ushort    type; };
template <> struct make_unsigned<uchar>       { typedef uchar     type; };

//
// Move Semantics (1)
//

/// Move reference type
template<typename T>
struct MoveReference
{
  /// Stored value type
  typedef T type;

  /// Constructors
  explicit MoveReference(T& reference)
    : mReference(reference)
  {
  }
  MoveReference(const MoveReference& rhs)
    : mReference(rhs.mReference)
  {
  }

  /// Arrow Operator
  /// Provides direct member access
  T* operator ->() const
  {
    return &mReference;
  }

  /// Indirection Operator
  /// Provides reference access
  T& operator *() const
  {
    return mReference;
  }

  /// Address Of Operator
  /// Provides address access
  T* operator &() const
  {
    return &mReference;
  }

// #ifdef SupportsMoveSemantics
//   /// Conversion Operator
//   operator T&&()
//   {
//     return std::move(mReference);
//   }
// #endif

  /// Data reference
  T& mReference;

private:
  /// No Copy Assignment Operator
  MoveReference& operator=(const MoveReference&);
};

//
// Add Qualifiers
//

/// Adds a pointer to the given type
template<typename T> struct add_pointer { typedef T* type; };

/// Adds a reference to the given type
template<typename T> struct add_reference { typedef T& type; };

//
// Remove Qualifiers (2)
//

/// Removes the top-most reference from a given type
template<typename T> struct remove_reference        { typedef T type; };
template<typename T> struct remove_reference< T& >  { typedef T type; };
#ifdef SupportsMoveSemantics
template<typename T> struct remove_reference< T&& > { typedef T type; };
#endif
template<typename T> struct remove_reference< MoveReference< T > >   { typedef T type; };
template<typename T> struct remove_reference< MoveReference< T >& >  { typedef T type; };
#ifdef SupportsMoveSemantics
template<typename T> struct remove_reference< MoveReference< T >&& > { typedef T type; };
#endif

/// Removes the top-most reference and cv-qualifiers from a given type
template<typename T> struct remove_reference_const_and_volatile { typedef typename remove_reference<typename remove_const_and_volatile< T >::type>::type type; };

//
// Move Semantics (2)
//

/// Provides a constant defined as true if T is a MoveReference<T> type, else defined as false
template<typename T> struct is_move_reference                     : public false_type {};
template<typename T> struct is_move_reference< MoveReference<T> > : public true_type  {};

/// Determines how ZeroMove is applied to types
template <typename T, typename Enable = void>
struct ZeroMoveHelper;

// Is built-in type?
template <typename T>
struct ZeroMoveHelper<T, T_ENABLE_IF(is_scalar<typename remove_const_and_volatile< T >::type>::value)>
{
  typedef T type;
};

// Is user type?
template <typename T>
struct ZeroMoveHelper<T, T_ENABLE_IF(!is_scalar<typename remove_const_and_volatile< T >::type>::value)>
{
  typedef MoveReference<typename remove_reference_const_and_volatile< T >::type> type;
};

#if defined(SupportsMoveSemantics)
  /// Creates a move reference
  template <typename T>
  typename ZeroMoveHelper<T>::type ZeroMove(T& value)
  {
    return (typename ZeroMoveHelper<T>::type)(value);
  }
#else
  template <typename T>
  T& ZeroMove(T& value)
  {
    return value;
  }
#endif

//
// Type Index
//

/// Sortable wrapper around std::type_info
/// Designed to be used as a key in associative containers
class TypeIndex
{
public:
  /// Default Constructor (Note: Creates an invalid TypeIndex!)
  TypeIndex()                               : mTypeInfo(nullptr)        {}
  /// Constructor
  TypeIndex(const std::type_info& typeInfo) : mTypeInfo(&typeInfo)      {}
  /// Copy Constructor
  TypeIndex(const TypeIndex& rhs)           : mTypeInfo(rhs.mTypeInfo)  {}
  /// Move Constructor (Behaves like a copy constructor)
  TypeIndex(MoveReference<TypeIndex> rhs)   : mTypeInfo(rhs->mTypeInfo) {}

  /// Copy Assignment Operator
  TypeIndex& operator =(const TypeIndex& rhs)         { mTypeInfo = rhs.mTypeInfo; return *this;  }
  /// Move Assignment Operator (Behaves like a copy assignment operator)
  TypeIndex& operator =(MoveReference<TypeIndex> rhs) { mTypeInfo = rhs->mTypeInfo; return *this; }

  /// Comparison Operators (compares their type_infos)
  bool operator ==(const TypeIndex& rhs) const { return *mTypeInfo == *rhs.mTypeInfo;           }
  bool operator !=(const TypeIndex& rhs) const { return !(*this == rhs);                        }
  bool operator  <(const TypeIndex& rhs) const { return mTypeInfo->before(*rhs.mTypeInfo) != 0; }
  bool operator >=(const TypeIndex& rhs) const { return !(*this < rhs);                         }
  bool operator  >(const TypeIndex& rhs) const { return rhs < *this;                            }
  bool operator <=(const TypeIndex& rhs) const { return !(rhs < *this);                         }

  /// Returns the type_info name
  const char* name() const { return mTypeInfo->name(); }

private:
  /// Underlying type_info
  const std::type_info* mTypeInfo;
};

} //namespace Zero


// For placement new
#include <new>
// For size_t
#include <stddef.h>
// For memmove, memcpy
#include <string.h>

namespace Zero
{
/// A special dummy type that we pass in as the first argument to a container's constructor
/// to enable passing in a list of values that we initialize the container with
/// This entirely exists to resolve ambiguities with other constructors (such as Array(size_t), if T was size_t there would be an issue)
class ContainerInitializerDummy
{
public:
};
#define ZeroInit ((Zero::ContainerInitializerDummy*)nullptr)

/// Base class for containers that use allocators.
template<typename AllocatorType>
class ZeroSharedTemplate AllocationContainer
{
public:
  typedef AllocatorType allocator_type;
  allocator_type& get_allocator(){return mAllocator;}
  void set_allocator(const allocator_type& allocator) { mAllocator = allocator; }
protected:
  allocator_type mAllocator;
};

/// Standard swap function
template<typename type> 
inline void Swap(type& a, type& b)
{
  type c(a);
  a = b;
  b = c;
}

/// A Pair of objects.
template<typename type0, typename type1>
struct ZeroSharedTemplate Pair
{
  typedef type0 first_type;
  typedef type1 second_type;
  typedef Pair<type0, type1> this_type;
  type0 first;
  type1 second;

  Pair(const type0& value0)
    : first(value0), second()
  {
  }

  Pair(const type0& value0, const type1& value1)
    : first(value0), second(value1)
  {
  }

  Pair(const type0& value0, MoveReference<type1> value1)
    : first(value0), second(ZeroMove(value1))
  {
  }

  Pair(const Pair& other)
    : first(other.first), second(other.second)
  {
  }

  Pair(MoveReference<Pair> other)
    : first(ZeroMove(other->first)), second(ZeroMove(other->second))
  {
  }

  Pair()
    : first(), second()
  {
  }

  void swap(Pair& right)
  {
    if(this != &right)
    {
      Swap(first, right.first);
      Swap(second, right.second);
    }
  }

  size_t Hash() const;

  friend inline bool operator == (const this_type& left, const this_type& right)
  {
    return left.first == right.first && left.second == right.second;
  }

  friend inline bool operator != (const this_type& left, const this_type& right)
  {
    return !(left == right);
  }
};

template<typename type0, typename type1>
Pair<type0,type1> make_pair(const type0& first, const type1& second)
{
  return Pair<type0,type1>(first, second);
}

/// Moves the specified type to a different memory destination without calling the destructor on the source instance
/// Used by our containers to speed up shifting operations
/// Provide a template specialization for your own class to define this behavior, else this default will be used
template<typename type>
struct MoveWithoutDestructionOperator
{
  static inline void MoveWithoutDestruction(type* dest, type* source)
  {
    // TODO: Use move constructor if available

    // Use copy constructor
    new(dest) type(*source);
    // Destroy the original
    source->~type();
  }
};

template<typename first, typename second>
struct MoveWithoutDestructionOperator< Pair<first, second> >
{
  static inline void MoveWithoutDestruction(Pair<first, second>* dest, 
                                            Pair<first, second>* source)
  {
    MoveWithoutDestructionOperator<first>::MoveWithoutDestruction(&dest->first, &source->first);
    MoveWithoutDestructionOperator<second>::MoveWithoutDestruction(&dest->second, &source->second);
  }
};

/// Move values from source array to new array using move
template<typename type>
inline void uninitialized_move(type* dest, type* source, size_t size, 
                               false_type /*ispod*/)
{
  type* destEnd = dest + size;
  while(dest != destEnd)
  {
    MoveWithoutDestructionOperator<type>::MoveWithoutDestruction(dest, source);
    ++dest;
    ++source;
  }
}

template<typename type>
inline void uninitialized_move(type* dest, type* source, size_t size, 
                               true_type /*ispod*/)
{
  memmove(dest, source, sizeof(type)*size);
}

template<typename type>
inline void uninitialized_moveRev(type* dest, type* source, size_t size, 
                                  false_type /*ispod*/)
{
  type* destEnd = dest + size;
  type* sourceEnd = source + size;
  while(size != 0)
  {
    --destEnd;
    --sourceEnd;
    MoveWithoutDestructionOperator<type>::MoveWithoutDestruction(destEnd, sourceEnd);
    --size;
  }
}

template<typename type>
inline void uninitialized_moveRev(type* dest, type* source, size_t size, 
                                  true_type /*ispod*/)
{
  memmove(dest, source, sizeof(type)*size);
}

template<typename type>
inline void uninitialized_copy(type* dest, type* source, size_t size, 
                               false_type /*ispod*/)
{
  type* destEnd = dest + size;
  while(dest != destEnd)
  {
    new(dest) type(*source);
    ++dest;
    ++source;
  }
}

template<typename type>
inline void uninitialized_copy(type* dest, type* source, size_t size, 
                               true_type /*ispod*/)
{
  memcpy(dest, source, sizeof(type)*size);
}

template<typename type, typename initType>
inline void constructWith(type* elem, const initType& source)
{
  // Copy construct from source
  new(elem) type(source);
}

template<typename type, typename initType>
inline void constructWith(type* elem, MoveReference<initType> source)
{
  // Move construct from source
  new(elem) type(ZeroMove(source));
}

template<typename type>
inline void construct(type* elem, false_type /*ispod*/)
{
  new(elem) type();
}

template<typename type>
inline void construct(type* /*elem*/, true_type /*ispod*/)
{
  //do nothing for pod
}

template<typename type>
inline void destroy(type* dest, false_type /*ispod*/)
{
  dest->~type();
}

template<typename type>
inline void destroy(type* /*dest*/, true_type /*ispod*/)
{
  //do nothing for pod types
}

template<typename type>
inline void uninitialized_fill(type* dest, size_t size, const type& source)
{
  type* destEnd = dest+size;
  while(dest!=destEnd)
  {
    new(dest) type(source);
    ++dest;
  }
}

template<typename type>
inline void uninitialized_fill(type* dest, size_t size, false_type /*ispod*/)
{
  type* destEnd = dest+size;
  while(dest!=destEnd)
  {
    new(dest) type();
    ++dest;
  }
}

template<typename type>
inline void uninitialized_fill(type* /*dest*/, size_t /*size*/, 
                               true_type /*ispod*/)
{
  //do nothing for pod types
}


template<typename type>
inline void destroyElements(type* begin, size_t size, false_type /*ispod*/)
{
  type* end = begin+size;
  while(begin!=end)
  {
    begin->~type();
    ++begin;
  }
}

template<typename type>
inline void destroyElements(type* /*begin*/, size_t /*size*/,
                            true_type /*ispod*/)
{
  //do nothing for pod types
}

//Forms a range with iterators.
template<typename containerType>
struct IteratorRange
{
  typedef typename containerType::iterator iterator;
  typedef typename containerType::reference reference;

  IteratorRange(iterator pbegin, iterator pend)
    : begin(pbegin) , end(pend)
  {
  }

  reference front() { return *begin; }
  void popFront()
  {
    ErrorIf(empty(), "Popped empty range.");
    ++begin;
  }

  bool empty() { return begin == end; }
  size_t length() { return end - begin; }
  iterator begin;
  iterator end;
};


//Forms a range with iterators.
template<typename iteratorType>
struct IteratorTypedRange
{
  typedef iteratorType iterator;
  typedef typename iteratorType::reference reference;

  IteratorTypedRange(iterator pbegin, iterator pend)
    : begin(pbegin), end(pend)
  {
  }

  reference front() { return *begin; }
  void popFront()
  {
    ErrorIf(empty(), "Popped empty range.");
    ++begin;
  }

  bool empty() { return begin == end; }
  size_t length() { return end - begin; }
  iterator begin;
  iterator end;
};


// Constant Pointer Range. Forms a range between two pointers.
template<typename type>
struct ConstPointerRange
{
  typedef const type* iterator;

  //Construct a range with two pointers.
  ConstPointerRange(iterator pbegin, iterator pend)
    : begin(pbegin), end(pend)
  {
  }

  //Construct a range with a pointer and a size.
  ConstPointerRange(iterator pbegin, size_t size)
    : begin(pbegin), end(pbegin + size)
  {
  }

  const type& front() { return *begin; }
  void popFront()
  {
    ErrorIf(empty(), "Popped empty range.");
    ++begin;
  }

  bool empty() { return begin == end; }
  size_t length() { return end - begin; }
  iterator begin;
  iterator end;
};

// Pointer Range. Forms a range between two pointers.
template<typename type>
struct PointerRange
{
  typedef type* iterator;

  //Construct a range with two pointers.
  PointerRange(iterator pbegin, iterator pend)
    : begin(pbegin), end(pend)
  {
  }

  //Construct a range with a pointer and a size.
  PointerRange(iterator pbegin, size_t size)
    : begin(pbegin), end(pbegin + size)
  {
  }

  type& front() { return *begin; }
  void popFront()
  {
    ErrorIf(empty(), "Popped empty range.");
    ++begin;
  }

  bool empty() { return begin == end; }
  size_t length() { return end - begin; }
  iterator begin;
  iterator end;
};

template<typename iteratorType>
IteratorTypedRange<iteratorType> BuildRange(iteratorType begin, 
                                            iteratorType end)
{
  return IteratorTypedRange<iteratorType>(begin, end);
}

template<typename elementType>
ConstPointerRange<elementType> BuildRange(elementType* begin, elementType* end)
{
  return ConstPointerRange<elementType>(begin, end);
}

template< typename type>
inline void DeleteOp(type* pointer) { delete pointer; }

template<typename keytype, typename type>
inline void DeleteOp(Pair<const keytype,type>& entry) { delete entry.second; }

template<typename keytype, typename type>
inline void DeleteOp(Pair<keytype,type>& entry) { delete entry.second; }


template<typename rangeType>
void DeleteObjectsIn(rangeType range)
{
  for(; !range.empty(); range.popFront())
  {
    DeleteOp(range.front());
  }
}

template<typename containerType>
void DeleteObjectsInContainer(containerType& container)
{
  DeleteObjectsIn(container.all());
  container.clear();
}

#ifdef DEBUG
  //Prevents an empty class from being the debug heap value.
  #define EmptyClass(className)       \
    byte SingleByte;                    \
    className():SingleByte(0){}         
#else
  #define EmptyClass(className)
#endif  

struct DataBlock
{
  DataBlock():Data(NULL), Size(0) {};
  DataBlock(byte* data, size_t size):Data(data), Size(size) {};
  operator bool(){return Data!=NULL;}
  byte* Data;
  size_t Size;
};

// Policy for how values are tested for equality
// Allow the containers to be searched by values
// that are not the same as the stored type
template<typename type>
struct ComparePolicy
{
  //Default use operator ==
  template<typename otherType>
  inline bool equal(const type& left, const otherType& right) const
  {
    return left == right;
  }
};

// Compare Policty for const char * which
// uses string comparison
template<>
struct ComparePolicy<const char*>
{
  inline bool equal(const char* left, const char* right) const
  {
    return strcmp(left, right) == 0;
  }

  template<typename stringType>
  inline bool equal(const char* left, const stringType& right) const
  {
    // use operator == to other type, usually strings
    return right == left;
  }
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file Allocator.hpp
/// Declaration of the  Allocator interface and the Default Allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef UseMemoryGraph
#define UseMemoryGraph 1
#endif

#if UseMemoryGraph

///////////////////////////////////////////////////////////////////////////////
///
/// \file Graph.hpp
/// Declaration of the Memory Graph.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once
///////////////////////////////////////////////////////////////////////////////
///
/// \file Memory.hpp
/// 
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Zero
{

typedef size_t MemCounterType;
typedef void* MemPtr;

MemPtr zAllocate(size_t numberOfBytes);
void zDeallocate(MemPtr);
MemPtr zStaticAllocate(size_t size);

#define UseStaticMemory()                                                \
  static void* operator new(size_t size){return zStaticAllocate(size);}  \
  static void operator delete(void* /*pMem*/, size_t /*size*/){}

#define OverloadedNew()                                             \
  static void* operator new(size_t size);                           \
  static void  operator delete(void* pMem, size_t size);            \
  static void* operator new (size_t size, void* ptr){return ptr;};  \
  static void  operator delete(void* mem, void* ptr){};

#define ImplementOverloadedNewWithAllocator(ClassName, AllocatorObj)                                 \
  void* ClassName::operator new(size_t size) { return AllocatorObj->Allocate(size); };               \
  void  ClassName::operator delete(void* pMem, size_t size) { AllocatorObj->Deallocate(pMem, size); }

}


///////////////////////////////////////////////////////////////////////////////
///
/// \file InList.hpp
/// Definition of the Intrusively linked list container.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once


//For ptrdiff
#include <cstddef>

namespace Zero
{

const int ObjListPtrDebugValue = 0xFFFFDEAD;

#ifndef DEBUGLINKS
#if _DEBUG
#define DEBUGLINKS 1
#else
#define DEBUGLINKS 0
#endif
#endif

template<typename type>
struct ZeroSharedTemplate Link
{
#if DEBUGLINKS
  Link() : Next((type*)ObjListPtrDebugValue) , Prev((type*)ObjListPtrDebugValue) {};
#endif
  type* Next;
  type* Prev;
};

#if defined(_MSC_VER) && _MSC_VER <= 1600
///Intrusive is used for debugging in Visual Studio
#define IntrusiveLink(objectType, linkName) \
union{ \
  struct{Link<objectType> linkName;}; \
  struct{objectType* Next; objectType* Prev;}; \
}
#else
#define IntrusiveLink(objectType, linkName) \
  Link<objectType> linkName
#endif

class ZeroShared LinkBase
{
public:
  IntrusiveLink(LinkBase, link);
};

template<typename Parent, typename Member>
inline ptrdiff_t PointerToMemberOffset(const Member Parent::* ptrToMember)
{
  return *(unsigned int*)(void*)&ptrToMember;
}

typedef const char * const cstrc;

cstrc cBadRemoveError = "Prev object next pointer does not match current object."
          "Most likely the prev object has been deleted or improperly removed.";
cstrc cBadLinkInsertError = "Link value is not set to debug value. "
"Probably a double insert or not yet removed from another list.";

cstrc cBadRemovedAlready = "Object has already been erased or was never added.";

///Intrusively linked list container. 
///Does not own the objects in contains (they are implicitly pointers)
///Objects can link and unlink without using the container.
template<typename type, typename refType, Link<type> type::* PtrToMember = &type::link>
class ZeroSharedTemplate BaseInList
{
public:
  //Should InList be value type or pointer to value typed?
  //pointer to value type make the interface the same as vector<type*>
  //value_typed make the iterator act just like a pointer which is useful.
  typedef type value_type;
  typedef type* pointer;

  typedef type& reference;
  typedef const type* const_pointer;
  typedef const type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type; 
  typedef BaseInList<type, refType, PtrToMember> this_type;

  typedef refType& sub_reference;

  static const size_t cInvalidIndex = size_t(-1);

  BaseInList()
  {
    SetEmpty();
  }

  ~BaseInList()
  {
    //ObjList does not own the object it contains so this is a no op
  }

  class range
  {
  public:
    typedef refType value_type;

    ///Default range is an empty range. Can only be checked for empty.
    range()
      : begin(NULL) , end(NULL)
    {
    }

    range(pointer pbegin, pointer pend)
      : begin(pbegin) , end(pend)
    {
    }

    sub_reference front(){return *static_cast<refType*>(begin);}
    sub_reference back(){return *static_cast<refType*>(Prev(end));}

    void popFront()
    {
      ErrorIf(empty(),"Popped empty range.");
      begin = Next(begin);
    }

    void popBack()
    {
      ErrorIf(empty(),"Popped empty range.");
      end = Prev(end);
    }

    bool empty(){return begin==end;}

    void spliceFront(pointer dest)
    {
      begin = splice(dest, begin);
    }

    pointer begin;
    pointer end;
  };

  // The exact same interface as range, except when you popFront and popBack are swapped, as well as front and back
  // This means that 'begin' and 'end' are actually the exact same as a normal range's begin/end, but we iterate the end here
  class reverse_range
  {
  public:
    typedef refType value_type;

    ///Default range is an empty range. Can only be checked for empty.
    reverse_range()
      : begin(NULL) , end(NULL)
    {
    }

    reverse_range(pointer pbegin, pointer pend)
      : begin(pbegin) , end(pend)
    {
    }

    sub_reference front(){return *static_cast<refType*>(Prev(end));}
    sub_reference back(){return *static_cast<refType*>(begin);}

    void popFront()
    {
      ErrorIf(empty(),"Popped empty range.");
      end = Prev(end);
    }

    void popBack()
    {
      ErrorIf(empty(),"Popped empty range.");
      begin = Next(begin);
    }

    bool empty(){return begin==end;}

    pointer begin;
    pointer end;
  };

  range all()
  {
    return range(Next(GetHeader()), GetHeader());
  }

  reverse_range reverse_all()
  {
    return reverse_range(Next(GetHeader()), GetHeader());
  }

  class iterator
  {
  public:
    friend class BaseInList;
    iterator(){};
    iterator(pointer ptr) : mPtr(ptr) {}
    void operator--(){mPtr = Prev(mPtr);}
    void operator++(){mPtr = Next(mPtr);}
    sub_reference front(){return *static_cast<refType*>(mPtr);}
    refType* operator->(){return static_cast<refType*>(mPtr);}
    refType* operator*(){return static_cast<refType*>(mPtr);}
    bool operator==(const iterator& it){return mPtr == it.mPtr;}
    bool operator!=(const iterator& it){return mPtr != it.mPtr;}
    operator bool(){return mPtr!=NULL;}
    operator pointer(){return mPtr;}
  private:
    pointer mPtr;
  };

  iterator begin(){return iterator(Next(GetHeader()));};
  iterator end(){return iterator(GetHeader());}
  iterator rbegin(){return iterator(Prev(GetHeader()));};
  //End is the same as forward because of sentinel node)
  iterator rend(){return iterator(GetHeader());}

  ///True if the list does not contain any nodes.
  bool empty()
  {
    return header.Next == GetHeader();
  }

  ///This function only works in debug mode (because in release
  ///clear doesn't set the next/prev pointers for each node).
  static inline bool VerifyUnlinkedDebugOnly(pointer element)
  {
#if DEBUGLINKS
    pointer prev = Prev(element);
    pointer next = Next(element);
    if(prev == (type*)ObjListPtrDebugValue && next == (pointer)ObjListPtrDebugValue)
      return true;
    else
      return false;
#else
    return true;
#endif
  }

  static inline iterator Unlink(pointer element)
  {
    pointer prev = Prev(element);
    pointer next = Next(element);

#if DEBUGLINKS
    ErrorIf(prev == (pointer)ObjListPtrDebugValue, cBadRemovedAlready);
    ErrorIf(next == (pointer)ObjListPtrDebugValue, cBadRemovedAlready);
#endif

    ErrorIf(Next(prev) != element, cBadLinkInsertError);
    ErrorIf(Prev(next) != element, cBadLinkInsertError);

    Next(prev) = next;
    Prev(next) = prev;

#if DEBUGLINKS
    Prev(element) = (pointer)ObjListPtrDebugValue;
    Next(element) = (pointer)ObjListPtrDebugValue;
#endif
    return next;
  }

  ///Inserts object in list BEFORE where.
  void insert_before(pointer where, pointer obj)
  {
    insert(where, obj);
  }

  ///Inserts object in list BEFORE where.
  void insert(pointer where, pointer obj)
  {

#if DEBUGLINKS
    ErrorIf(Next(obj) != (type*)ObjListPtrDebugValue, cBadLinkInsertError);
    ErrorIf(Prev(obj) != (type*)ObjListPtrDebugValue, cBadLinkInsertError);
#endif

    Next(obj) = where;
    Prev(obj) = Prev(where);
    Next(Prev(where)) = obj;
    Prev(where) = obj;
  }

  ///Inserts object in list after where.
  void insert_after(pointer where, pointer obj)
  {
#if DEBUGLINKS
    ErrorIf(Next(obj) != (type*)ObjListPtrDebugValue, cBadLinkInsertError);
    ErrorIf(Prev(obj) != (type*)ObjListPtrDebugValue, cBadLinkInsertError);
#endif

    Next(obj) = Next(where);
    Prev(obj) = where;
    Prev(Next(where)) = obj;
    Next(where) = obj;
  }

  /// Inserts before the given index
  void insertAt(size_t index, pointer obj)
  {
    size_t currIndex = 0;
    iterator it = begin();

    do 
    {
      if(currIndex == index)
      {
        insert_before(it, obj);
        return;
      }
      
      ++currIndex;
      ++it;
    } while (it != end());

    push_back(obj);
  }

  ///Adds the object to the end of the list.
  void push_back(pointer obj)
  {
    pointer header = GetHeader();
    insert(header, obj);
  };

  void pop_back()
  {
    Unlink(&back());
  };

  ///Adds the object to the beginning of the list
  void push_front(pointer obj)
  {
    insert_after(GetHeader(), obj);
  };

  void pop_front()
  {
    Unlink(&front());
  };

  ///Removes all the objects from the list. It will
  ///unlink the individual objects internal pointers
  ///only in debug mode.
  void clear()
  {
#if DEBUGLINKS
    iterator it = begin();
    while(it != end())
    {
      it = erase(it);
    }
#endif
    SetEmpty();
  };

  // O(N) walk to find the given elements index
  size_t findIndex(pointer element)
  {
    size_t index = 0;
    iterator it = begin();
    do 
    {
      if((pointer)it == element)
        return index;
      ++index;
      ++it;
    } while (it != end());

    return cInvalidIndex;
  }

  sub_reference front()
  {
    return *static_cast<refType*>(Next(GetHeader()));
  }

  sub_reference back()
  {
    return *static_cast<refType*>(Prev(GetHeader()));
  }

  //Swaps one list elements with another this also must
  //fix the prev and next pointers of the first and
  //last objects located in the list
  void swap(this_type& other)
  {
    Swap(header.Next, other.header.Next);
    Swap(header.Prev, other.header.Prev);

    //If the list contained pointers fix them
    if(header.Next != other.GetHeader())
    {
      Prev(header.Next) = GetHeader();
      Next(header.Prev) = GetHeader();
    }
    else
    {
      SetEmpty();
    }

    if(other.header.Next != GetHeader())
    {
      Prev(other.header.Next) = other.GetHeader();
      Next(other.header.Prev) = other.GetHeader();
    }
    else
    {
      other.SetEmpty();
    }
  }

  ///Unlinks the object from the list. Does not destroy it.
  //returns the next item in the list.
  iterator erase(iterator it)
  {
    return Unlink(it);
  }

  iterator eraseAndGetPrev(iterator it)
  {
    iterator prev = Prev(it);
    erase(it);
    return prev;
  }

  //Function for iterating over the list when performing destructive
  //operations (operations that would break the next pointer) such
  //as erase and delete
  template<typename unaryFunction>
  void safeForEach(iterator begin, iterator end, unaryFunction op)
  {
    while(begin != end)
    {
      iterator next = Next(begin);
      op(begin);
      begin = next;
    }
  }

  void erase(range eraseRange)
  {
    iterator begin = eraseRange.begin;
    iterator end = eraseRange.end;
    while(begin != end)
      begin = erase(begin);
  }

  ///Splices the range with the provided 
  ///into the list BEFORE where.
  static void splice(iterator where, range right)
  {
    ErrorIf(right.empty(), "Cannot splice and empty range.");

    Next(Prev(right.begin)) = right.end;
    Next(Prev(right.end)) = where;
    Next(Prev(where)) = right.begin;
    pointer prevNode = Prev(where);
    Prev(where) = Prev(right.end);
    Prev(right.end) = Prev(right.begin);
    Prev(right.begin) = prevNode;
  }

  ///Splices a single object from 'from'
  static iterator splice(iterator where, iterator from)
  {
    pointer next = Next(from);
    splice(where, range(from, next));
    return next;
  }

  //Splices entire list leaving right empty
  void splice(iterator where, this_type& right)
  {
    splice(where, right.all());
  }

  template<typename Comparer>
  void merge(this_type& right, Comparer comparer)
  {
    range leftR = all();
    range rightR = right.all();

    while(!leftR.empty() && !rightR.empty())
    {
      if(comparer(rightR.front(), leftR.front()))
      {
        //right is 'greater' than left
        //move a right node into list
        rightR.spliceFront(leftR.begin);
      }
      else
      {
        leftR.popFront();
      }
    }

    if(!rightR.empty())
      splice(leftR.begin, rightR);
  }


  template<typename Comparer>
  void sort(Comparer comparer)
  {
    //If there is more than two nodes sort the list
    if(header.Next != header.Prev)
    {
      const size_t cMaxBins = 25;
      this_type temp;
      this_type bins[cMaxBins+1];
      size_t maxBin = 0;

      while(!empty())
      {
        //Move a single elements onto the temp list
        temp.splice(temp.begin() , range(begin(), Next(begin())));

        size_t curBin = 0;
        for(; curBin < maxBin && !bins[curBin].empty();++curBin)
        {
          bins[curBin].merge(temp, comparer);
          bins[curBin].swap(temp);
        }

        if(curBin == cMaxBins)
          bins[curBin-1].merge(temp, comparer);
        else
        {
          bins[curBin].swap(temp);
          if(curBin == maxBin)
            ++maxBin;
        }
      }

      //All elements are now in bins merge all bins together
      for(size_t mergeBin=1; mergeBin<maxBin; ++mergeBin)
      {
        //Merge previous into current bin
        bins[mergeBin].merge(bins[mergeBin-1], comparer);
      }

      //move back to list
      splice(begin(), bins[maxBin-1]);

    }

  }

  template<typename Comparer>
  void insert_sorted(iterator where, pointer valueInInsert, Comparer comparer)
  {
    while(where!= end())
    {
      if(comparer(*valueInInsert, *where))
        break;
      ++where;
    }
    insert(where, valueInInsert);
  }

  void SetEmpty()
  {
    header.Next = GetHeader();
    header.Prev = GetHeader();
  }

  inline static pointer& Next(pointer obj){ return ToLink(obj).Next; }
  inline static pointer& Prev(pointer obj){ return ToLink(obj).Prev; }
  
  iterator NextWrap(iterator iter)
  { 
    // Increment the iterator
    iterator i = iter;
    ++i;

    // If it's the end, increment passed the sentinel
    if(i == end())
      ++i;

    return i;
  }

  iterator PrevWrap(iterator iter)
  { 
    // Decrement the iterator
    iterator i = iter;
    --i;

    // If it's the end, decrement passed the sentinel
    if(i == end())
      --i;

    return i;
  }

protected:

  //InList is not copyable (not really a valid operation)
  BaseInList(const BaseInList&){}
  void operator=(const BaseInList&){}

  inline static pointer ToNode(Link<type>& link)
  {return (pointer)((unsigned char*)&link - PointerToMemberOffset(PtrToMember));}
  inline static Link<type>& ToLink(pointer obj)
  {return obj->*PtrToMember; }

  pointer GetHeader(){return ToNode(header);}
  Link<type> header;

};

template<typename type, Link<type> type::* PtrToMember = &type::link>
class ZeroSharedTemplate InList : public BaseInList<type, type, PtrToMember>
{
public:

  InList()
  {

  }

private:

  //InList is not copyable (not really a valid operation)
  InList(const InList&){}
  void operator=(const InList&){}
};

template<typename type, typename baseLinkType = LinkBase>
class ZeroSharedTemplate InListBaseLink : public BaseInList<baseLinkType, type, &baseLinkType::link>
{
public:
  InListBaseLink()
  {

  }

private:

  //InList is not copyable (not really a valid operation)
  InListBaseLink(const InListBaseLink&){}
  void operator=(const InListBaseLink&){}
};


template<typename type, Link<type> type::* PtrToMember>
void EraseAndDelete(type* element)
{
  InList<type, PtrToMember>::Unlink(element);
  delete element;
}



//Erase helper  function
template<typename type, Link<type> type::* PtrToMember>
void DeleteObjectsIn(InList<type, PtrToMember>& container)
{
  container.safeForEach(container.begin(), container.end(), EraseAndDelete<type,PtrToMember>);
}

template<typename type, Link<type> type::* PtrToMember>
void OnlyDeleteObjectIn(InList<type, PtrToMember>& container)
{
  container.safeForEach(container.begin(), container.end(), DeleteOp<type>);
}

template<typename type, typename basetype>
void EraseAndDeleteBase(basetype* element)
{
  InListBaseLink<type, basetype>::Unlink(element);
  delete static_cast<type*>(element);
}

template<typename type, typename baseLinkType>
void DeleteObjectsIn(InListBaseLink<type, baseLinkType>& container)
{
  container.safeForEach(container.begin(), container.end(), EraseAndDeleteBase<type, baseLinkType>);
}


}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file FixedString.hpp
/// Declaration of FixedArray, FixedString, and String Range.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <ctype.h>
///////////////////////////////////////////////////////////////////////////////
///
/// \file StringRange.hpp
///
/// Authors: Chris Peters, Joshua Davis
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

const char* const cEmpty = "";

class StringSplitRange;
class String;
class StringRange;
typedef const StringRange& StringRangeParam;

class ZeroShared StringRange
{
public:
  typedef char value_type;
  typedef const char* iterator;

  static const size_t InvalidIndex = (uint)-1;

  StringRange();
  StringRange(iterator cstring);
  StringRange(iterator pbegin, iterator pend);
  StringRange(iterator pbegin, size_t len);

  const char& front() const;
  const char& back() const;
  void popFront();
  void popFront(size_t n);
  void popBack();
  bool contains(iterator pos);
  int CompareTo(const StringRange& right) const;
  bool operator==(const StringRange& right) const;
  bool operator<(const StringRange& right) const;
  bool operator==(char c) const;
  bool operator!=(char c) const;
  char operator[](size_t index);
  uint FindFirstOf(byte value);
  uint FindFirstOf(StringRangeParam value) const;
  uint FindLastOf(byte value) const;
  uint FindLastOf(StringRangeParam value) const;
  uint FindFirstNonWhitespaceCharIndex() const;
  uint FindLastNonWhitespaceCharIndex() const;
  value_type FindFirstNonWhitespaceChar() const;
  value_type FindLastNonWhitespaceChar() const;

  bool Contains(StringRangeParam value) const;
  bool EndsWith(StringRangeParam value) const;
  StringRange FindFirstRangeOf(StringRangeParam value) const;
  StringRange FindLastRangeOf(StringRangeParam value) const;
  StringRange FindRangeExclusive(StringRangeParam startRange, StringRangeParam endRange) const;
  StringRange FindRangeInclusive(StringRangeParam startRange, StringRangeParam endRange) const;
  String Replace(StringRangeParam oldValue, StringRangeParam newValue) const;
  StringSplitRange Split(StringRangeParam separator) const;
  bool StartsWith(StringRangeParam value) const;
  StringRange Trim() const;
  StringRange TrimEnd() const;
  StringRange TrimStart() const;
  String ToUpper() const;
  String ToLower() const;

  bool IsAllUpper() const;
  bool IsAllWhitespace() const;
  StringRange sub_string_unsafe(size_t offset, size_t length) const;
  StringRange sub_string(size_t offset, size_t length) const;

  iterator data() const { return begin; }
  bool empty() const { return begin == end; }
  size_t size() const { return end - begin; }
  size_t length() const { return end - begin; }
  size_t sizeInBytes() const {return end - begin; }
  iterator begin;
  iterator end;
};

/// A range that splits a StringRange based upon a separator range.
class ZeroShared StringSplitRange
{
public:
  StringSplitRange(StringRange range, StringRange separator);
  StringRange front();
  void popFront();
  bool empty();

  void SkipNext();

  StringRange mSeparator;
  StringRange mCurrentRange;
  StringRange mRemainingRange;
};

//string range vs cstr
inline bool operator==(const StringRange& left, cstr right)
{
  return left.size() == strlen(right) &&
         strncmp(left.data(), right, left.size()) == 0;
}

inline bool operator!=(const StringRange& left, cstr right)
{
  return !(left == right);
}

inline bool operator==(cstr left, const StringRange& right)
{
  return strlen(left) == right.size() &&
         strncmp(left, right.data(), right.size()) == 0;
}

inline bool operator<(const StringRange& left, cstr right)
{
  return strncmp(left.data(), right, left.size()) < 0;
}

inline bool operator<(cstr left, const StringRange& right)
{
  return strncmp(left, right.data(), right.size()) < 0;
}

} // namespace Zero


namespace Zero
{

template<typename type, size_t maxSize>
class FixedArray
{
public:
  typedef type value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef FixedArray<type, maxSize> this_type;
  typedef ConstPointerRange<type> range;

  explicit FixedArray()
    : mSize(0)
  {}

  explicit FixedArray(size_type size)
    : mSize(size)
  {}

  FixedArray(pointer data, size_type size)
    : mSize(size)
  {
    if(mSize > maxSize) mSize = maxSize;
    uninitialized_copy(mData, data, mSize, true_type());
  }

  range all() { return range(mData, mSize); }
  bool empty()const { return mSize == 0; }
  const_pointer data() const { return mData; }
  size_type size() const { return mSize; }
  size_type capacity() const { return maxSize; }

  reference front()
  {
    ErrorIf(mSize == 0, "Empty array, no front element.");
    return mData[0];
  }

  const_reference front() const
  {
    ErrorIf(mSize == 0, "Empty array, no front element.");
    return mData[0];
  }

  reference back()
  {
    ErrorIf(mSize == 0, "Empty array, no back element.");
    return mData[mSize - 1];
  }

  const_reference back() const
  {
    ErrorIf(mSize == 0, "Empty array, no back element.");
    return mData[mSize - 1];
  }

  void push_back(type& element)
  {
    ErrorIf(mSize>=maxSize, "Array at max size");
    mData[mSize] = element;
    ++mSize;
  }

  type& push_back()
  {
    ErrorIf(mSize>=maxSize, "Array at max size");
    ++mSize;
    return *(mData+(mSize-1));
  }

  //Removes the last element in the array.
  void pop_back()
  {
    ErrorIf(mSize == 0,"Empty array, can not pop back element.");
    --mSize;
  }

  void eraseIndex(uint index)
  {
    ErrorIf(index>mSize, "Index out of bounds.");
    //Shift over values
    uint lastValid = mSize-1;
    for(uint i=index;index<lastValid;++i)
      mData[i] = mData[i+1];
    //decrement size
    --mSize;
  }

  //simple erase value
  void erase_value(type& value)
  {
    for(uint i=0;i<mSize;++i)
    {
      if(mData[i] == value)
      {
        //value found remove it
        eraseIndex(i);
        return;
      }
    }
  }

protected:
  type mData[maxSize];
  size_type mSize;
};

template<size_t maxSize>
class ZeroSharedTemplate FixedString : public FixedArray<char, maxSize>
{
public:
  typedef FixedArray<char, maxSize> base_type;
  typedef FixedString<maxSize> this_type;
  typedef typename base_type::const_pointer const_pointer;
  typedef typename base_type::size_type size_type;
  
  typedef StringRange range;
  range all()
  { 
    return StringRange(this->mData, this->mSize); 
  }

  FixedString()
    : base_type(0)
  {
    memset(this->mData, 0, maxSize);
  }

  explicit FixedString(const_pointer cstring)
  {
    assign(cstring, strlen(cstring));
  }

  explicit FixedString(range r)
  {
    assign(r.data(), r.length());
  }

  template<size_t otherSize>
  explicit FixedString(const FixedString<otherSize>& fstring)
  {
    assign(fstring.data(), fstring.size());
  }

  void operator=(const_pointer cstring)
  {
    assign(cstring, strlen(cstring));
  }

  void operator=(range r)
  {
    assign(r.data(), r.length());
  }

  void assign(const_pointer cstring, size_type size)
  {
    memset(this->mData, 0, maxSize);

    if (size > maxSize - 1)
    {
      Error("String is not large enough for range.");
      size = maxSize - 1;
    }
    
    this->mSize = size;
    //need room for null terminator
    if(this->mSize > (maxSize - 1))
      this->mSize = maxSize - 1;

    memcpy(this->mData, cstring, this->mSize);
    this->mData[this->mSize] = '\0';
  }

  template<size_t otherSize>
  friend inline bool operator==(const this_type& left,
                                const FixedString<otherSize>& right)
  {
    return strcmp(left.data(), right.data()) == 0;
  }

  template<size_t otherSize>
  friend inline bool operator<(const this_type& left, 
                               const FixedString<otherSize>& right)
  {
    return strcmp(left.data(), right.data()) < 0;
  }

  const_pointer c_str()const{return this->mData;}
};

template<size_t s>
inline bool operator==(const FixedString<s>& left, cstr right)
{
  return strcmp(left.data(), right) == 0;
}

template<size_t s>
inline bool operator!=(const FixedString<s>& left, cstr right)
{
  return strcmp(left.data(), right) != 0;
}

}//namespace Zero


namespace Zero
{

namespace Memory
{

struct ZeroShared Stats
{
  enum StatFlags
  {
    ShowActive     = 1,
    ShowDedicated  = 2,
    ShowPeak       = 4,
    ShowBytes      = 8,
    ShowTotal      = 16,
    ShowLocal      = 32,
    ShowCount      = 64
  };

  MemCounterType Allocations;
  MemCounterType Active;
  MemCounterType BytesAllocated;
  MemCounterType BytesDedicated;
  MemCounterType PeakAllocated;

  Stats();

  template<typename Vistor>
  void Visit(Vistor& vistor, size_t flags);
  void Accumulate(const Stats& right);
};

///Base Memory graph node. All allocators are derived from this class for
///runtime memory statics collection and debugging. Class provides a graph
///structure for hierarchical grouping of memory and the ability to name allocators.
class ZeroShared Graph : public LinkBase
{
public:
  UseStaticMemory();

  cstr GetName(){return Name.c_str();}
  FixedString<32> Name;
  Graph* mParent;
  Stats mData;

  Graph(StringRange name, Graph* parent);

  void DeltaDedicated(MemCounterType bytes)
  {
    mData.BytesDedicated+=bytes;
  }

  void AddAllocation(MemCounterType bytes)
  {
    ++mData.Active;
    ++mData.Allocations;
    mData.BytesAllocated+=bytes;
    if(mData.BytesAllocated > mData.PeakAllocated)
      mData.PeakAllocated = mData.BytesAllocated;
  }

  void RemoveAllocation(MemCounterType bytes)
  {
    --mData.Active;
    mData.BytesAllocated-=bytes;
  }

  typedef InListBaseLink<Graph>::range RangeType;
  RangeType GetChildren(){return Children.all();}

  InListBaseLink<Graph> Children;
  void PrintHelper(size_t tabs, size_t flags, cstr name);
  void PrintHeader(size_t flags);
  void Compute(Stats& data);
  void PrintGraph(size_t flags);
  void Print(size_t tabs, size_t flags);

  virtual void CleanUp();
  virtual ~Graph();
private:
  //Can not copy memory managers.
  Graph(const Graph&);
  void operator=(const Graph&);
};


class Heap;
class Root: public Graph
{
public:
  Root(StringRange name, Graph* parent)
    :Graph(name, parent)
  {
  }

  static Root* RootGraph;
  static Heap* GloblHeap;
  static Heap* StaticHeap;

  static void Initialize();
  static void Shutdown();
  static void PrintAll();
};

Heap* GetGlobalHeap();
Heap* GetNamedHeap(cstr name);
Root* GetRoot();
Heap* GetStaticHeap();
void Shutdown();
void DumpMemoryDebuggerStats(cstr projectName);

class ZeroShared StandardMemory
{
public:
  static inline void MemCopy(void* dest, void* source, size_t numberOfBytes){memcpy(dest, source, numberOfBytes);}
  static inline void MemMove(void* dest, void* source, size_t numberOfBytes){memmove(dest, source, numberOfBytes);}
};

}//namespace Memory
}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file Heap.hpp
/// Declaration of the Heap Allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Zero
{
namespace Memory
{

class HeapPrivate;

///Heap allocator. The heap allocator allocates memory directly from the 
///system heap using malloc and free.
class ZeroShared Heap : public Graph
{
public:
  Heap(StringRange name, Graph* parent);
  MemPtr Allocate(size_t numberOfBytes);
  void Deallocate(MemPtr ptr, size_t numberOfBytes);

  virtual void Print(size_t tabs, size_t flags);
};

template <typename type>
type* HeapAllocate(Heap* heap)
{
  MemPtr memory = heap->Allocate(sizeof(type));
  type* object = new(memory) type();
  return object;
}

template <typename type, typename ConstructionType>
type* HeapAllocate(Heap* heap, const ConstructionType& constructionData)
{
  MemPtr memory = heap->Allocate(sizeof(type));
  type* object = new(memory) type(constructionData);
  return object;
}

template <typename type>
void HeapDeallocate(Heap* heap, type* instance)
{
  instance->~type();
  heap->Deallocate(instance,sizeof(type));
}


}//namespace Memory


#define UseStaticHeap() \
  static void* operator new(size_t size){ return Memory::GetStaticHeap()->Allocate(size); } \
  static void operator delete(void* pMem, size_t size){return Memory::GetStaticHeap()->Deallocate(pMem, size);}

template<typename NodeType>
class ZeroSharedTemplate TypedAllocator : public Memory::StandardMemory
{
public:
  TypedAllocator()
    :mNode(Memory::GetGlobalHeap())
  {
  }

  TypedAllocator(cstr name)
    :mNode(Memory::GetNamedHeap(name))
  {
  }

  TypedAllocator(NodeType* manager)
    :mNode(manager)
  {
  }

  MemPtr Allocate(size_t numberOfBytes){return mNode->Allocate(numberOfBytes); };
  void Deallocate(MemPtr ptr, size_t numberOfBytes){mNode->Deallocate(ptr, numberOfBytes);}
  NodeType* mNode;
};

// This allocator specifically works with 
template<typename NodeType>
class ZeroSharedTemplate MemsetZeroTypedAllocator : public TypedAllocator<NodeType>
{
public:
  MemsetZeroTypedAllocator()
    :mNode(Memory::GetGlobalHeap())
  {
  }

  MemsetZeroTypedAllocator(cstr name)
    :mNode(Memory::GetNamedHeap(name))
  {
  }

  MemsetZeroTypedAllocator(NodeType* manager)
    :mNode(manager)
  {
  }

  MemPtr Allocate(size_t numberOfBytes)
  {
    if(mNode == nullptr)
      mNode = Memory::GetGlobalHeap();
    return mNode->Allocate(numberOfBytes);
  }

  void Deallocate(MemPtr ptr, size_t numberOfBytes)
  {
    if(mNode == nullptr)
      mNode = Memory::GetGlobalHeap();
    mNode->Deallocate(ptr, numberOfBytes);
  }

  NodeType* mNode;
};

typedef TypedAllocator<Memory::Heap> HeapAllocator;

//Override default
typedef TypedAllocator<Memory::Heap> DefaultAllocator;
typedef MemsetZeroTypedAllocator<Memory::Heap> MemsetZeroDefaultAllocator;

}//namespace Zero


#else

namespace Zero
{

void* zAllocate(size_t numberOfBytes);
void zDeallocate(void*);

class ZeroShared StandardMemory
{
public:
  static inline void MemCopy(void* dest, void* source, size_t numberOfBytes)
  {
    memcpy(dest, source, numberOfBytes);
  }

  static inline void MemMove(void* dest, void* source, size_t numberOfBytes)
  {
    memmove(dest, source, numberOfBytes);
  }
};

//Default allocator of Standard Memory. This allocator
//is used by default for all the containers.
class ZeroShared DefaultAllocator : public StandardMemory
{
public:
  enum{ cAlignment = 4 };
  void* Allocate(size_t numberOfBytes) { return zAllocate(numberOfBytes); };
  void Deallocate(void* ptr, size_t numberOfBytes) { zDeallocate(ptr); }
};

}//namespace Zero

#endif



namespace Zero
{

size_t HashString(const char* str, size_t size);

inline size_t HashUint(size_t a)
{
  a = (a ^ 61) ^ (a >> 16);
  a = a + (a << 3);
  a = a ^ (a >> 4);
  a = a * 0x27d4eb2d;
  a = a ^ (a >> 15);
  return a;
}

//From Thomas Wang, Jan 1997
inline size_t Hash64to32Shift(u64 key)
{
  key = (~key) + (key << 18); // key = (key << 18) - key - 1;
  key = key ^ (key >> 31);
  key = key * 21; // key = (key + (key << 2)) + (key << 4);
  key = key ^ (key >> 11);
  key = key + (key << 6);
  key = key ^ (key >> 22);
  return (uint) key;
}

// Policy for how values are hashed
template<typename type>
struct ZeroSharedTemplate HashPolicy : public ComparePolicy<type>
{
  EmptyClass(HashPolicy);
  size_t operator()(const type& value) const
  {
    //Default behavior is to expect the type to have a 
    //hashing member function. If a compile error occurs here
    //define a hashing function or pass in a hash policy.
    return (size_t)value.Hash();
  }
};

// Implementation of the Pair hash function
template<typename type0, typename type1>
size_t Pair<type0, type1>::Hash() const
{
  return HashPolicy<first_type>()(first) ^ HashPolicy<second_type>()(second) * 7187;
}

///Hash Function for short.
template<>
struct ZeroShared HashPolicy<short> : public ComparePolicy<int>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const short& value) const
  {
    size_t valuePromoted = (size_t)value;
    return HashUint(valuePromoted);
  }
};

///Hash Function for Integers.
template<>
struct ZeroShared HashPolicy<int> : public ComparePolicy<int>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const int& value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};

///Hash Function for unsigned integers.
template<>
struct ZeroShared HashPolicy<unsigned int> : public ComparePolicy<unsigned int>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const unsigned int& value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};

template<>
struct ZeroShared HashPolicy<long> : public ComparePolicy<long>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const long& value) const
  {
    return HashUint((size_t)value);
  }
};

template<>
struct ZeroShared HashPolicy<unsigned long> : public ComparePolicy<unsigned long>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const unsigned long& value) const
  {
    return HashUint((size_t)value);
  }
};

///Hash Function for pointers.
template<typename type>
struct ZeroSharedTemplate HashPolicy<type*> : public ComparePolicy<type*>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const type* value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};

///Hash Function for floats.
template<>
struct ZeroShared HashPolicy<float> : public ComparePolicy<float>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const float& value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};

///Hash function for const char *
template<>
struct ZeroShared HashPolicy<const char*> : public ComparePolicy<const char*>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const char* value) const
  {
    return HashString(value, strlen(value));
  }
};

template<>
struct ZeroShared HashPolicy<u64> : public ComparePolicy<u64>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const u64& value) const
  {
    return Hash64to32Shift(value);
  }
};

template<>
struct ZeroShared HashPolicy<s64> : public ComparePolicy<s64>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const s64& value) const
  {
    return Hash64to32Shift((u64)value);
  }
};

void* const cHashOpenNode = NULL;
void* const cHashEndNode = (void*)1;

template<typename ValueType, typename Hasher, typename Allocator>
class ZeroSharedTemplate HashedContainer : public AllocationContainer<Allocator>
{
public:
  //standard container typedefs
  typedef ValueType value_type;
  typedef size_t size_type;
  typedef ValueType& reference;
  typedef const ValueType& const_reference;
  typedef AllocationContainer<Allocator> base_type;
  typedef HashedContainer<ValueType, Hasher, Allocator> this_type;
  using base_type::mAllocator;

protected:
  //Internal node value
  struct Node
  {
    //The value stored in the node (only valid if 'next' is not set to 'cHashOpenNode');
    ValueType Value;

    //Can be set to another node in the chain, or to 'cHashOpenNode'
    //which means the node itself is open, or to 'cHashEndNode'
    //which means its at the end of the chain
    Node* next;
  };

public:

  //Default constructor
  HashedContainer()
  {
    mTableSize = 0;
    mSize = 0;
    mTable = NULL;
    mMaxLoadFactor = 0.8f;
  }

  ~HashedContainer()
  {
    deallocate();
  }

  //Range for hash map.
  struct range
  {
    typedef typename this_type::value_type value_type;

    range()
      : begin(nullptr), end(nullptr), mSize(0)
    {}

    range(Node* rbegin, Node* rend, size_t size)
      : begin(rbegin), end(rend)
    { mSize = size; }

    bool empty()
    { 
      return begin == end;
    }

    reference front()
    {
      return begin->Value;
    }

    void popFront()
    {
      ErrorIf(empty(),"Popped an empty range.");
      ++begin;
      --mSize;

      begin = SkipDead(begin, end);
      //Skip empty slots
      while(begin != end && begin->next == cHashOpenNode)
        ++begin;
    }

    size_t length() { return mSize; }

    size_type size() { return length(); }

  private:
    Node* begin;
    Node* end;
    size_t mSize;
  };

  //Get the hash value for a given value then
  //mod it by the table size to get a valid index.
  size_type HashedIndex(const_reference value)
  {
    return mHasher(value) % mTableSize;
  }

  ///////Container Global Modify//////////////////

  //Rehash the contents of the table.
  void rehash(size_type newTableSize)
  {
    if(newTableSize < mSize)
      return;

    //Expand table to new size
    Node* oldTable = mTable;
    size_type oldTableSize = mTableSize;

    //Allocate the new table
    Node* newTable = (Node*)mAllocator.Allocate(newTableSize * sizeof(Node));

    //Set all buckets to the open node.
    for(size_type i = 0; i < newTableSize; ++i)
      newTable[i].next = (Node*)cHashOpenNode;

    //Set the internal member values
    mTable = newTable;
    mTableSize = newTableSize;
    mSize = 0;

    //Now reinsert all valid buckets values
    for(size_type i = 0; i < oldTableSize; ++i)
    {
      Node& node = oldTable[i];
      if(node.next != cHashOpenNode)
      {
        //If this errors here, it means most likely their 'equals' operator is wrong
        insertInternal(node.Value, OnCollisionError);
      }
    }

    //Free the old table if it existed
    if(oldTableSize != 0)
    {
      destructTableValues(oldTable, oldTableSize);
      mAllocator.Deallocate(oldTable, oldTableSize * sizeof(Node));
    }
  }

  //Destroy all elements.
  void clear()
  {
    destructTableValues(mTable, mTableSize);
    mSize = 0;
  }

  //Destroy all elements and frees all memory.
  void deallocate()
  {
    if(mTable != NULL)
    {
      //free all the values in the and then delete the table.
      destructTableValues(mTable, mTableSize);
      mAllocator.Deallocate(mTable, mTableSize * sizeof(Node));
    }

    mTableSize = 0;
    mSize = 0;
    mTable = NULL;
  }

  range all() const
  {
    Node* start = SkipDead(mTable, mTable + mTableSize);
    return range(start, mTable + mTableSize, mSize);
  }
  
  void swap(this_type& other)
  {
    Swap(mTable, other.mTable);
    Swap(mTableSize, other.mTableSize);
    Swap(mSize, other.mSize);
    Swap(mMaxLoadFactor, other.mMaxLoadFactor);
    Swap(mHasher, other.mHasher);
  }

  ////////////Insertion///////////////////////

  //Override
  static Node* OnCollisionOverride(Node* dest, const_reference value)
  {
    dest->Value = value;
    return dest;
  }

  //Error
  static Node* OnCollisionError(Node* dest, const_reference value)
  {
    (void)value;
    (void)dest;
    Error("Double insert, value was not inserted!");
    return NULL;
  }

  //Just return the bucket
  static Node* OnCollisionReturn(Node* dest, const_reference value)
  {
    (void)value;
    return dest;
  }

  //Insert a value.
  template <typename CollisionFunc>
  Node* insertInternal(const_reference value, CollisionFunc onCollison )
  {
    //Expand the table if insertion would break load factor
    //even if it might be a double insert
    checkForExpand(mSize + 1);

    
    //Find the node for this value this is its
    //primary bucket
    size_type curHash = HashedIndex(value);
    Node* node = mTable + curHash;

    //If the node is empty (see 'next')
    if(node->next != cHashOpenNode)
    {
      //If there is a collision check to see if it the
      //object is in its primary bucket.

      //Possible Collision or same key.
      if(mHasher.equal(node->Value, value))
      {
        return onCollison(node, value);
      }
      else
      {
        //Hash Collision
        //If this hashed value is not in its primary bucket
        //steal this bucket (robin hood hashing)
        size_type actualHash = HashedIndex(node->Value);
        if(actualHash != curHash)
        {
          //Kick the node out of the bucket

          Node* movingNodePrimary = mTable+actualHash;

          ErrorIf(movingNodePrimary->next == cHashOpenNode , 
            "Bad hash function. Hash value has changed or other issue.");

          Node* movingNodePrev = movingNodePrimary;

          //Search through the moving nodes links
          //and find the previous node. This node
          //needs it next updated.
          while(movingNodePrev->next != node)
            movingNodePrev = movingNodePrev->next;

          //Remove the object from the chain.
          movingNodePrev->next = movingNodePrev->next->next;

          //Inert the old object into its bucket chain
          AppendToBucketChain(movingNodePrev, node->Value);

          //Replace in current node
          DestructNode(node);
          FillOpenNode(node, value);

          //Increase size
          ++mSize;
          return node;

        }
        else
        {
          //This bucket is the primary key for this value
          Node* primaryNode = node;

          //Different keys can be in the same bucket chain.
          //So the entire bucket chain must be checked
          //for double insert.

          Node* searchNode = primaryNode;
          while(searchNode != cHashEndNode)
          {
            if(mHasher.equal(searchNode->Value, value))
            {
              return onCollison(searchNode, value);
            }
            searchNode = searchNode->next;
          }

          //Not in the list insert into this chain
          ++mSize;
          return AppendToBucketChain(primaryNode, value);

        }
      }

    }
    else
    {
      //bucket is free use it
      //Construct the key
      //Copy data into it
      ++mSize;
      FillOpenNode(node, value);
      return node;
    }

  }


  ////////Find//////////////////////////////

  //Find an element value that hashes and compares to a
  //value in the hash map.
  template<typename searchType, typename searchHasherType>
  Node* internal_find_as(const searchType& searchValue, 
                         searchHasherType searchHasher) const
  {
    if(mTableSize == 0)
      return (Node*)cHashOpenNode;

    //Hash the value given with the provided hasher.
    size_type searchHash = searchHasher(searchValue) % mTableSize;
    Node* node = mTable+searchHash;

    //If the node's next is set to 'cHashOpenNode', it means that
    // the node itself is open/empty
    if(node->next != cHashOpenNode)
    {
      do
      {
        //Check to see if the value of this node is equal
        //to the search value.
        if(searchHasher.equal(searchValue, node->Value))
          return node;

        //Move through all the objects in the linked list.
        node = node->next;
      }
      while(node != cHashEndNode);

    }
    return (Node*)cHashOpenNode;
  }

  size_t count(const_reference value)
  {
    Node* foundNode = internal_find_as(value, mHasher);
    if(foundNode != cHashOpenNode)
      return 1;
    else
      return 0;
  }


  ///////Erasing//////////////////////////


  //Erase a value if found.
  void erase(const_reference value)
  {
    Node* foundNode = internal_find_as(value, mHasher);
    if(foundNode != cHashOpenNode)
      eraseNode(foundNode);
  }

  void eraseNode(Node* node)
  {
    ErrorIf(node==NULL || node->next == cHashOpenNode, 
            "Attempted to erase an invalid node.");
    size_type eraseHash = HashedIndex(node->Value);
    Node* bucketPrev = mTable + eraseHash;

    if(bucketPrev == node)
    {
      if(bucketPrev->next != (Node*)cHashEndNode)
      {
        //node is the first node in a bucket chain
        //remove the front by moving the next node
        //in the chain into this bucket
        MoveNode(bucketPrev, bucketPrev->next);
      }
      else
      {
        //Node chain just destroy it
        DestructNode(bucketPrev);
      }
      --mSize;
      return;
    }

    //Search for node's parent
    while(bucketPrev->next != node)
      bucketPrev = bucketPrev->next;

    //remove the node from the list
    bucketPrev->next = node->next;
    DestructNode(node);
    --mSize;
  }

  //////////Information Functions///////////
  size_type bucket_count() const { return mTableSize; }
  size_type size() const { return mSize; }
  bool empty()const {return mSize == 0; }

  //////////Load Factor///////////////////////
  float max_load_factor()const { return mMaxLoadFactor; }
  float load_factor() const { return float(mSize) / float(mTableSize); }
  void set_max_load_factor(float newMax)
  {
    mMaxLoadFactor = newMax;
    checkForExpand(mSize);
  }


  ///Equals///////////

  bool operator==(const this_type& other)
  {
    if (other.size() != this->size())
      return false;

    range r = this->all();
    while(!r.empty())
    {
      Node* node = other.internal_find_as(r.front(), mHasher);
      if(node == (Node*)cHashOpenNode)
        return false;

      if (r.front() != node->Value)
        return false;

      r.popFront();
    }

    return true;
  }

protected:

  static Node* SkipDead(Node* start, Node* end)
  {
    while(start != end && start->next == cHashOpenNode)
      ++start;
    return start;
  }

  Node* mTable;
  size_type mTableSize;
  size_type mSize;
  float mMaxLoadFactor;
  Hasher mHasher;
  typedef Node node_type;

  void checkForExpand(size_type newsize)
  {
    if(mTableSize == 0 ||
       (float(newsize) / float(mTableSize)) > max_load_factor())
    {
      size_type newTableSize = GetNextSize(mTableSize);
      if(newTableSize == 0)
        newTableSize = 16;
      rehash(newTableSize);
    }
  }

  //assumes d is power of 2
  size_type GetNextSize(size_type d)
  {
    return d * 2;
  }

  Node* GetLastInBucketChain(Node* node)
  {
    while(node->next != cHashEndNode)
      node = node->next;
    return node;
  }

  inline Node* AppendToBucketChain(Node* root, const_reference value)
  {
    Node* lastInBucket = GetLastInBucketChain(root);
    Node* openSlot = GetNextOpenBucket(lastInBucket);

    FillOpenNode(openSlot, value);
    lastInBucket->next = openSlot;
    return openSlot;
  }

  static void destructTableValues(Node* data, size_type size)
  {
    for(size_type i = 0; i < size; ++i)
    {
      //call the destructor on all the value types
      if(data[i].next != cHashOpenNode)
        data[i].Value.~ValueType();

      data[i].next = (Node*)cHashOpenNode;
    }
  }

  void MoveNode(Node* dest, Node* source)
  {
    DestructNode(dest);

    //Move
    new(&dest->Value) value_type(source->Value);
    dest->next = source->next;

    DestructNode(source);
  }

  void FillOpenNode(Node* node, const_reference value)
  {
    new(&node->Value) value_type(value);
    node->next = (Node*)cHashEndNode;
  }

  void DestructNode(Node* node)
  {
    //Call the destructor on the value
    node->Value.~ValueType();
    //Mark this bucket as open.
    node->next = (Node*)cHashOpenNode;
  }

  Node* GetNextOpenBucket(Node* startingNode)
  {
    Node* cur = startingNode;
    Node* end = mTable + mTableSize;

    //Find a 'nearby' bucket by searching around the current
    //bucket

    while(cur < end)
    {
      if(cur->next == cHashOpenNode)
        return cur;
      ++cur;
    }

    cur = startingNode;
    while(cur >= mTable)
    {
      if(cur->next == cHashOpenNode)
        return cur;
      --cur;
    }

    Error("No free slots. Hash map is not working correctly.");

    return (Node*)cHashOpenNode;
  }

};

}//namespace Zero


///////////////////////////////////////////////////////////////////////////////
///
/// \file Array.hpp
/// Declaration of the Array container.
///
/// Authors: Chris Peters, Andrew Colean
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes



namespace Zero
{
/// Generic dynamic array class / Linear Sequence. Equivalent to std::vector.
/// Stores objects in contiguous blocks of dynamically allocated 
/// memory allowing random access.
/// Constant time insertion and removal at the end. 
/// Linear time for insertion and removal at beginning or middle.
/// This array is also optimized to use pod conventions (memcpy, no destructors)
/// on fundamental types or types with proper type traits.(see TypeTraits).
template< typename ValueType,
          typename Allocator = DefaultAllocator, 
          typename value_tt  = StandardTraits<ValueType> >
class ZeroSharedTemplate Array : public AllocationContainer<Allocator>
{
public:
  /// Standard Typedefs
  typedef ValueType                             value_type;
  typedef value_type*                           pointer;
  typedef const value_type*                     const_pointer;
  typedef value_type&                           reference;
  typedef const value_type&                     const_reference;
  typedef pointer                               iterator;
  typedef const_pointer                         const_iterator;
  typedef size_t                                size_type;
  typedef ptrdiff_t                             difference_type;
  typedef Array<ValueType, Allocator, value_tt> this_type;
  typedef AllocationContainer<Allocator>        base_type;
  using base_type::mAllocator;

  /// Type Traits
  typedef value_tt                                             value_type_traits;
  typedef typename value_type_traits::is_pod_                  typeIsPod;
  typedef typename value_type_traits::has_trivial_copy_        typePodCopy;
  typedef typename value_type_traits::has_trivial_destructor_  typePodDes;
  typedef typename value_type_traits::has_trivial_constructor_ typePodCon;
  typedef typename value_type_traits::is_pod_                  typePodMove;

  /// Constants
  static const size_type InvalidIndex = size_type(-1);

  /// Provides access to a range of elements contained between two iterators
  struct range
  {
    /// Typedefs
    typedef typename this_type::value_type      value_type;
    typedef typename this_type::pointer         pointer;
    typedef typename this_type::const_pointer   const_pointer;
    typedef typename this_type::reference       reference;
    typedef typename this_type::const_reference const_reference;
    typedef typename this_type::iterator        iterator;
    typedef typename this_type::const_iterator  const_iterator;
    typedef typename this_type::size_type       size_type;
    typedef typename this_type::difference_type difference_type;
    typedef value_type                          contiguousRangeType;

    /// Member Functions
    range()                             : mBegin(nullptr), mEnd(nullptr) {}
    range(iterator begin, iterator end) : mBegin(begin), mEnd(end) {}

    /// Data Access
    iterator        begin()                           { return mBegin;         }
    iterator        end()                             { return mEnd;           }
    void            popFront()                        { ++mBegin;              }
    void            popBack()                         { --mEnd;                }
    reference       front()                           { return *mBegin;        }
    reference       back()                            { return *(mEnd - 1);    }
    bool            empty() const                     { return mBegin == mEnd; }
    size_type       length() const                    { return mEnd - mBegin;  }
    size_type       size() const                      { return length();       }
    reference       operator[](size_type index)       { return mBegin[index];  }
    const_reference operator[](size_type index) const { return mBegin[index];  }

    /// Iterators
    iterator mBegin;
    iterator mEnd;
  };

  //
  // Member Functions
  //

  /// Default Constructor
  Array()
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
  }

  /// Copy Constructor
  Array(const this_type& other)
    : base_type(other),
      mData(nullptr),
      mCapacity(other.mSize),
      mSize(other.mSize)
  {
    if(other.mSize != 0)
    {
      mData = (value_type*)mAllocator.Allocate(mSize*sizeof(value_type));
      uninitialized_copy(mData, other.mData, mSize, typePodCopy());
    }
  }

  /// Move Constructor
  Array(MoveReference<this_type> other)
    : base_type(*other),
      mData(other->mData),
      mCapacity(other->mCapacity),
      mSize(other->mSize)
  {
    other->release_data();
  }

  /// Constructs an array of the specified size with default constructed values
  explicit Array(size_type size)
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
    changeCapacity(size);
    uninitialized_fill(mData, size, typePodCon());
    mSize = size;
  }

  /// Constructs an array of the specified size with copy constructed values
  Array(size_type size, const_reference fillType)
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
    changeCapacity(size);
    uninitialized_fill(mData, size, fillType);
    mSize = size;
  }
  Array(ContainerInitializerDummy*, const_reference p0)
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
    reserve(1);
    push_back(p0);
  }
  Array(ContainerInitializerDummy*, const_reference p0, const_reference p1)
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
    reserve(2);
    push_back(p0);
    push_back(p1);
  }
  Array(ContainerInitializerDummy*, const_reference p0, const_reference p1, const_reference p2)
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
    reserve(3);
    push_back(p0);
    push_back(p1);
    push_back(p2);
  }
  Array(ContainerInitializerDummy*, const_reference p0, const_reference p1, const_reference p2, const_reference p3)
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
    reserve(4);
    push_back(p0);
    push_back(p1);
    push_back(p2);
    push_back(p3);
  }
  Array(ContainerInitializerDummy*, const_reference p0, const_reference p1, const_reference p2, const_reference p3, const_reference p4)
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
    reserve(5);
    push_back(p0);
    push_back(p1);
    push_back(p2);
    push_back(p3);
    push_back(p4);
  }
  Array(ContainerInitializerDummy*, const_reference p0, const_reference p1, const_reference p2, const_reference p3, const_reference p4, const_reference p5)
    : mData(nullptr),
      mCapacity(0),
      mSize(0)
  {
    reserve(6);
    push_back(p0);
    push_back(p1);
    push_back(p2);
    push_back(p3);
    push_back(p4);
    push_back(p5);
  }

  /// Destructor
  ~Array()
  {
    deallocate();
  }

  /// Copy Assignment Operator
  void operator=(const this_type& other)
  {
    if(&other == this)
      return;

    assign(const_cast<this_type*>(&other)->all());
  }

  /// Move Assignment Operator
  void operator=(MoveReference<this_type> other)
  {
    if(&other == this)
      return;

    deallocate();

    mData     = other->mData;
    mCapacity = other->mCapacity;
    mSize     = other->mSize;

    other->release_data();
  }

  /// Comparison Operators
  bool operator ==(const this_type& rhs) const
  {
    return equal(this->all(), rhs.all());
  }
  bool operator !=(const this_type& rhs) const
  {
    return !(*this == rhs);
  }

  //
  // Element Information
  //

  /// Maximum number of elements before the internal buffer must be reallocated
  /// Adjusted automatically on insertion or manually with reserve and set_capacity
  size_type capacity() const { return mCapacity; }

  /// Returns true if the array contains any elements, else false
  bool empty() const { return mSize == 0; }

  /// Returns the number of elements in the array
  size_type size() const { return mSize; }

  //
  // Element Access
  //

  /// Returns an iterator to the beginning of the array
  iterator       begin()       { return mData; }
  const_iterator begin() const { return mData; }

  /// Returns an iterator to the end of the array
  iterator       end()       { return mData + mSize; }
  const_iterator end() const { return mData + mSize; }

  /// Returns a range of all elements in the array
  range all()       { return range(begin(), end());           }
  range all() const { return const_cast<Array*>(this)->all(); }

  /// Returns a pointer to the underlying data array
  pointer       data()       { return mData; }
  const_pointer data() const { return mData; }

  /// Returns the range of elements from index to index + length
  range sub_range(size_type index, size_type length)
  {
    ErrorIf(index >= mSize, "Accessed array out of bounds.");
    ErrorIf(index + length > mSize, "Accessed array out of bounds.");
    return range(mData + index, mData + index + length);
  }
  range sub_range(size_type index, size_type length) const
  {
    return const_cast<Array*>(this)->sub_range(index, length);
  }

  /// Returns a reference to the element at the specified index
  reference operator[](size_type index)
  {
    ErrorIf(index >= mSize, "Accessed array out of bounds.");
    return mData[index];
  }
  const_reference operator[](size_type index) const
  {
    ErrorIf(index >= mSize, "Accessed array out of bounds.");
    return mData[index];
  }

  /// Returns a reference to the element at the front of the array
  reference front()
  {
    ErrorIf(mSize == 0, "Empty array, no front element.");
    return mData[0];
  }
  const_reference front() const
  {
    ErrorIf(mSize == 0, "Empty array, no front element.");
    return mData[0];
  }

  /// Returns a reference to the element at the back of the array
  reference back()
  {
    ErrorIf(mSize == 0, "Empty array, no back element.");
    return mData[mSize - 1];
  }
  const_reference back() const
  {
    ErrorIf(mSize == 0, "Empty array, no back element.");
    return mData[mSize - 1];
  }

  //
  // Element Modification
  //

  /// Swaps this array's internal data with another array
  void swap(this_type& other)
  {
    Swap(mData, other.mData);
    Swap(mSize, other.mSize);
    Swap(mCapacity, other.mCapacity);
  }

  /// Constructs an element at the back of the array
  reference push_back()
  {
    expandToNewSize(mSize+1);
    construct(mData+mSize, typeIsPod());
    ++mSize;
    return *(mData+(mSize-1));
  }

  /// Copies an element to the back of the array
  void push_back(const_reference item)
  {
    const_pointer toBeAdded = &item;
    if(mCapacity < mSize + 1)
    {
      //Is the item from this array.
      //This prevents errors with array.push_back(array[0]);
      if(toBeAdded >= begin() && toBeAdded < end())
      {
        size_type index = toBeAdded - begin();
        expandToNewSize(mSize + 1);
        //mData is now the newly allocated array.
        //Find the value in the new array
        toBeAdded = mData + index;
      }
      else
      {
        expandToNewSize(mSize + 1);
      }
    }
    constructWith(mData + mSize, *toBeAdded);
    ++mSize;
  }

  /// Moves an element to the back of the array
  void push_back(MoveReference<value_type> item)
  {
    pointer toBeAdded = &item;
    if(mCapacity < mSize + 1)
    {
      //Is the item from this array.
      //This prevents errors with array.push_back(array[0]);
      if(toBeAdded >= begin() && toBeAdded < end())
      {
        size_type index = toBeAdded - begin();
        expandToNewSize(mSize + 1);
        //mData is now the newly allocated array.
        //Find the value in the new array
        toBeAdded = mData + index;
      }
      else
      {
        expandToNewSize(mSize + 1);
      }
    }
    constructWith(mData + mSize, ZeroMove(*toBeAdded));
    ++mSize;
  }

  /// Removes the element at the front of the array
  void pop_front()
  {
    erase(mData);
  }

  /// Removes the element at the back of the array
  void pop_back()
  {
    ErrorIf(mSize == 0, "Empty array, can not pop back element.");
    destroy(mData + mSize - 1, typePodDes());
    --mSize;
  }

  /// Changes the number of elements stored in the array
  /// Removes or default constructs elements at the back of the array as necessary
  void resize(size_type newSize)
  {
    //Check to see if the size did not change
    if(mSize == newSize)
      return;
    else if(mSize < newSize)
    {
      //Expand memory for array
      reserve(newSize);

      //Only construct on new elements
      //Elements from current size to new size
      uninitialized_fill(mData + mSize, newSize - mSize, typePodCon());
    }
    else
    {
      //array shrinking 
      //Destroy elements from new size to old size
      destroyElements(mData + newSize, mSize - newSize, typePodDes());
    }
    mSize = newSize;
  }

  /// Changes the number of elements stored in the array
  /// Removes or copy constructs elements at the back of the array as necessary
  void resize(size_type newSize, const_reference defaultValue)
  {
    //Check to see if the size did not change
    if(mSize == newSize)
      return;
    else if(mSize < newSize)
    {
      //Expand memory for array
      reserve(newSize);

      //Only construct on new elements
      //Elements from current size to new size
      uninitialized_fill(mData + mSize, newSize - mSize, defaultValue);
    }
    else
    {
      //array shrinking 
      //Destroy elements from new size to old size
      destroyElements(mData + newSize, mSize - newSize, typePodDes());
    }
    mSize = newSize;
  }

  /// Clears all elements from the array
  /// Effectively resizes the array to zero
  void clear()
  {
    destroyElements(mData, mSize, typePodDes());
    mSize = 0;
  }

  /// Reserves at least the specified element capacity
  void reserve(size_type newCapacity)
  {
    if(mCapacity < newCapacity)
      changeCapacity(newCapacity);
  }

  /// Reserves exactly the specified element capacity
  void set_capacity(size_type newCapacity)
  {
    if(newCapacity != mCapacity)
      changeCapacity(newCapacity);
  }

  /// Destroys all elements and frees reserved memory
  void deallocate()
  {
    destroyElements(mData, mSize, typePodDes());
    if(mCapacity)
      mAllocator.Deallocate(mData, sizeof(value_type)*mCapacity);
    mSize = 0;
    mCapacity = 0;
  }

  /// Takes control of a block of memory and treats it as a valid array
  void set_data(pointer memory, size_type size)
  {
    deallocate();
    mSize = size;
    mCapacity = size;
    mData = memory;
  }

  /// Clears all data members, does not free reserved memory
  /// Allows external users to take control of the underlying array
  void release_data()
  {
    mSize = 0;
    mCapacity = 0;
    mData = nullptr;
  }

  //
  // Insertion Operations
  //

  /// Clears the array and inserts a range of elements
  template<typename iteratorType>
  void assign(iteratorType begin, iteratorType end)
  {
    clear();
    insert(0, BuildRange(begin,end));
  }
  template<typename inputRangeType>
  void assign(inputRangeType range)
  {
    clear();
    insert(0, range);
  }
  template<typename inputRangeType>
  void assign(MoveReference<inputRangeType> range)
  {
    clear();
    insert(0, ZeroMove(range));
  }

  /// Appends a range of elements to the end of the array
  template<typename inputRangeType>
  void append(inputRangeType inputRange)
  {
    insert(mData + mSize, inputRange);
  }
  template<typename inputRangeType>
  void append(MoveReference<inputRangeType> inputRange)
  {
    insert(mData + mSize, ZeroMove(inputRange));
  }

  /// Inserts a range of elements before the specified position in the array
  template<typename iteratorType>
  void insert(pointer where, iteratorType begin, iteratorType end)
  {
    insert(where, BuildRange(begin,end));
  }
  template<typename inputRangeType>
  void insert(pointer where, inputRangeType inputRange)
  {
    if(where == nullptr && mSize == 0)
    {
      //insert on empty container
      changeCapacity(inputRange.length());
      where = mData;
    }

    ErrorIf(where < mData || where > mData + mSize, 
            "Access array out of bounds.");

    size_type elementsToInsert = inputRange.length();

    //Expand this container to the new size
    pointer buffer = insertExpandCapacity(where, elementsToInsert);

    for(; !inputRange.empty(); inputRange.popFront())
    {
      constructWith(buffer, inputRange.front());
      ++buffer;
    }

    mSize += elementsToInsert;
  }
  template<typename inputRangeType>
  void insert(pointer where, MoveReference<inputRangeType> inputRange)
  {
    if(where == nullptr && mSize == 0)
    {
      //insert on empty container
      changeCapacity(inputRange->length());
      where = mData;
    }

    ErrorIf(where < mData || where > mData + mSize, 
            "Access array out of bounds.");

    size_type elementsToInsert = inputRange->length();

    //Expand this container to the new size
    pointer buffer = insertExpandCapacity(where, elementsToInsert);

    for(; !inputRange->empty(); inputRange->popFront())
    {
      constructWith(buffer, ZeroMove(inputRange->front()));
      ++buffer;
    }

    mSize += elementsToInsert;
  }
  template<typename inputRangeType>
  void insertAt(size_type index, inputRangeType inputRange)
  {
    //for insertion the index can be mSize
    ErrorIf(index > mSize, "Access array out of bounds.");
    insert(mData + index, inputRange);
  }
  template<typename inputRangeType>
  void insertAt(size_type index, MoveReference<inputRangeType> inputRange)
  {
    //for insertion the index can be mSize
    ErrorIf(index > mSize, "Access array out of bounds.");
    insert(mData + index, ZeroMove(inputRange));
  }

  /// Inserts an element before the specified position in the array
  void insert(pointer where, const_reference value)
  {
    ErrorIf(where < mData || where > mData + mSize, 
            "Access array out of bounds.");
    ConstPointerRange<value_type> singleValue(&value, &value+1);
    insert(where, singleValue);
  }
  void insert(pointer where, MoveReference<value_type> value)
  {
    ErrorIf(where < mData || where > mData + mSize, 
            "Access array out of bounds.");
    PointerRange<value_type> singleValue(&value, &value+1);
    insert(where, ZeroMove(singleValue));
  }
  void insertAt(size_type index, const_reference value)
  {
    //for insertion the index can be mSize
    ErrorIf(index > mSize, "Access array out of bounds.");
    if(index == mSize)
      push_back(value);
    else
      insert(mData + index, value);
  }
  void insertAt(size_type index, MoveReference<value_type> value)
  {
    //for insertion the index can be mSize
    ErrorIf(index > mSize, "Access array out of bounds.");
    if(index == mSize)
      push_back(ZeroMove(value));
    else
      insert(mData + index, ZeroMove(value));
  }

  //
  // Removal Operations
  //

  /// Removes the element at the specified position in the array
  void eraseAt(size_type index)
  {
    ErrorIf(index >= mSize, "Access array out of bounds.");
    eraseElements(mData + index, 1);
  }
  pointer erase(pointer where)
  {
    ErrorIf(where < mData || where > mData + mSize, 
            "Access array out of bounds.");
    eraseElements(where, 1);
    if(!empty())
      return where;//safe memory is not reallocated
    else
      return end();
  }

  /// Removes the sub-range of elements from their positions in the array
  void erase(range elements)
  {
    eraseElements(elements.begin(), elements.length());
  }

  /// Removes the first equivalent element from the array
  template<typename CompareType>
  void erase_value(const CompareType& value)
  {
    size_type index = findIndex(value);

    ReturnIf(index == InvalidIndex, , "Value not found in the array");

    erase(mData + index);
  }

  //
  // Search Operations
  //

  /// Returns the index of the first equivalent element from the array, else InvalidIndex
  template<typename CompareType>
  size_type findIndex(const CompareType& value) const
  {
    for (size_type i = 0; i < mSize; ++i)
    {
      if (mData[i] == value)
        return i;
    }

    return InvalidIndex;
  }

  /// Returns an iterator to the first equivalent element in the array, else end()
  template<typename CompareType>
  iterator find_iterator(const CompareType& value)
  {
    // Find first instance
    size_type index = findIndex(value);
    if(index == InvalidIndex) // Unable?
      return end();
    else
      return mData + index;
  }
  template<typename CompareType>
  const_iterator find_iterator(const CompareType& value) const
  {
    return const_cast<this_type*>(this)->find_iterator(value);
  }

  /// Returns a pointer to the first equivalent element in the array, else nullptr
  template<typename CompareType>
  pointer find_pointer(const CompareType& value) const
  {
    // Find first instance
    size_type index = findIndex(value);
    if(index == InvalidIndex) // Unable?
      return nullptr;
    else
      return mData + index;
  }

  /// Returns true if the array contains an equivalent element, else false
  template<typename CompareType>
  bool contains(const CompareType& value) const
  {
    return findIndex(value) != InvalidIndex;
  }

protected:
  /// Expand the array at where by numberOf elements and return a 
  /// pointer to where the new data will be inserted.
  /// When a large amount of data is inserted the array will
  /// often have to reallocated. Using the standard resize function will
  /// copy all the old elements over to the new array then insert have to
  /// move them again. This function allocates new memory if necessary
  /// and copies the memory in front of and back of where in place. 
  /// It then returns the pointer for the block to insert the new elements.
  pointer insertExpandCapacity(pointer where, size_type numberOfElements)
  {
    size_type neededCapacity = numberOfElements + mSize ;
    if(neededCapacity > mCapacity)
    {
      //Need more room expand capacity
      size_type newCapacity = mCapacity + (mCapacity / 2);
      if(neededCapacity > newCapacity)
      {
        //Needed size is bigger then %50 expansion
        //just use the new size
        newCapacity = neededCapacity;
      }

      pointer newData = (pointer)mAllocator.Allocate(newCapacity*sizeof(value_type));
      size_type firstBlockSize = where - mData;
      size_type secondBlockSize = end() -  where;
      pointer startOfSecondBlock = newData+firstBlockSize+numberOfElements;
      pointer startOfFirstBlock = newData;

      if(mSize != 0)
      {
        //Copy over first block of data
        if(firstBlockSize != 0)
          uninitialized_move(startOfFirstBlock, mData, firstBlockSize, typePodMove());


        //Copy over second block of data
        if(secondBlockSize != 0)
        {
          uninitialized_move(startOfSecondBlock, mData+firstBlockSize, 
                             secondBlockSize, typePodMove());
        }
      }

      //Deallocate old memory
      if(mCapacity != 0)
        mAllocator.Deallocate(mData, sizeof(value_type)*mCapacity);


      mCapacity = newCapacity;
      mData = newData;

      return newData + firstBlockSize;

    }
    else
    {
      //There is enough room just move the elements after where outwards
      size_type elementsToMove = end() - where;

      //Watch out we have an overlapped write
      if(elementsToMove != 0)
      {
        uninitialized_moveRev(where + numberOfElements, where, elementsToMove, 
                              typePodMove());
      }
      return where;
    }
  }

  /// Removes the specified number of elements from the array starting at the given position
  void eraseElements(pointer where, size_type numberOfElements)
  {
    size_type elementsToMove = (end() - where) - numberOfElements;

    destroyElements(where, numberOfElements, typeIsPod());

    if(elementsToMove > 0)
    {
      uninitialized_move(where, where + numberOfElements, elementsToMove, 
                         typePodMove());
    }

    mSize -= numberOfElements;
  }

  /// Expands the underlying array capacity as necessary to fit the specified new size
  void expandToNewSize(size_type newSize)
  {
    //Do not expand if new size fits in current capacity
    if(mCapacity < newSize)
    {
      //If capacity is not zero expand by %50 of capacity
      //if it is zero set it to 2
      size_type expandedSize = mCapacity != 0 ? mCapacity + (mCapacity / 2) : 2;
      if(expandedSize < newSize)
      {
        //%50 expansion was not enough space just expand to the new size
        changeCapacity(newSize);
      }
      else
      {
        //use the expanded size
        changeCapacity(expandedSize);
      }
    }
  }

  /// This function directly changes the capacity
  /// If the capacity is lowered it will destroy the old elements using resize
  void changeCapacity(size_type newCapacity)
  {
    //delete extra elements if necessary
    if(newCapacity < mSize)
      resize(newCapacity);

    if(newCapacity == 0)
      return;

    //Allocate the new buffer size
    pointer newData = (pointer)mAllocator.Allocate(newCapacity*sizeof(value_type));

    //copy everything in mSize above. resize call above shrinks if necessary.
    if(mSize != 0)
      uninitialized_move(newData, mData, mSize, typePodMove());

    //Deallocate old memory if any allocated
    if(mCapacity != 0)
      mAllocator.Deallocate(mData, sizeof(value_type)*mCapacity);

    mCapacity = newCapacity;
    mData = newData;
  }

  /// Underlying array
  pointer   mData;
  /// Element capacity
  size_type mCapacity;
  /// Number of elements in the array
  size_type mSize;

  /// Friends
  template<typename T>
  friend struct MoveWithoutDestructionOperator;
};

/// PodArray is the same as Array except Pod conventions are forced on
template<typename ValueType, typename Allocator = DefaultAllocator>
class ZeroSharedTemplate PodArray : public Array<ValueType, Allocator, PodOverride>
{
public:
  typedef Array<ValueType, Allocator, PodOverride> base_type;
  typedef typename base_type::size_type size_type;

  PodArray()
    : base_type()
  {
  }

  explicit PodArray(size_type size)
    : base_type(size)
  {
  }
};

/// Array Move-Without-Destruction Operator
template<typename ValueType, typename Allocator, typename tt_traits>
struct MoveWithoutDestructionOperator<Array<ValueType, Allocator, tt_traits> >
{
  static inline void MoveWithoutDestruction(Array<ValueType, Allocator, tt_traits>* dest, 
                                            Array<ValueType, Allocator, tt_traits>* source)
  {
    dest->mData = source->mData;
    dest->mCapacity = source->mCapacity;
    dest->mSize = source->mSize;

    new (&dest->mAllocator) Allocator(source->mAllocator);
  }
};

} // namespace Zero



namespace Zero
{
//----------------------------------------------------------------------- Utility
bool CaseSensitiveCompare(char a, char b);
bool CaseInsensitiveCompare(char a, char b);
typedef bool (*CharComparer)(char a, char b);

//----------------------------------------------------------------------- String
class ZeroShared String
{
public:
  ///////Standard typedefs/////////////
  typedef char              value_type;
  typedef value_type*       pointer;
  typedef const value_type* const_pointer;
  typedef value_type&       reference;
  typedef const value_type& const_reference;
  typedef size_t            size_type;
  typedef s32               count_type;
  typedef std::ptrdiff_t    difference_type;
  typedef String            this_type;
  typedef StringRange       range;

  ///////Iterators/////////////////////
  typedef const value_type* iterator;
  typedef const value_type* const_iterator;

  static const uint InvalidIndex = (uint)-1;

  struct StringNode
  {
    count_type RefCount;
    size_type Size;
    size_type HashCode;
    value_type Data[1];

    void addRef();

    void release();

    static bool isEqual(StringNode* l, StringNode* r);
  };

  ///////Constructors//////////////////
  String();

  String(StringNode* node)
  {
    mNode = node;
    node->HashCode = HashString(node->Data, node->Size);
  }

  //Caution: This is not explicit for ease of use.
  String(const_pointer cstring)
  {
    if(cstring != NULL)
    {
      size_t length = strlen(cstring);
      if (length == 0)
        initializeToDefault();
      else
        assign(cstring, length);
    }
    else
    {
      Error("Construction of a string from a NULL pointer is not valid");
      initializeToDefault();
    }
  }

  String(StringRange str)
  {
    assign(str.begin, str.size());
  }

  String(const_pointer cstring, size_type size)
  {
    assign(cstring, size);
  }

  String(const_pointer cstart, const_pointer cend)
  {
    assign(cstart, cend - cstart);
  }

  //Copy constructor
  String(const this_type& rhs)
  {
    assign(rhs.mNode);
  }

  explicit String(char character)
  {
    char str[2] = { character, '\0' };
    assign(str, 1);
  }

  explicit String(int unicodeCharacter)
  {
    //until we actually do unicode encoding, just call the character version
    char str[2] = { (char)unicodeCharacter, '\0' };
    assign(str, 1);
  }

  String& operator=(const String& other)
  {
    // Instead of checking if we're doing self assignment with the string, its much more useful to check if
    // we're self assigning the node (because there could be two different String objets with the same StringNode)
    if (this->mNode == other.mNode)
      return *this;

    //release this strings data
    release();
    //assign and add a reference
    assign(other.mNode);
    return *this;
  }

  ~String() 
  {
    release();
  }

  ///////Data Access Functions/////////
  size_type hash() const
  {
    return mNode->HashCode;
  }

  value_type operator[](size_type index) const
  {
    // We allow the index to access the null character at the end
    ErrorIf(index > size(), "Accessed string array out of bounds.");
    return *(data() + index);
  }

  bool empty() const { return mNode->Size == 0; }
  const_pointer data() const { return mNode->Data; }
  const_pointer c_str() const { return mNode->Data; }
  size_type size() const { return mNode->Size; }
  void clear() { *this = String(); }
  char front() const { return mNode->Data[0]; }
  char back() const { return mNode->Data[mNode->Size - 1]; }

  ////////Equality and Inequality///////


  //////////Equal operators//////////////
  //Primary equal operator for strings
  friend inline bool operator == (const this_type& left, const this_type& right)
  {
    return StringNode::isEqual(left.mNode, right.mNode);
  }

  bool operator != (const String& right) const
  {
    return !((*this) == right);
  }

  ///////Less than operators///////////
  friend inline bool operator < (const this_type& left, const this_type& right)
  {
    return strcmp(left.c_str(), right.c_str()) < 0;
  }

  ///////Greater than operators///////////
  friend inline bool operator > (const this_type& left, const this_type& right)
  {
    return strcmp(right.c_str(), left.c_str()) < 0;
  }

  StringRange sub_string_unsafe(size_type offset, size_type length) const
  {
    return all().sub_string_unsafe(offset, length);
  }

  StringRange sub_string(size_type offset, size_type length) const
  {
    return all().sub_string(offset, length);
  }

  operator StringRange() const { return all(); }

  ///////Iteration/////////////////////////

  iterator begin() const { return c_str(); }
  iterator end() const { return c_str() + size(); }
  StringRange all() const { return StringRange(begin(), end()); }
  static String Format(cstr format, ...);
  static String FormatArgs(cstr format, va_list va);

  // Gets the string node that represents this string (only use in advanced cases)
  StringNode* GetNode() const { return mNode; }

  template<typename type>
  friend struct MoveWithoutDestructionOperator;
  static String ReplaceSub(StringRange source, StringRange text, 
                              size_type start, size_type end);

  uint FindFirstOf(byte value) const
  {
    return all().FindFirstOf(value);
  }

  uint FindFirstOf(const StringRange& value) const
  {
    return all().FindFirstOf(value);
  }

  uint FindLastOf(byte value) const
  {
    return all().FindLastOf(value);
  }

  uint FindLastOf(const StringRange& value) const
  {
    return all().FindLastOf(value);
  }

  uint FindFirstNonWhitespaceCharIndex() const
  {
    return all().FindFirstNonWhitespaceCharIndex();
  }

  uint FindLastNonWhitespaceCharIndex() const
  {
    return all().FindLastNonWhitespaceCharIndex();
  }

  char FindFirstNonWhitespaceChar() const
  {
    return all().FindFirstNonWhitespaceChar();
  }

  char FindLastNonWhitespaceChar() const
  {
    return all().FindLastNonWhitespaceChar();
  }

  /// Returns true if all the characters in a string are upper-case
  bool IsAllUpper() const
  {
    return all().IsAllUpper();
  }

  /// Returns true if all the characters in a string are whitespace
  bool IsAllWhitespace() const
  {
    return all().IsAllWhitespace();
  }

  /// Returns true if the string starts with the given text
  bool StartsWith(StringRange startsWith, CharComparer compare = CaseSensitiveCompare) const
  {
    return StartsWith(all(), startsWith, compare);
  }

  /// Returns true if the string starts with the given text
  static bool StartsWith(StringRange source, StringRange startsWith, CharComparer compare = CaseSensitiveCompare)
  {
    // If the string we're matching is larger than our string, then we don't match
    if (startsWith.size() > source.size())
      return false;

    for (uint i = 0; i < startsWith.size(); ++i)
    {
      char compareChar = startsWith[i];
      char ourChar = source[i];
      
      if (!compare(compareChar, ourChar))
      {
        return false;
      }
    }

    return true;
  }

  static String Repeat(char c, size_t numberOfTimes)
  {
    // Create a temporary memory buffer that contains the character repeated over and over
    char* buffer = (char*)alloca(numberOfTimes);
    memset(buffer, c, numberOfTimes);

    // Return a string made out of the buffer
    return String(buffer, numberOfTimes);
  }

  bool Contains(StringRangeParam value) const
  {
    return all().Contains(value);
  }

  int CompareTo(StringRangeParam value) const
  {
    return all().CompareTo(value);
  }

  bool EndsWith(StringRangeParam value) const
  {
    return all().EndsWith(value);
  }

  StringRange FindFirstRangeOf(StringRangeParam value)
  {
    return all().FindFirstRangeOf(value);
  }

  StringRange FindLastRangeOf(StringRangeParam value)
  {
    return all().FindLastRangeOf(value);
  }

  StringRange FindRangeExclusive(StringRangeParam startRange, StringRangeParam endRange)
  {
    return all().FindRangeExclusive(startRange, endRange);
  }

  StringRange FindRangeInclusive(StringRangeParam startRange, StringRangeParam endRange)
  {
    return all().FindRangeInclusive(startRange, endRange);
  }

  static String Join(StringRangeParam separator, StringRangeParam string1, StringRangeParam string2);
  static String Join(StringRangeParam separator, StringRangeParam string1, StringRangeParam string2, StringRangeParam string3);
  static String Join(StringRangeParam separator, StringRangeParam string1, StringRangeParam string2, StringRangeParam string3, StringRangeParam string4);
  static String Join(StringRangeParam separator, const Array<String>& strings);

  // A simple policy (to be used with Join below) to convert a the value type of a
  // range of Strings to StringRanges (aka to convert range.front() to a StringRange)
  struct SimplePolicy
  {
    StringRange ToStringRange(const String& value)
    {
      return value.all();
    }
  };

  // Joins the given range with the provided separator. The range is assumed to be copyable
  // (to get the size of the range) and the policy is expected to have a ToStringRange member
  // function that takes the type of range.front() and returns a StringRange.
  template <typename RangeType, typename PolicyType>
  static String JoinRange(StringRangeParam separator, RangeType range, PolicyType policy)
  {
    // First we need to know how big the range is, so copy the range and iterate over to count
    RangeType counterRange = range;
    size_t count = 0;
    for(; !counterRange.empty(); counterRange.popFront())
      ++count;
    
    // Now allocate enough pointers for the ranges and copy them over
    StringRange* values = (StringRange*)alloca(sizeof(StringRange) * count);
    size_t i = 0;
    // Fill out the array of StringRanges
    for(; !range.empty(); range.popFront())
    {
      values[i] = policy.ToStringRange(range.front());
      ++i;
    }
    
    return JoinInternal(separator, values, count);
  }

  template <typename RangeType>
  static String JoinRange(StringRangeParam separator, RangeType range)
  {
    // Assume range.front() returns String and use the SimplePolicy
    return JoinRange<RangeType, SimplePolicy>(separator, range, SimplePolicy());
  }

  static String JoinInternal(StringRangeParam separator, const StringRange* values, size_t count);

  String Replace(StringRangeParam oldValue, StringRangeParam newValue) const
  {
    return all().Replace(oldValue, newValue);
  }

  StringSplitRange Split(StringRangeParam separator) const
  {
    return all().Split(separator);
  }

  bool StartsWith(StringRangeParam value)
  {
    return all().StartsWith(value);
  }

  StringRange TrimStart()
  {
    return all().TrimStart();
  }

  StringRange TrimEnd()
  {
    return all().TrimEnd();
  }

  StringRange Trim()
  {
    return all().Trim();
  }

  String ToUpper() const
  {
    return all().ToUpper();
  }

  String ToLower() const
  {
    return all().ToLower();
  }

  // Internally allocates a node
  // This should never be called by the user except in rare optimization cases
  static StringNode* allocateNode(size_type size);

private:
  void initializeToDefault();
  void addRef();
  void release();
  void assign(const_pointer data, size_type size);
  void assign(StringNode* node);
  StringNode* mNode;
};

typedef const String& StringParam;
typedef const String& StringRef;

//----------------------------------------------------------- String Token Range
class StringTokenRange
{
public:
  StringTokenRange(StringRange stringRange, char delim);
  
  StringRange front();
  void popFront();
  bool empty();


  StringRange curRange;
  StringRange internalRange;
  char mDelim;
};

inline bool operator==(const String& left, cstr right)
{
  return strcmp(left.data(), right) == 0;
}

inline bool operator!=(const String& left, cstr right)
{
  return strcmp(left.data(), right) != 0;
}

inline bool operator<(const String& left, cstr right)
{
  return strcmp(left.data(), right) < 0;
}

//String vs other StringRange
inline bool operator==(const String& left, const StringRange& right)
{
  return left.size() == right.size() && 
         strncmp(left.data(), right.data(), right.size()) == 0;
}

inline bool operator==(const StringRange& left, const String& right)
{
  return left.size() == right.size() && 
         strncmp(left.data(), right.data(), left.size()) == 0;
}

inline bool operator<(const String& left, const StringRange& right)
{
  return strncmp(left.data(), right.data(), right.size()) < 0;
}

inline bool operator<(const StringRange& left, const String& right)
{
  return strncmp(left.data(), right.data(), left.size()) < 0;
}

template<size_t s>
inline bool operator==(const FixedString<s>& left, const String& right)
{
  return strcmp(left.data(), right.data()) == 0;
}

template<size_t s>
inline bool operator==(const String& left, const FixedString<s>& right)
{
  return strcmp(left.data(), right.data()) == 0;
}

//--------------------------------------------------- Hash Policy (String Range)
//Hash policy for string range
template<>
struct ZeroShared HashPolicy<StringRange>
{
  EmptyClass(HashPolicy);
  inline size_t operator () (const StringRange& value) const
  {
    return HashString(value.begin, value.size());
  }

  inline bool equal(const StringRange& left, const StringRange& right) const
  {
    return left == right;
  }

  template<typename stringType>
  inline bool equal(const StringRange& left, const stringType& right) const
  {
    // use operator == to other type, usually strings
    return right == left;
  }
};

//--------------------------------------------------------- Hash Policy (String)
//Hash policy for String class.
template<>
struct ZeroShared HashPolicy<String>
{
  EmptyClass(HashPolicy);
  inline size_t operator () (const String& value) const
  {
    return value.hash();
  }

  inline bool equal(const String& left, const String& right) const
  {
    return left == right;
  }
};

//------------------------------------------------------- Move Operator (String)
template<>
struct MoveWithoutDestructionOperator<String>
{
  static inline void MoveWithoutDestruction(String* dest, String* source)
  {
    dest->mNode = source->mNode;
  }
};

//------------------------------------------------------------- Global Functions
String ToLower(StringParam before);

// Wraps text input on space boundaries (does not add -)
String WordWrap(StringRange input, size_t maxLineLength);

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file StringUtility.hpp
///
/// 
/// Authors: Chris Peters
/// Copyright 2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

//----------------------------------------------------------------------- String
bool CaseInsensitiveStringLess(String a, String b);

// Split string into to two parts not including the delimiter
// if the delimiter is not found it will return an empty range as the second range.
Pair<StringRange,StringRange> SplitOnFirst(StringRange filename, char delimiter);

// Split string into to two parts not including the delimiter
// if the delimiter is not found it will return an empty range as the second range.
Pair<StringRange,StringRange> SplitOnLast(StringRange filename, char delimiter);

// Strip all of string before last of delimiter
StringRange StripBeforeLast(StringRange filename, char delimiter);

//Join strings together using a delimiter
String JoinStrings(const Array<String>& strings, StringParam delimiter);

char OnlyAlphaNumeric(char c);

// Fills a given string array with all permutations of a given string
void Permute(StringParam src, Array<String>& perms);

// Fills a given string array with all permutations of a given string
void SuperPermute(StringParam src, Array<String>& perms);

template<typename transformFunc>
String TransformString(StringRange string, transformFunc f)
{
  uint size = string.size();
  uint bufferSize = size+1;
  char* buffer = (char*)alloca(bufferSize);
  ZeroStrCpy(buffer, bufferSize, string.data());
  for (size_t i = 0; i < size; ++i)
    buffer[i] = f(buffer[i]);
  buffer[size] = '\0';
  return buffer;
}

template<typename Predicate>
StringRange RangeUntilFirst(String string, Predicate predicate)
{
  for(uint i=0;i<string.size();++i)
  {
    if(predicate(string[i]))
      return string.sub_string(0, i);
  }
  return string.all();
}

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file StringBuilder.hpp
/// Declaration of StringBuilder.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


///////////////////////////////////////////////////////////////////////////////
///
/// \file StringConversion.hpp
/// Conversion to and from strings.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once




namespace Zero
{

// Convert Integers into hexadecimal format "4A34"
uint WriteToHex(char* buffer, uint bufferSize, u64 integerValue);
uint WriteToHex(char* buffer, uint bufferSize, u32 integerValue);

// Write out 'places' number of hex digits from integerValue
uint WriteToHexSize(char* buffer, uint bufferSize, uint places, u64 integerValue);

// Read 64 bit hex string
u64 ReadHexString(StringRange range);

//Basic conversion function (input must be UTF-16/2) DestAscii must unicodeLength +1 (for null terminator)
void ConvertUnicodeToAscii(char* destAscii, uint destAsciiLength, const wchar_t* unicodeData, size_t unicodeLength);

// Convert String to value (takes value reference so function can be overloaded)
void ToValue(StringRange range, String& value);
void ToValue(StringRange range, StringRange& value);

void ToValue(StringRange range, bool& value);
void ToValue(StringRange range, float& value);
void ToValue(StringRange range, double& value);
void ToValue(StringRange range, int& value);
void ToValue(StringRange range, uint& value);
void ToValue(StringRange range, u64& value);
void ToValue(StringRange range, s64& value);

template<typename type>
inline void ToValue(StringRange token, type& value)
{
  //no ToValue cast for this type
  type::InvalidCall();
}

// Convert value to string and  write into buffer returns the number of bytes written.
uint ToBuffer(char* buffer, uint bufferSize, bool value, bool shortFormat = false);
uint ToBuffer(char* buffer, uint bufferSize, float value, bool shortFormat = false);
uint ToBuffer(char* buffer, uint bufferSize, double value, bool shortFormat = false);
uint ToBuffer(char* buffer, uint bufferSize, int value, bool shortFormat = false);
uint ToBuffer(char* buffer, uint bufferSize, uint value, bool shortFormat = false);
uint ToBuffer(char* buffer, uint bufferSize, u64 value, bool shortFormat = false);

template<typename type>
uint ToBuffer(char* buffer, uint bufferSize, const type& value)
{
  // No ToBuffer for this type
  return type::InvalidCall();
}

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file ByteBuffer.hpp
/// Definition of ByteBuffer.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

class ByteBufferBlock;

///ByteBuffer used for efficient appending. Structured as an array of blocks.
class ZeroShared ByteBuffer
{
public:
  typedef unsigned char byteType;

  //Block of data in the ByteBuffer
  struct Block
  {
    size_t Size;
    byteType* Data;
  };

  //Block range is used to iterate
  //through all blocks on the buffer.
  struct BlockRange
  {
    BlockRange(ByteBuffer* buffer);
    const Block& front();
    bool empty();
    void popFront();
  private:
    void loadBlock();
    size_t mBlockSize;
    size_t mLastBlockSize;
    byteType** mBlock;
    byteType** mLast;
    Block mCurrent;
  };

  ByteBuffer(size_t blockSize=512);
  ~ByteBuffer();

  //Get current position of writing
  size_t Tell();

  //Write bytes to the buffer.
  void Write(const byteType* data, size_t sizeInBytes);

  //Add Data to end of buffer.
  void Append(const byteType* data, size_t sizeInBytes);

  //Backs up by a certain number of bytes
  void Backup(size_t sizeInBytes);

  byte operator[](size_t index) const;
  byte& operator[](size_t index);

  //Get size of buffer.
  size_t GetSize() const {return mTotalSize;}

  //Get buffer as a string
  String ToString() const;

  //Extract into a raw memory buffer
  void ExtractInto(byteType* buffer, size_t bufferSizeInBytes) const;

  //Extract into a ByteBufferReader
  void ExtractInto(ByteBufferBlock& buffer) const;

  //Deallocate memory of blocks
  void Deallocate();

  //Get range of all blocks
  BlockRange Blocks();

private:
  ByteBuffer(const ByteBuffer&) {};
  void operator=(const ByteBuffer&) {};

protected:

  Array<byteType*> mBlocks;
  size_t mBlockSize;
  size_t mTotalSize;
  size_t mCurBlockSize;
  byteType* mCurBlockBuffer;
};

///ByteBufferBlock is a simple wrapper around a single contiguous block of memory.
///has same interface as a file.
class ByteBufferBlock
{
public:
  ByteBufferBlock();
  ~ByteBufferBlock();

  //Create buffer with the given size
  ByteBufferBlock(size_t size);

  //Create a buffer from existing data. If data is owned
  //buffer will deallocate data on destruction.
  ByteBufferBlock(byte* data, size_t size, bool owned);

  //Set data to use for this byte buffer
  void SetData(byte* data, size_t size, bool owned);

  //Set data block to use for this byte buffer
  void SetBlock(DataBlock block);

  //Read data from buffer.
  size_t Read(byte* data, size_t sizeInBytes);

  //Write data to the buffer
  size_t Write(byte* data, size_t sizeInBytes);
  
  //Write a single byte of data
  size_t Write(byte value);

  //Seek to position
  void Seek(int offset, uint origin);

  //Pointer to current position in buffer.
  byte* GetCurrent();

  //Size of a buffer.
  size_t Size();

  //Return current position.
  size_t Tell();
  
  //Get start of block
  byte* GetBegin();

  //Deallocate memory if owned.
  void Deallocate();

private:
  byte* mData;
  size_t mSize;
  byte* mCurrent;
  bool mOwnsData;
  friend class ByteBuffer;
};

}


namespace Zero
{

//Simple String Builder
String BuildString(StringRange a, StringRange b);
String BuildString(StringRange a, StringRange b, StringRange c);
String BuildString(StringRange a, StringRange b, StringRange c, StringRange d);
String BuildString(StringRange a, StringRange b, StringRange c, StringRange d, StringRange e);
String BuildString(StringRange** ranges, uint count);

String StringJoin(Array<String>& strings, StringParam joinToken);


///Extension of ByteBuffer for building strings. Has
///stream operators overloaded so it can act as a replacement
///for io streams.
class ZeroShared StringBuilder : public ByteBuffer
{
public:
  template<typename type>
  friend struct MoveWithoutDestructionOperator;

  StringBuilder(){};
  ~StringBuilder(){};
  void operator+=(StringRange adapter){Append(adapter);}
  void operator+=(char character){Append(character);}
  void Append(StringRange adapter);
  void Append(char character);
  char& operator[](size_t index);

  void Repeat(size_t count, StringParam str);

private:
  StringBuilder(const StringBuilder&) {};
  void operator=(const StringBuilder&) {};
};

template<>
struct MoveWithoutDestructionOperator<StringBuilder>
{
  static inline void MoveWithoutDestruction(StringBuilder* dest, StringBuilder* source)
  {
    MoveWithoutDestructionOperator< Array<ByteBuffer::byteType*> >::MoveWithoutDestruction(&dest->mBlocks, &source->mBlocks);
    
    dest->mBlockSize = source->mBlockSize;
    dest->mTotalSize = source->mTotalSize;
    dest->mCurBlockSize = source->mCurBlockSize;
    dest->mCurBlockBuffer = source->mCurBlockBuffer;
  }
};

inline StringBuilder& operator<<(StringBuilder& builder, StringRange range)
{
  builder.Append(range);
  return builder;
}

inline StringBuilder& operator<<(StringBuilder& builder, cstr text)
{
  builder.Append(text);
  return builder;
}

inline StringBuilder& operator<<(StringBuilder& builder, char character)
{
  builder.Append(character);
  return builder;
}

inline StringBuilder& operator<<(StringBuilder& builder, StringRef str)
{
  builder.Append(str.all());
  return builder;
}

//Generic templated
template<typename type>
inline StringBuilder& operator<<(StringBuilder& builder, const type& value)
{
  const uint bufferSize = 128;
  char buffer[bufferSize];
  uint size = ToBuffer(buffer, bufferSize, value);
  builder.Append(StringRange(buffer, buffer+size));
  return builder;
}


}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file HashMap.hpp
/// Definition of the HashMap associative container.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once




namespace Zero
{

template<typename Hasher, typename KeyType, typename DataType>
struct ZeroSharedTemplate PairHashAdapter
{
  Hasher mHasher;
  typedef Pair<KeyType, DataType> pair_type;

  size_t operator()(const KeyType& value)
  {
    return mHasher(value);
  }

  size_t operator()(const pair_type& value)
  {
    return mHasher(value.first);
  }

  bool equal(const pair_type& left, const pair_type& right)
  {
    return mHasher.equal(left.first, right.first);
  }

  template<typename otherPairType>
  bool equal(const KeyType& left, const otherPairType& rightPair)
  {
    return mHasher.equal(left, rightPair.first);
  }
};

///Hash Map is an Associative Hashed Container. 
//Stores values by hashing keys providing constant insertion, removal, and 
//searching. Iteration is not in done is sort order.
template< typename KeyType, typename DataType, 
          typename Hasher = HashPolicy<KeyType>, 
          typename Allocator = DefaultAllocator >
class ZeroSharedTemplate HashMap :  public HashedContainer< Pair<KeyType, DataType>, 
                                                            PairHashAdapter< Hasher, KeyType, DataType >, 
                                                            Allocator >
{
public:
  typedef KeyType key_type;
  typedef DataType data_type;
  typedef HashMap<KeyType, DataType> this_type;
  typedef Pair<KeyType, DataType> value_type;
  typedef Pair<KeyType, DataType> pair;
  typedef size_t size_type;
  typedef data_type& reference;
  typedef HashedContainer< value_type, 
                           PairHashAdapter<Hasher, KeyType, DataType>, 
                           Allocator > base_type;
  typedef typename base_type::Node* iterator;
  typedef typename base_type::Node Node;
  typedef typename base_type::range range;

  HashMap()
  {
  }

  ~HashMap()
  {
  }

  struct valuerange
  {
    typedef data_type value_type;
    range r;
    valuerange(const typename base_type::range& _r)
      : r(_r){}
    bool empty() { return r.empty(); }
    void popFront() { return r.popFront(); }
    size_type size() { return r.size(); }
    reference front() { return r.front().second; }
  };
  
  // range of all the values in the map.
  valuerange values() const { return valuerange(base_type::all()); }

  data_type& operator[](const key_type& key)
  {
    Node* node = base_type::internal_find_as(key, base_type::mHasher);
    if(node != cHashOpenNode)
    {
      return node->Value.second;
    }
    else
    {
      value_type newType(key, data_type());
      node = base_type::insertInternal(newType, base_type::OnCollisionOverride);
      return node->Value.second;
    }
  }

  void insert(const value_type& datapair)
  {
    base_type::insertInternal(datapair, base_type::OnCollisionOverride);
  }

  void insert(const key_type& key, const data_type& value)
  {
    base_type::insertInternal(value_type(key, value), base_type::OnCollisionOverride);
  }

  void insert(range pair_range)
  {
    for (; !pair_range.empty(); pair_range.popFront())
    {
      base_type::insertInternal(pair_range.front(), base_type::OnCollisionOverride);
    }
  }

  bool insertOrError(const value_type& datapair)
  {
    return base_type::insertInternal(datapair, base_type::OnCollisionError) != NULL;
  }

  bool insertOrError(const key_type& key, const data_type& value)
  {
    return base_type::insertInternal(value_type(key, value), base_type::OnCollisionError) != NULL;
  }

  template <typename VType>
  bool insertOrError(const VType& value, cstr error)
  {
    (void)error;
    bool result = insertOrError(value);
    ErrorIf(result == false, "%s", error);
    return result;
  }

  template <typename KType, typename VType>
  bool insertOrError(const KType& key, const VType& value, cstr error)
  {
    return insertOrError(value_type(key, value), error);
  }

  bool insertNoOverwrite(const value_type& datapair)
  {
    return base_type::insertInternal(datapair, base_type::OnCollisionReturn) != NULL;
  }

  bool insertNoOverwrite(const key_type& key, const data_type& value)
  {
    return base_type::insertInternal(value_type(key, value), base_type::OnCollisionReturn) != NULL;
  }

  template<typename searchType, typename searchHasher>
  range find_as(const searchType& searchKey,
                searchHasher keyHasher = HashPolicy<searchType>())
  {
    Node* node = base_type::internal_find_as(searchKey, 
                                             PairHashAdapter< searchHasher,
                                                              searchType,
                                                              DataType >());
    if(node != cHashOpenNode)
      return range(node, node + 1, 1);
    else
      return range((Node*)cHashOpenNode, (Node*)cHashOpenNode, 0);
  }

  range find(const key_type& searchKey) const
  {
    Node* node = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(node != cHashOpenNode)
      return range(node, node + 1, 1);
    else
      return range((Node*)cHashOpenNode, (Node*)cHashOpenNode, 0);
  }

  bool tryGetValue(const key_type& searchKey, data_type& valueOut)
  {
    Node* node = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(node != cHashOpenNode)
    {
      valueOut = node->Value.second;
      return true;
    }
    else
      return false;
  }

  void erase(const key_type& searchKey)
  {
    Node* node = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(node != (Node*)cHashOpenNode)
      base_type::eraseNode(node);
  }

  size_t count(const key_type& searchKey)
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(foundNode != cHashOpenNode)
      return 1;
    else
      return 0;
  }

  data_type findValue(const key_type& searchKey, const data_type& ifNotFound) const
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(foundNode != cHashOpenNode)
      return foundNode->Value.second;
    else
      return ifNotFound;
  }

  //Returns a pointer to the value if found, or null if not found
  data_type* findPointer(const key_type& searchKey, data_type* ifNotFound = nullptr) const
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(foundNode != cHashOpenNode)
      return &(foundNode->Value.second);
    else
      return ifNotFound;
  }

  bool containsKey(const key_type& searchKey) const
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    return (foundNode != cHashOpenNode);
  }

  HashMap(const HashMap& other)
  {
    *this = other;
  }

  void operator = (const HashMap& other)
  {
    this->clear();
    range r = other.all();
    while(!r.empty())
    {
      insert(r.front());
      r.popFront();
    }
  }

private:
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file HashSet.hpp
/// Definition of the HashSet associative container.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once



namespace Zero
{

template<typename Hasher, typename ValueType>
struct SetHashAdapter
{
  Hasher mHasher;
  size_t operator()(const ValueType& value)
  {
    return (size_t)mHasher(value);
  }

  bool equal(const ValueType& left, const ValueType& right)
  {
    return mHasher.equal(left, right);
  }

  template<typename othertype>
  bool equal(const ValueType& left, const othertype& right)
  {
    return mHasher.equal(left, right);
  }
};

///Hash Set is an Associative Hashed Container. 
template< typename ValueType, 
          typename Hasher = HashPolicy<ValueType>, 
          typename Allocator = DefaultAllocator >
class ZeroSharedTemplate HashSet : public HashedContainer< ValueType, 
                                                           SetHashAdapter< Hasher, ValueType >, 
                                                           Allocator >
{
public:
  typedef ValueType value_type;
  typedef size_t size_type;
  typedef value_type& reference;
  typedef HashSet<ValueType, Hasher, Allocator> this_type;
  typedef HashedContainer< ValueType, 
                           SetHashAdapter< Hasher, ValueType >,
                           Allocator > base_type;
  typedef typename base_type::Node* iterator;
  typedef typename base_type::Node Node;
  typedef typename base_type::range range;

  HashSet()
  {
  }

  ///Warning: Depending on the contents of the hash sets, this may be expensive.
  HashSet(const HashSet& other)
  {
    *this = other;
  }

  ///Warning: Depending on the contents of the hash sets, this may be expensive.
  void operator = (const HashSet& other)
  {
    // Don't self assign
    if(&other == this)
      return;

    this->clear();
    range r = other.all();
    while(!r.empty())
    {
      base_type::insertInternal(r.front(), base_type::OnCollisionOverride);
      r.popFront();
    }
  }

  range find(const value_type& value)
  {
    //searching for the actual type of the container.
    Node* node = base_type::internal_find_as(value, base_type::mHasher);
    if(node != cHashOpenNode)
      return range(node, node + 1, 1);
    else
      return range((Node*)cHashOpenNode, (Node*)cHashOpenNode, 0);
  }

  template<typename searchType, typename searchHasher>
  range find_as(const searchType& searchKey, 
                searchHasher keyHasher = HashPolicy<searchType>()) const
  {
    Node* node = base_type::internal_find_as(searchKey, keyHasher);
    if(node != cHashOpenNode)
      return range(node, node + 1, 1);
    else
      return range((Node*)cHashOpenNode, (Node*)cHashOpenNode, 0);
  }

  value_type findValue(const value_type& searchKey, const value_type& ifNotFound) const
  {
    Node* node = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(node != cHashOpenNode)
      return node->Value;
    else
      return ifNotFound;
  }

  //Returns a pointer to the value if found, or null if not found
  value_type* findPointer(const value_type& searchKey) const
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(foundNode != cHashOpenNode)
      return &(foundNode->Value);
    else
      return NULL;
  }

  void insert(const value_type& value)
  {
    base_type::insertInternal(value, base_type::OnCollisionOverride);
  }

  bool insertOrError(const value_type& value)
  {
    return base_type::insertInternal(value, base_type::OnCollisionError) != NULL;
  }

  bool insertOrError(const value_type& value, cstr error)
  {
    bool result = insertOrError(value);
    ErrorIf(result == false, "%s", error);
    return result;
  }

  bool insertNoOverwrite(const value_type& value)
  {
    return base_type::insertInternal(value, base_type::OnCollisionReturn) != NULL;
  }

  bool contains(const value_type& value) const
  {
    return base_type::internal_find_as(value, base_type::mHasher)!=cHashOpenNode;
  }

  ~HashSet()
  {
  }
};

}//namespace Zero


///////////////////////////////////////////////////////////////////////////////
///
/// \file OwnedArray.hpp
/// Declaration of the OwnedArray container.
///
/// Authors: Trevor Sundberg
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once


namespace Zero
{

//------------------------------------------------------------------------ OwnedArray

template<typename type, typename Allocator = DefaultAllocator, 
                        typename value_tt = StandardTraits<type> >
class ZeroSharedTemplate OwnedArray : public Array<type, Allocator, value_tt>
{
public:

  //Deletes all elements within the array.
  ~OwnedArray()
  {
    for (size_t i = 0; i < this->size(); ++i)
    {
      delete (*this)[i];
    }
  }
};



}//namespace Zero


///////////////////////////////////////////////////////////////////////////////
///
/// \file BlockArray.hpp
/// Declaration of the BlockArray container.
///
/// Authors: Joshua Davis
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



///////////////////////////////////////////////////////////////////////////////
///
/// \file Algorithm.hpp
/// Declaration of the basic algorithms for Containers.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Zero
{

template<typename argument, typename result>
struct unary_function
{
  typedef argument argument_type;
  typedef result result_type;
};

template<typename argument0, typename argument1, typename result>
struct binary_function
{
  typedef argument0 first_argument_type;
  typedef argument1 second_argument_type;
  typedef result result_type;
};

#define StandardFunctor(name, operation)                    \
template<typename type>                                     \
struct name : public binary_function<type,type,bool>{       \
bool operator()(const type& left, const type& right) const{ \
return (left operation right);}};

StandardFunctor(equal_to, ==);
StandardFunctor(not_equal_to, !=);
StandardFunctor(less, <);
StandardFunctor(greater, >);
StandardFunctor(logical_and, &&);
StandardFunctor(logical_or, ||);

#undef StandardFunctor

// Linearly searches the input range and returns the range starting with either 
// the (value == searchValue) or an empty version of input range if value is not
// found.
template<typename inputRange, typename serachValueType>
inputRange find(inputRange input, const serachValueType& searchValue)
{
  while(!input.empty())
  {
    if(input.front() == searchValue)
      return input;
    input.popFront();
  }
  return input;
}

// Linearly searches the input range and returns the range starting with either 
// the Predicate(value) == true or an empty version of input range if value is not 
// found.
template<typename inputRange, typename Predicate>
inputRange find_if(inputRange input, Predicate predicate)
{
  while(!input.empty())
  {
    if(predicate(input.front()))
      return input;
    input.popFront();
  }
  return input;
}

template<typename inputRange, typename testInputRange>
inputRange find_first_of(inputRange input, testInputRange testInput)
{
  while(!input.empty())
  {
    for(testInputRange test = testInput; !test.empty(); test.popFront())
    {
      if(input.front() == test.front())
        return input;
    }
    input.popFront();
  }
  return input;
}


// Performs the unary operation on all elements in the range.
template<typename inputRange, typename unaryOperator>
void for_each(inputRange input, unaryOperator op)
{
  while(!input.empty())
  {
    op(input.front());
    input.popFront();
  }
}

// Transform all elements in input range using the unaryOperator and then place
// the result of the operation in outputRange.
template<typename inputRange, typename outputRange, typename unaryOperator>
void transform(inputRange input, outputRange output, unaryOperator op)
{
  ErrorIf(output.length() < input.length(), "Ouput range is smaller than input range.");
  while(!input.empty())
  {
    output.front() = op(input.front());
    output.popFront();
    input.popFront();
  }
}

// Copy values from one range to another
template<typename inputRange, typename outputRange>
void copy(inputRange input, outputRange output)
{
  ErrorIf(output.length() < input.length(), "Ouput range is smaller than input range.");
  while(!input.empty())
  {
    output.front() = input.front();
    output.popFront();
    input.popFront();
  }
}

// Set all values in range to source value
template<typename inputRange, typename fillType>
inline void fill(inputRange range, const fillType& sourceValue)
{
  while(!range.empty())
  {
    range.front() = sourceValue;
    range.popFront();
  }
}

// Check if two ranges are equal
template<typename inputRange0, typename inputRange1>
bool equal(inputRange0 range0, inputRange1 range1)
{
  while(!range0.empty() && !range1.empty())
  {
    if(!(range0.front() == range1.front()))
      return false;
    range0.popFront();
    range1.popFront();
  }

  if(range0.empty() && range1.empty())
    return true;
  else
    return false;
}

// Insertion sort
template<typename iterator, typename Comparer, typename type>
void insertionSort(iterator begin, iterator end, Comparer comparer, type* /*dummy*/)
{
  if(begin != end)
  {
    iterator iter = begin;
    ++iter;
    //Insert each element
    for(;iter != end; ++iter)
    {
      iterator insert = iter;
      type test = *insert;
      iterator prev = insert;
      --prev;

      while(comparer(test, *prev))
      {
        //Move previous up
        *insert = *prev;

        if(prev == begin)
        {
          --insert;
          break;
        }

        --prev;
        --insert;
      }

      //copy element into position
      *insert = test;
    }
  }
}

// partition used in quick sort
template<typename iterator, typename Comparer, typename type> 
inline Pair<iterator, iterator> partition(iterator first, iterator last, 
                                          Comparer comparer, type* /*dummy*/)
{
  size_t size = last - first;

  //Make last point to the last valid
  //element instead of the end
  --last;

  //make a pointer to the pivot
  iterator pivot = first;

  //Swap the pivot value to the front
  Zero::Swap(*pivot, *(first + size / 2));

  //Move first to the first valid element
  ++first;

  //Make sure the pivot is the median value (middle value) 
  //of the first, middle, and last elements. This prevents N^2 
  //performance on a already sorted list
  if(comparer(*last, *first))  Zero::Swap(*last, *first);
  if(comparer(*pivot, *first)) Zero::Swap(*pivot, *first);
  if(comparer(*last, *pivot))  Zero::Swap(*last, *pivot);

  //store the pivot value on the stack
  type pivotValue = *pivot;

  //keep looping while the iterators have not crossed
  while (first < last) 
  {
    //search from the left for a value greater
    //than the pivot
    do ++first; 
    while(comparer(*first, pivotValue));

    //search from the right for a value
    //less than the pivot
    do --last; 
    while(comparer(pivotValue, *last));

    //If the two value are not the middle
    if (first < last) 
    {
      Zero::Swap(*first, *last);
    }
  };

  //Move pivot back into position
  Zero::Swap(*pivot, *last);

  //return the last and first of the two new ranges.
  return Pair<iterator, iterator>(last, first);
}

const size_t cSortMaxStackSize = 40;
const size_t cSortLimit = 32;

// primary quick sort algorithm
template<typename iterator, typename Comparer, typename type>
void quickSort(iterator begin, iterator end, type* dummy, Comparer comparer)
{
  size_t stackSize = 0;

  // Instead of using recursion quick sort uses a static array
  // for performance
  Pair<iterator, iterator> rangeStack[cSortMaxStackSize];

  for(;;)
  {
    size_t rangeSize = end - begin;

    // Use quick sort for larger arrays
    if(rangeSize > cSortLimit)
    {
      Pair<iterator, iterator> division = partition(begin, end, comparer, dummy);

      // push the larger division for later
      // make the smaller division the current begin and end
      if(division.first - begin > end - division.second)
      {
        // left side larger
        rangeStack[stackSize] = make_pair(begin, division.first);
        ++stackSize;

        begin = division.second;
        // end stays the same
      }
      else
      {
        // right side larger
        rangeStack[stackSize] = make_pair(division.second, end);
        ++stackSize;

        // begin stays the same
        end = division.first;
      }

    }
    else
    {
      // Perform insertion sort on smaller range

      // if range is one element skip sorting
      if(rangeSize > 1)
      {
        insertionSort(begin, end, comparer, dummy);
      }

      // Pop the current range moving back
      if(stackSize > 0)
      {
        --stackSize;
        begin = rangeStack[stackSize].first;
        end = rangeStack[stackSize ].second;
      }
      else
      {
        // no more ranges sort is complete
        return;
      }
    }
  }
}

template<typename range,typename type>
void sortWithLess(range r, type* dummy)
{
  quickSort(r.begin(), r.end(), dummy, less<type>());
}

template<typename range>
void sort(range r)
{
  //if you see an error on this line, odds are you passed in an array instead of array.all()
  size_t temp = sizeof(typename range::contiguousRangeType);
  sortWithLess(r, &r.front());
}

template<typename range, typename Comparer>
void sort(range r, Comparer comparer)
{
  //if you see an error on this line, odds are you passed in an array instead of array.all()
  size_t temp = sizeof(typename range::contiguousRangeType);
  UnusedParameter(temp);
  quickSort(r.begin(), r.end(), &r.front(), comparer);
}

template<typename iterator>
void reverse(iterator start, iterator end)
{
  --end;
  while(start<end)
  {
    Zero::Swap(*start, *end);
    ++start;
    --end;
  }
}

template<typename rangeType>
bool IsSorted(rangeType range)
{
  if(!range.empty())
  {
    rangeType r0 = range;
    rangeType r1 = range;
    r1.popFront();
    while(!r1.empty())
    {
      if(r1.front()  < r0.front())
        return false;
      r0.popFront();
      r1.popFront();
    }
  }
  return true;
}


template<typename rangeType, typename searchType, typename valueType>
valueType& BinarySearch(rangeType& range, const searchType& searchValue, valueType& valueIfNotFound)
{
  size_t begin = 0;
  size_t end = range.size();

  while(begin < end)
  {
    size_t mid = (begin+end) / 2;
    if(range[mid] < searchValue)
    {
      begin = mid + 1;
    }
    else
    {
      end = mid;
    }
  }

  if((begin < range.size()) && (range[begin] == searchValue))
  {
    return range[begin];
  }
  else
  {
    return valueIfNotFound;
  }
}

/// Performs a binary search to find the lower bound of the specified value in the range
/// Returns an iterator to the first value in the range that is greater-or-equal (predicate true) to the specified value, else end
template<typename rangeType, typename valueType, typename predicate>
rangeType lowerBound(rangeType r, const valueType& value, predicate pred)
{
  rangeType newRange = r;
  int count = newRange.length();
  while(count > 0)
  {
    int step = count / 2;
    typename rangeType::reference newValue = newRange[step];
    if( pred(newValue, value) )
    {
      newRange.mBegin = newRange.mBegin + step + 1;
      count -= step + 1;
    }
    else
      count = step;
  }
  return newRange;
}
template<typename iteratorType, typename valueType, typename predicate>
iteratorType lowerBound(iteratorType begin, iteratorType end, const valueType& value, predicate pred)
{
  return lowerBound(BuildRange(begin, end), value, pred).begin();
}

/// Performs a binary search to find the upper bound of the specified value in the range
/// Returns an iterator to the first value in the range that is greater (predicate false) than the specified value, else end
template<typename rangeType, typename valueType, typename predicate>
rangeType upperBound(rangeType r, const valueType& value, predicate pred)
{
  rangeType newRange = r;
  int count = newRange.length();
  while(count > 0)
  {
    int step = count / 2;
    typename rangeType::reference newValue = newRange[step];
    if( !pred(value, newValue) )
    {
      newRange.mBegin = newRange.mBegin + step + 1;
      count -= step + 1;
    }
    else
      count = step;
  }
  return newRange;
}
template<typename iteratorType, typename valueType, typename predicate>
iteratorType upperBound(iteratorType begin, iteratorType end, const valueType& value, predicate pred)
{
  return upperBound(BuildRange(begin, end), value, pred).begin();
}

/// Returns the lower and upper bound of the specified value in the range
template<typename rangeType, typename valueType, typename predicate>
rangeType lowerAndUpperBound(rangeType r, const valueType& value, predicate pred)
{
  return BuildRange( lowerBound(r, value, pred).begin(),
                     upperBound(r, value, pred).begin() );
}

template<typename rangeType, typename Predicate>
rangeType search(rangeType searchRange, rangeType toFind, Predicate predicate)
{
  size_t findSize = toFind.size();
  while(searchRange.size() >= findSize)
  {
    rangeType r0 = searchRange;
    rangeType find = toFind;
    while(!r0.empty() && predicate(r0.front(), find.front()))
    {
      r0.popFront();
      find.popFront();

      if(find.empty())
        return searchRange;
    }

    searchRange.popFront();
  }

  //make the range empty
  searchRange.popFront(searchRange.size());

  return searchRange;
}

template<typename rangeType> 
rangeType search(rangeType searchRange, rangeType toFind)
{
  return search(searchRange, toFind, equal_to<typename rangeType::value_type>());
}

// Inserts a value into a sorted list
// return true if value was inserted false if
// value was already in the list
template<typename containertype, typename type>
bool SortedInsert(containertype& container, type& value)
{
  typename containertype::iterator cur = container.begin();
  typename containertype::iterator end = container.end();
  while(cur != end)
  {
    type& currentValue = *cur;
    if(value < currentValue)
    {
      // value is less than current value
      // insert the value at this location
      container.insert(cur, value);
      return true;
    }
    else if(value == currentValue)
    {
      // already in list
      // failed to insert
      return false;
    }
    ++cur;
  }

  //insert at end
  container.push_back(value);
  return true;
}


//Array Algorithms


template<typename desttype, typename range>
void PushAll(desttype& a, range inputRange )
{
  for(;!inputRange.empty();inputRange.popFront())
  {
    a.push_back(inputRange.front());
  }
}


template<typename type>
struct EqualTo
{
  EqualTo(type& value)
    :TestValue(value)
  {
  }

  type TestValue;

  bool operator()(type& any)
  {
    return TestValue == any;
  }
};

const size_t NotFoundIndex = (size_t)-1;

// Find the index of the first value that passes the predicate
// or NotFoundIndex when not found
template<typename ArrayType, typename Predicate>
size_t FindFirstIndex(ArrayType& array, Predicate predicate)
{
  // Loop through elements
  size_t size = array.size();
  for (size_t i = 0; i < size; ++i)
  {
    // Found value return
    if(predicate(array[i]))
      return i;
  }
  return NotFoundIndex;
}

// Remove all elements that do not pass Predicate
template<typename ArrayType, typename Predicate>
size_t RemoveAll(ArrayType& array, Predicate predicate)
{
  // Loop through all elements in the array
  // Copying over valid elements 
  size_t sourceIndex = 0;
  size_t destIndex = 0;
  size_t size = array.size();
  size_t removeCount = 0;

  for(; sourceIndex < size;)
  {
    if(predicate(array[sourceIndex]))
    {
      // If not valid just move forward source
      ++sourceIndex;
      ++removeCount;
    }
    else
    {
      // Need to keep value in array

      // Do not copy if already in place
      if(sourceIndex != destIndex)
      {
        array[destIndex] = array[sourceIndex];
      }

      // Move both forward
      ++destIndex;
      ++sourceIndex;
    }
  }

  // get rid of unused elements at the end
  array.resize(destIndex);
  return removeCount;
}

// Remove a element placing last element in its place
// to prevent extra copying
template<typename ArrayType>
void RemoveSwap(ArrayType& array, size_t index)
{
  array[index] = array.back();
  array.pop_back();
}

}//namespace Zero


namespace Zero
{

///Generic front deque array class. Store objects in buckets of a 1 << shiftSize.
///Fast when the total number of objects being inserted is not known.
///Currently hardcoded as only storing pod types.
template<typename type, uint shiftSize = 6, typename Allocator = DefaultAllocator>
class PodBlockArray : public AllocationContainer<Allocator>
{
public:
  //-------------------------------------------------------- Standard Typedefs
  typedef type value_type;
  typedef value_type* pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef PodBlockArray<type, shiftSize, Allocator> this_type;
  typedef AllocationContainer<Allocator> base_type;
  using base_type::mAllocator;

  enum
  {
    /*used to determine the size of a bucket as well as to mask off
    the lower bits and determine the number of buckets*/
    ShiftSize = shiftSize,
    BucketSize = 1 << ShiftSize,//the size of a bucket (how many objects)
    BucketMask = BucketSize - 1,//mask to determine the index within a bucket
  };

  struct iterator
  {
    iterator()
    {
      mBlockArray = NULL;
      mCurrentIndex = 0;
    }

    iterator(this_type* blockArray, size_type startIndex)
    {
      mBlockArray = blockArray;
      mCurrentIndex = startIndex;
    }

    void operator++()
    {
      ++mCurrentIndex;
    }

    void operator--()
    {
      --mCurrentIndex;
    }

    reference operator*()
    {
      return (*mBlockArray)[mCurrentIndex];
    }

    size_type operator-(const iterator& other)
    {
      return mCurrentIndex - other.mCurrentIndex;
    }

    iterator operator+(size_type offset)
    {
      return iterator(mBlockArray, mCurrentIndex + offset);
    }

    bool operator==(const iterator& other)
    {
      if(mBlockArray == other.mBlockArray && 
         mCurrentIndex == other.mCurrentIndex)
        return true;
      return false;
    }

    bool operator<(const iterator& other)
    {
      return mCurrentIndex < other.mCurrentIndex;
    }

    bool operator!=(const iterator& other)
    {
      return !(*this == other);
    }

    this_type* mBlockArray;
    size_type mCurrentIndex;
  };

  struct range
  {
    typedef typename this_type::value_type      value_type;
    typedef value_type                          contiguousRangeType;

    range()
    {
      mCurrentIndex = 0;
      mEndIndex = 0;
      mBlockArray = NULL;
    }

    range(this_type* blockArray)
    {
      mBlockArray = blockArray;
      mCurrentIndex = 0;
      mEndIndex = blockArray->mSize;
    }

    range(this_type* blockArray, size_type startIndex, size_type endIndex)
    {
      mBlockArray = blockArray;
      mCurrentIndex = startIndex;
      mEndIndex = endIndex;
    }

    reference front()
    {
      return (*mBlockArray)[mCurrentIndex];
    }

    void popFront()
    {
      ++mCurrentIndex;
    }

    bool empty()
    {
      return mCurrentIndex >= mEndIndex;
    }

    iterator begin()
    {
      return iterator(mBlockArray,mCurrentIndex);
    }

    iterator end()
    {
      return iterator(mBlockArray,mEndIndex);
    }

    this_type* mBlockArray;
    size_type mCurrentIndex;
    size_type mEndIndex;
  };

  PodBlockArray()
  {
    mSize = 0;
    mCapacity = 0;
    mData = NULL;
  }

  PodBlockArray(const this_type& other)
  {
    mSize = 0;
    mCapacity = 0;
    mData = NULL;
    copy(other);
  }

  PodBlockArray(size_type size)
  {
    mData = NULL;
    mSize = 0;
    mCapacity = 0;
    resize(size);
  }

  PodBlockArray(size_type size, const_reference defaultValue)
  {
    mData = NULL;
    mSize = 0;
    mCapacity = 0;
    resize(size, defaultValue);
  }

  ~PodBlockArray()
  {
    deallocate();
  }

  void operator=(const this_type& other)
  {
    copy(other);
  }

  bool empty() const
  {
    return mSize == 0;
  }

  size_t size() const
  {
    return mSize;
  }

  reference operator[](size_t index)
  {
    ErrorIf(index > mSize, "Accessed block array out of bounds.");
    return mData[index >> ShiftSize][index & BucketMask];
  }

  const_reference operator[](size_t index) const
  {
    ErrorIf(index > mSize, "Accessed block array out of bounds.");
    return mData[index >> ShiftSize][index & BucketMask];
  }

  iterator begin()
  {
    return iterator(this,0);
  }

  iterator end()
  {
    return iterator(this, mSize);
  }

  reference front()
  {
    ErrorIf(mSize == 0, "Empty block array, no front element.");
    return mData[0][0];
  }

  const_reference front() const
  {
    ErrorIf(mSize == 0, "Empty block array, no front element.");
    return mData[0][0];
  }

  reference back()
  {
    ErrorIf(mSize == 0, "Empty block array, no back element.");
    return (*this)[mSize - 1];
  }

  const_reference back() const
  {
    ErrorIf(mSize == 0, "Empty block array, no back element.");
    return (*this)[mSize - 1];
  }

  void push_back(const_reference item)
  {
    //if adding one object causes us to go over our capacity,
    //then increase our capacity by one bucket
    if(mSize >= mCapacity)
      change_capacity(mCapacity + 1);

    //insert the new item at the last index
    (*this)[mSize] = item;
    ++mSize;
  }
  
  reference push_back()
  {
    //see the above push_back
    if(mSize >= mCapacity)
      change_capacity(mCapacity + 1);

    //we aren't filling in the last item, just giving
    //back a reference for the user to fill out
    ++mSize;
    return (*this)[mSize - 1];
  }

  void pop_back()
  {
    ErrorIf(mSize == 0,"Empty block array, can not pop back element.");
    //don't change capacity at all, just decrement our size
    //(since we are pod we don't have to call a destructor on the last item)
    --mSize;
  }

  void clear()
  {
    //pod assumption, don't call destructors on the objects
    mSize = 0;
  }

  void deallocate()
  {
    size_type bucketCount = bucketCountFromSize(mCapacity);
    //deallocate all of our buckets
    for(uint i = 0; i < bucketCount; ++i)
      mAllocator.Deallocate(mData[i], sizeof(value_type) * BucketSize);
    //now deallocate the array of our buckets
    mAllocator.Deallocate(mData, sizeof(pointer) * bucketCount);
  }

  void change_capacity(size_type newCapacity)
  {
    //we never shrink at the moment, so if the capacity is the same or less do nothing
    if(newCapacity <= mCapacity)
      return;

    //round capacity up to the next bucket size
    if(newCapacity & BucketMask)
      newCapacity = (newCapacity & ~BucketMask) + (1 << ShiftSize);

    size_type newBucketSize = bucketCountFromSize(newCapacity);
    size_type oldBucketSize = bucketCountFromSize(mCapacity);
    //allocate our new array of buckets
    pointer* newData = (pointer*)mAllocator.Allocate(newBucketSize * sizeof(pointer));
    
    //if we had any buckets previously, copy over our pointers to them
    //then deallocate the old array of buckets
    if(mCapacity != 0)
    {
      uninitialized_move(newData,mData,oldBucketSize,true_type());
      mAllocator.Deallocate(mData, sizeof(pointer) * oldBucketSize);
    }

    //now allocate any new buckets we need
    for(size_t i = oldBucketSize; i < newBucketSize; ++i)
      newData[i] = (pointer)mAllocator.Allocate(sizeof(value_type) * BucketSize);

    //finally set our new state
    mData = newData;
    mCapacity = newCapacity;
  }

  range all()
  {
    return range(this);
  }

  //Returns and range for all the elements in the container.
  range all() const
  {
    return const_cast<PodBlockArray*>(this)->all();
  }

  range sub_range(size_type index, size_type length)
  {
    ErrorIf(index >= mSize, "Accessed block array out of bounds.");
    ErrorIf(index + length > mSize, "Accessed block array out of bounds.");
    return range(this, index, index + length);
  }

  bool operator==(this_type& other)
  {
    return equal(this->all(), other.all());
  }

  void resize(size_t newSize)
  {
    //resizing to the same size, do nothing
    if(mSize == newSize)
      return;

    //we only need to handle getting bigger, because getting smaller is
    //just overriding our size variable (pod assumption)

    //if our new size causes us to go beyond our capacity,
    //compute and change the capacity
    if(newSize > mCapacity)
      change_capacity(newSize);

    mSize = newSize;
  }

  void resize(size_t newSize, const_reference defaultvalue)
  {
    //resizing to the same size, do nothing
    if(mSize == newSize)
      return;

    //compute our old/new capacity and the index inside of those buckets
    size_type newBucketCount = (newSize >> ShiftSize);
    size_type oldBucketCount = (mSize >> ShiftSize);
    size_type newBucketIndex = newSize & BucketMask;
    size_type oldBucketIndex = mSize & BucketMask;

    //update the capacity
    change_capacity(newSize);
      
    //now we have to set the default value in all of the new buckets (only if we grew)
    if(newSize > mSize)
    {
      //first, set the default value in any remaining portion of the old bucket
      uninitialized_fill(mData[oldBucketCount] + oldBucketIndex, BucketSize - oldBucketIndex, defaultvalue);

      //if we aren't changing the bucket size we are done
      if(oldBucketCount != newBucketCount)
      {
        //now fill any complete buckets up
        for(uint i = oldBucketCount + 1; i < newBucketCount; ++i)
          uninitialized_fill(mData[i], BucketSize, defaultvalue);
        //finally, fill out the used portion of the last bucket
        uninitialized_fill(mData[newBucketCount],newBucketIndex,defaultvalue);
      }
    }

    mSize = newSize;
  }

  void copy(const this_type& other)
  {
    //fix our size to be the same as the other object
    resize(other.mSize);

    //if we have no size, don't do anything
    if(other.mSize == 0)
      return;

    size_type bucketSize = bucketCountFromSize(mSize);
    size_type lastBucket = bucketSize - 1;
    size_type lastBucketFillCount = mSize & BucketMask;

    //fill out all complete buckets
    for(size_type i = 0; i < lastBucket; ++i)
      uninitialized_copy(mData[i],other.mData[i],BucketSize,true_type());
    //fill out the remaining portion of the last bucket
    uninitialized_copy(mData[lastBucket],other.mData[lastBucket],lastBucketFillCount,true_type());
  }

  size_type bucketCountFromSize(size_type size)
  {
    size_type buckets = size >> ShiftSize;
    if(size & BucketMask)
      ++buckets;
    return buckets;
  }

  ///The current number of items we have
  size_type mSize;
  ///The max number of items we can store before we
  ///need to allocate more (bucketSize * numOfBuckets)
  size_type mCapacity;
  ///The start of our 2d array
  pointer* mData;
};

}//namespace Zero


///////////////////////////////////////////////////////////////////////////////
///
/// \file ForEachRange.hpp
/// Range based for each macro.
///
/// Authors: Chris Peters
/// Copyright 2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// The forRange macros use two for loops, so we need to do some extra work
// to make the 'break' keyword properly break out of both loops. The
// '__continueLoop' variable is used to both only loop once on the
// second for loop, and to detect breaks.
// This function is used to assign values to '__continueLoop' inside an
// if statement while avoiding the warning of assignment in a conditional statement
template <typename T>
bool AssignValue(T& toBeAssigned, T value)
{
  toBeAssigned = value;
  return true;
}

#if !ZeroHasAuto && !ZeroHasTypeOf 

//namespace to contain helpers functions
namespace fr
{

//System for getting the type with out evaluating the expression.

//Type holder
template<typename type> struct typeOf{ typedef type encodedType; };

//Convert an expression of given type to an
//expression of type typeOf<type>
template<typename type>
typeOf<type> EncodeType(const type& t)
{
  return typeOf<type>();
}

//Convertible to typeOf<type> for any type
struct AnyTypeConvert
{
  template<typename type>
  operator typeOf<type> () const
  {
    return typeOf<type>();
  }
};

//Convert an expression to the type typeOf<type> without
//evaluating the expression by using the properties of the
//ternary operator.
#define ENCODED_TYPEOF(container) \
  (true ? fr::AnyTypeConvert() : fr::EncodeType(container))

struct RangeBase
{
  operator bool() const { return false; }
};

template<typename type>
struct AnyRange : RangeBase
{
  AnyRange(const type& r) : item(r) {}
  mutable type item;
};

//Return a stack version of the Range
//life time will be extened by reference
template<typename type>
AnyRange<type> BuildRange(const type& begin)
{
  return AnyRange<type>(begin);
}

template<typename type>
type& RangeCast(RangeBase& any)
{
  return static_cast<AnyRange<type>&>(any).item;
}

//Range based functions
template<typename type>
bool IsEmpty(RangeBase& r, typeOf<type>)
{
  return RangeCast<type>(r).empty();
}

template<typename type>
void PopFront(RangeBase& r, typeOf<type>)
{
  RangeCast<type>(r).popFront();
}

template<typename type>
typename type::value_type& 
  Front(RangeBase& r, typeOf<type>)
{
  return RangeCast<type>(r).front();
}

}//namespace fr

#define forRange(value, rangeExpr)                                                 \
  if(bool __continueLoop = true)                                                \
  for(fr::RangeBase& __rangeT = fr::BuildRange(rangeExpr);                         \
  __continueLoop == true && !fr::IsEmpty(__rangeT, ENCODED_TYPEOF(rangeExpr)); \
   fr::PopFront(__rangeT, ENCODED_TYPEOF(rangeExpr)))                              \
  if(AssignValue(__continueLoop, false))                                         \
  for(value = fr::Front(__rangeT, ENCODED_TYPEOF(rangeExpr));                      \
  !__continueLoop; __continueLoop = true)

#else

template <typename RangeType>
bool PopFront(RangeType& range)
{
  range.popFront();
  return true;
}

// With auto this is much easier to define
#define ZeroForRangeHelper(value, rangeName, rangeExpr, rangePostPop, rangePrePop)                      \
  if(bool __continueLoop = true)                                                                        \
  for(AutoDeclare(rangeName, rangeExpr); __continueLoop == true && !rangeName.empty(); rangePostPop)    \
  if(AssignValue(__continueLoop, false))                                                                \
  for(value = rangeName.front(); !__continueLoop; __continueLoop = true)                                \
  rangePrePop

// This is the classic version that we use which will pop after the entire iteration of the loop is complete
// Because some ranges may return references to values they actually store, we must use this order of popping
#define forRange(value, rangeExpr) ZeroForRangeHelper(value, __rangeT, rangeExpr, __rangeT.popFront(), )

// A newer version of range iteration which allows us to name our range variable (so we can query it)
// This version will call 'front' and then immediately after grabbing the value it will call 'popFront'
// This means if the range does something irregular such as storing the value and modifying the stored value in popFront, it will break
// This form of iteration is generally safer however for iterating through intrusive lists and unlinking them as you go
#define ZeroForRangeVar(value, rangeName, rangeExpr) ZeroForRangeHelper(value, rangeName, rangeExpr, , if(PopFront(rangeName)))

#endif

///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Chris Peters
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

/// UniquePointer takes sole ownership over a pointer and 
/// deletes it when is goes out of scope
template<typename Type>
class UniquePointer
{
public:
  UniquePointer(Type* type) { mPointer = type; }
  UniquePointer() { mPointer = nullptr; }
  ~UniquePointer() { Reset(); }

  UniquePointer(MoveReference<UniquePointer> other)
  {
    // Steal Pointer from rvalue
    mPointer = other->mPointer;
    other->mPointer = nullptr;
  }
  
  void operator=(MoveReference<UniquePointer> other)
  {
    if(this == &other)
      return;
    
    Reset();

    // Steal Pointer from rvalue
    mPointer = other.mPointer;
    other.mPointer = nullptr;
  }
  
#ifdef SupportsMoveSemantics
  UniquePointer(UniquePointer&& other)
  {
    // Steal Pointer from rvalue
    mPointer = other.mPointer;
    other.mPointer = nullptr;
  }
  
  void operator=(UniquePointer&& other)
  {
    if(this == &other)
      return;
  
    Reset();
    // Steal Pointer from rvalue
    mPointer = other.mPointer;
    other.mPointer = nullptr;
  }
#else
  UniquePointer(const UniquePointer& otherConst)
  {
    UniquePointer& other = (UniquePointer&)otherConst;
    mPointer = other.mPointer;
    other.mPointer = nullptr;
  }
  
  void operator=(const UniquePointer& otherConst)
  {
    if(this == &otherConst)
      return;
  
    UniquePointer& other = (UniquePointer&)otherConst;

    Reset();
    // Steal Pointer from rvalue
    mPointer = other.mPointer;
    other.mPointer = nullptr;
  }
#endif

  Type* operator->() { return mPointer; }
  Type& operator*() { return *mPointer; }
  operator Type*() { return mPointer; }

  void operator=(Type* pointer)
  {
    Reset();
    mPointer = pointer;
  }

  // Reset pointer back to null
  void Reset()
  {
    if(mPointer)
    {
      delete mPointer;
      mPointer = nullptr;
    }
  }

  // Take ownership of pointer
  Type* Release()
  {
    Type* pointer = mPointer;
    mPointer = nullptr;
    return pointer;
  }

private:

#ifdef SupportsMoveSemantics
  // Can not copy UniquePointer
  UniquePointer(const UniquePointer& other);
  void operator=(const UniquePointer& other);
#endif

  Type* mPointer;
};

//------------------------------------------------------- Move Operator (String)
template<typename T>
struct MoveWithoutDestructionOperator<UniquePointer<T> >
{
  static inline void MoveWithoutDestruction(UniquePointer<T>* dest, UniquePointer<T>* source)
  {
    memcpy(dest, source, sizeof(UniquePointer<T>));
  }
};

template<typename type>
UniquePointer<type> AutoHandle(type* event)
{
  UniquePointer<type> handle(event);
  return handle;
}

template<typename type>
UniquePointer<type> MakeUnique()
{
  return UniquePointer<type>(new type());
}

template<typename type, typename param0>
UniquePointer<type> MakeUnique(const param0& p0)
{
  return UniquePointer<type>(new type(p0));
}

template<typename type, typename param0, typename param1>
UniquePointer<type> MakeUnique(const param0& p0, const param0& p1)
{
  return UniquePointer<type>(new type(p0, p1));
}

}

///////////////////////////////////////////////////////////////////////////////
///
/// \file Atomic.hpp
/// Declaration of the atomic functions.
///
/// Authors: Chris Peters, Andrew Colean
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes
#include <climits>



///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes


// Fixed-Width Signed Integral Types
typedef smax intmax;
typedef s64  int64;
typedef s32  int32;
typedef s16  int16;
typedef s8   int8;

// Fixed-Width Unsigned Integral Types
typedef umax uintmax;
typedef u64  uint64;
typedef u32  uint32;
typedef u16  uint16;
typedef u8   uint8;

// Fastest Signed Integral Types (minimum width specified)
typedef s64 intfast64;
typedef s32 intfast32;
typedef s32 intfast16;
typedef s8  intfast8;

// Fastest Unsigned Integral Types (minimum width specified)
typedef u64 uintfast64;
typedef u32 uintfast32;
typedef u32 uintfast16;
typedef u8  uintfast8;

// Other Types
typedef uint32 Bits;     // 1 Bit
typedef uint32 Bytes;    // 8 Bits
typedef uint32 Kilobits; // 1000 Bits
typedef double Kbps;     // Kilobits per second

///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Written as an unholy macro so it can be used at compile time.
// We could have used a constexpr function instead of this madness if we had that C++11 feature!

#define LOG2_64(X) ((X) == 0 ? 63 : 0)
#define LOG2_63(X) ((X) == 0 ? 62 : LOG2_64(X >> 1))
#define LOG2_62(X) ((X) == 0 ? 61 : LOG2_63(X >> 1))
#define LOG2_61(X) ((X) == 0 ? 60 : LOG2_62(X >> 1))
#define LOG2_60(X) ((X) == 0 ? 59 : LOG2_61(X >> 1))
#define LOG2_59(X) ((X) == 0 ? 58 : LOG2_60(X >> 1))
#define LOG2_58(X) ((X) == 0 ? 57 : LOG2_59(X >> 1))
#define LOG2_57(X) ((X) == 0 ? 56 : LOG2_58(X >> 1))
#define LOG2_56(X) ((X) == 0 ? 55 : LOG2_57(X >> 1))
#define LOG2_55(X) ((X) == 0 ? 54 : LOG2_56(X >> 1))
#define LOG2_54(X) ((X) == 0 ? 53 : LOG2_55(X >> 1))
#define LOG2_53(X) ((X) == 0 ? 52 : LOG2_54(X >> 1))
#define LOG2_52(X) ((X) == 0 ? 51 : LOG2_53(X >> 1))
#define LOG2_51(X) ((X) == 0 ? 50 : LOG2_52(X >> 1))
#define LOG2_50(X) ((X) == 0 ? 49 : LOG2_51(X >> 1))
#define LOG2_49(X) ((X) == 0 ? 48 : LOG2_50(X >> 1))
#define LOG2_48(X) ((X) == 0 ? 47 : LOG2_49(X >> 1))
#define LOG2_47(X) ((X) == 0 ? 46 : LOG2_48(X >> 1))
#define LOG2_46(X) ((X) == 0 ? 45 : LOG2_47(X >> 1))
#define LOG2_45(X) ((X) == 0 ? 44 : LOG2_46(X >> 1))
#define LOG2_44(X) ((X) == 0 ? 43 : LOG2_45(X >> 1))
#define LOG2_43(X) ((X) == 0 ? 42 : LOG2_44(X >> 1))
#define LOG2_42(X) ((X) == 0 ? 41 : LOG2_43(X >> 1))
#define LOG2_41(X) ((X) == 0 ? 40 : LOG2_42(X >> 1))
#define LOG2_40(X) ((X) == 0 ? 39 : LOG2_41(X >> 1))
#define LOG2_39(X) ((X) == 0 ? 38 : LOG2_40(X >> 1))
#define LOG2_38(X) ((X) == 0 ? 37 : LOG2_39(X >> 1))
#define LOG2_37(X) ((X) == 0 ? 36 : LOG2_38(X >> 1))
#define LOG2_36(X) ((X) == 0 ? 35 : LOG2_37(X >> 1))
#define LOG2_35(X) ((X) == 0 ? 34 : LOG2_36(X >> 1))
#define LOG2_34(X) ((X) == 0 ? 33 : LOG2_35(X >> 1))
#define LOG2_33(X) ((X) == 0 ? 32 : LOG2_34(X >> 1))
#define LOG2_32(X) ((X) == 0 ? 31 : LOG2_33(X >> 1))
#define LOG2_31(X) ((X) == 0 ? 30 : LOG2_32(X >> 1))
#define LOG2_30(X) ((X) == 0 ? 29 : LOG2_31(X >> 1))
#define LOG2_29(X) ((X) == 0 ? 28 : LOG2_30(X >> 1))
#define LOG2_28(X) ((X) == 0 ? 27 : LOG2_29(X >> 1))
#define LOG2_27(X) ((X) == 0 ? 26 : LOG2_28(X >> 1))
#define LOG2_26(X) ((X) == 0 ? 25 : LOG2_27(X >> 1))
#define LOG2_25(X) ((X) == 0 ? 24 : LOG2_26(X >> 1))
#define LOG2_24(X) ((X) == 0 ? 23 : LOG2_25(X >> 1))
#define LOG2_23(X) ((X) == 0 ? 22 : LOG2_24(X >> 1))
#define LOG2_22(X) ((X) == 0 ? 21 : LOG2_23(X >> 1))
#define LOG2_21(X) ((X) == 0 ? 20 : LOG2_22(X >> 1))
#define LOG2_20(X) ((X) == 0 ? 19 : LOG2_21(X >> 1))
#define LOG2_19(X) ((X) == 0 ? 18 : LOG2_20(X >> 1))
#define LOG2_18(X) ((X) == 0 ? 17 : LOG2_19(X >> 1))
#define LOG2_17(X) ((X) == 0 ? 16 : LOG2_18(X >> 1))
#define LOG2_16(X) ((X) == 0 ? 15 : LOG2_17(X >> 1))
#define LOG2_15(X) ((X) == 0 ? 14 : LOG2_16(X >> 1))
#define LOG2_14(X) ((X) == 0 ? 13 : LOG2_15(X >> 1))
#define LOG2_13(X) ((X) == 0 ? 12 : LOG2_14(X >> 1))
#define LOG2_12(X) ((X) == 0 ? 11 : LOG2_13(X >> 1))
#define LOG2_11(X) ((X) == 0 ? 10 : LOG2_12(X >> 1))
#define LOG2_10(X) ((X) == 0 ? 9  : LOG2_11(X >> 1))
#define LOG2_9(X)  ((X) == 0 ? 8  : LOG2_10(X >> 1))
#define LOG2_8(X)  ((X) == 0 ? 7  : LOG2_9(X >> 1))
#define LOG2_7(X)  ((X) == 0 ? 6  : LOG2_8(X >> 1))
#define LOG2_6(X)  ((X) == 0 ? 5  : LOG2_7(X >> 1))
#define LOG2_5(X)  ((X) == 0 ? 4  : LOG2_6(X >> 1))
#define LOG2_4(X)  ((X) == 0 ? 3  : LOG2_5(X >> 1))
#define LOG2_3(X)  ((X) == 0 ? 2  : LOG2_4(X >> 1))
#define LOG2_2(X)  ((X) == 0 ? 1  : LOG2_3(X >> 1))
#define LOG2_1(X)  ((X) == 0 ? 0  : LOG2_2(X >> 1))
#define LOG2_0(X)  ((X) == 0 ? 0  : LOG2_1(X >> 1))

/// Log base 2 of X
#define LOG2(X) LOG2_0(X)

#include <algorithm>

namespace Zero
{

/// Verify platform byte length
StaticAssert(PlatformByteLength, CHAR_BIT == 8, "Platform byte length must be 8 bits");

/// Converts Bits to Bytes
#define BITS_TO_BYTES(b) (((b) + 7) >> 3)
/// Converts Bytes to Bits
#define BYTES_TO_BITS(B) ((B) * 8)

/// Unsigned integer bit size
#define UINT_BITS    (BYTES_TO_BITS(sizeof(uint)))
/// Maximum unsigned integer bit size
#define UINTMAX_BITS (BYTES_TO_BITS(sizeof(uintmax)))

/// Right-justified bit N
#define RBIT(N) (uint8(1) << (N))
/// Left-justified bit N
#define LBIT(N) (uint8(128) >> (N))

/// Sets the right-justified bit N of Byte if Condition is true, else clears it
#define ASSIGN_RBIT(Condition, Byte, N) ((*(uint8*)Byte) ^= ((-(bool)(Condition) ^ ((uint8)*Byte)) & RBIT(N)))
/// Sets the left-justified bit N of Byte if Condition is true, else clears it
#define ASSIGN_LBIT(Condition, Byte, N) ((*(uint8*)Byte) ^= ((-(bool)(Condition) ^ ((uint8)*Byte)) & LBIT(N)))

/// Equivalent to (X / 8)
#define DIV8(X) ((X) >> 3)
/// Equivalent to (X % 8)
#define MOD8(X) ((X) & 7)
/// Rounds X up to the next multiple of 8
#define ROUND_UP_8(X) ( MOD8(X) == 0 ? (X) : (X) + (8 - MOD8(X)) )

/// Equivalent to (2 ^ X)
#define POW2(X) (uintmax(1) << (X))

#define ROUND_UP_POW2_32(X) ((X) | (X) >> 32)
#define ROUND_UP_POW2_16(X) ((X) | (X) >> 16)
#define ROUND_UP_POW2_8(X)  ((X) | (X) >> 8)
#define ROUND_UP_POW2_4(X)  ((X) | (X) >> 4)
#define ROUND_UP_POW2_2(X)  ((X) | (X) >> 2)
#define ROUND_UP_POW2_1(X)  ((X) | (X) >> 1)

/// Rounds X up to the next highest power of 2
#define ROUND_UP_POW2(X) (ROUND_UP_POW2_32(ROUND_UP_POW2_16(ROUND_UP_POW2_8(ROUND_UP_POW2_4(ROUND_UP_POW2_2(ROUND_UP_POW2_1((X) - 1)))))) + 1)

/// Returns the number of bits needed to represent X
#define BITS_NEEDED_TO_REPRESENT(X) (LOG2(X) + 1)

/// Rounds X up to the next highest integer
#define ROUND_UP(X) (intmax(X) + (1 - intmax(intmax((X) + 1) - (X))))

/// Returns the exact uint type of N bits, else void
#define EXACT_UINT(N) typename conditional<(N) == 8,  uint8,                                   \
                      typename conditional<(N) == 16, uint16,                                  \
                      typename conditional<(N) == 32, uint32,                                  \
                      typename conditional<(N) == 64, uint64, void>::type>::type>::type>::type

/// Returns the nearest uint type of N bits, else uintmax
#define NEAREST_UINT(N) typename conditional<(N) <= 8,  uint8,                                      \
                        typename conditional<(N) <= 16, uint16,                                     \
                        typename conditional<(N) <= 32, uint32,                                     \
                        typename conditional<(N) <= 64, uint64, uintmax>::type>::type>::type>::type

/// Returns the fastest uint type of at least N bits, else uintmax
#define FASTEST_UINT(N) typename conditional<(N) <= 8,  uintfast8,                                      \
                        typename conditional<(N) <= 16, uintfast16,                                     \
                        typename conditional<(N) <= 32, uintfast32,                                     \
                        typename conditional<(N) <= 64, uintfast64, uintmax>::type>::type>::type>::type

/// Returns the exact int type of N bits, else void
#define EXACT_INT(N) typename conditional<(N) == 8,  int8,                                   \
                     typename conditional<(N) == 16, int16,                                  \
                     typename conditional<(N) == 32, int32,                                  \
                     typename conditional<(N) == 64, int64, void>::type>::type>::type>::type

/// Returns the nearest int type of N bits, else intmax
#define NEAREST_INT(N) typename conditional<(N) <= 8,  int8,                                     \
                       typename conditional<(N) <= 16, int16,                                    \
                       typename conditional<(N) <= 32, int32,                                    \
                       typename conditional<(N) <= 64, int64, intmax>::type>::type>::type>::type

/// Returns the fastest int type of at least N bits, else intmax
#define FASTEST_INT(N) typename conditional<(N) <= 8,  intfast8,                                     \
                       typename conditional<(N) <= 16, intfast16,                                    \
                       typename conditional<(N) <= 32, intfast32,                                    \
                       typename conditional<(N) <= 64, intfast64, intmax>::type>::type>::type>::type

/// Returns the minimum of a and b
#define MIN(a, b) ( (a) < (b) ? (a) : (b) )

/// Returns the maximum of a and b
#define MAX(a, b) ( (a) > (b) ? (a) : (b) )

/// Endianness (Byte Order)
namespace Endianness
{
  enum Enum
  {
    Little = 0x04030201UL,
    Big    = 0x01020304UL,
    PDP    = 0x02010403UL
  };
  typedef uint32 Type;
}
static const union { uint8 bytes[4]; Endianness::Enum value; } platformEndianness = { 0x01, 0x02, 0x03, 0x04 };

/// Returns the platform endianness
inline Endianness::Enum PlatformEndianness(void)
{
  return platformEndianness.value;
}

/// Returns true if the platform is in network byte order
inline bool IsPlatformNetworkByteOrder(void)
{
  return PlatformEndianness() == Endianness::Big;
}

/// Returns the endian flipped equivalent of the specified value
template<typename T>
inline T EndianFlip(T value)
{
  // Single byte?
  if(sizeof(value) == 1)
    return value; // Nothing to flip!

  // Reverse byte order
  T flipped = T();
  for(Bytes i = 0; i < sizeof(value); ++i)
    ((byte*)&flipped)[i] = ((byte*)&value)[sizeof(value) - 1 - i];

  return flipped;
}

/// Performs an endian flip on little endian platforms
template<typename T>
inline T NetworkFlip(T value)
{
  return (PlatformEndianness() == Endianness::Little) ? EndianFlip(value) : value;
}

/// Returns the number of bits needed to represent the signed integral value
template<typename T>
R_ENABLE_IF(is_integral<T>::value && is_signed<T>::value, Bits) BitsNeededToRepresent(T value)
{
  typedef typename make_unsigned<T>::type UT;

  // Reinterpret cast to unsigned type, then determine bits needed
  return BitsNeededToRepresent((UT)value);
}
/// Returns the number of bits needed to represent the unsigned integral value
template<typename T>
R_ENABLE_IF(is_integral<T>::value && is_unsigned<T>::value, Bits) BitsNeededToRepresent(T value)
{
  return BITS_NEEDED_TO_REPRESENT(value);
}

/// Returns value as a binary string
template<typename T>
String GetBinaryString(const T& value)
{
  StringBuilder result;
  byte* valueCursor = (byte*)&value;

  // Read every byte (from left to right)
  for(uint i = 0; i < sizeof(value); ++i)
  {
    // Read every bit in the byte (from left to right)
    for(uint j = 0; j < 8; ++j)
      result += *valueCursor & LBIT(j) ? '1' : '0';

    // Next byte
    result += ' ';
    ++valueCursor;
  }

  return result.ToString();
}

/// Returns true if memA and memB are overlapping
inline bool MemoryIsOverlapping(const byte* memA, Bytes memASize, const byte* memB, Bytes memBSize)
{
  if((memA - memB <= 0 && memB - (memA + memASize) <= 0)                            //    memB starting point is within memA?
  || (memA - (memB + memBSize) <= 0 && (memB + memBSize) - (memA + memASize) <= 0)) // OR memB ending point is within memA?
    return true;  // There is overlap
  else
    return false; // No overlap
}

/// Clamps value to within the specified inclusive range
template<typename T>
inline const T& Clamp(const T& value, const T& minValue, const T& maxValue)
{
  return std::max(std::min(value, maxValue), minValue);
}

/// Returns the interpolated value between a and b at alpha [0, 1], where 0 is a and 1 is b
template <typename T, typename F>
inline T Interpolate(T a, T b, F alpha)
{
  return a + ((b - a) * alpha);
}

/// Returns the average of previous and current, given currentWeight [0, 1]
template <typename T, typename F>
inline T Average(T previous, T current, F currentWeight)
{
  return T((previous * (F(1) - currentWeight)) + (current * currentWeight));
}

/// Returns the specified value rounded up
template<typename T, typename F>
inline T Round(F value)
{
  return T(value + F(0.5));
}

} // namespace Zero


namespace Zero
{

//
// Atomic Operations
//

/// Atomic operations provide fast, lockless, indivisible, thread-safe operations
/// These methods are used to implement multithreaded lock-free data structures with well defined behavior

/// Sets the value stored in target
void AtomicStore(volatile s8*  target, s8  value);
void AtomicStore(volatile s16* target, s16 value);
void AtomicStore(volatile s32* target, s32 value);
void AtomicStore(volatile s64* target, s64 value);

/// Returns the value stored in target
s8  AtomicLoad(volatile s8*  target);
s16 AtomicLoad(volatile s16* target);
s32 AtomicLoad(volatile s32* target);
s64 AtomicLoad(volatile s64* target);

/// Sets the value stored in target
/// Returns the previous value stored in target
s8  AtomicExchange(volatile s8*  target, s8  value);
s16 AtomicExchange(volatile s16* target, s16 value);
s32 AtomicExchange(volatile s32* target, s32 value);
s64 AtomicExchange(volatile s64* target, s64 value);

/// Sets the value stored in target if target is bit-wise equal to comparison
/// Returns the previous value stored in target
s8  AtomicCompareExchange(volatile s8*  target, s8  value, s8  comparison);
s16 AtomicCompareExchange(volatile s16* target, s16 value, s16 comparison);
s32 AtomicCompareExchange(volatile s32* target, s32 value, s32 comparison);
s64 AtomicCompareExchange(volatile s64* target, s64 value, s64 comparison);

/// Sets the value stored in target if target is bit-wise equal to comparison
/// Returns true if the exchange took place, else false
bool AtomicCompareExchangeBool(volatile s8*  target, s8  value, s8  comparison);
bool AtomicCompareExchangeBool(volatile s16* target, s16 value, s16 comparison);
bool AtomicCompareExchangeBool(volatile s32* target, s32 value, s32 comparison);
bool AtomicCompareExchangeBool(volatile s64* target, s64 value, s64 comparison);

/// Adds the specified value to the value stored in target
/// Returns the previous value stored in target
s8  AtomicFetchAdd(volatile s8*  target, s8  value);
s16 AtomicFetchAdd(volatile s16* target, s16 value);
s32 AtomicFetchAdd(volatile s32* target, s32 value);
s64 AtomicFetchAdd(volatile s64* target, s64 value);

/// Subtracts the specified value from the value stored in target
/// Returns the previous value stored in target
s8  AtomicFetchSubtract(volatile s8*  target, s8  value);
s16 AtomicFetchSubtract(volatile s16* target, s16 value);
s32 AtomicFetchSubtract(volatile s32* target, s32 value);
s64 AtomicFetchSubtract(volatile s64* target, s64 value);

/// Pre-increments the value stored in target
/// Returns the current value stored in target
s8  AtomicPreIncrement(volatile s8*  target);
s16 AtomicPreIncrement(volatile s16* target);
s32 AtomicPreIncrement(volatile s32* target);
s64 AtomicPreIncrement(volatile s64* target);

/// Post-increments the value stored in target
/// Returns the previous value stored in target
s8  AtomicPostIncrement(volatile s8*  target);
s16 AtomicPostIncrement(volatile s16* target);
s32 AtomicPostIncrement(volatile s32* target);
s64 AtomicPostIncrement(volatile s64* target);

/// Pre-decrements the value stored in target
/// Returns the current value stored in target
s8  AtomicPreDecrement(volatile s8*  target);
s16 AtomicPreDecrement(volatile s16* target);
s32 AtomicPreDecrement(volatile s32* target);
s64 AtomicPreDecrement(volatile s64* target);

/// Post-decrements the value stored in target
/// Returns the previous value stored in target
s8  AtomicPostDecrement(volatile s8*  target);
s16 AtomicPostDecrement(volatile s16* target);
s32 AtomicPostDecrement(volatile s32* target);
s64 AtomicPostDecrement(volatile s64* target);

//
// Atomic Primitives
//

/// Atomic access object
/// Provides lockless thread-safe access to a primitive type
template <typename T, typename Enable = void>
class Atomic;

/// Integral specialization
/// Able to provide atomic arithmetic
template <typename T>
class Atomic<T, T_ENABLE_IF(is_integral<T>::value && !is_bool<T>::value)>
{
public:
  /// Typedefs
  typedef typename remove_reference_const_and_volatile<T>::type value_type;
  typedef EXACT_INT(BYTES_TO_BITS(sizeof(value_type)))          underlying_type;

  /// Constructors
  Atomic()                 : mValue()                                          {}
  Atomic(value_type value) : mValue(reinterpret_cast<underlying_type&>(value)) {}

  /// Assignment Operator
  /// Sets the current value (equivalent to Store())
  value_type operator =(value_type value)          { Store(value); return value; }
  value_type operator =(value_type value) volatile { Store(value); return value; }

  /// Conversion Operator
  /// Returns the current value (equivalent to Load())
  operator value_type() const          { return Load(); }
  operator value_type() const volatile { return Load(); }

  /// Sets the current value
  void Store(value_type value)          { AtomicStore(&mValue, reinterpret_cast<underlying_type&>(value)); }
  void Store(value_type value) volatile { AtomicStore(&mValue, reinterpret_cast<underlying_type&>(value)); }

  /// Returns the current value
  value_type Load() const          { underlying_type result = AtomicLoad(const_cast<underlying_type*>(&mValue)); return reinterpret_cast<value_type&>(result); }
  value_type Load() const volatile { underlying_type result = AtomicLoad(const_cast<underlying_type*>(&mValue)); return reinterpret_cast<value_type&>(result); }

  /// Sets the current value
  /// Returns the previous value
  value_type Exchange(value_type value)          { underlying_type result = AtomicExchange(&mValue, reinterpret_cast<underlying_type&>(value)); return reinterpret_cast<value_type&>(result); }
  value_type Exchange(value_type value) volatile { underlying_type result = AtomicExchange(&mValue, reinterpret_cast<underlying_type&>(value)); return reinterpret_cast<value_type&>(result); }

  /// Sets the current value if it is bit-wise equal to comparison
  /// Returns the previous value
  value_type CompareExchange(value_type value, value_type comparison)          { underlying_type result = AtomicCompareExchange(&mValue, reinterpret_cast<underlying_type&>(value), reinterpret_cast<underlying_type&>(comparison)); return reinterpret_cast<value_type&>(result); }
  value_type CompareExchange(value_type value, value_type comparison) volatile { underlying_type result = AtomicCompareExchange(&mValue, reinterpret_cast<underlying_type&>(value), reinterpret_cast<underlying_type&>(comparison)); return reinterpret_cast<value_type&>(result); }

  /// Sets the current value if it is bit-wise equal to comparison
  /// Returns true if the exchange took place, else false
  bool CompareExchangeBool(value_type value, value_type comparison)          { return AtomicCompareExchangeBool(&mValue, reinterpret_cast<underlying_type&>(value), reinterpret_cast<underlying_type&>(comparison)); }
  bool CompareExchangeBool(value_type value, value_type comparison) volatile { return AtomicCompareExchangeBool(&mValue, reinterpret_cast<underlying_type&>(value), reinterpret_cast<underlying_type&>(comparison)); }

  //
  // Arithmetic Operations
  //

  /// Adds the specified value to the current value
  /// Returns the previous value
  value_type FetchAdd(value_type value)          { underlying_type result = AtomicFetchAdd(&mValue, reinterpret_cast<underlying_type&>(value)); return reinterpret_cast<value_type&>(result); }
  value_type FetchAdd(value_type value) volatile { underlying_type result = AtomicFetchAdd(&mValue, reinterpret_cast<underlying_type&>(value)); return reinterpret_cast<value_type&>(result); }

  /// Subtracts the specified value to the current value
  /// Returns the previous value
  value_type FetchSubtract(value_type value)          { underlying_type result = AtomicFetchSubtract(&mValue, reinterpret_cast<underlying_type&>(value)); return reinterpret_cast<value_type&>(result); }
  value_type FetchSubtract(value_type value) volatile { underlying_type result = AtomicFetchSubtract(&mValue, reinterpret_cast<underlying_type&>(value)); return reinterpret_cast<value_type&>(result); }

  /// Adds the specified value to the current value (equivalent to FetchAdd())
  /// Returns the current value
  value_type operator +=(value_type value)          { return FetchAdd(value); }
  value_type operator +=(value_type value) volatile { return FetchAdd(value); }

  /// Subtracts the specified value to the current value (equivalent to FetchSubtract())
  /// Returns the current value
  value_type operator -=(value_type value)          { return FetchSubtract(value); }
  value_type operator -=(value_type value) volatile { return FetchSubtract(value); }

  /// Pre-increments the value
  /// Returns the current value
  value_type operator ++()          { underlying_type result = AtomicPreIncrement(&mValue); return reinterpret_cast<value_type&>(result); }
  value_type operator ++() volatile { underlying_type result = AtomicPreIncrement(&mValue); return reinterpret_cast<value_type&>(result); }

  /// Post-increments the value
  /// Returns the previous value
  value_type operator ++(int)          { underlying_type result = AtomicPostIncrement(&mValue); return reinterpret_cast<value_type&>(result); }
  value_type operator ++(int) volatile { underlying_type result = AtomicPostIncrement(&mValue); return reinterpret_cast<value_type&>(result); }

  /// Pre-decrements the value
  /// Returns the current value
  value_type operator --()          { underlying_type result = AtomicPreDecrement(&mValue); return reinterpret_cast<value_type&>(result); }
  value_type operator --() volatile { underlying_type result = AtomicPreDecrement(&mValue); return reinterpret_cast<value_type&>(result); }

  /// Post-decrements the value
  /// Returns the previous value
  value_type operator --(int)          { underlying_type result = AtomicPostDecrement(&mValue); return reinterpret_cast<value_type&>(result); }
  value_type operator --(int) volatile { underlying_type result = AtomicPostDecrement(&mValue); return reinterpret_cast<value_type&>(result); }

private:
  /// No Copy Constructor
  Atomic(const Atomic&);
  /// No Copy Assignment Operator
  Atomic& operator =(const Atomic&);

  /// Value object
  volatile underlying_type mValue;
};

/// Floating-point and boolean specialization
/// Unable to provide atomic arithmetic
template <typename T>
class Atomic<T, T_ENABLE_IF(is_floating_point<T>::value || is_bool<T>::value)>
{
public:
  /// Typedefs
  typedef typename remove_reference_const_and_volatile<T>::type value_type;
  typedef EXACT_INT(BYTES_TO_BITS(sizeof(value_type)))          underlying_type;

  /// Constructors
  Atomic()                 : mValue()                                          {}
  Atomic(value_type value) : mValue(reinterpret_cast<underlying_type&>(value)) {}

  /// Assignment Operator
  /// Sets the current value (equivalent to Store())
  value_type operator =(value_type value)          { Store(value); return value; }
  value_type operator =(value_type value) volatile { Store(value); return value; }

  /// Conversion Operator
  /// Returns the current value (equivalent to Load())
  operator value_type() const          { return Load(); }
  operator value_type() const volatile { return Load(); }

  /// Sets the current value
  void Store(value_type value)          { AtomicStore(&mValue, reinterpret_cast<underlying_type&>(value)); }
  void Store(value_type value) volatile { AtomicStore(&mValue, reinterpret_cast<underlying_type&>(value)); }

  /// Returns the current value
  value_type Load() const          { underlying_type result = AtomicLoad(const_cast<underlying_type*>(&mValue)); return reinterpret_cast<value_type&>(result); }
  value_type Load() const volatile { underlying_type result = AtomicLoad(const_cast<underlying_type*>(&mValue)); return reinterpret_cast<value_type&>(result); }

  /// Sets the current value
  /// Returns the previous value
  value_type Exchange(value_type value)          { underlying_type result = AtomicExchange(&mValue, reinterpret_cast<underlying_type&>(value)); return reinterpret_cast<value_type&>(result); }
  value_type Exchange(value_type value) volatile { underlying_type result = AtomicExchange(&mValue, reinterpret_cast<underlying_type&>(value)); return reinterpret_cast<value_type&>(result); }

  /// Sets the current value if it is bit-wise equal to comparison
  /// Returns the previous value
  value_type CompareExchange(value_type value, value_type comparison)          { underlying_type result = AtomicCompareExchange(&mValue, reinterpret_cast<underlying_type&>(value), reinterpret_cast<underlying_type&>(comparison)); return reinterpret_cast<value_type&>(result); }
  value_type CompareExchange(value_type value, value_type comparison) volatile { underlying_type result = AtomicCompareExchange(&mValue, reinterpret_cast<underlying_type&>(value), reinterpret_cast<underlying_type&>(comparison)); return reinterpret_cast<value_type&>(result); }

  /// Sets the current value if it is bit-wise equal to comparison
  /// Returns true if the exchange took place, else false
  bool CompareExchangeBool(value_type value, value_type comparison)          { return AtomicCompareExchangeBool(&mValue, reinterpret_cast<underlying_type&>(value), reinterpret_cast<underlying_type&>(comparison)); }
  bool CompareExchangeBool(value_type value, value_type comparison) volatile { return AtomicCompareExchangeBool(&mValue, reinterpret_cast<underlying_type&>(value), reinterpret_cast<underlying_type&>(comparison)); }

private:
  /// No Copy Constructor
  Atomic(const Atomic&);
  /// No Copy Assignment Operator
  Atomic& operator =(const Atomic&);

  /// Value object
  volatile underlying_type mValue;
};

} // namespace Zero



///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean, Trevor Sundberg
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes
///////////////////////////////////////////////////////////////////////////////
///
/// \file OsShared.hpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once




namespace Zero
{

typedef void *OsHandle;
typedef unsigned long OsInt;
const OsHandle cInvalidHandle = (OsHandle)0xFFFFFFFF; 
const uint cDebugNameMax = 32;

class StackHandle
{
public:
  StackHandle()
  {
    mHandle = cInvalidHandle;
  }

  ~StackHandle()
  {
    Close();
  }

  OsHandle Transfer()
  {
    OsHandle handle = mHandle;
    mHandle = cInvalidHandle;
    return handle;
  }

  void operator=(OsHandle handle)
  {
    mHandle = handle;
  }

  operator OsHandle*()
  {
    return &mHandle;
  }

  operator OsHandle()
  {
    return mHandle;
  }

  void Close();
  
private:
  OsHandle mHandle;
};

}//namespace Zero


///////////////////////////////////////////////////////////////////////////////
///
/// \file ErrorCodes.hpp
/// Basic error codes.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file EnumDeclaration.hpp
/// Declaration of enum declaration macros.
///
/// Authors: Joshua Claeys, Joshua Davis, Auto-Generated
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

//Used to determine whether or not the enum is going to be used as a bit field
//or an index.  As a bit field, each index needs to be shifted.
#define _BitField() 1 << 
#define _Indexed() 
#define _AddNone(name) namespace name { enum {None}; }  

#define _ExpandNames1(name,mode,value1)                                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0};                                          \
  enum {Size = 1};                                                            \
  static const cstr Names[] = {#value1, NULL};                                \
  static const uint Values[] = {value1};                                      \
  }                                                                           \

#define _ExpandNames2(name,mode,value1,value2)                                \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1};                         \
  enum {Size = 2};                                                            \
  static const cstr Names[] = {#value1, #value2, NULL};                       \
  static const uint Values[] = {value1, value2};                              \
  }                                                                           \

#define _ExpandNames3(name,mode,value1,value2,value3)                         \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2};        \
  enum {Size = 3};                                                            \
  static const cstr Names[] = {#value1, #value2, #value3, NULL};              \
  static const uint Values[] = {value1, value2, value3};                      \
  }                                                                           \

#define _ExpandNames4(name,mode,value1,value2,value3,value4)                  \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3};                                          \
  enum {Size = 4};                                                            \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, NULL};     \
  static const uint Values[] = {value1, value2, value3, value4};              \
  }                                                                           \

#define _ExpandNames5(name,mode,value1,value2,value3,value4,value5)           \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4};                         \
  enum {Size = 5};                                                            \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               NULL};                                         \
  static const uint Values[] = {value1, value2, value3, value4, value5};      \
  }                                                                           \

#define _ExpandNames6(name,mode,value1,value2,value3,value4,value5,value6)    \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5};        \
  enum {Size = 6};                                                            \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, NULL};                                \
  static const uint Values[] = {value1, value2, value3, value4, value5, value6\
                                };                                            \
  }                                                                           \

#define _ExpandNames7(name,mode,value1,value2,value3,value4,value5,value6,    \
                      value7)                                                 \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6};                                          \
  enum {Size = 7};                                                            \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, NULL};                       \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7};                              \
  }                                                                           \

#define _ExpandNames8(name,mode,value1,value2,value3,value4,value5,value6,    \
                      value7,value8)                                          \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7};                         \
  enum {Size = 8};                                                            \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, NULL};              \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8};                      \
  }                                                                           \

#define _ExpandNames9(name,mode,value1,value2,value3,value4,value5,value6,    \
                      value7,value8,value9)                                   \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8};        \
  enum {Size = 9};                                                            \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, NULL};     \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9};              \
  }                                                                           \

#define _ExpandNames10(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10)                          \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9};                                         \
  enum {Size = 10};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               NULL};                                         \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10};     \
  }                                                                           \

#define _ExpandNames11(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11)                  \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10};                      \
  enum {Size = 11};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, NULL};                               \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11};                                     \
  }                                                                           \

#define _ExpandNames12(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12)          \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11};   \
  enum {Size = 12};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, NULL};                     \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12};                            \
  }                                                                           \

#define _ExpandNames13(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13)  \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12};                                        \
  enum {Size = 13};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, NULL};           \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13};                   \
  }                                                                           \

#define _ExpandNames14(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14)                                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13};                     \
  enum {Size = 14};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14, NULL}; \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14};          \
  }                                                                           \

#define _ExpandNames15(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15)                                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14};  \
  enum {Size = 15};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, NULL};                               \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15}; \
  }                                                                           \

#define _ExpandNames16(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16)                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15};                                        \
  enum {Size = 16};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, NULL};                     \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16};                                     \
  }                                                                           \

#define _ExpandNames17(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17)                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16};                     \
  enum {Size = 17};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, NULL};           \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17};                            \
  }                                                                           \

#define _ExpandNames18(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18)               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17};  \
  enum {Size = 18};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18, NULL}; \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18};                   \
  }                                                                           \

#define _ExpandNames19(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19)       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18};                                        \
  enum {Size = 19};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, NULL};                               \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19};          \
  }                                                                           \

#define _ExpandNames20(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20)                                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19};                     \
  enum {Size = 20};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, NULL};                     \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20}; \
  }                                                                           \

#define _ExpandNames21(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21)                                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20};  \
  enum {Size = 21};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, NULL};           \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21};                                     \
  }                                                                           \

#define _ExpandNames22(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22)                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21};                                        \
  enum {Size = 22};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22, NULL}; \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22};                            \
  }                                                                           \

#define _ExpandNames23(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23)                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22};                     \
  enum {Size = 23};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, NULL};                               \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23};                   \
  }                                                                           \

#define _ExpandNames24(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24)               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23};  \
  enum {Size = 24};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, NULL};                     \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24};          \
  }                                                                           \

#define _ExpandNames25(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25)       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24};                                        \
  enum {Size = 25};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, #value25, NULL};           \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24, value25}; \
  }                                                                           \

#define _ExpandNames26(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26)                                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25};                     \
  enum {Size = 26};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, #value25, #value26, NULL}; \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24, value25,  \
                                value26};                                     \
  }                                                                           \

#define _ExpandNames27(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27)                                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26};  \
  enum {Size = 27};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, #value25, #value26,        \
                               #value27, NULL};                               \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24, value25,  \
                                value26, value27};                            \
  }                                                                           \

#define _ExpandNames28(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28)                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27};                                        \
  enum {Size = 28};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, #value25, #value26,        \
                               #value27, #value28, NULL};                     \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24, value25,  \
                                value26, value27, value28};                   \
  }                                                                           \

#define _ExpandNames29(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28,value29)                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27, value29 = mode 28};                     \
  enum {Size = 29};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, #value25, #value26,        \
                               #value27, #value28, #value29, NULL};           \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24, value25,  \
                                value26, value27, value28, value29};          \
  }                                                                           \

#define _ExpandNames30(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28,value29,value30)               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27, value29 = mode 28, value30 = mode 29};  \
  enum {Size = 30};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, #value25, #value26,        \
                               #value27, #value28, #value29, #value30, NULL}; \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24, value25,  \
                                value26, value27, value28, value29, value30}; \
  }                                                                           \

#define _ExpandNames31(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28,value29,value30,value31)       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27, value29 = mode 28, value30 = mode 29,   \
                   value31 = mode 30};                                        \
  enum {Size = 31};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, #value25, #value26,        \
                               #value27, #value28, #value29, #value30,        \
                               #value31, NULL};                               \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24, value25,  \
                                value26, value27, value28, value29, value30,  \
                                value31};                                     \
  }                                                                           \

#define _ExpandNames32(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28,value29,value30,value31,       \
                       value32)                                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static const cstr EnumName = #name;                                         \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27, value29 = mode 28, value30 = mode 29,   \
                   value31 = mode 30, value32 = mode 31};                     \
  enum {Size = 32};                                                           \
  static const cstr Names[] = {#value1, #value2, #value3, #value4, #value5,   \
                               #value6, #value7, #value8, #value9, #value10,  \
                               #value11, #value12, #value13, #value14,        \
                               #value15, #value16, #value17, #value18,        \
                               #value19, #value20, #value21, #value22,        \
                               #value23, #value24, #value25, #value26,        \
                               #value27, #value28, #value29, #value30,        \
                               #value31, #value32, NULL};                     \
  static const uint Values[] = {value1, value2, value3, value4, value5,       \
                                value6, value7, value8, value9, value10,      \
                                value11, value12, value13, value14, value15,  \
                                value16, value17, value18, value19, value20,  \
                                value21, value22, value23, value24, value25,  \
                                value26, value27, value28, value29, value30,  \
                                value31, value32};                            \
  }                                                                           \


#define DeclareEnum1(name,v1)                                                 \
        _ExpandNames1(name,_Indexed(),v1)
#define DeclareEnum2(name,v1,v2)                                              \
        _ExpandNames2(name,_Indexed(),v1,v2)
#define DeclareEnum3(name,v1,v2,v3)                                           \
        _ExpandNames3(name,_Indexed(),v1,v2,v3)
#define DeclareEnum4(name,v1,v2,v3,v4)                                        \
        _ExpandNames4(name,_Indexed(),v1,v2,v3,v4)
#define DeclareEnum5(name,v1,v2,v3,v4,v5)                                     \
        _ExpandNames5(name,_Indexed(),v1,v2,v3,v4,v5)
#define DeclareEnum6(name,v1,v2,v3,v4,v5,v6)                                  \
        _ExpandNames6(name,_Indexed(),v1,v2,v3,v4,v5,v6)
#define DeclareEnum7(name,v1,v2,v3,v4,v5,v6,v7)                               \
        _ExpandNames7(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7)
#define DeclareEnum8(name,v1,v2,v3,v4,v5,v6,v7,v8)                            \
        _ExpandNames8(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8)
#define DeclareEnum9(name,v1,v2,v3,v4,v5,v6,v7,v8,v9)                         \
        _ExpandNames9(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9)
#define DeclareEnum10(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)                    \
        _ExpandNames10(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)
#define DeclareEnum11(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11)                \
        _ExpandNames11(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11)
#define DeclareEnum12(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12)            \
        _ExpandNames12(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12)
#define DeclareEnum13(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13)        \
        _ExpandNames13(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13)
#define DeclareEnum14(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14)    \
        _ExpandNames14(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14)
#define DeclareEnum15(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15)\
        _ExpandNames15(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15)
#define DeclareEnum16(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16)                                                    \
        _ExpandNames16(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16)
#define DeclareEnum17(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17)                                                \
        _ExpandNames17(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17)
#define DeclareEnum18(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18)                                            \
        _ExpandNames18(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18)
#define DeclareEnum19(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19)                                        \
        _ExpandNames19(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19)
#define DeclareEnum20(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20)                                    \
        _ExpandNames20(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20)
#define DeclareEnum21(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21)                                \
        _ExpandNames21(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21)
#define DeclareEnum22(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22)                            \
        _ExpandNames22(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22)
#define DeclareEnum23(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23)                        \
        _ExpandNames23(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23)
#define DeclareEnum24(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24)                    \
        _ExpandNames24(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24)
#define DeclareEnum25(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25)                \
        _ExpandNames25(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25)
#define DeclareEnum26(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26)            \
        _ExpandNames26(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26)
#define DeclareEnum27(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27)        \
        _ExpandNames27(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27)
#define DeclareEnum28(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28)    \
        _ExpandNames28(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28)
#define DeclareEnum29(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29)\
        _ExpandNames29(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28,v29)
#define DeclareEnum30(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29,\
                      v30)                                                    \
        _ExpandNames30(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28,v29,v30)
#define DeclareEnum31(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29,\
                      v30,v31)                                                \
        _ExpandNames31(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28,v29,v30,v31)
#define DeclareEnum32(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29,\
                      v30,v31,v32)                                            \
        _ExpandNames32(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28,v29,v30,v31,v32)

#define DeclareBitField1(name,v1)                                             \
        _ExpandNames1(name,_BitField(),v1)                                    \
        _AddNone(name)
#define DeclareBitField2(name,v1,v2)                                          \
        _ExpandNames2(name,_BitField(),v1,v2)                                 \
        _AddNone(name)
#define DeclareBitField3(name,v1,v2,v3)                                       \
        _ExpandNames3(name,_BitField(),v1,v2,v3)                              \
        _AddNone(name)
#define DeclareBitField4(name,v1,v2,v3,v4)                                    \
        _ExpandNames4(name,_BitField(),v1,v2,v3,v4)                           \
        _AddNone(name)
#define DeclareBitField5(name,v1,v2,v3,v4,v5)                                 \
        _ExpandNames5(name,_BitField(),v1,v2,v3,v4,v5)                        \
        _AddNone(name)
#define DeclareBitField6(name,v1,v2,v3,v4,v5,v6)                              \
        _ExpandNames6(name,_BitField(),v1,v2,v3,v4,v5,v6)                     \
        _AddNone(name)
#define DeclareBitField7(name,v1,v2,v3,v4,v5,v6,v7)                           \
        _ExpandNames7(name,_BitField(),v1,v2,v3,v4,v5,v6,v7)                  \
        _AddNone(name)
#define DeclareBitField8(name,v1,v2,v3,v4,v5,v6,v7,v8)                        \
        _ExpandNames8(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8)               \
        _AddNone(name)
#define DeclareBitField9(name,v1,v2,v3,v4,v5,v6,v7,v8,v9)                     \
        _ExpandNames9(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9)            \
        _AddNone(name)
#define DeclareBitField10(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)                \
        _ExpandNames10(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)       \
        _AddNone(name)
#define DeclareBitField11(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11)            \
        _ExpandNames11(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11)   \
        _AddNone(name)
#define DeclareBitField12(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12)        \
        _ExpandNames12(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12)                                                   \
        _AddNone(name)
#define DeclareBitField13(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13)    \
        _ExpandNames13(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13)                                               \
        _AddNone(name)
#define DeclareBitField14(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14)\
        _ExpandNames14(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14)                                           \
        _AddNone(name)
#define DeclareBitField15(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15)                                                \
        _ExpandNames15(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15)                                       \
        _AddNone(name)
#define DeclareBitField16(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16)                                            \
        _ExpandNames16(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16)                                   \
        _AddNone(name)
#define DeclareBitField17(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17)                                        \
        _ExpandNames17(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17)                               \
        _AddNone(name)
#define DeclareBitField18(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18)                                    \
        _ExpandNames18(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18)                           \
        _AddNone(name)
#define DeclareBitField19(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19)                                \
        _ExpandNames19(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19)                       \
        _AddNone(name)
#define DeclareBitField20(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20)                            \
        _ExpandNames20(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20)                   \
        _AddNone(name)
#define DeclareBitField21(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21)                        \
        _ExpandNames21(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21)               \
        _AddNone(name)
#define DeclareBitField22(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22)                    \
        _ExpandNames22(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22)           \
        _AddNone(name)
#define DeclareBitField23(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23)                \
        _ExpandNames23(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23)       \
        _AddNone(name)
#define DeclareBitField24(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24)            \
        _ExpandNames24(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24)   \
        _AddNone(name)
#define DeclareBitField25(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25)        \
        _ExpandNames25(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25)                                                   \
        _AddNone(name)
#define DeclareBitField26(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26)    \
        _ExpandNames26(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26)                                               \
        _AddNone(name)
#define DeclareBitField27(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27)\
        _ExpandNames27(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27)                                           \
        _AddNone(name)
#define DeclareBitField28(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28)                                                \
        _ExpandNames28(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28)                                       \
        _AddNone(name)
#define DeclareBitField29(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28,v29)                                            \
        _ExpandNames29(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28,v29)                                   \
        _AddNone(name)
#define DeclareBitField30(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28,v29,v30)                                        \
        _ExpandNames30(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28,v29,v30)                               \
        _AddNone(name)
#define DeclareBitField31(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28,v29,v30,v31)                                    \
        _ExpandNames31(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28,v29,v30,v31)                           \
        _AddNone(name)
#define DeclareBitField32(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28,v29,v30,v31,v32)                                \
        _ExpandNames32(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28,v29,v30,v31,v32)                       \
        _AddNone(name)




namespace Zero
{

DeclareEnum2(StatusState, 
  Success, 
  Failure);

class Status
{
public:
  Status()
   :CurrentState(StatusState::Success), ExtendedErrorCode(0), IgnoreMessage(false)
  {}

  Status(StatusState::Enum state, StringRef message)
    :CurrentState(state), Message(message), ExtendedErrorCode(0), IgnoreMessage(false)
  {}

  bool Failed(){return CurrentState != StatusState::Success; }
  bool Succeeded(){return CurrentState == StatusState::Success; }

  void SetFailed(StringRef message, u32 extenedErrorCode = 0)
  {
    CurrentState = StatusState::Failure;
    Message = message;
    ExtendedErrorCode = extenedErrorCode;
  }

  void SetSucceeded(StringRef message = String())
  {
    CurrentState = StatusState::Success;
    Message = message;
    ExtendedErrorCode = 0;
  }

  void AppendFailed(StringRef message)
  {
    CurrentState = StatusState::Failure;
    Message = BuildString(Message, message);
  }

  // Conversion to bool
  operator bool(){return CurrentState == StatusState::Success;}
  // Current state
  StatusState::Enum CurrentState;
  // Message for display.
  String Message;
  // Some functions want to return more detail on why they failed
  // so outer code can react to failures, this is usually a declare enum
  u32 ExtendedErrorCode;
  // As an optimization, we can suggest that we don't care about the message string
  // This is only a suggestion and may not be used (but should be heeded in high performance areas)
  bool IgnoreMessage;
};

#define StatusReturnIfFailed(Status, ...) ReturnIf((Status).Failed(), __VA_ARGS__, "%s", (Status).Message.c_str())

}

///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes


///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes


namespace Zero
{

/// Unsigned integer of N bits
template <Bits N, bool WrapAware = false>
class UintN
{
public:
  /// Typedefs
  typedef NEAREST_UINT(N) value_type;

  /// Constants
  static const Bits       bits    = N;
  static const Bytes      bytes   = BITS_TO_BYTES(bits);
  static const value_type min     = 0U;
  static const value_type max     = POW2(bits) - 1;
  static const value_type halfmax = max / 2;

  /// Default Constructor
  UintN(void)                     : mValue(min)         {}
  /// Copy Constructor
  UintN(const UintN& rhs)         : mValue(rhs.mValue)  {}
  /// Move Constructor
  UintN(MoveReference<UintN> rhs) : mValue(rhs->mValue) {}
  /// Conversion Constructor
  UintN(value_type rhs)           : mValue(Clamp(rhs))  {}

  /// Copy Assignment Operator
  UintN& operator=(const UintN& rhs)         { mValue = rhs.mValue; return *this;  }
  /// Move Assignment Operator
  UintN& operator=(MoveReference<UintN> rhs) { mValue = rhs->mValue; return *this; }
  /// Assignment Operator
  UintN& operator=(value_type rhs)           { mValue = Clamp(rhs); return *this;  }

  /// Arithmetic Operators
  UintN operator+(UintN rhs) const { return mValue + rhs.mValue;                }
  UintN operator-(UintN rhs) const { return mValue - rhs.mValue;                }
  UintN operator*(UintN rhs) const { return mValue * rhs.mValue;                }
  UintN operator/(UintN rhs) const { return mValue / rhs.mValue;                }
  UintN operator%(UintN rhs) const { return mValue % rhs.mValue;                }
  UintN operator++(void)           { mValue = Clamp(++mValue); return *this;    }
  UintN operator++(int)            { UintN temp(*this); ++(*this); return temp; }
  UintN operator--(void)           { mValue = Clamp(--mValue); return *this;    }
  UintN operator--(int)            { UintN temp(*this); --(*this); return temp; }

  /// Bitwise Operators
  UintN operator~(void) const       { return ~mValue;              }
  UintN operator&(UintN rhs) const  { return mValue & rhs.mValue;  }
  UintN operator|(UintN rhs) const  { return mValue | rhs.mValue;  }
  UintN operator^(UintN rhs) const  { return mValue ^ rhs.mValue;  }
  UintN operator<<(UintN rhs) const { return mValue << rhs.mValue; }
  UintN operator>>(UintN rhs) const { return mValue >> rhs.mValue; }

  /// Compound Assignment Operators
  UintN& operator+=(UintN rhs)  { mValue = Clamp(mValue + rhs.mValue); return *this;  }
  UintN& operator-=(UintN rhs)  { mValue = Clamp(mValue - rhs.mValue); return *this;  }
  UintN& operator*=(UintN rhs)  { mValue = Clamp(mValue * rhs.mValue); return *this;  }
  UintN& operator/=(UintN rhs)  { mValue = Clamp(mValue / rhs.mValue); return *this;  }
  UintN& operator%=(UintN rhs)  { mValue = Clamp(mValue % rhs.mValue); return *this;  }
  UintN& operator&=(UintN rhs)  { mValue = Clamp(mValue & rhs.mValue); return *this;  }
  UintN& operator|=(UintN rhs)  { mValue = Clamp(mValue | rhs.mValue); return *this;  }
  UintN& operator^=(UintN rhs)  { mValue = Clamp(mValue ^ rhs.mValue); return *this;  }
  UintN& operator<<=(UintN rhs) { mValue = Clamp(mValue << rhs.mValue); return *this; }
  UintN& operator>>=(UintN rhs) { mValue = Clamp(mValue >> rhs.mValue); return *this; }

  /// Comparison Operators
  bool operator==(UintN rhs) const { return mValue == rhs.mValue;          }
  bool operator!=(UintN rhs) const { return mValue != rhs.mValue;          }
  bool operator>(UintN rhs) const  { return IsGreaterThan<WrapAware>(rhs); }
  bool operator<(UintN rhs) const  { return IsLessThan<WrapAware>(rhs);    }
  bool operator>=(UintN rhs) const { return *this > rhs || *this == rhs;   }
  bool operator<=(UintN rhs) const { return *this < rhs || *this == rhs;   }

  /// Logical Operators
  bool operator!(void) const            { return !mValue;              }
  bool operator&&(value_type rhs) const { return mValue && rhs.mValue; }
  bool operator||(value_type rhs) const { return mValue || rhs.mValue; }

  /// Returns the underlying value
  value_type& value(void)       { return mValue; }
  value_type  value(void) const { return mValue; }

private:
  /// Clamps a value to fit within the representable bit range
  static inline value_type Clamp(value_type mValue)
  {
    return mValue <= max ? mValue : (mValue - max) - 1;
  }

  /// Wrap-aware greater-than comparison operator
  /// Returns true if rhs is greater, else false
  template<bool UseWrapAware>
  inline bool IsGreaterThan(UintN rhs) const
  {
    if(UseWrapAware)
      return (mValue == rhs.mValue ? false : (rhs - *this).mValue > halfmax);
    else
      return mValue > rhs.mValue;
  }

  /// Wrap-aware less-than comparison operator
  /// Returns true if rhs is lesser, else false
  template<bool UseWrapAware>
  inline bool IsLessThan(UintN rhs) const
  {
    if(UseWrapAware)
      return (mValue == rhs.mValue ? false : (rhs - *this).mValue < halfmax);
    else
      return mValue < rhs.mValue;
  }

  /// Underlying value
  value_type mValue;
};

} // namespace Zero


//---------------------------------------------------------------------------------//
//                           BitStream Configuration                               //
//---------------------------------------------------------------------------------//

/// Use portable floating-point format?
/// For communication between platforms with differing floating-point formats
#ifndef BITSTREAM_USE_PORTABLE_FLOATING_POINT
#define BITSTREAM_USE_PORTABLE_FLOATING_POINT 0
#endif

/// Default memory allocation byte size
/// Used if reserve is not called before first write
#ifndef BITSTREAM_DEFAULT_RESERVE_BYTES
#define BITSTREAM_DEFAULT_RESERVE_BYTES POW2(5)
#endif
StaticAssertWithinRange(StaticAssertRange1, BYTES_TO_BITS(BITSTREAM_DEFAULT_RESERVE_BYTES), 1, Bits(-1));

/// Maximum memory allocation byte size
#ifndef BITSTREAM_MAX_BYTES
#define BITSTREAM_MAX_BYTES POW2(28)
#endif
StaticAssertWithinRange(StaticAssertRange2, BYTES_TO_BITS(BITSTREAM_MAX_BYTES), 1, Bits(-1));

namespace Zero
{

/// Bit alignment
DeclareEnum2(BitAlignment,
  Bit,   /// Bit aligned
  Byte); /// Byte aligned

/// Serialize direction
DeclareEnum2(SerializeDirection,
  Write, /// Perform a write
  Read); /// Perform a read

//---------------------------------------------------------------------------------//
//                                  BitStream                                      //
//---------------------------------------------------------------------------------//

/// Forward Declarations
class BitStream;

/// Serializes data
/// Returns the number of bits serialized if successful, else 0
template<typename T>
Bits Serialize(SerializeDirection::Enum direction, BitStream& bitStream, T& value)
{
  //StaticAssert(MissingUserDefinedSerialize, false, "Requires a user-defined Serialize function");
  return 0;
}

/// Serializes data from an inclusive range
/// Returns the number of bits serialized if successful, else 0
template<typename T, typename R>
Bits SerializeInRange(SerializeDirection::Enum direction, BitStream& bitStream, T& value_, const R& minValue_, const R& maxValue_)
{
  //StaticAssert(MissingUserDefinedSerializeInRange, false, "Requires a user-defined SerializeInRange function");
  return 0;
}

/// Bit-packed data stream
class BitStream
{
public:
  /// Default Constructor
  BitStream();
  /// Copy Constructor
  BitStream(const BitStream& rhs);
  /// Move Constructor
  BitStream(MoveReference<BitStream> rhs);

  /// Destructor
  ~BitStream();

  /// Copy Assignment Operator
  BitStream& operator =(const BitStream& rhs);
  /// Move Assignment Operator
  BitStream& operator =(MoveReference<BitStream> rhs);

  /// Comparison Operators
  bool operator ==(const BitStream& rhs) const;
  bool operator !=(const BitStream& rhs) const;
  bool operator  <(const BitStream& rhs) const;

  //
  // Member Functions
  //

  /// Sets the bit alignment
  /// Affects any successive write or read operations
  void SetAlignment(BitAlignment::Enum alignment) const { mAlignment = alignment; }
  /// Returns the bit alignment
  BitAlignment::Enum GetAlignment() const               { return mAlignment;      }

  /// Returns the data array
  const byte* GetData() const { return mData; }
  /// Returns the data array exposed for writing to the internal buffer directly.
  /// Be sure there's enough room by calling Reserve() prior to this call and inform
  /// the BitStream of data written by calling SetBitsWritten() or SetBytesWritten() afterwards.
  byte* GetDataExposed()      { return mData; }

  /// Returns the data array capacity in bits
  Bits GetBitCapacity() const   { return BYTES_TO_BITS(GetByteCapacity()); }
  /// Returns the data array capacity in bytes
  Bytes GetByteCapacity() const { return mByteCapacity;                    }

  /// Returns the number of bits written
  Bits GetBitsWritten() const   { return mBitsWritten;                   }
  /// Returns the number of bytes written (Rounded up, ex. 12 bits = 2 bytes)
  Bytes GetBytesWritten() const { return BITS_TO_BYTES(GetBitsWritten()); }

  /// Returns the number of bits unwritten
  Bits GetBitsUnwritten() const   { return GetBitCapacity() - GetBitsWritten(); }
  /// Returns the number of bytes unwritten (Rounded up, ex. 12 bits = 2 bytes)
  Bytes GetBytesUnwritten() const { return BITS_TO_BYTES(GetBitsUnwritten());   }

  /// Returns the number of bits read
  Bits GetBitsRead() const   { return mBitsRead;                    }
  /// Returns the number of bytes read (Rounded up, ex. 12 bits = 2 bytes)
  Bytes GetBytesRead() const { return BITS_TO_BYTES(GetBitsRead()); }

  /// Returns the number of bits unread
  Bits GetBitsUnread() const   { return mBitsWritten - mBitsRead;       }
  /// Returns the number of bytes unread (Rounded up, ex. 12 bits = 2 bytes)
  Bytes GetBytesUnread() const { return BITS_TO_BYTES(GetBitsUnread()); }

  /// Returns the number of bits serialized
  Bits GetBitsSerialized(SerializeDirection::Enum direction) const   { return (direction == SerializeDirection::Write) ? mBitsWritten : mBitsRead; }
  /// Returns the number of bytes serialized (Rounded up, ex. 12 bits = 2 bytes)
  Bytes GetBytesSerialized(SerializeDirection::Enum direction) const { return BITS_TO_BYTES(GetBitsSerialized(direction)); }

  /// Returns true if the BitStream is empty (0 bits written), else false
  bool IsEmpty() const { return mBitsWritten ? false : true; }

  /// Reserves at least the specified memory capacity, reallocating if necessary
  void Reserve(Bytes capacity);

  /// Clears all data written and resets the bitstream, optionally freeing reserved memory
  void Clear(bool freeMemory);

  //
  // Serialize Operations
  //

  /// Serializes a single bit
  /// Returns the number of bits serialized if successful, else 0
  Bits SerializeBit(SerializeDirection::Enum direction, bool& value)
  {
    return (direction == SerializeDirection::Write) ? WriteBit(value)
                                                    : ReadBit(value);
  }
  /// Serializes multiple bits
  /// Returns the number of bits serialized if successful, else 0
  Bits SerializeBits(SerializeDirection::Enum direction, byte* data, Bits dataBits)
  {
    return (direction == SerializeDirection::Write) ? WriteBits(data, dataBits)
                                                    : ReadBits(data, dataBits);
  }

  /// Serializes a single byte
  /// Returns the number of bits serialized if successful, else 0
  Bits SerializeByte(SerializeDirection::Enum direction, uint8& value)
  {
    return (direction == SerializeDirection::Write) ? WriteByte(value)
                                                    : ReadByte(value);
  }
  /// Serializes multiple bytes
  /// Returns the number of bits serialized if successful, else 0
  Bits SerializeBytes(SerializeDirection::Enum direction, byte* data, Bytes dataBytes)
  {
    return (direction == SerializeDirection::Write) ? WriteBytes(data, dataBytes)
                                                    : ReadBytes(data, dataBytes);
  }

  /// Serializes a boolean value
  /// Returns the number of bits serialized if successful, else 0
  Bits Serialize(SerializeDirection::Enum direction, bool& value)
  {
    return (direction == SerializeDirection::Write) ? Write(value)
                                                    : Read(value);
  }
  /// Serializes a string value
  /// Returns the number of bits serialized if successful, else 0
  Bits Serialize(SerializeDirection::Enum direction, String& value)
  {
    return (direction == SerializeDirection::Write) ? Write(value)
                                                    : Read(value);
  }
  /// Serializes an integral value
  /// Returns the number of bits serialized if successful, else 0
  template<typename T>
  R_ENABLE_IF(is_enum_or_integral<T>::value, Bits) Serialize(SerializeDirection::Enum direction, T& value)
  {
    return (direction == SerializeDirection::Write) ? Write(value)
                                                    : Read(value);
  }
  /// Serializes a floating-point value
  /// Returns the number of bits serialized if successful, else 0
  template<typename T>
  R_ENABLE_IF(is_floating_point<T>::value, Bits) Serialize(SerializeDirection::Enum direction, T& value)
  {
    return (direction == SerializeDirection::Write) ? Write(value)
                                                    : Read(value);
  }
  /// Serializes a fixed array of values
  /// Returns the number of bits written if successful, else 0
  template<typename T, size_t Size>
  Bits Serialize(SerializeDirection::Enum direction, const T (& array)[Size])
  {
    Bits bitsSerialized = 0;

    // Serialize every element
    for(size_t i = 0; i < Size; ++i)
      bitsSerialized += Serialize(direction, array[i]);

    return bitsSerialized;
  }
  /// Serializes a fixed array of values
  /// Returns the number of bits written if successful, else 0
  template<typename T>
  Bits Serialize(SerializeDirection::Enum direction, const T* array, size_t size)
  {
    Bits bitsSerialized = 0;

    // Serialize every element
    for(size_t i = 0; i < size; ++i)
      bitsSerialized += Serialize(direction, array[i]);

    return bitsSerialized;
  }
  /// Serializes a UintN value
  /// Returns the number of bits serialized if successful, else 0
  template <Bits N, bool WrapAware>
  Bits Serialize(SerializeDirection::Enum direction, UintN<N, WrapAware>& value)
  {
    return (direction == SerializeDirection::Write) ? Write(value)
                                                    : Read(value);
  }
  /// Serializes a user-defined value
  /// Returns the number of bits serialized if successful, else 0
  template<typename T>
  R_ENABLE_IF(!is_scalar<T>::value, Bits) Serialize(SerializeDirection::Enum direction, T& value)
  {
    // Invoke user-defined function
    return Zero::Serialize(direction, *this, value);
  }

  /// Serializes an integral value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits serialized if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(is_enum_or_integral<T>::value && is_enum_or_integral<R>::value, Bits) SerializeInRange(SerializeDirection::Enum direction, T& value_, R minValue_, R maxValue_)
  {
    return (direction == SerializeDirection::Write) ? WriteInRange(value_, minValue_, maxValue_)
                                                    : ReadInRange(value_, minValue_, maxValue_);
  }
  /// Serializes a floating-point value from an inclusive range, using only floatPrecisionBits
  /// Returns the number of bits serialized if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(is_floating_point<T>::value, Bits) SerializeInRange(SerializeDirection::Enum direction, T& value, R minValue_, R maxValue_, Bits floatPrecisionBits = (BYTES_TO_BITS(sizeof(T)) / 2))
  {
    return (direction == SerializeDirection::Write) ? WriteInRange(value, minValue_, maxValue_, floatPrecisionBits)
                                                    : ReadInRange(value, minValue_, maxValue_, floatPrecisionBits);
  }
  /// Serializes a UintN value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits serialized if successful, else 0
  template <Bits N, bool WrapAware, typename R>
  R_ENABLE_IF(is_enum_or_integral<R>::value, Bits) SerializeInRange(SerializeDirection::Enum direction, UintN<N, WrapAware>& value, R minValue, R maxValue)
  {
    return (direction == SerializeDirection::Write) ? WriteInRange(value, minValue, maxValue)
                                                    : ReadInRange(value, minValue, maxValue);
  }
  /// Serializes a user-defined value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits serialized if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(!is_scalar<T>::value, Bits) SerializeInRange(SerializeDirection::Enum direction, T& value_, const R& minValue_, const R& maxValue_)
  {
    // Invoke user-defined function
    return Zero::SerializeInRange(direction, *this, value_, minValue_, maxValue_);
  }

  //
  // Write Operations
  //

  /// Writes a single bit
  /// Returns the number of bits written if successful, else 0
  Bits WriteBit(bool value);
  /// Writes multiple bits
  /// Returns the number of bits written if successful, else 0
  Bits WriteBits(const byte* data, Bits dataBits);

  /// Writes a single byte
  /// Returns the number of bits written if successful, else 0
  Bits WriteByte(uint8 value);
  /// Writes multiple bytes
  /// Returns the number of bits written if successful, else 0
  Bits WriteBytes(const byte* data, Bytes dataBytes);

  /// Writes a boolean value
  /// Returns the number of bits written if successful, else 0
  Bits Write(bool value) { return WriteBit(value); }
  /// Writes a string value
  /// Returns the number of bits written if successful, else 0
  Bits Write(const String& value);

  /// Writes an enum value
  /// Returns the number of bits written if successful, else 0
  template<typename T>
  R_ENABLE_IF(is_enum<T>::value, Bits) Write(T value)
  {
    // Typedefs
    typedef EXACT_INT(BYTES_TO_BITS(sizeof(T))) intType;

    // Write enum as integer
    return Write((intType)value);
  }
  /// Writes an integral value
  /// Returns the number of bits written if successful, else 0
  template<typename T>
  R_ENABLE_IF(is_integral<T>::value, Bits) Write(T value)
  {
    // Flip to big endian
    value = NetworkFlip(value);

    // Write value
    return WriteBits((const byte*)&value, BYTES_TO_BITS(sizeof(value)));
  }
  /// Writes a floating-point value
  /// Returns the number of bits written if successful, else 0
  template<typename T>
  R_ENABLE_IF(is_floating_point<T>::value, Bits) Write(T value)
  {
    // Finite value (not NaN or infinity) check
    Assert(-std::numeric_limits<T>::max() <= value && value <= std::numeric_limits<T>::max());

#if BITSTREAM_USE_PORTABLE_FLOATING_POINT

    const Bits totalBits = BYTES_TO_BITS(sizeof(T));       // Total bits (sign + exp + mant)
    Bits       mantBits  = std::numeric_limits<T>::digits; // Mantissa bits
    Bits       expBits   = totalBits - mantBits;           // Exponent bits
    --mantBits;                                            // Sign bit
    Assert(totalBits == (1 + expBits + mantBits));

    // Typedefs
    typedef EXACT_UINT(BYTES_TO_BITS(sizeof(T))) uintType;
    typedef EXACT_INT(BYTES_TO_BITS(sizeof(T)))  intType;

    // Convert to IEEE-754
    uintType result;
    if(value == T(0))
      result = 0;
    else
    {
      T normValue = value;

      // Get sign bit, begin normalization
      uintType sign = 0;
      if(value < T(0))
      {
        sign = 1;
        normValue *= T(-1);
      }

      // Get exponent shift, finish normalization
      intType shift = 0;
      while(normValue >= T(2))
      {
        normValue /= T(2);
        ++shift;
      }
      while(normValue < T(1))
      {
        normValue *= T(2);
        --shift;
      }
      --normValue;

      // Get mantissa and exponent, stored as unsigned integers
      uintType mantissa = uintType(normValue * (T(uintType(1) << mantBits) + T(0.5)));
      uintType exponent = shift + (uintType(1) << (expBits - 1)) - 1;

      // Concatenate result (Sign | Exponent | Mantissa)
      result = (sign << (totalBits - 1)) | (exponent << (totalBits - expBits - 1)) | mantissa;
    }

    // Flip to big endian
    result = NetworkFlip(result);

    // Write the result
    return WriteBits((const byte*)&result, totalBits);

#else

    // Flip to big endian
    value = NetworkFlip(value);

    // Write the value
    return WriteBits((const byte*)&value, BYTES_TO_BITS(sizeof(value)));

#endif
  }
  /// Writes a fixed array of values
  /// Returns the number of bits written if successful, else 0
  template<typename T, size_t Size>
  Bits Write(const T (& array)[Size])
  {
    Bits bitsWritten = 0;

    // Write every element
    for(size_t i = 0; i < Size; ++i)
      bitsWritten += Write(array[i]);

    return bitsWritten;
  }
  /// Writes a fixed array of values
  /// Returns the number of bits written if successful, else 0
  template<typename T>
  Bits Write(const T* array, size_t size)
  {
    Bits bitsWritten = 0;

    // Write every element
    for(size_t i = 0; i < size; ++i)
      bitsWritten += Write(array[i]);

    return bitsWritten;
  }
  /// Writes a UintN value
  /// Returns the number of bits written if successful, else 0
  template <Bits N, bool WrapAware>
  Bits Write(UintN<N, WrapAware> value)
  {
    return WriteInRange(value.value(), value.min, value.max);
  }
  /// Writes a user-defined value
  /// Returns the number of bits written if successful, else 0
  template<typename T>
  R_ENABLE_IF(!is_scalar<T>::value, Bits) Write(const T& value)
  {
    // Invoke user-defined function
    return Zero::Serialize(SerializeDirection::Write, *this, const_cast<T&>(value));
  }

  /// Writes an enum value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits written if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(is_enum<T>::value && is_enum_or_integral<R>::value, Bits) WriteInRange(T value_, R minValue_, R maxValue_)
  {
    // Typedefs
    typedef EXACT_INT(BYTES_TO_BITS(sizeof(T))) intType;

    // Write enum as integer
    return WriteInRange((intType)value_, (intType)minValue_, (intType)maxValue_);
  }
  /// Writes an integral value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits written if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(is_integral<T>::value && is_integral<R>::value, Bits) WriteInRange(T value_, R minValue_, R maxValue_)
  {
    typedef typename conditional<is_signed<R>::value, R, T>::type V;
    V value    = V(value_);
    V minValue = V(minValue_);
    V maxValue = V(maxValue_);
    Assert(minValue <= maxValue);
    value = Clamp(value, minValue, maxValue);

    // Determine bits needed to represent the entire range of possible values
    V range = maxValue - minValue;
    Bits bitSize = BitsNeededToRepresent(range);

    // Normalize value (to range)
    V normValue = value - minValue;
    Assert(0 <= normValue && normValue <= range);

    // Convert from right-justified to left-justified
    normValue <<= (BYTES_TO_BITS(sizeof(normValue)) - bitSize);

    // Flip to big endian
    normValue = NetworkFlip(normValue);

    // Write the normalized value
    return WriteBits((const byte*)&normValue, bitSize);
  }
  /// Writes a floating-point value from an inclusive range, using only floatPrecisionBits
  /// Returns the number of bits written if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(is_floating_point<T>::value, Bits) WriteInRange(T value, R minValue_, R maxValue_, Bits floatPrecisionBits = (BYTES_TO_BITS(sizeof(T)) / 2))
  {
    T minValue = T(minValue_);
    T maxValue = T(maxValue_);
    floatPrecisionBits = Clamp(floatPrecisionBits, Bits(1), Bits(BYTES_TO_BITS(sizeof(T))));
    Assert(minValue < maxValue);
    value = Clamp(value, minValue, maxValue);

    // Typedefs
    typedef EXACT_UINT(BYTES_TO_BITS(sizeof(T))) uintType;

    // Calculate upper bound (max representable number)
    uintType upperBound = (uintType(1) << floatPrecisionBits) - 1;

    // Determine range
    T range = maxValue - minValue;

    // Normalize value (to range)
    T normValue = value - minValue;

    // Quantize value
    T ratio = Clamp(normValue/range, T(0), T(1));           // Where the value lies in the range
    uintType quantizedValue = uintType(ratio * upperBound); // Create an integer with the same ratio

    // Write quantized value
    return WriteInRange(quantizedValue, uintType(0), upperBound);
  }
  /// Writes a UintN value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits written if successful, else 0
  template <Bits N, bool WrapAware, typename R>
  R_ENABLE_IF(is_enum_or_integral<R>::value, Bits) WriteInRange(UintN<N, WrapAware> value, R minValue, R maxValue)
  {
    typedef typename UintN<N, WrapAware>::value_type value_type;

    return WriteInRange(value.value(), (value_type)minValue, (value_type)maxValue);
  }
  /// Writes a user-defined value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits written if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(!is_scalar<T>::value, Bits) WriteInRange(const T& value_, const R& minValue_, const R& maxValue_)
  {
    // Invoke user-defined function
    return Zero::SerializeInRange(SerializeDirection::Write, *this, const_cast<T&>(value_), minValue_, maxValue_);
  }

  /// Writes until a byte boundary is reached
  /// Returns the number of bits written
  Bits WriteUntilByteAligned();

  /// Appends to the back of the BitStream (Writes up to dataBits, Read from specified bitStream)
  /// Returns the number of bits appended
  Bits Append(const BitStream& bitStream, Bits dataBits);
  Bits Append(const BitStream& bitStream) { return Append(bitStream, bitStream.GetBitsUnread()); }

  /// Appends the entirety of the value BitStream to back of this BitStream
  /// Returns the number of bits appended
  Bits AppendAll(const BitStream& value)
  {
    value.ClearBitsRead();
    Bits result = Append(value);
    value.ClearBitsRead();
    return result;
  }

  /// Clears this BitStream and appends the unread remainder of the value BitStream
  /// Returns the number of bits appended
  Bits AssignRemainder(const BitStream& value)
  {
    Clear(false);
    return Append(value);
  }

  /// Trims the front of the BitStream (Writes up to dataBits bits to a copy, Read from this bitStream, and overwrites this bitStream with the copy)
  /// Returns the number of bits trimmed
  Bits TrimFront(Bits dataBits);
  Bits TrimFront() { return TrimFront(GetBitsUnread()); }

  /// Unwrites the specified number of bits
  void Unwrite(Bits bitsToUnwrite) { mBitsWritten = (mBitsWritten > bitsToUnwrite) ? (mBitsWritten - bitsToUnwrite) : 0; }

  /// Sets the number of bits written
  void SetBitsWritten(Bits bitsWritten)    { mBitsWritten = bitsWritten;                  }
  /// Sets the number of bytes written
  void SetBytesWritten(Bytes bytesWritten) { SetBitsWritten(BYTES_TO_BITS(bytesWritten)); }
  /// Clears the number of bits written
  void ClearBitsWritten()                  { mBitsWritten = 0;                            }

  //
  // Read Operations
  //

  /// Reads a single bit
  /// Returns the number of bits read if successful, else 0
  Bits ReadBit(bool& value) const;
  /// Reads multiple bits
  /// Returns the number of bits read if successful, else 0
  Bits ReadBits(byte* data, Bits dataBits) const;

  /// Reads a single byte
  /// Returns the number of bits read if successful, else 0
  Bits ReadByte(uint8& value) const;
  /// Reads multiple bytes
  /// Returns the number of bits read if successful, else 0
  Bits ReadBytes(byte* data, Bytes dataBytes) const;

  /// Reads a boolean value
  /// Returns the number of bits read if successful, else 0
  Bits Read(bool& value) const { return ReadBit(value); }
  /// Reads a string value
  /// Returns the number of bits read if successful, else 0
  Bits Read(String& value) const;

  /// Reads an enum value
  /// Returns the number of bits read if successful, else 0
  template<typename T>
  R_ENABLE_IF(is_enum<T>::value, Bits) Read(T& value) const
  {
    // Typedefs
    typedef EXACT_INT(BYTES_TO_BITS(sizeof(T))) intType;

    // Read enum as integer
    return Read((intType&)value);
  }
  /// Reads an integral value
  /// Returns the number of bits read if successful, else 0
  template<typename T>
  R_ENABLE_IF(is_integral<T>::value, Bits) Read(T& value) const
  {
    // Read the value
    Bits bitsRead = ReadBits((byte*)&value, BYTES_TO_BITS(sizeof(value)));
    if(!bitsRead) // Unable?
      return 0;

    // Flip from big endian
    value = NetworkFlip(value);

    // Result
    return bitsRead;
  }
  /// Reads a floating-point value
  /// Returns the number of bits read if successful, else 0
  template<typename T>
  R_ENABLE_IF(is_floating_point<T>::value, Bits) Read(T& value) const
  {
#if BITSTREAM_USE_PORTABLE_FLOATING_POINT

    const Bits totalBits = BYTES_TO_BITS(sizeof(T));       // Total bits (sign + exp + mant)
    Bits mantBits        = std::numeric_limits<T>::digits; // Mantissa bits
    Bits expBits         = totalBits - mantBits;           // Exponent bits
    --mantBits;                                            // Sign bit
    Assert(totalBits == (1 + expBits + mantBits));

    // Typedefs
    typedef EXACT_UINT(BYTES_TO_BITS(sizeof(T))) uintType;
    typedef EXACT_INT(BYTES_TO_BITS(sizeof(T)))  intType;

    // Read the result
    uintType result = 0;
    Bits bitsRead = ReadBits((byte*)&result, totalBits);
    if(!bitsRead) // Unable?
      return 0;

    // Flip from big endian
    result = NetworkFlip(result);

    // Convert from IEEE-754
    if(result == 0)
      value = T(0);
    else
    {
      T normValue = T(1); // Implicit 1.0

      // Read the mantissa
      normValue += T(result & ((uintType(1) << mantBits) - 1)) / T(uintType(1) << mantBits);

      // Read the exponent
      intType shift = ((result >> mantBits) & ((uintType(1) << expBits) - 1)) - ((uintType(1) << (expBits - 1)) - 1);
      while(shift > T(0))
      {
        normValue *= T(2);
        --shift;
      }
      while(shift < T(0))
      {
        normValue /= T(2);
        ++shift;
      }

      // Read the sign
      if((result >> (totalBits - 1)) & 1)
        normValue *= T(-1);

      value = normValue;
    }

    // Result
    return bitsRead;

#else

    // Read the value
    Bits bitsRead = ReadBits((byte*)&value, BYTES_TO_BITS(sizeof(value)));
    if(!bitsRead) // Unable?
      return 0;

    // Flip from big endian
    value = NetworkFlip(value);

    // Result
    return bitsRead;

#endif
  }
  /// Reads a fixed array of values
  /// Returns the number of bits written if successful, else 0
  template<typename T, size_t Size>
  Bits Read(T (& array)[Size])
  {
    Bits bitsRead = 0;

    // Read every element
    for(size_t i = 0; i < Size; ++i)
      bitsRead += Read(array[i]);

    return bitsRead;
  }
  /// Reads a fixed array of values
  /// Returns the number of bits written if successful, else 0
  template<typename T>
  Bits Read(T* array, size_t size)
  {
    Bits bitsRead = 0;

    // Read every element
    for(size_t i = 0; i < size; ++i)
      bitsRead += Read(array[i]);

    return bitsRead;
  }
  /// Reads a UintN value
  /// Returns the number of bits read if successful, else 0
  template <Bits N, bool WrapAware>
  Bits Read(UintN<N, WrapAware>& value) const
  {
    return ReadInRange(value.value(), value.min, value.max);
  }
  /// Reads a user-defined value
  /// Returns the number of bits read if successful, else 0
  template<typename T>
  R_ENABLE_IF(!is_scalar<T>::value, Bits) Read(T& value) const
  {
    // Invoke user-defined function
    return Zero::Serialize(SerializeDirection::Read, *const_cast<BitStream*>(this), value);
  }

  /// Reads an enum value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits read if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(is_enum<T>::value && is_enum_or_integral<R>::value, Bits) ReadInRange(T& value_, R minValue_, R maxValue_) const
  {
    // Typedefs
    typedef EXACT_INT(BYTES_TO_BITS(sizeof(T))) intType;

    // Read enum as integer
    return ReadInRange((intType&)value_, (intType)minValue_, (intType)maxValue_);
  }
  /// Reads an integral value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits read if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(is_integral<T>::value && is_integral<R>::value, Bits) ReadInRange(T& value_, R minValue_, R maxValue_) const
  {
    typedef typename conditional<is_signed<R>::value, R, T>::type V;
    typedef typename make_unsigned<V>::type                       UV;
    V value;
    V minValue = V(minValue_);
    V maxValue = V(maxValue_);
    Assert(minValue <= maxValue);

    // Determine bits needed to represent the entire range of possible values
    V range = maxValue - minValue;
    Bits bitSize = BitsNeededToRepresent(range);

    // Read the normalized value
    V normValue = 0;
    Bits bitsRead = ReadBits((byte*)&normValue, bitSize);
    if(!bitsRead) // Unable?
     return 0;

    // Flip from big endian
    normValue = NetworkFlip(normValue);

    // Convert from left-justified to right-justified
    normValue = (UV)normValue >> (BYTES_TO_BITS(sizeof(normValue)) - bitSize);

    // Denormalize value
    Assert(0 <= normValue && normValue <= range);
    value = normValue + minValue;
    Assert(minValue <= value && value <= maxValue);

    // Result
    value_ = T(value);
    return bitsRead;
  }
  /// Reads a floating-point value from an inclusive range, using only floatPrecisionBits
  /// Returns the number of bits read if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(is_floating_point<T>::value, Bits) ReadInRange(T& value, R minValue_, R maxValue_, Bits floatPrecisionBits = (BYTES_TO_BITS(sizeof(T)) / 2)) const
  {
    T minValue = T(minValue_);
    T maxValue = T(maxValue_);
    floatPrecisionBits = Clamp(floatPrecisionBits, Bits(1), Bits(BYTES_TO_BITS(sizeof(T))));
    Assert(minValue < maxValue);

    // Typedefs
    typedef EXACT_UINT(BYTES_TO_BITS(sizeof(T))) uintType;

    // Calculate upper bound (max representable number)
    uintType upperBound = (uintType(1) << floatPrecisionBits) - 1;

    // Read quantized value
    uintType quantizedValue;
    Bits bitsRead = ReadInRange(quantizedValue, uintType(0), upperBound);
    if(!bitsRead) // Unable?
      return 0;

    // Determine range
    T range = maxValue - minValue;

    // Dequantize value
    T ratio = Clamp(T(quantizedValue) / T(upperBound), T(0), T(1)); // Where the quantized value lies in the range
    T normValue = ratio * range;                                    // Create a float with the same ratio

    // Denormalize value
    value = normValue + minValue;
    Assert(minValue <= value && value <= maxValue);

    // Result
    return bitsRead;
  }
  /// Reads a UintN value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits read if successful, else 0
  template <Bits N, bool WrapAware, typename R>
  R_ENABLE_IF(is_enum_or_integral<R>::value, Bits) ReadInRange(UintN<N, WrapAware>& value, R minValue, R maxValue) const
  {
    typedef typename UintN<N, WrapAware>::value_type value_type;

    return ReadInRange(value.value(), (value_type)minValue, (value_type)maxValue);
  }
  /// Reads a user-defined value from an inclusive range, using only the bits necessary to represent the entire range
  /// Returns the number of bits read if successful, else 0
  template<typename T, typename R>
  R_ENABLE_IF(!is_scalar<T>::value, Bits) ReadInRange(T& value_, const R& minValue_, const R& maxValue_) const
  {
    // Invoke user-defined function
    return Zero::SerializeInRange(SerializeDirection::Read, *const_cast<BitStream*>(this), value_, minValue_, maxValue_);
  }

  /// Returns the byte length of the string to be read next (including null terminator), else 0
  Bytes PeekStringBytes() const;

  /// Reads until a byte boundary is reached
  /// Returns the number of bits read
  Bits ReadUntilByteAligned() const;

  /// Unreads the specified number of bits
  void Unread(Bits bitsToUnread) const { mBitsRead = (mBitsRead > bitsToUnread) ? (mBitsRead - bitsToUnread) : 0; }

  /// Sets the number of bits read
  void SetBitsRead(Bits bitsRead) const    { mBitsRead = bitsRead;                  }
  /// Sets the number of bytes read
  void SetBytesRead(Bytes bytesRead) const { SetBitsRead(BYTES_TO_BITS(bytesRead)); }
  /// Clears the number of bits read
  void ClearBitsRead() const               { mBitsRead = 0;                         }

protected:
  //
  // Helper Functions
  //

  /// Initializes the BitStream
  void Initialize();
  /// Reallocates if necessary to fit the additional bits
  void ReallocateIfNecessary(Bits additionalBits);
  /// Reallocates to the specified capacity, copying data if copyData is enabled
  void Reallocate(Bytes capacity, bool copyData);

  /// Binary data array
  byte*                      mData;
  /// Binary data capacity
  Bytes                      mByteCapacity;
  /// Also next write position
  Bits                       mBitsWritten;
  /// Also next read position
  mutable Bits               mBitsRead;
  /// Internal bit alignment policy
  mutable BitAlignment::Enum mAlignment;
};

/// Returns the BitStream as a binary string
/// Note: Resets the read cursor
String GetBinaryString(const BitStream& bitStream, Bytes bytesPerLine = 8);

} // namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file File.hpp
/// Declaration of the helper macros.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


#define PlatformByteAlignmentSize sizeof(void*)

// Make sure the private data is of a type that is aligned for proper native alignment
// (most likely pointer reading alignment). Still take the size in bytes and round up to the nearest whole value.
#define ZeroDeclarePrivateDataBytes(SizeInBytes)                                                 \
  void* mPrivateData[(SizeInBytes + PlatformByteAlignmentSize - 1) / PlatformByteAlignmentSize];

#define ZeroDeclarePrivateData(Type, SizeInBytes) \
  ZeroDeclarePrivateDataBytes(SizeInBytes);       \
  Type(const Type& right);                        \
  Type& operator = (const Type& right);

#define ZeroGetPrivateData(Type) \
  Type* self = (Type*)mPrivateData;

#define ZeroAssertPrivateDataSize(Type)                                           \
  StaticAssert(IncreaseSizeOfPrivateData_PrivateTypeTooBig,                       \
    sizeof(Type) <= sizeof(mPrivateData),                                         \
    "Increase the size of the private data because the private type is too big");

// For completely pod private data, it's easier just to clear it out (no destructor)
#define ZeroMemClearPrivateData(Type)             \
  memset(mPrivateData, 0, sizeof(mPrivateData));  \
  ZeroAssertPrivateDataSize(Type);                \
  ZeroGetPrivateData(Type);

#define ZeroConstructPrivateData(Type, ...) \
  Type* self = new (mPrivateData) Type();   \
  ZeroAssertPrivateDataSize(Type);

#define ZeroDestructPrivateData(Type, ...)  \
    ((Type*)mPrivateData)->~Type();

///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean, Trevor Sundberg
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes



namespace Zero
{

/// Socket address type designated by protocol
namespace SocketAddressFamily
{
  enum Enum
  {
    Unspecified      = 0,   /// Unspecified SocketAddressFamily
    Unix             = 1,   /// UNIX Interprocess Communication Protocols (Pipes)
    InternetworkV4   = 2,   /// Internetwork Version 4 (IPv4) Protocols
    ImpLink          = 3,   /// ARPANET IMP Addresses
    Pup              = 4,   /// PUP Protocols
    Chaos            = 5,   /// MIT CHAOS Protocols
    Ns               = 6,   /// IPX (XEROX NS) Protocols
    Ipx              = Ns,  /// IPX (XEROX NS) Protocols
    Iso              = 7,   /// OSI (ISO) Protocols
    Osi              = Iso, /// OSI (ISO) Protocols
    Ecma             = 8,   /// European Computer Manufacturers
    DataKit          = 9,   /// DataKit Protocols
    Ccitt            = 10,  /// CCITT Protocols
    Sna              = 11,  /// IBM SNA Protocol
    DecNet           = 12,  /// DECnet Protocol
    DataLink         = 13,  /// DataLink Interface
    Lat              = 14,  /// LAT Protocol
    Hyperchannel     = 15,  /// NSC Hyperchannel
    AppleTalk        = 16,  /// AppleTalk Protocols
    NetBios          = 17,  /// NetBios Addresses
    VoiceView        = 18,  /// VoiceView Protocols
    Firefox          = 19,  /// Firefox Protocols
    Unknown1         = 20,  /// Unknown Protocol
    Banyan           = 21,  /// Banyan Protocols
    Atm              = 22,  /// Native ATM Services
    InternetworkV6   = 23,  /// Internetwork Version 6 (IPv6) Protocols
    Cluster          = 24,  /// Microsoft Wolfpack Protocol
    Ieee12844        = 25,  /// IEEE 1284.4 WG Protocol
    Irda             = 26,  /// IrDA Protocols
    NetworkDesigners = 28   /// Network Designers OSI and Gateway Protocols
  };
  typedef uint Type;
}

/// Socket address resolution behavior flags
namespace SocketAddressFlags
{
  enum Enum
  {
    None                      = 0,          /// No SocketAddressFlags
    AnyAddress                = 0x00000001, /// Given an empty host, the host will resolve to the 'any' address, which can be used by the OS to automatically determine a socket's address at bind time
    RequestCannonName         = 0x00000002, /// Request the canonical name in the first ai_canonname member
    NumericHost               = 0x00000004, /// Host name is numeric string
    NumericService            = 0x00000008, /// Service name is a numeric string
    RequestIpv6and4           = 0x00000100, /// Request both IPv6 and IPv4 addresses with RequestIpv4Mapped
    ResolveIfGlobalAddress    = 0x00000400, /// Resolves only if a global address is configured
    RequestIpv4Mapped         = 0x00000800, /// On IPv6 request failure, request an IPv4-mapped IPv6 address
    ResolveNonAuthoritative   = 0x00004000, /// Allow address resolution from a non-authoritative namespace provider
    ResolveSecure             = 0x00008000, /// Enable address resolution from a secure channel
    RequestPreferredNames     = 0x00010000, /// Request address resolution for a preferred user name
    RequestQualifiedName      = 0x00020000, /// Request the fully qualified domain name in the first ai_canonname member, must not be set with RequestCannonName
    FileServerHint            = 0x00040000, /// Hint that the host being queried is a file server
    DisableInternationalNames = 0x00080000  /// Disable internationalized domain name handling
  };
  typedef uint Type;
}

/// Socket protocol
namespace SocketProtocol
{
  enum Enum
  {
    Ip                                = 0,   /// Internet Protocol
    Ipv6HopOptions                    = Ip,  /// Internet Protocol Version 6 (IPv6) Hop-By-Hop Options
    Unspecified                       = Ip,  /// Unspecified Protocol
    Icmp                              = 1,   /// Internet Control Message Protocol
    Igmp                              = 2,   /// Internet Group Management Protocol
    Ggp                               = 3,   /// Gateway-to-Gateway Protocol
    Ipv4                              = 4,   /// Internet Protocol Version 4 (IPv4)
    Stream                            = 5,   /// Stream Protocol
    Tcp                               = 6,   /// Transmission Control Protocol
    Cbt                               = 7,   /// Core Based Trees Protocol
    Egp                               = 8,   /// Exterior Gateway Protocol
    Igp                               = 9,   /// Private Interior Gateway Protocol
    Pup                               = 12,  /// PARC Universal Packet Protocol
    Udp                               = 17,  /// User Datagram Protocol
    Idp                               = 22,  /// Internet Datagram Protocol
    Rdp                               = 27,  /// Reliable Data Protocol
    Ipv6                              = 41,  /// Internet Protocol Version 6 (IPv6)
    Ipv6RoutingHeader                 = 43,  /// Internet Protocol Version 6 (IPv6) Routing Header
    Ipv6FragmentHeader                = 44,  /// Internet Protocol Version 6 (IPv6) Fragment Header
    IpSecEncapsulatingSecurityPayload = 50,  /// Internet Protocol Security Encapsulating Security Payload
    IpSecAuthenticationHeader         = 51,  /// Internet Protocol Security Authentication Header
    IcmpV6                            = 58,  /// Internet Control Message Protocol Version 6 (ICMPv6)
    Ipv6NoNextHeader                  = 59,  /// Internet Protocol Version 6 (IPv6) No Next Header
    Ipv6DestinationOptions            = 60,  /// Internet Protocol Version 6 (IPv6) Destination Options
    Nd                                = 77,  /// Net Disk Protocol
    Iclfxbm                           = 78,  /// Wideband monitoring
    Pim                               = 103, /// Protocol Independent Multicast
    Pgm                               = 113, /// Pragmatic General Multicast
    L2tp                              = 115, /// Level 2 Tunneling Protocol
    Sctp                              = 132, /// Stream Control Transmission Protocol
    Raw                               = 255  /// Raw Internet Protocol
  };
  typedef uint Type;
}

/// Socket protocol type
DeclareEnum6(SocketType,
  Unspecified,      /// Unspecified SocketType
  Stream,           /// Reliable Connection-Based Streams (such as TCP)
  Datagram,         /// Unreliable Connectionless Datagrams (such as UDP)
  RawDatagram,      /// Raw Unreliable Connectionless Datagrams
  ReliableDatagram, /// Reliable Connectionless Datagrams
  StreamPacket);    /// Reliable Connection-Based Stream Packets

/// Socket operation set
DeclareEnum3(SocketIo,
  Read,  /// Read (Receive) Operation
  Write, /// Write (Send) Operation
  Both); /// Read and Write Operations

/// Socket capability set
DeclareEnum3(SocketSelect,
  Read,   /// Check Socket Readability
  Write,  /// Check Socket Writability
  Error); /// Check Socket Errors

/// Socket operation behavior flags
namespace SocketFlags
{
  enum Enum
  {
    None                 = 0,         /// No SocketFlags
    OutOfBand            = (1 << 0),  /// Send/Receive Out-Of-Band Data
    Peek                 = (1 << 1),  /// Peek Incoming Data
    DontRoute            = (1 << 2),  /// Send Without Routing
    WaitAll              = (1 << 3),  /// Wait Until Packet Is Completely Full
    Interrupt            = (1 << 4),  /// Send/Receive Inside Interrupt Context
    Truncated            = (1 << 8),  /// Packet Data Was/May Be Truncated
    ControlDataTruncated = (1 << 9),  /// Control Data Was/May Be Truncated
    Broadcast            = (1 << 10), /// Broadcast Data
    Multicast            = (1 << 11), /// Multicast Data
    Partial              = (1 << 15)  /// Partially Send/Receive Data
  };
  typedef uint Type;
}

/// Socket behavior option
/// Applies to all sockets unless otherwise specified
namespace SocketOption
{
  enum Enum
  {
    DebugOutput         = 0x0001,        /// Enable debug output? (Get/Set : bool)
    IsListening         = 0x0002,        /// Socket is in listening mode? Valid for connection-based protocols (Get : bool)
    ReuseAddress        = 0x0004,        /// Allow binding to an address and port already in use? (Get/Set : bool)
    KeepAlive           = 0x0008,        /// Socket connections should use keep-alive? Valid for connection-based protocols (Get/Set : bool)
    DontRoute           = 0x0010,        /// Send without routing? Valid for message-oriented protocols (Get/Set : bool)
    CanBroadcast        = 0x0020,        /// Socket is configured to broadcast? Valid for protocols that support broadcast (Get/Set : bool)
    SendLoopback        = 0x0040,        /// Send data using the loopback adapter? (Get/Set : bool)
    Linger              = 0x0080,        /// Socket should remain open for a set duration after being closed? Valid for connection-based protocols (Get/Set : linger)
    OutOfBandInline     = 0x0100,        /// Return Out-Of-Band data inline with regular data? (Get/Set : bool)
    DontLinger          = ~Linger,       /// Socket should remain open for a set duration after being closed? Valid for connection-based protocols (Get/Set : bool)
    ExclusiveAddress    = ~ReuseAddress, /// Socket has exclusive use of the address and port it's bound to? Must be set before calling bind (Get/Set : bool)
    SendBufferSize      = 0x1001,        /// Socket buffer size reserved for sending data (Get/Set : uint)
    ReceiveBufferSize   = 0x1002,        /// Socket buffer size reserved for receiving data (Get/Set : uint)
    SendLowWatermark    = 0x1003,        /// Minimum number of bytes to process for send operations (Get/Set : uint)
    ReceiveLowWatermark = 0x1004,        /// Minimum number of bytes to process for receive operations (Get/Set : uint)
    SendTimeout         = 0x1005,        /// Blocking send call timeout in milliseconds, zero indicates no timeout (Get/Set : uint)
    ReceiveTimeout      = 0x1006,        /// Blocking receive call timeout in milliseconds, zero indicates no timeout (Get/Set : uint)
    ErrorCode           = 0x1007,        /// The last error code set on the socket (Get : uint)
    SocketType          = 0x1008,        /// Socket type (Get : uint)
    SocketState         = 0x1009,        /// Current socket state (Get : CSADDR_INFO)
    MaxMessageSize      = 0x2003,        /// Max outgoing message size in bytes. Valid for message-oriented protocols (Get : uint)
    ProviderConfig      = 0x3001,        /// Socket service provider configuration (Get/Set : char*)
    ConditionalAccept   = 0x3002,        /// Accept/reject incoming connections by the application? Valid for connection-based protocols (Get/Set : bool)
    PauseAccept         = 0x3003,        /// Pause accepting connections. Valid for connection-based protocols (Get/Set : bool)
    CompartmentId       = 0x3004,        /// Socket compartment (Get/Set : uint)
    RandomizePort       = 0x3005,        /// Randomize wildcard port assignment (Get/Set : bool)
    PortScalability     = 0x3006         /// Maximize local port scalability by allocating wildcard ports multiple times for different local address port pairs? (Get/Set : bool)
  };
  typedef uint Type;
}

/// IPv4 Socket behavior option
/// Applies to all IPv4 sockets unless otherwise specified
namespace SocketIpv4Option
{
  enum Enum
  {
    Options                                 = 1,  /// All IPv4 options (Get/Set : char*)
    IncludeHeader                           = 2,  /// Application provides the IP header? Valid only for raw sockets (Get/Set : bool)
    TimeToLive                              = 4,  /// Time To Live (TTL, aka hop limit) of packets (Get/Set : bool)
    MulticastInterface                      = 9,  /// Multicast traffic interface (Get/Set : uint)
    MulticastTimeToLive                     = 10, /// Time To Live (TTL, aka hop limit) of multicast packets (Get/Set : uint)
    MulticastLoopback                       = 11, /// Allow local, outgoing multicast data to be received using the loopback adapter? (Get/Set : bool)
    AddMulticastGroupMembership             = 12, /// Add membership to the specified multicast group (Set : ip_mreq)
    RemoveMulticastGroupMembership          = 13, /// Remove membership from the specified multicast group (Set : ip_mreq)
    DontFragment                            = 14, /// Don't fragment messages. Valid for message-oriented protocols (Get/Set : bool)
    AddMulticastGroupAndSourceMembership    = 15, /// Add membership to the specified multicast group and accept data from the supplied multicast source address (Set : ip_mreq_source)
    RemoveMulticastGroupAndSourceMembership = 16, /// Remove membership from the specified multicast group and ignore data from the supplied multicast source address (Set : ip_mreq_source)
    RemoveMulticastSourceMembership         = 17, /// Ignore data from the supplied multicast source address (Set : ip_mreq_source)
    AddMulticastSourceMembership            = 18, /// Accept data from the supplied multicast source address (Set : ip_mreq_source)
    ReturnPacketInfo                        = 19, /// Return the packet information when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ReturnTimeToLive                        = 21, /// Return the Time To Live (TTL, aka hop limit) when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ReceiveBroadcast                        = 22, /// Allow broadcast reception? (Get/Set : bool)
    ReturnArrivalInterface                  = 24, /// Return the arrival interface when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ReturnDestinationAddress                = 25, /// Return the destination address when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    EnableInterfaceList                     = 28, /// Enable an interface list
    AddInterfaceListEntry                   = 29, /// Add an interface list entry
    RemoveInterfaceListEntry                = 30, /// Remove an interface list entry
    UnicastInterface                        = 31, /// Unicast traffic interface (Get/Set : uint)
    Ipv6RoutingHeader                       = 32, /// IPv6 routing header
    ReturnRoutingHeader                     = 38, /// Return the routing header when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    TrafficClass                            = 39, /// Packet traffic class
    ReturnTrafficClass                      = 40, /// Return the packet traffic class when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ReturnOriginalArrivalInterface          = 47  /// Return the original arrival interface when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
  };
  typedef uint Type;
}

/// IPv6 Socket behavior option
/// Applies to all IPv6 sockets unless otherwise specified
namespace SocketIpv6Option
{
  enum Enum
  {
    HopOptions                     = 1,  /// All IPv6 hop-by-hop options (Get/Set : char*)
    IncludeHeader                  = 2,  /// Application provides the IP header? Valid only for datagram and raw sockets (Get/Set : bool)
    UnicastTimeToLive              = 4,  /// Time To Live (TTL, aka hop limit) of unicast packets (Get/Set : uint)
    MulticastInterface             = 9,  /// Multicast traffic interface (Get/Set : uint)
    MulticastTimeToLive            = 10, /// Time To Live (TTL, aka hop limit) of multicast packets (Get/Set : uint)
    MulticastLoopback              = 11, /// Allow local, outgoing multicast data to be received using the loopback adapter? (Get/Set : bool)
    AddMulticastGroupMembership    = 12, /// Add membership to the specified multicast group (Set : ipv6_mreq)
    RemoveMulticastGroupMembership = 13, /// Remove membership from the specified multicast group (Set : ipv6_mreq)
    DontFragment                   = 14, /// Don't fragment messages. Valid for message-oriented protocols (Get/Set : bool)
    ReturnPacketInfo               = 19, /// Return the packet information when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ReturnTimeToLive               = 21, /// Return the Time To Live (TTL, aka hop limit) when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ProtectionLevel                = 23, /// Restrict the scope of a listening socket (Get/Set : int)
    ReturnArrivalInterface         = 24, /// Return the arrival interface when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ReturnDestinationAddress       = 25, /// Return the destination address when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ChecksumOffset                 = 26, /// Offset to checksum for outgoing packets. Valid only for raw sockets
    Ipv6Only                       = 27, /// Restrict communication to IPv6 only? (Sockets bound to IPv6 addresses have the capability to communicate with IPv4 mapped addresses) (Get/Set : bool)
    EnableInterfaceList            = 28, /// Enable an interface list
    AddInterfaceListEntry          = 29, /// Add an interface list entry
    RemoveInterfaceListEntry       = 30, /// Remove an interface list entry
    UnicastInterface               = 31, /// Unicast traffic interface (Get/Set : uint)
    Ipv6RoutingHeader              = 32, /// IPv6 routing header
    ReturnRoutingHeader            = 38, /// Return the routing header when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    TrafficClass                   = 39, /// Packet traffic class
    ReturnTrafficClass             = 40, /// Return the packet traffic class when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
    ReturnOriginalArrivalInterface = 47  /// Return the original arrival interface when a packet is received, in the WSAMSG structure returned by WSARecvMsg? Valid only for datagram or raw sockets (Get/Set : bool)
  };
  typedef uint Type;
}

/// TCP Socket behavior option
/// Applies to all TCP sockets unless otherwise specified
namespace SocketTcpOption
{
  enum Enum
  {
    NoDelay                       = 1, /// Disable Nagle's algorithm (send packets without waiting for data to coalesce)? (Get/Set : bool)
    ExpeditedImplemented          = 2, /// Service provider implemented expedited data as specified in RFC 1122? (Get/Set : bool)
    IdleDurationBeforeKeepAlive   = 3, /// Idle duration, in seconds, before keep alive begins (Get/Set : uint)
    MaxSegmentSize                = 4, /// Max outgoing segment size in bytes (Get/Set : uint)
    RetransmitDurationBeforeClose = 5, /// Retransmit duration, in seconds, before the connection is closed (Get/Set : uint)
    UrgentImplemented             = 6  /// Service provider implemented urgent data as specified in RFC 1122? (Get/Set : bool)
  };
  typedef uint Type;
}

/// UDP Socket behavior option
/// Applies to all UDP sockets unless otherwise specified
namespace SocketUdpOption
{
  enum Enum
  {
    NoChecksum       = 1, /// Send datagrams with a zero checksum? (Get/Set : bool)
    ChecksumCoverage = 20 /// Send datagrams with a checksum? (Get/Set : bool)
  };
  typedef uint Type;
}

/// Internet protocol version
DeclareEnum4(InternetProtocol,
  Unspecified, /// Unspecified internet protocol version
  V4,          /// Internetwork protocol version 4
  V6,          /// Internetwork protocol version 6
  Both);       /// Internetwork protocol version 4 and 6

/// Internet protocol version range
static const InternetProtocol::Type InternetProtocolMin = InternetProtocol::Unspecified;
static const InternetProtocol::Type InternetProtocolMax = InternetProtocol::Both;

} // namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean, Trevor Sundberg
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes


namespace Zero
{

/// Maximum IPv4 numeric address host string length (including null terminator)
static const size_t Ipv4StringLength = 16;

/// Maximum IPv6 numeric address host string length (including null terminator)
static const size_t Ipv6StringLength = 46;

/// Any available port
static const ushort AnyPort = 0;

/// IPv4 minimum packet header size
static const size_t Ipv4MinHeaderBytes = 20;
/// IPv4 maximum packet header size
static const size_t Ipv4MaxHeaderBytes = 60;
/// UDP datagram header size
static const size_t UdpHeaderBytes     = 8;

/// UDP maximum datagram length after header size
static const size_t DatagramMtuBytes = 65536 - UdpHeaderBytes;
/// Ethernet v2 MTU
static const size_t EthernetMtuBytes = 1500;
/// IPv4 minimum reassembly buffer size
static const size_t Ipv4MinMtuBytes  = 576;

// TODO: Add IPv6 constants

} // namespace Zero


namespace Zero
{

//---------------------------------------------------------------------------------//
//                                SocketAddress                                    //
//---------------------------------------------------------------------------------//

/// Network host identifier
class SocketAddress
{
public:
  /// Creates an empty socket address
  SocketAddress();

  /// Copy Constructor
  SocketAddress(const SocketAddress& rhs);

  /// Copy Assignment Operator
  SocketAddress& operator =(const SocketAddress& rhs);

  /// Comparison Operators
  bool operator ==(const SocketAddress& rhs) const;
  bool operator !=(const SocketAddress& rhs) const;
  bool operator  <(const SocketAddress& rhs) const;

  /// Returns true if the socket address is not empty, else false
  operator bool(void) const;

  /// Returns true if the socket address is empty, else false
  bool IsEmpty() const;

  /// Returns the socket address family
  SocketAddressFamily::Enum GetAddressFamily() const;

  /// Sets the socket address to identify the specified IPv4 host and port
  /// Will block until host name resolution completes or times out
  void SetIpv4(Status& status, StringParam host, uint port);
  void SetIpv4(Status& status, StringParam host, uint port, SocketAddressFlags::Enum addressFlags);

  /// Sets the socket address to identify the specified IPv6 host and port
  /// Will block until host name resolution completes or times out
  void SetIpv6(Status& status, StringParam host, uint port);
  void SetIpv6(Status& status, StringParam host, uint port, SocketAddressFlags::Enum addressFlags);

  /// Sets the socket address to identify the specified host and service
  /// Will block until host name resolution completes or times out
  void Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily);
  void Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily,
           SocketAddressFlags::Enum addressFlags);

  /// Sets the socket address to identify the specified host and service
  /// Will block until host name resolution completes or times out
  void Set(Status& status, StringParam host, StringParam service, SocketAddressFamily::Enum addressFamily,
           SocketProtocol::Enum protocol, SocketType::Enum type, SocketAddressFlags::Enum addressFlags);

  /// Sets the IPv4/6 socket address port
  void SetIpPort(Status& status, uint port);
  /// Returns the IPv4/6 socket address port, else 0
  uint GetIpPort(Status& status) const;

  /// Clears the socket address
  void Clear();

  /// Address data
  ZeroDeclarePrivateDataBytes(128);
};

/// Serializes a socket address (currently only defined for InternetworkV4 and InternetworkV6 socket addresses)
/// Returns the number of bits serialized if successful, else 0
Bits Serialize(SerializeDirection::Enum direction, BitStream& bitStream, SocketAddress& socketAddress);

/// Returns true if the socket address represents a valid IPv4 host, else false
/// This does not imply that the host exists, only that the socket address is well formed
bool IsValidIpv4Address(const SocketAddress& address);
/// Returns true if the socket address represents a valid IPv6 host, else false
/// This does not imply that the host exists, only that the socket address is well formed
bool IsValidIpv6Address(const SocketAddress& address);

/// Returns true if the numeric address string represents a valid IPv4 host, else false
/// This does not imply that the host exists, only that the numeric address string is well formed
bool IsValidIpv4Address(StringParam address);
/// Returns true if the numeric address string represents a valid IPv6 host, else false
/// This does not imply that the host exists, only that the numeric address string is well formed
bool IsValidIpv6Address(StringParam address);

/// Converts a valid IPv4 socket address to a numeric address string, else String()
String Ipv4AddressToString(const SocketAddress& address);
/// Converts a valid IPv6 socket address to a numeric address string, else String()
String Ipv6AddressToString(const SocketAddress& address);

/// Returns a port as a numeric string, else String()
String PortToString(uint port);

/// Converts a valid IPv4 socket address to a numeric address string with appended port number, else String()
String Ipv4AddressToStringWithPort(const SocketAddress& address);
/// Converts a valid IPv6 socket address to a numeric address string with appended port number, else String()
String Ipv6AddressToStringWithPort(const SocketAddress& address);

/// Converts a valid IPv4 numeric address string to a socket address, else SocketAddress()
SocketAddress StringToIpv4Address(StringParam address);
SocketAddress StringToIpv4Address(StringParam address, ushort port);

/// Converts a valid IPv6 numeric address string to a socket address, else SocketAddress()
SocketAddress StringToIpv6Address(StringParam address);
SocketAddress StringToIpv6Address(StringParam address, ushort port);

//---------------------------------------------------------------------------------//
//                                    Socket                                       //
//---------------------------------------------------------------------------------//

/// Network host endpoint
/// Facilitates interprocess communication
class Socket
{
public:
  /// Creates a closed socket
  Socket();

  /// Destroys the socket (closes the socket if still open)
  ~Socket();

  /// Move Constructor
  Socket(MoveReference<Socket> rhs);

  /// Move Assignment Operator
  Socket& operator =(MoveReference<Socket> rhs);

  /// Returns the maximum number of connections the os can backlog while listening
  static uint GetMaxListenBacklog();

  /// Returns true if the error code is a common receive error, else false
  /// These errors are considered continuable and should not be reported via asserts
  static bool IsCommonReceiveError(uint extendedErrorCode);

  /// Returns true if the error code is a common accept error, else false
  /// These errors are considered continuable and should not be reported via asserts
  static bool IsCommonAcceptError(uint extendedErrorCode);

  /// Returns true if the socket is opened, else false
  /// This does not imply that the socket is connected or bound, only that we have a valid socket handle
  bool IsOpen() const;

  /// Returns the socket address family if open, else SocketAddressFamily::Unspecified
  SocketAddressFamily::Enum GetAddressFamily() const;

  /// Returns the socket type if open, else SocketType::Unspecified
  SocketType::Enum GetType() const;

  /// Returns the socket protocol if open, else SocketProtocol::Unspecified
  SocketProtocol::Enum GetProtocol() const;

  /// Returns true if the socket is bound to a local address, else false
  bool IsBound() const;

  /// Returns the local address this socket is bound to, else SocketAddress()
  SocketAddress GetBoundLocalAddress() const;

  /// Returns true if the socket is set in listening mode, else false
  bool IsListening() const;

  /// Returns true if the socket is set in blocking mode, else false
  bool IsBlocking() const;

  /// Returns true if the socket is actually connected to a remote address, else false
  bool IsConnected() const;

  /// Returns the remote address specified in the last connect call, else SocketAddress()
  /// This does not imply that the socket is actually connected to this address, only that a connect call with this address was previously made
  SocketAddress GetConnectedRemoteAddress() const;

  /// Opens the closed socket as a host for the specified protocol (closes the socket if already open)
  void Open(Status& status, SocketAddressFamily::Enum addressFamily, SocketType::Enum type, SocketProtocol::Enum protocol);

  /// Associates the open socket with the specified local address
  /// For IP addresses, if the host or port are left empty the OS will automatically determine their values
  void Bind(Status& status, const SocketAddress& localAddress);

  /// Sets the bound socket to listening mode, ready to accept incoming connections
  /// Valid only for connection-based sockets
  void Listen(Status& status, uint backlog);

  /// Sets the open socket's blocking mode
  /// If enabled the socket will block on non-immediate operation calls (such as send and receive)
  void SetBlocking(Status& status, bool blocking);

  /// Accepts an incoming connection on the listening socket
  /// Outputs a bound socket connected to the remote host
  /// Valid only for connection-based sockets
  void Accept(Status& status, Socket* connectionOut);

  /// Attempts to connect to the specified remote address on the non-listening socket
  /// Will block until the connect attempt completes (unless the socket is set to non-blocking)
  /// For connectionless sockets this only scopes send and receive operations to this address
  void Connect(Status& status, const SocketAddress& remoteAddress);

  /// Shuts down the specified connected socket operations
  /// Safe to call from other threads (blocking calls will simply terminate with an error)
  /// The socket is still considered open after this call, to free socket resources use close
  void Shutdown(Status& status, SocketIo::Enum io);

  /// Closes the open socket and frees associated resources
  /// Safe to call from other threads (blocking calls will simply terminate with an error)
  /// The socket is considered closed after this call
  void Close(Status& status);

  /// Sends data on the connected socket to the connected remote address
  /// Will block if the send buffer is full (unless the socket is set to non-blocking)
  /// Returns the number of bytes sent (0 if an error occurs, status will contain the error)
  size_t Send(Status& status, const byte* data, size_t dataLength, SocketFlags::Enum flags = SocketFlags::None);

  /// Sends data on the open socket to the specified remote address
  /// Will block if the send buffer is full (unless the socket is set to non-blocking)
  /// Returns the number of bytes sent (0 if an error occurs, status will contain the error)
  size_t SendTo(Status& status, const byte* data, size_t dataLength, const SocketAddress& to, SocketFlags::Enum flags = SocketFlags::None);

  /// Receives data on the connected socket from the connected remote address
  /// Will block if the receive buffer is empty (unless the socket is set to non-blocking)
  /// Returns the number of bytes received (0 if an error occurs, status will contain the error)
  size_t Receive(Status& status, byte* dataOut, size_t dataLength, SocketFlags::Enum flags = SocketFlags::None);

  /// Receives data on the open socket from any remote address
  /// Will block if the receive buffer is empty (unless the socket is set to non-blocking)
  /// Returns the number of bytes received (0 if an error occurs, status will contain the error)
  size_t ReceiveFrom(Status& status, byte* dataOut, size_t dataLength, SocketAddress& from, SocketFlags::Enum flags = SocketFlags::None);

  /// Returns true if the specified socket capability is ready for use, else false
  /// In a high efficiency situation, mechanisms other than select should be used
  bool Select(Status& status, SocketSelect::Enum selectMode, float timeoutSeconds) const;

  /// Gets the current value of the specified socket option
  template <typename Option, typename T>
  void GetSocketOption(Status& status, Option option, T& value) const
  {
    size_t valueLength = sizeof(value);
    GetSocketOption(status, option, &value, &valueLength);
  }
  template <typename Option>
  void GetSocketOption(Status& status, Option option, bool& value) const
  {
    size_t temp       = size_t(value);
    size_t tempLength = sizeof(temp);
    GetSocketOption(status, option, &temp, &tempLength);
    value = bool(temp);
  }
  void GetSocketOption(Status& status, SocketOption::Enum option, void* value, size_t* valueLength) const;
  void GetSocketOption(Status& status, SocketIpv4Option::Enum option, void* value, size_t* valueLength) const;
  void GetSocketOption(Status& status, SocketIpv6Option::Enum option, void* value, size_t* valueLength) const;
  void GetSocketOption(Status& status, SocketTcpOption::Enum option, void* value, size_t* valueLength) const;
  void GetSocketOption(Status& status, SocketUdpOption::Enum option, void* value, size_t* valueLength) const;

  /// Sets the current value of the specified socket option
  template <typename Option, typename T>
  void SetSocketOption(Status& status, Option option, T& value)
  {
    size_t valueLength = sizeof(value);
    SetSocketOption(status, option, &value, valueLength);
  }
  template <typename Option>
  void SetSocketOption(Status& status, Option option, bool& value)
  {
    size_t temp       = size_t(value);
    size_t tempLength = sizeof(temp);
    SetSocketOption(status, option, &temp, tempLength);
    value = bool(temp);
  }
  void SetSocketOption(Status& status, SocketOption::Enum option, const void* value, size_t valueLength);
  void SetSocketOption(Status& status, SocketIpv4Option::Enum option, const void* value, size_t valueLength);
  void SetSocketOption(Status& status, SocketIpv6Option::Enum option, const void* value, size_t valueLength);
  void SetSocketOption(Status& status, SocketTcpOption::Enum option, const void* value, size_t valueLength);
  void SetSocketOption(Status& status, SocketUdpOption::Enum option, const void* value, size_t valueLength);

  /// Native socket handle
  OsHandle                  mHandle;
  /// Socket address family
  SocketAddressFamily::Enum mAddressFamily;
  /// Socket protocol type
  SocketType::Enum          mType;
  /// Socket protocol
  SocketProtocol::Enum      mProtocol;
  /// Is this socket set in listening mode?
  bool                      mIsListening;
  /// Is this socket set in blocking mode?
  bool                      mIsBlocking;
  /// Local address this socket is bound to
  SocketAddress             mBoundLocalAddress;
  /// Remote address this socket is connected to
  SocketAddress             mConnectedRemoteAddress;

private:
  /// No Copy Constructor
  Socket(const Socket&);
  /// No Copy Assignment Operator
  Socket& operator=(const Socket&);

  /// Friends
  template<typename type>
  friend struct MoveWithoutDestructionOperator;
};

/// Socket Move-Without-Destruction Operator
template<>
struct MoveWithoutDestructionOperator<Socket>
{
  static inline void MoveWithoutDestruction(Socket* dest, Socket* source)
  {
    // Construct new socket in place at destination
    new(dest) Socket(ZeroMove(*source));
  }
};

} // namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.hpp
/// Declaration of the Thread class.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

// Is threading enabled on this platform?
extern const bool ThreadingEnabled;

/// Thread class manages Os threads.
class Thread
{
public:
  typedef OsInt (*EntryFunction)(void*);

  //Construct a thread object does not create the thread.
  //Initialize and then resume to run the thread.
  Thread();
  ~Thread();

  //Is this a valid thread or uninitialized.
  bool IsValid();

  //Initializes the thread but does not run it.
  bool Initialize(EntryFunction entryFunction, void* instance, cstr threadName);

  //Resume the thread.
  void Resume();

  //Suspend the thread.
  void Suspend();

  //Close the thread handle. Thread should have been shut down.
  //before calling this function.
  void Close();

  //Block waiting for the thread to complete.
  //The thread should either complete in a reasonable way or
  //be signaled to be closed.
  OsInt WaitForCompletion();

  //Is the thread completed?
  bool IsCompleted();

  //Removes the thread from this object.
  OsHandle Detach();

  //Get the OsHandle to the thread.
  OsHandle GetThreadHandle();

  // Template Helper for creating Entry Functions
  // From member functions
  template<typename classType, OsInt (classType::*MemberFunction)()>
  static OsInt ObjectEntryCreator(void* objectInstance)
  {
    classType* object = (classType*)objectInstance;
    OsInt returnValue = (object->*MemberFunction)();
    return returnValue;
  }

private:
  char mThreadName[cDebugNameMax];
  ZeroDeclarePrivateData(Thread, 20);
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadSync.hpp
/// Declaration of Thread synchronization classes.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

class Status;

/// Thread Lock
/// Safe to lock multiple times from the same thread
class ThreadLock
{
public:
  ThreadLock();
  ~ThreadLock();
  void Lock();
  void Unlock();

  ZeroDeclarePrivateData(ThreadLock, 48);
};

//Wrapper around an unnamed event.
class OsEvent
{
public:
  OsEvent();
  ~OsEvent();
  void Initialize(bool manualReset = false, bool startSignaled = false);
  void Close();
  void Signal();
  void Reset();
  void Wait();
  OsHandle GetHandle() { return mHandle; }
private:
  OsHandle mHandle;
};

const int MaxSemaphoreCount = 0x0FFFFFFF;

//Semaphore class. Multithreaded counter / gatekeeper.
class Semaphore
{
public:
  Semaphore();
  ~Semaphore();
  void Increment();
  void Decrement();
  void Reset();
  void WaitAndDecrement();
private:
  OsHandle mHandle;

  ZeroDeclarePrivateData(Semaphore, 8);
};

/// Not fully implemented as it's currenlty only needed for interprocess communication
class Mutex
{
public:
  Mutex();
  ~Mutex();

  void Initialize(Status& status, const char* mutexName, bool failIfAlreadyExists = false);

private:
  ZeroDeclarePrivateData(Mutex, 8);
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file Utilities.hpp
/// Declaration of the Utilities class.
/// 
/// Authors: Trevor Sundberg, Chris Peters
/// Copyright 2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

class Status;

/// System Memory Information
struct MemoryInfo
{
  uint Reserve;
  uint Commit;
  uint Free;
};

namespace Os
{

// Sleep the current thread for ms milliseconds.
void Sleep(uint ms);

// Set the Timer Frequency (How often the os checks threads for sleep, etc)
void SetTimerFrequency(uint ms);

// Get the user name for the current profile
String UserName();

// Get the computer name
String ComputerName();

// Get computer Mac Address of adapter 0
u64 GetMacAddress();

// Check if a debugger is attached
bool IsDebuggerAttached();

// Debug break (only if a debugger is attached)
void DebugBreak();

// Verb used to open file
DeclareEnum4(Verb, Default, Open, Edit, Run);

// Open the file using the appropriate Os application or
// launch an external application.
void SystemOpenFile(cstr file, uint verb=Verb::Default, cstr parameters=NULL, cstr workingDirectory=NULL);
bool SystemOpenFile(Status& status, cstr file, uint verb=Verb::Default, cstr parameters=NULL, cstr workingDirectory=NULL);

// Get the memory status of the Os.
void GetMemoryStatus(MemoryInfo& memoryInfo);

// Get an Environmental variable
String GetEnvironmentalVariable(StringRef variable);

// Translate a os error code.
String TranslateErrorCode(int errorCode);

// Get a string describing the current operating system version.
String GetVersionString();

}

// Generate a 64 bit unique Id. Uses system timer and mac
// address to generate the id.
u64 GenerateUniqueId64();

// Waits for expression to evaluate to true, checking approximately every pollPeriod (in milliseconds)
#define WaitUntil(expression, pollPeriod) \
do { while(!(expression)) { Os::Sleep(pollPeriod); } } while(gConditionalFalseConstant)

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file File.hpp
/// Declaration of the Os file class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once






namespace Zero
{

// File Read Write Mode
DeclareEnum4(FileMode,
     // Open file for reading, reading starts at beginning of file
     // If the file does not exist opening will fail
     Read,
     // Open file for writing, if the file exists it be truncated to zero
     // If the file does not exist it will be created
     Write,
     // Open file for writing, writing starts at the end of the file
     // If the file does not exist it will be created
     Append,
     // Open for reading and writing, reading/writing starts at the beginning of file
     // If the file does not exist it will be created
     ReadWrite);

// Hint on how the file will be accessed
DeclareEnum2(FileAccessPattern, Sequential, Random);

// What permissions others have when accessing the same file
DeclareBitField4(FileShare, Read, Write, Delete, Unspecified);

// Position in file
typedef u64 FilePosition;

// Used in file Seek
DeclareEnum3(FileOrigin, Current, Begin, End);

byte* ReadFileIntoMemory(cstr path, size_t& fileSize, size_t extra = 0);
DataBlock ReadFileIntoDataBlock(cstr path);
size_t WriteToFile(cstr filePath, byte * pData, size_t bufferSize);

/// Os file class
class File
{
public:
  static const int MaxPath = 260;
  static const int PlatformMaxPath;

  File();
  ~File();
  
  /// Open the file
  /// We take an optional status (this should eventually be refactored, but we wanted to keep current asserting functionality)
  bool Open(StringParam filePath, FileMode::Enum mode, FileAccessPattern::Enum accessPattern, FileShare::Enum share = FileShare::Unspecified, Status* status = nullptr);

  /// Close the file
  void Close();
  
  /// Current read/write position in the file
  FilePosition Tell();
  
  /// Move the read write position to a new filePosition realative to origin
  bool Seek(FilePosition filePosition, FileOrigin::Enum origin = FileOrigin::Begin);
  
  /// Write data to the file
  size_t Write(byte* data, size_t sizeInBytes);
  
  /// Read data from the file
  size_t Read(byte* data, size_t sizeInBytes);

  /// Force all reads / write to the disk
  void Flush();
  
  /// Size of the file when opened (not current)
  /// Returns -1 if it fails to get the size of the file
  size_t Size();
  
  /// Size of the file when currently
  /// Returns -1 if it fails to get the size of the file
  long long CurrentFileSize();
  
  /// Is the file currently open?
  bool IsOpen();

private:
  ZeroDeclarePrivateData(File, 50);

  String mFilePath;
  FileMode::Enum mFileMode;
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file FileSystem.hpp
/// Declaration of the file system functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



///////////////////////////////////////////////////////////////////////////////
///
/// \file FilePath.hpp
/// Declaration of the FilePath class.
///
/// Authors: Joshua Davis
/// Copyright 2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

/// Represents info about a file path. This can be converted to the full
/// path by using FilePath.CombineWithExtension(Folder, FileName, Extension).
struct FilePathInfo
{
  /// The full folder path of the file without the file name or extension.
  /// Note this doesn't include the trailing folder separator.
  /// FileName of "A/B/File.txt" will be "A/B/".
  StringRange Folder;
  /// Name of the file without the extension or path.
  /// FileName of "A/B/File.txt" will be "File".
  StringRange FileName;
  /// The extension of the file (which is everything that follows after
  /// the last '.') without the '.'. So "A/B/File.txt" will return "txt".
  StringRange Extension;
};

// Helper class to combine paths and extract info out of a path.
class FilePath
{
public:
  static String Combine(StringRange path0, StringRange path1);
  static String Combine(StringRange path0, StringRange path1, StringRange path2);
  static String Combine(StringRange path0, StringRange path1, StringRange path2, StringRange path3);
  static String Combine(StringRange path0, StringRange path1, StringRange path2, StringRange path3, StringRange path4);
  static String Combine(const StringRange** paths, uint count, StringRange extension);
  static String CombineWithExtension(StringRange path, StringRange fileName, StringRange ext);

  /// Remove all different slashes
  static String Normalize(StringRange path);
  /// Get a path info object
  static FilePathInfo GetPathInfo(StringRange path);
  /// Return extension of file path so "A/B/File.txt" is "txt"
  static StringRange GetExtension(StringRange path);
  /// Returns the file name with the extension so "A/B/File.txt" is "File.txt"
  static StringRange GetFileName(StringRange path);
  /// Returns just the file name so "A/B/File.txt" is "File"
  static StringRange GetFileNameWithoutExtension(StringRange path);
  /// Returns the name of the directory "A/B/File.txt" is "A/B"
  static StringRange GetDirectoryPath(StringRange path);
  /// Returns the name of the directory "A/B/File.txt" is "B"
  static StringRange GetDirectoryName(StringRange path);
};

}//namespace Zero


namespace Zero
{

DeclareEnum4(FileSystemErrors, 
  FileNotFound, 
  FileNotAccessible,
  FileNotWritable,
  FileLocked
);

extern const char  cDirectorySeparatorChar;
extern const char* cDirectorySeparatorCstr;
extern bool cFileSystemCaseInsensitive;

/// Intialize the file system
/// Some file systems have startup/shutdown steps that need to be taken.
void InitFileSystem();
void ShutdownFileSystem();

/// Copies a file. Will spin lock if fails up to a max number of iterations. (Calls CopyFileInternal)
bool CopyFile(StringRef dest, StringRef source);
/// The actual platform specific file copy function.
bool CopyFileInternal(StringRef dest, StringRef source);

/// Move a file. Must be folder to folder or file to file.
/// Will spin lock if fails up to a max number of iterations. (Calls MoveFileInternal)
bool MoveFile(StringRef dest, StringRef source);
/// The actual platform specific function. Move a file. Must be folder to folder or file to file.
bool MoveFileInternal(StringRef dest, StringRef source);

/// Deletes a file. Will spin lock if fails up to a max number of iterations. (Calls DeleteFileInternal)
bool DeleteFile(StringRef file);
/// The actual platform specific function. 
bool DeleteFileInternal(StringRef dest);

/// Delete an entire directory
bool DeleteDirectory(StringRef directory);

/// Create a directory.
void CreateDirectory(StringRef dest);

/// Create a directory and any parent directories required
void CreateDirectoryAndParents(StringRef directory);

/// -1 Destination is older or does not exist.
///  0 Destination and source are the same.
///  1 Destination is newer.
int CheckFileTime(StringRef dest, StringRef source);

/// Returns the date/time of the file
bool GetFileDateTime(StringParam filePath, CalendarDateTime& result);

/// Is the dest file older than the source file?
inline bool DestinationIsOlder(StringRef dest, StringRef source)
{
  return CheckFileTime(dest, source) <= 0;
}

/// Update file time to current time.
int SetFileToCurrentTime(StringRef filename);

/// Get the file last modified time.
TimeType GetFileModifiedTime(StringRef filename);

/// Get Size of file zero if not found
u32 GetFileSize(StringRef fileName);

//Does the file exist?
bool FileExists(StringRef filePath);

//Is the file exist and is writable?
bool FileWritable(StringRef filePath);

//Does the directory exist?
bool DirectoryExists(StringRef directoryPath);

//Is this path a directory?
bool IsDirectory(StringRef directoryPath);

// Use OS dependent behavior to strip the path of redundancies (such as .., and . where they are redundant)
// Side note: Windows has a few mechanisms that are partially incorrect in different places, so it is 
// probably best for us to call Normalize using FilePath before Canonicalizing
// For example: Windows doesn't remove redundant slashes
String CanonicalizePath(StringRef directoryPath);

/// Special Paths

/// Get the current working directory for this process.
String GetWorkingDirectory();

/// Set the working directory for this process.
void SetWorkingDirectory(String path);

/// Directory for application cache and config files.
String GetUserLocalDirectory();

/// Directory for user modifiable configuration files.
String GetUserDocumentsDirectory();

/// Directory to the application.
String GetApplicationDirectory();

/// Full Path to the application.
String GetApplication();

/// Get directory for temporary files.
String GetTemporaryDirectory();

/// Get an id string for a file. String returned
/// will be unique for every file on the system.
String UniqueFileId(StringRef fullpath);

class FileEntry
{
public:
  String mPath;
  String mFileName;
  u64 mSize;

  String GetFullPath()
  {
    return FilePath::Combine(mPath, mFileName);
  }
};

/// File range for iterating over files in a directory
class FileRange
{
public:
  
  //Path of directory to walk
  FileRange(StringRef filePath);
  ~FileRange();

  // Range interface
  bool empty();
  cstr front();
  // This function should be used over front (and should eventually replace it)
  FileEntry frontEntry();

  void popFront();

private:
  String mPath;
  ZeroDeclarePrivateData(FileRange, 500);
};

}


///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.hpp
/// Declaration of the ExternalLibrary class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Zero
{
/// An externally loaded native library (example, a Windows .dll or *nix .so file)
class ExternalLibrary
{
public:
  ExternalLibrary();
  ~ExternalLibrary();

  // Is this a valid library or is it uninitialized?
  bool IsValid();

  // Loads a library in by file path
  void Load(cstr filePath);

  // Unload the library (safe to call more than once)
  void Unload();

  // Read a function out of the external library by name
  void* GetFunctionByName(cstr name);

  // Whether we unload the library when we're destructed (default true)
  bool mUnloadOnDestruction;

private:
  OsHandle mHandle;
};

}//namespace Zero


///////////////////////////////////////////////////////////////////////////////
///
/// \file Math.hpp
/// Central location for all the math used by the Zero engine.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file Reals.hpp
/// Declaration of the real typedef and utility functions.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

namespace Math
{

typedef float real;
typedef short half;

//a pointer of the given type
typedef real* RealPointer;
//a const pointer of the given type
typedef const real* ConstRealPointer;
//a reference of the given type
typedef real& RealRef;
//a const reference of the given type
typedef const real& ConstRealRef;

const uint cX = 0;
const uint cY = 1;
const uint cZ = 2;
const uint cW = 3;

//these cannot be constants
extern const real& cInfinite;

const real cPi = real(3.1415926535897932384626433832795);
const real cTwoPi = real(2.0) * cPi;

//Golden ratio!
const real cGoldenRatio = real(1.6180339887498948482045868343656);

real Epsilon(void);
real PositiveMax(void);
real PositiveMin();
bool Equal(real lhs, real rhs);
bool Equal(real lhs, real rhs, real epsilon);
bool NotEqual(real lhs, real rhs);
bool IsZero(real val);
bool IsNegative(real number);
bool IsPositive(real number);
bool LessThan(real lhs, real rhs);
bool LessThanOrEqual(real lhs, real rhs);
bool GreaterThan(real lhs, real rhs);
bool GreaterThanOrEqual(real lhs, real rhs);
real Sqrt(real val);
bool SafeSqrt(real val, real& result);
real Rsqrt(real val);
real Sq(real sqrt);
real Pow(real base, real exp);
real Log(real val);
real Log(real val, real base);
real Log10(real val);
real Log2(real val);
real Exp(real val);
real Exp2(real val);
real Abs(real val);
int Abs(int val);
real FMod(real dividend, real divisor);
bool SafeFMod(real dividend, real divisor, real& result);
real GetSign(real val);
int Sign(real val);
int Sign(int val);
real Cos(real val);
real Sin(real val);
real Tan(real angle);
real Cot(real angle);
real Cosh(real val);
real Sinh(real val);
real Tanh(real angle);
real ArcCos(real angle);
real ArcSin(real angle);
real ArcTan(real angle);
real ArcTan2(real y, real x);
bool SafeArcCos(real radians, real& result);
bool SafeArcSin(real radians, real& result);
real RadToDeg(real radians);
real DegToRad(real degrees);
real Fractional(real val);
real Round(real val);
real Round(real value, int places);
real Round(real value, int places, int base);
real Truncate(real val);
real Truncate(real val, int places);
real Truncate(real val, int places, int base);
real Ceil(real val);
real Ceil(real val, int places);
real Ceil(real val, int places, int base);
real Floor(real val);
real Floor(real val, int places);
real Floor(real val, int places, int base);
real Step(real y, real x);
int CountBits(int value);
bool IsValid(real val);

int IntegerPositiveMax();
int IntegerNegativeMin();

template <typename T>
inline T Max(const T lhs, const T rhs)
{
  return lhs > rhs ? lhs : rhs;
}

template <typename T>
inline T Min(const T lhs, const T rhs) 
{
  return lhs > rhs ? rhs : lhs;
}

template <typename T>
inline T Clamp(const T x, const T xMin, const T xMax)
{
  return Max(xMin, Min(x, xMax));
}

template <typename T>
inline T Clamp(const T value) 
{
  return Clamp(value, T(0), T(1));
}

/// Clamps between min and max but it sets a bool saying whether or not a value was clamped.
template <typename T>
inline T DebugClamp(const T x, const T xMin, const T xMax, bool& wasClamped)
{
  wasClamped = true;
  if(x < xMin)  
    return xMin;
  if(x > xMax)
    return xMax;
  wasClamped = false;
  return x;
}

template <typename T>
inline T ClampIfClose(const T x, const T xMin, const T xMax, const T epsilon)
{
  real value = x < xMin && x > (xMin - epsilon) ? xMin : x;
  value = value > xMax && value < (xMax + epsilon) ? xMax : value;
  return value;
}

template <typename T>
inline bool TryClampIfClose(T& x, const T xMin, const T xMax, const T epsilon)
{
  if(x < xMin)
  {
    if(x > (xMin - epsilon))
      x = xMin;
    else
      return false;
  }
  if(x > xMax)
  {
    if(x < (xMax + epsilon))
      x = xMax;
    else
      return false;
  }
  return true;
}

template <typename T>
inline real InverseLerp(const T x, const T start, const T end)
{
  if(end == start)
  {
    return real(1.0);
  }

  return (x - start) / (end - start);
}

template <typename T>
inline real InverseLerpClamped(const T x, const T start, const T end)
{
  return Clamp(InverseLerp(x, start, end));
}

///Checks to see if x is within the interval of [xMin, xMax]
template <typename T>
inline bool InRange(const T x, const T xMin, const T xMax)
{
    return ((xMin <= x) && (x <= xMax));
}

///Checks to see if x is within the interval of (xMin, xMax)
template <typename T>
inline bool InBounds(const T x, const T xMin, const T xMax)
{
    return ((xMin < x) && (x < xMax));
}

template <typename T>
inline T Wrap(const T x, const T xMin, const T xMax)
{
    return (x < xMin) ? (x + (xMax - xMin)) : 
           ((x > xMax) ? (x - (xMax - xMin)) : x);
}

template <typename T>
inline void Swap(T& a, T& b)
{
  T temp(a);
  a = b;
  b = temp;
}

template <typename Data, typename T>
inline Data Lerp(const Data& start, const Data& end, T interpolationValue)
{
  return (T(1.0) - interpolationValue) * start + interpolationValue * end;
}

template <typename Data>
inline Data SmoothStep(const Data& start, const Data& end, real t)
{
  t = Clamp((t - start) / (end - start));
  
  // 3t^2 - 2t^3
  return t * t * (3 - 2 * t);
}

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector2.hpp
/// Declaration of the Vector 2 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


///////////////////////////////////////////////////////////////////////////////
///
/// \file BoolVector2.hpp
/// Declaration of the BoolVector2 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Math
{

struct BoolVector2;
typedef BoolVector2 BoolVec2;
typedef const BoolVector2& BoolVec2Param;
typedef BoolVector2& BoolVec2Ref;
typedef BoolVector2* BoolVec2Ptr;

///2 dimensional integral vector.
struct BoolVector2
{
  BoolVector2(void) {}
  explicit BoolVector2(bool x, bool y);

  bool& operator[](uint index);
  bool operator[](uint index) const;

  //Unary Operators
  BoolVector2 operator!(void) const;

  //Binary Vector Comparisons
  bool operator==(BoolVec2Param rhs) const;
  bool operator!=(BoolVec2Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(bool x, bool y);

  union
  {
    struct  
    {
      bool x, y;
    };
    bool array[2];
  };

  static const BoolVector2 cZero;
  static const BoolVector2 cXAxis;
  static const BoolVector2 cYAxis;
};

}// namespace Math


namespace Math
{

struct Vector2;
typedef Vector2 Vec2;
typedef const Vector2& Vec2Param;
typedef Vector2& Vec2Ref;
typedef Vector2* Vec2Ptr;

//--------------------------------------------------------------------- Vector 2
///2 dimensional vector.
struct Vector2
{
  Vector2(void) {};
  explicit Vector2(real x, real y);
  explicit Vector2(real xy);
  explicit Vector2(ConstRealPointer data);

  real& operator[](uint index);
  real operator[](uint index) const;

  //Unary Operators
  Vector2 operator-(void) const;

  //Binary Assignment Operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary Operators (Reals)
  Vector2 operator*(real rhs) const;
  Vector2 operator/(real rhs) const;

  //Binary Assignment Operators (vectors)
  void operator+=(Vec2Param rhs);
  void operator-=(Vec2Param rhs);

  //Binary Operators (vectors)
  Vector2 operator+(Vec2Param rhs) const;
  Vector2 operator-(Vec2Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(Vec2Param rhs) const;
  bool operator!=(Vec2Param rhs) const;

  //Vector component-wise multiply and divide
  Vector2 operator*(Vec2Param rhs) const;
  Vector2 operator/(Vec2Param rhs) const;

  ///Component-wise assignment multiplication
  void operator*=(Vec2Param rhs);
  void operator/=(Vec2Param rhs);

  //Comparison operators
  BoolVec2 operator< (Vec2Param rhs) const;
  BoolVec2 operator<=(Vec2Param rhs) const;
  BoolVec2 operator> (Vec2Param rhs) const;
  BoolVec2 operator>=(Vec2Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(real x, real y);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  ///Calculate and return this vector reflected about the given vector.
  Vector2 Reflect(Vec2Param reflectionAxis) const;

  /// Projects this vector onto the given vector (must be normalized)
  Vector2 ProjectOnVector(Vec2Param normalizedVector) const;
  /// Projects this onto a plane (the normal must be normalized)
  Vector2 ProjectOnPlane(Vec2Param planeNormal) const;

  /// Calculates the reflection vector across a given vector.
  Vector2 ReflectAcrossVector(Vec2Param normalizedVector) const;
  /// Calculates the reflection vector across a given plane.
  Vector2 ReflectAcrossPlane(Vec2Param planeNormal) const;

  /// Calculates the refraction vector through a plane given a certain index of refraction.
  Vector2 Refract(Vec2Param planeNormal, real refractionIndex) const;

  ///Add a vector multiplied by a scalar to this vector. A commonly done 
  ///operation and this reduces temporaries.
  void AddScaledVector(Vec2Param vector, real scalar);

  ///Compute the dot product of this vector with the given vector.
  real Dot(Vec2Param rhs) const;

  ///Get the length of this vector.
  real Length(void) const;

  ///Get the squared length of this vector.
  real LengthSq(void) const;

  ///Calculate and return a unit-length copy of this vector.
  Vector2 Normalized(void) const;

  ///Make this vector have a length of 1, returns the original length.
  real Normalize(void);

  ///Attempt to give this vector a length of 1, but checks if it's possible.
  ///Instead of crashing, will return 0 if the vector was not able to be 
  ///normalized.
  real AttemptNormalize(void);

  ///Flips this vector so it's pointing in the opposite direction.
  Vec2Ref Negate(void);

  ///Checks to see if the values of this vector's elements are usable.
  bool Valid(void) const;

  void Splat(real value);

  union
  {
    struct  
    {
      real x, y;
    };
    real array[2];
  };

  static const Vector2 cZero;
  static const Vector2 cXAxis;
  static const Vector2 cYAxis;
  static const Vector2 Axes[2];
};

Vector2 operator*(real lhs, Vec2Param rhs);

///Compute the distance between two given points.
real Distance(Vec2Param lhs, Vec2Param rhs);

///Compute the dot product of the two given vectors.
real Dot(Vec2Param lhs, Vec2Param rhs);

///Compute the 2d cross product of the two given vectors.
real Cross(Vec2Param lhs, Vec2Param rhs);

///Get the length of the given vector.
real Length(Vec2Param vec);

///Get the squared length of the given vector.
real LengthSq(Vec2Param vec);

///Calculate and return a unit-length copy of the given vector.
Vector2 Normalized(Vec2Param vec);

///Make the given vector have a length of 1, returns the original length.
real Normalize(Vec2Ptr vec);

///Attempt to give the given vector a length of 1, but checks if it's possible.
///Instead of crashing, this will return 0 if the vector was not able to be 
///normalized.
real AttemptNormalize(Vec2Ptr vec);

///Flips the given vector so it's pointing in the opposite direction.
void Negate(Vec2Ptr vec);

///Returns a vector pointing in the opposite direction of the given vector.
Vector2 Negated(Vec2Param vec);

///Returns a vector with absolute valued elements of the given vector.
Vector2 Abs(Vec2Param vec);

///Returns the component-wise minimum vector of the two vectors.
Vector2 Min(Vec2Param lhs, Vec2Param rhs);

///Returns the component-wise maximum vector of the two vectors.
Vector2 Max(Vec2Param lhs, Vec2Param rhs);

///Linearly interpolate between the two vectors, the t-value is restricted to 
///the range [0, 1].
Vector2 Lerp(Vec2Param start, Vec2Param end, real tValue);

///Clamps the values of the elements of the given vector to the range [min, max]
void Clamp(Vec2Ptr vec, real min, real max);

/// Same as clamp, however it fills out whether or not anything was clamped.
/// Useful when an assert message should be shown if anything was clamped.
Vector2 DebugClamp(Vec2Param vec, real min, real max, bool& wasClamped);

///Returns the bisector of the given vectors.
Vector2 GetBisector(Vec2Param v0, Vec2Param v1);

///Get the perpendicular vector to the given vector
Vector2 GetPerpendicular(Vec2Param vec);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector3.hpp
/// Declaration of the Vector 3 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



///////////////////////////////////////////////////////////////////////////////
///
/// \file BoolVector3.hpp
/// Declaration of the BoolVector3 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Math
{

struct BoolVector3;
typedef BoolVector3 BoolVec3;
typedef const BoolVector3& BoolVec3Param;
typedef BoolVector3& BoolVec3Ref;
typedef BoolVector3* BoolVec3Ptr;

///2 dimensional integral vector.
struct BoolVector3
{
  BoolVector3(void) {}
  explicit BoolVector3(bool x, bool y, bool z);

  bool& operator[](uint index);
  bool operator[](uint index) const;

  //Unary Operators
  BoolVector3 operator!(void) const;

  //Binary Vector Comparisons
  bool operator==(BoolVec3Param rhs) const;
  bool operator!=(BoolVec3Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(bool x, bool y, bool z);

  union
  {
    struct  
    {
      bool x, y, z;
    };
    bool array[3];
  };

  static const BoolVector3 cZero;
  static const BoolVector3 cXAxis;
  static const BoolVector3 cYAxis;
  static const BoolVector3 cZAxis;
};

}// namespace Math


namespace Math
{

struct Vector3;
typedef Vector3 Vec3;
typedef const Vector3& Vec3Param;
typedef Vector3& Vec3Ref;
typedef Vector3* Vec3Ptr;

//--------------------------------------------------------------------- Vector 3
///3 dimensional vector.
struct Vector3
{
  Vector3(void) {};
  explicit Vector3(real x, real y, real z);
  //Splat all elements
  explicit Vector3(real xyz);
  explicit Vector3(Vec2Param vec2, real z = real(0.0));
  explicit Vector3(ConstRealPointer data);

  real& operator[](uint index);
  real operator[](uint index) const;

  //Unary Operators
  Vector3 operator-(void) const;

  //Binary Assignment Operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary Operators (Reals)
  Vector3 operator*(real rhs) const;
  Vector3 operator/(real rhs) const;

  //Binary Assignment Operators (vectors)
  void operator+=(Vec3Param rhs);
  void operator-=(Vec3Param rhs);

  //Binary Operators (vectors)
  Vector3 operator+(Vec3Param rhs) const;
  Vector3 operator-(Vec3Param rhs) const;  

  //Binary Vector Comparisons
  bool operator==(Vec3Param rhs) const;
  bool operator!=(Vec3Param rhs) const;

  //Vector component wise multiply and divide
  Vector3 operator*(Vec3Param rhs) const;
  Vector3 operator/(Vec3Param rhs) const;

  ///Component-wise assignment multiplication
  void operator*=(Vec3Param rhs);
  void operator/=(Vec3Param rhs);

  //Comparison operators
  BoolVec3 operator< (Vec3Param rhs) const;
  BoolVec3 operator<=(Vec3Param rhs) const;
  BoolVec3 operator> (Vec3Param rhs) const;
  BoolVec3 operator>=(Vec3Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(real x, real y, real z);

  ///Set all of the values of the vector to the passed in value.
  void Splat(real xyz);

  ///Do a component-wise scaling of this vector with the given vector.
  void ScaleByVector(Vec3Param rhs);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  /// Projects this vector onto the given vector (must be normalized)
  Vector3 ProjectOnVector(Vec3Param normalizedVector) const;
  /// Projects this onto a plane (the normal must be normalized)
  Vector3 ProjectOnPlane(Vec3Param planeNormal) const;
  
  /// Calculates the reflection vector across a given vector.
  Vector3 ReflectAcrossVector(Vec3Param normalizedVector) const;
  /// Calculates the reflection vector across a given plane.
  Vector3 ReflectAcrossPlane(Vec3Param planeNormal) const;

  /// Calculates the refraction vector through a plane given a certain index of refraction.
  Vector3 Refract(Vec3Param planeNormal, real refractionIndex) const;


  ///Add a vector multiplied by a scalar to this vector. A commonly done 
  ///operation and this reduces temporaries.
  void AddScaledVector(Vec3Param vector, real scalar);

  ///Compute the dot product of this vector with the given vector.
  real Dot(Vec3Param rhs) const;

  ///Get the length of this vector.
  real Length(void) const;

  ///Get the squared length of this vector.
  real LengthSq(void) const;

  ///Calculate and return a unit-length copy of this vector.
  Vector3 Normalized(void) const;

  ///Make this vector have a length of 1, returns the original length.
  real Normalize(void);

  ///Ceil each component of the vector.
  void Ceil(void);

  ///Floor each component of the vector.
  void Floor(void);

  ///Truncate each component of the vector.
  void Truncate(void);

  ///If positive, it always rounds up, if negative, it always rounds down
  void RoundToExtremes();

  ///Round each component of the vector.
  void Round(void);

  ///Attempt to give this vector a length of 1, but checks if it's possible.
  ///Instead of crashing, will return 0 if the vector was not able to be 
  ///normalized.
  real AttemptNormalize(void);
  Vector3 AttemptNormalized() const;

  ///Flip this vector so it's pointing in the opposite direction.
  Vec3Ref Negate(void);

  ///Checks to see if the values of this vector's elements are usable.
  bool Valid(void) const;

  ///Compute the cross product of this vector with the given vector.
  Vector3 Cross(Vec3Param rhs) const;
  void InvertComponents(void);

  union
  {
    struct  
    {
      real x, y, z;
    };
    real array[3];
  };

  static const Vector3 cZero;
  static const Vector3 cXAxis;
  static const Vector3 cYAxis;
  static const Vector3 cZAxis;
  static const Vector3 Axes[3];
};

Vector3 operator*(real lhs, Vec3Param rhs);

bool Equal(Vec3Param lhs, Vec3Param rhs, real epsilon);

///Compute the distance between two given vectors.
real Distance(Vec3Param lhs, Vec3Param rhs);

///Compute the dot product of the two given vectors.
real Dot(Vec3Param lhs, Vec3Param rhs);

//Vector component-wise multiply
Vector3 ScaledByVector(Vec3Param lhs, Vec3Param rhs);

//Vector component-wise divide
Vector3 DividedByVector(Vec3Param lhs, Vec3Param rhs);

///Get the length of the given vector.
real Length(Vec3Param vec);

///Get the squared length of the given vector.
real LengthSq(Vec3Param vec);

///Calculate and return a unit-length copy of the given vector.
Vector3 Normalized(Vec3Param vec);

///Make the given vector have a length of 1, returns the original length.
real Normalize(Vec3Ptr vec);

///Attempt to give the given vector a length of 1, but checks if it's possible.
///Instead of crashing, this will return 0 if the vector was not able to be 
///normalized.
real AttemptNormalize(Vec3Ptr vec);

///Compute the cross product of the two given vectors.
Vector3 Cross(Vec3Param lhs, Vec3Param rhs);

///Compute the cross product of the two given vectors for 2d.
///The result is only the z axis of the cross product.
Vector3 Cross2d(Vec3Param lhs, Vec3Param rhs);

///Set all of the given vector's elements to 0.
void ZeroOut(Vec3Ptr vec);

///Flips the given vector so it's pointing in the opposite direction.
void Negate(Vec3Ptr vec);

///Returns a vector pointing in the opposite direction of the given vector.
Vector3 Negated(Vec3Param vec);

///Returns a vector with absolute valued elements of the given vector.
Vector3 Abs(Vec3Param vec);

///Returns the component-wise minimum vector of the two vectors.
Vector3 Min(Vec3Param lhs, Vec3Param rhs);

///Returns the component-wise maximum vector of the two vectors.
Vector3 Max(Vec3Param lhs, Vec3Param rhs);

///Linearly interpolate between the two vectors, the t-value is restricted to 
///the range [0, 1].
Vector3 Lerp(Vec3Param start, Vec3Param end, real tValue);

///Clamps the values of the elements of the given vector to the range [min, max]
void Clamp(Vec3Ptr vec, real min, real max);

///Calculates and returns the given vector with its values clamped to the range
///[min, max].
Vector3 Clamped(Vec3Param vec, real min, real max);

/// Same as clamp, however it fills out whether or not anything was clamped.
/// Useful when an assert message should be shown if anything was clamped.
Vector3 DebugClamp(Vec3Param vec, real min, real max, bool& wasClamped);

///Returns if all values in lhs are less than all values in rhs
bool AllLess(Vec3Param lhs, Vec3Param rhs);

///Returns if any value in lhs is less than any value in rhs
bool AnyLess(Vec3Param lhs, Vec3Param rhs);

///Returns if all values in lhs are greater than all values in rhs
bool AllGreater(Vec3Param lhs, Vec3Param rhs);

///Returns if any value in lhs is greater than any value in rhs
bool AnyGreater(Vec3Param lhs, Vec3Param rhs);

real DistanceToLineSq(Vec3Param start, Vec3Param end, Vec3Param point);

}// namespace Math



namespace Math
{

//-------------------------------------------------------------- Unary Operators
inline Vector3 Vector3::operator-(void) const
{
  return Vector3(-x, -y, -z);
}

//------------------------------------------ Binary Assignment Operators (reals)
inline void Vector3::operator*=(real rhs)
{
  x *= rhs;
  y *= rhs;
  z *= rhs;
}

inline void Vector3::operator/=(real rhs)
{
  ErrorIf(rhs == real(0.0), "Math::Vector3 - Division by zero.");
  x /= rhs;
  y /= rhs;
  z /= rhs;
}

//----------------------------------------------------- Binary Operators (reals)

inline Vector3 Vector3::operator*(real rhs) const
{
  Vector3 ret = *this;
  ret *= rhs;
  return ret;
}

inline Vector3 Vector3::operator/(real rhs) const
{
  ErrorIf(Math::IsZero(rhs), "Math::Vector3 - Division by zero.");
  Vector3 ret = *this;
  ret /= rhs;
  return ret;
}

//----------------------------------------- Binary Assignment Operator (Vectors)

inline void Vector3::operator+=(Vec3Param rhs)
{
  x += rhs.x;
  y += rhs.y;
  z += rhs.z;
}

inline void Vector3::operator-=(Vec3Param rhs)
{
  x -= rhs.x;
  y -= rhs.y;
  z -= rhs.z;
}

//--------------------------------------------------- Binary Operators (Vectors)
inline Vector3 Vector3::operator+(Vec3Param rhs) const
{
  Vector3 ret = *this;
  ret += rhs;
  return ret;
}

inline Vector3 Vector3::operator-(Vec3Param rhs) const
{
  Vector3 ret = *this;
  ret -= rhs;
  return ret;
}

inline Vector3 Vector3::operator*(Vec3Param rhs) const
{
  return Vector3(x * rhs.x, y * rhs.y, z * rhs.z);
}

inline Vector3 Vector3::operator/(Vec3Param rhs) const
{  
  ErrorIf(rhs.x == real(0.0) || rhs.y == real(0.0) || rhs.z == real(0.0),
          "Vector3 - Division by zero.");
  return Vector3(x / rhs.x, y / rhs.y, z / rhs.z);
}

inline void Vector3::operator*=(Vec3Param rhs)
{
  x *= rhs.x;
  y *= rhs.y;
  z *= rhs.z;
}

inline void Vector3::operator/=(Vec3Param rhs)
{
  x /= rhs.x;
  y /= rhs.y;
  z /= rhs.z;
}

inline real Vector3::Dot(Vec3Param rhs) const
{
  return x * rhs.x + y * rhs.y + z * rhs.z;
}

inline real Dot(Vec3Param lhs, Vec3Param rhs)
{  
  return lhs.Dot(rhs);
}

}//namespace Math


///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector4.hpp
/// Declaration of the Vector 4 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once


///////////////////////////////////////////////////////////////////////////////
///
/// \file BoolVector4.hpp
/// Declaration of the BoolVector4 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Math
{

struct BoolVector4;
typedef BoolVector4 BoolVec4;
typedef const BoolVector4& BoolVec4Param;
typedef BoolVector4& BoolVec4Ref;
typedef BoolVector4* BoolVec4Ptr;

///2 dimensional integral vector.
struct BoolVector4
{
  BoolVector4(void) {}
  explicit BoolVector4(bool x, bool y, bool z, bool w);

  bool& operator[](uint index);
  bool operator[](uint index) const;

  //Unary Operators
  BoolVector4 operator!(void) const;

  //Binary Vector Comparisons
  bool operator==(BoolVec4Param rhs) const;
  bool operator!=(BoolVec4Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(bool x, bool y, bool z, bool w);

  union
  {
    struct  
    {
      bool x, y, z, w;
    };
    bool array[4];
  };

  static const BoolVector4 cZero;
  static const BoolVector4 cXAxis;
  static const BoolVector4 cYAxis;
  static const BoolVector4 cZAxis;
  static const BoolVector4 cWAxis;
};

}// namespace Math


namespace Math
{

struct Vector4;
typedef Vector4 Vec4;
typedef const Vector4& Vec4Param;
typedef Vector4& Vec4Ref;
typedef Vector4* Vec4Ptr;

//--------------------------------------------------------------------- Vector 4
struct Vector4
{
  Vector4(void) {};
  explicit Vector4(real x, real y, real z, real w);
  explicit Vector4(ConstRealPointer data);
  //Splat all elements
  explicit Vector4(real xyzw);

  real& operator[](uint index);
  real operator[](uint index) const;

  //Unary Operators
  Vector4 operator-(void) const;

  //Binary Assignment Operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary Operators (Reals)
  Vector4 operator*(real rhs) const;
  Vector4 operator/(real rhs) const;

  //Binary Assignment Operators (vectors)
  void operator+=(Vec4Param rhs);
  void operator-=(Vec4Param rhs);
  void operator*=(Vec4Param rhs);
  void operator/=(Vec4Param rhs);

  //Binary Operators (vectors)
  Vector4 operator+(Vec4Param rhs) const;
  Vector4 operator-(Vec4Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(Vec4Param rhs) const;
  bool operator!=(Vec4Param rhs) const;

  //Vector component wise multiply and divide
  Vector4 operator*(Vec4Param rhs) const;
  Vector4 operator/(Vec4Param rhs) const;

  //Comparison operators
  BoolVec4 operator< (Vec4Param rhs) const;
  BoolVec4 operator<=(Vec4Param rhs) const;
  BoolVec4 operator> (Vec4Param rhs) const;
  BoolVec4 operator>=(Vec4Param rhs) const;

  void Set(real x, real y, real z, real w);

  ///Set all of the values of the vector to the passed in value.
  void Splat(real xyzw);

  ///Do a component-wise scaling of this vector with the given vector.
  void ScaleByVector(Vec4Param rhs);

  Vector4 ScaledByVector(Vec4Param rhs) const;

  void ZeroOut(void);
  void AddScaledVector(Vec4Param vector, real scalar);

  real Dot(Vec4Param rhs) const;
  real Length(void) const;
  real LengthSq(void) const;
  Vector4 Normalized(void) const;
  real Normalize(void);
  real AttemptNormalize(void);
  Vec4Ref Negate(void);
  bool Valid(void) const;

  /// Projects this vector onto the given vector (must be normalized)
  Vector4 ProjectOnVector(Vec4Param normalizedVector) const;
  /// Projects this onto a plane (the normal must be normalized)
  Vector4 ProjectOnPlane(Vec4Param planeNormal) const;
  
  /// Calculates the reflection vector across a given vector.
  Vector4 ReflectAcrossVector(Vec4Param normalizedVector) const;
  /// Calculates the reflection vector across a given plane.
  Vector4 ReflectAcrossPlane(Vec4Param planeNormal) const;

  /// Calculates the refraction vector through a plane given a certain index of refraction.
  Vector4 Refract(Vec4Param planeNormal, real refractionIndex) const;

  union
  {
    struct  
    {
      real x, y, z, w;
    };
    real array[4];
  };

  static const Vector4 cZero;
  static const Vector4 cXAxis;
  static const Vector4 cYAxis;
  static const Vector4 cZAxis;
  static const Vector4 cWAxis;
  static const Vector4 Axes[4];
};

Vector4 operator*(real lhs, Vec4Param rhs);
real Dot(Vec4Param lhs, Vec4Param rhs);
real Length(Vec4Param vect);
real LengthSq(Vec4Param vect);
Vector4 Normalized(Vec4Param vect);
real Normalize(Vec4Ptr vect);
real AttemptNormalize(Vec4Ptr vect);
void Negate(Vec4Ptr vec);
Vector4 Negated(Vec4Param vec);
Vector4 Abs(Vec4Param vec);
Vector4 Min(Vec4Param lhs, Vec4Param rhs);
Vector4 Max(Vec4Param lhs, Vec4Param rhs);
Vector4 Clamped(Vec4Param vec, real min, real max);
Vector4 Lerp(Vec4Param start, Vec4Param end, real tValue);

}// namespace Math


///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix2.hpp
/// Declares the Matrix 2 structure.
///
/// Authors: Joshua Davis
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once




namespace Math
{

struct Matrix2;
typedef Matrix2 Mat2;
typedef const Matrix2& Mat2Param;
typedef Matrix2& Mat2Ref;
typedef Matrix2* Mat2Ptr;

struct Matrix2
{
public:
  Matrix2() {};
  Matrix2(real p00, real p01,
          real p10, real p11);
  Matrix2(ConstRealPointer data_);

  Vec2Ref operator[](uint index);
  Vec2Param operator[](uint index) const;

  ConstRealPointer Begin() const;
  ConstRealPointer End() const;
  RealPointer Begin();
  RealPointer End();

  //binary assignment operators (Reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //binary operators (Reals)
  Matrix2 operator*(real rhs) const;
  Matrix2 operator/(real rhs) const;

  //binary assignment operators (matrices)
  void operator+=(Mat2Param rhs);
  void operator-=(Mat2Param rhs);

  //binary operators (matrices)
  Matrix2 operator+(Mat2Param rhs) const;
  Matrix2 operator-(Mat2Param rhs) const;
  Matrix2 operator*(Mat2Param rhs) const;

  //matrix comparisons
  bool operator==(Mat2Param rhs) const;
  bool operator!=(Mat2Param rhs) const;

  real operator()(uint r, uint c) const;
  real& operator()(uint r, uint c);

  Matrix2 Transposed() const;
  Matrix2 Inverted();
  Matrix2 Concat(Mat2Param rhs) const;
  Mat2Ref Identity();
  Mat2Ref SetIdentity();
  Mat2Ref ZeroOut();

  real Determinant() const;

  bool Valid() const;

  void Rotate(real radians);
  void Scale(real x, real y);
  void Scale(Vec2Param rhs);
  Vector2 Transform(Vec2Param vector) const;
  void TransformVector(Vec2Ref vector) const;
  Vector2 BasisVector(u32 index) const;

  Vector2 Basis(uint index) const;
  Vector2 Cross(uint index) const;


  union 
  {
    struct
    {
      real m00, m01, 
           m10, m11;
    };

    real array[4];
  };

  static const Matrix2 cIdentity;
};

Matrix2 operator*(real lhs, Mat2Param rhs);

Matrix2 Concat(Mat2Param lhs, Mat2Param rhs);
Vector2 Transform(Mat2Param mat, Vec2Param vector);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix3.hpp
/// Declaration of the Matrix 3 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file MatrixStorage.hpp
/// Declaration of the switch for how matrices are stored.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///Used to set the way matrices are laid out. If 0, then the columns of an 
///orthogonal basis matrix represent the xyz-axes of the rotation. If 1, then 
///the rows of an orthogonal basis matrix represent the xyz-axes of the 
///rotation. This only changes how the memory is laid out for matrices, the 
///matrix interfaces do not change (and neither does the code that uses them).
///The reason why this should be changed is for the memory layout with respect 
///to SIMD operations. Early versions of SSE (2 and 3) are more efficient with
///column operations (so basis vectors in the rows, I know it's backwards but go 
///with it), and xmvector and SSE 4 are more efficient with row operations (so 
///basis vectors in the columns).
#ifndef ColumnBasis
#define ColumnBasis 1
#endif





namespace Math
{

///Forward declaration
struct Quaternion;
typedef const Quaternion& QuatParam;

///Forward declaration
struct Matrix4;
typedef const Matrix4& Mat4Param;

struct Matrix3;
typedef Matrix3 Mat3;
typedef const Matrix3& Mat3Param;
typedef Matrix3& Mat3Ref;
typedef Matrix3* Mat3Ptr;

//--------------------------------------------------------------------- Matrix 3
///3 dimensional square matrix. Supports operations with other 3 dimensional
///square matrices, 2 dimensional vectors, and 3 dimensional vectors.
struct Matrix3
{
#if ColumnBasis == 1
typedef Vector3   BasisVector;
typedef Vec3Param CrossVector;
#else
typedef Vec3Param BasisVector;
typedef Vector3   CrossVector;
#endif

public:
  Matrix3(void) {};
  explicit Matrix3(real p00, real p01, real p02, 
                   real p10, real p11, real p12,
                   real p20, real p21, real p22);
  Matrix3(ConstRealPointer data_);

  //Binary assignment operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary operators (reals)
  Matrix3 operator*(real rhs) const;
  Matrix3 operator/(real rhs) const;

  //Binary assignment operators (matrices)
  void operator+=(Mat3Param rhs);
  void operator-=(Mat3Param rhs);
  
  //Binary operators (matrices)
  Matrix3 operator+(Mat3Param rhs) const;
  Matrix3 operator-(Mat3Param rhs) const;
  Matrix3 operator*(Mat3Param rhs) const;

  //Matrix comparisons
  bool operator==(Mat3Param rhs) const;
  bool operator!=(Mat3Param rhs) const;

  real operator()(uint r, uint c) const;
  real& operator()(uint r, uint c);

  Vector3& operator[](uint index);
  const Vector3& operator[](uint index) const;

  ///Returns a copy of this matrix with its elements transposed.
  Matrix3 Transposed(void) const;

  ///Transposes this matrix in place.
  Mat3Ref Transpose(void);

  ///Returns the inverse of this matrix.
  Matrix3 Inverted(void) const;

  ///Inverts this matrix in place.
  Mat3Ref Invert(void);

  ///Inverts, but clamps the determinant to the smallest positive float number.
  Matrix3 SafeInverted() const;

  ///Inverts in place, but clamps the determinant to the smallest positive float number.
  void SafeInvert();

  ///Multiplies this matrix with the given matrix on its right-hand side.
  Matrix3 Concat(Mat3Param rhs) const;

  ///Sets this matrix's elements to that of the identity matrix.
  Mat3Ref SetIdentity(void);

  ///Sets all of the elements in this matrix to 0.
  Mat3Ref ZeroOut(void);

  real Determinant(void) const;

  bool Valid(void) const;

  ///Converts this matrix into a pure scaling matrix.
  void Scale(real x, real y, real z);

  ///Converts this matrix into a pure scaling matrix.
  void Scale(Vec3Param rhs);

  ///Converts this matrix into a pure rotation matrix, given an axis-angle pair.
  void Rotate(real x, real y, real z, real radian);

  ///Converts this matrix into a pure rotation matrix, given an axis-angle pair.
  void Rotate(Vec3Param rhs, real radian);

  ///Converts this matrix into a pure translation matrix for 2-D vectors.
  void Translate(real x, real y);

  ///Converts this matrix into a pure translation matrix for 2-D vectors.
  void Translate(Vec2Param rhs);

  ///Builds a matrix that should be used on 2D points/vectors
  void BuildTransform(Vec2Param translate, real radians, Vec2Param scale);

  ///Builds a matrix that should be used on 3D points/vectors
  void BuildTransform(QuatParam rotate, Vec3Param scale);

  ///Forces the current matrix to be orthonormal.
  Mat3Ref Orthonormalize(void);

  ///Accesses the basis vector at the given index, with the basis vector defined
  ///as the basis vector of a pure rotation matrix.
  BasisVector Basis(uint index) const;

  ///Accesses the elements in the "x-axis" of the matrix, with the "x-axis" 
  ///defined as the x-axis of a pure rotation matrix.
  BasisVector BasisX(void) const;

  ///Accesses the elements in the "y-axis" of the matrix, with the "y-axis" 
  ///defined as the y-axis of a pure rotation matrix.
  BasisVector BasisY(void) const;

  ///Accesses the elements in the "z-axis" of the matrix, with the "z-axis" 
  ///defined as the z-axis of a pure rotation matrix.
  BasisVector BasisZ(void) const;

  ///Accesses the cross vector at the given index, with the cross vector defined
  ///as the elements in the matrix perpendicular to that of the corresponding
  ///basis vector.
  CrossVector Cross(uint index) const;
  void SetBasis(uint index, Vec3Param basisVector);
  void SetBasis(uint index, real x, real y, real z);
  void SetCross(uint index, Vec3Param crossVector);
  void SetCross(uint index, real x, real y, real z);

  union 
  {
    struct
    {
#if ColumnBasis == 1
      real m00, m01, m02,
           m10, m11, m12, 
           m20, m21, m22;
#else
      real m00, m10, m20,
           m01, m11, m21, 
           m02, m12, m22;
#endif 
    };
    real array[9];
  };

  static const Matrix3 cIdentity;
};

Matrix3 operator*(real lhs, Mat3Param rhs);
Matrix3 Concat(Mat3Param lhs, Mat3Param rhs);

///This builds a matrix that should be used on 2D points/vectors
Matrix3 BuildTransform(Vec2Param translate, real radians, Vec2Param scale);

///This builds a matrix that should be used on 3D points/vectors
Matrix3 BuildTransform(QuatParam rotate, Vec3Param scale);

Vector3 Transform(Mat3Param mat, Vec3Param vector);
void Transform(Mat3Param matrix, Vec3Ptr vector);

/// Applies transformation with the translation (p.x, p.y, 1)
Vector2 TransformPoint(Mat3Param matrix, Vec2Param vector);

/// Applies transformation without the translation (n.x, n.y, 0)
Vector2 TransformNormal(Mat3Param matrix, Vec2Param normal);

///Transforms the given vector by the matrix as if the matrix was transposed.
Vector3 TransposedTransform(Mat3Param mat, Vec3Param vector);

///Transforms the given vector by the matrix as if the matrix was transposed.
void TransposedTransform(Mat3Param matrix, Vec3Ptr vector);

real Trace(Mat3Param matrix);

real Cofactor(Mat3Param matrix, uint row, uint column);

///Takes a symmetric matrix and diagonalizes it.
void Diagonalize(Mat3Ptr matrix);
Matrix3 Diagonalized(Mat3Param matrix);

void Invert(Mat3Ptr matrix);
Matrix3 Inverted(Mat3Param matrix);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix4.hpp
/// Declaration of the Matrix 4 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once






namespace Math
{
///Forward declaration
struct Quaternion;
typedef const Quaternion& QuatParam;

///Forward declaration
struct Matrix3;
typedef const Matrix3& Mat3Param;
typedef Matrix3* Mat3Ptr;

struct Matrix4;
typedef Matrix4 Mat4;
typedef const Matrix4& Mat4Param;
typedef Matrix4& Mat4Ref;
typedef Matrix4* Mat4Ptr;

///4 dimensional square matrix. Supports operations with other 4 dimensional
///square matrices, 3 dimensional vectors, and 4 dimensional vectors.
struct Matrix4
{
#if ColumnBasis == 1
typedef Vector4   BasisVector;
typedef Vec4Param CrossVector;
#else
typedef Vec4Param BasisVector;
typedef Vector4   CrossVector;
#endif

public:
  Matrix4(void) {};
  Matrix4(real p00, real p01, real p02, real p03,
          real p10, real p11, real p12, real p13,
          real p20, real p21, real p22, real p23,
          real p30, real p31, real p32, real p33);
  Matrix4(ConstRealPointer data_);
  Matrix4(Vec4Param basisX, Vec4Param basisY,
          Vec4Param basisZ, Vec4Param basisW);

  //Binary assignment operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary operators (reals)
  Matrix4 operator*(real rhs) const;
  Matrix4 operator/(real rhs) const;

  //Binary assignment operators (matrices)
  void operator+=(Mat4Param rhs);
  void operator-=(Mat4Param rhs);

  //Binary operators (matrices)
  Matrix4 operator+(Mat4Param rhs) const;
  Matrix4 operator-(Mat4Param rhs) const;
  Matrix4 operator*(Mat4Param rhs) const;

  //Matrix comparisons
  bool operator==(Mat4Param rhs) const;
  bool operator!=(Mat4Param rhs) const;

  real operator()(uint r, uint c) const;
  real& operator()(uint r, uint c);

  ///Returns a copy of this matrix with its elements transposed.
  Matrix4 Transposed(void) const;

  //Transposes this matrix in place.
  Mat4Ref Transpose(void);

  ///Returns the inverse of this matrix.
  Matrix4 Inverted(void) const;

  ///Inverts this matrix in place.
  Mat4Ref Invert(void);

  ///Multiplies this matrix with the given matrix on its right-hand side.
  Matrix4 Concat(Mat4Param rhs) const;

  ///Sets this matrix's elements to that of the identity matrix.
  Mat4Ref SetIdentity(void);

  ///Sets all of the elements in this matrix to 0.
  Mat4Ref ZeroOut(void);

  real Determinant(void) const;
  bool Valid(void) const;

  ///Converts this matrix into a pure scaling matrix.
  void Scale(real x, real y, real z);

  ///Converts this matrix into a pure scaling matrix.
  void Scale(Vec3Param axis);

  ///Converts this matrix into a pure rotation matrix, given an axis-angle pair.
  void Rotate(real x, real y, real z, real radians);

  ///Converts this matrix into a pure rotation matrix, given an axis-angle pair.
  void Rotate(Vec3Param axis, real radians);

  ///Converts this matrix into a pure translation matrix for 3-D vectors.
  void Translate(real x, real y, real z);

  ///Converts this matrix into a pure translation matrix for 3-D vectors.
  void Translate(Vec3Param axis);

  ///Converts this matrix into a transformation matrix, incorporating 
  ///translation, rotation, and scale. Meant for 3-D vectors.
  void BuildTransform(Vec3Param translate, QuatParam rotate, Vec3Param scale);

  ///Converts this matrix into a transformation matrix, incorporating 
  ///translation, rotation, and scale. Meant for 3-D vectors.
  void BuildTransform(Vec3Param translate, Mat3Param rotate, Vec3Param scale);

  ///Decomposes this matrix into its scale, rotation, and translational
  ///components.
  void Decompose(Vec3Ptr scale, Mat3Ptr rotate, Vec3Ptr translate) const;

  ///Attempts to decompose this matrix into a scale, rotation, and translational
  ///component while removing shear. The "original" matrix is not necessarily
  ///recovered, though the resulting matrix is orthonormal among its components.
  void Decompose(Vec3Ptr scale, Vec3Ptr shear, Mat3Ptr rotate, 
                 Vec3Ptr translate) const;

  ///Accesses the basis vector at the given index, with the basis vector defined
  ///as the basis vector of a pure rotation matrix.
  BasisVector Basis(uint index) const;

  ///Accesses the elements in the "x-axis" of the matrix, with the "x-axis" 
  ///defined as the x-axis of a pure rotation matrix.
  BasisVector BasisX(void) const;

  ///Accesses the elements in the "y-axis" of the matrix, with the "y-axis" 
  ///defined as the y-axis of a pure rotation matrix.
  BasisVector BasisY(void) const;

  ///Accesses the elements in the "z-axis" of the matrix, with the "z-axis" 
  ///defined as the z-axis of a pure rotation matrix.
  BasisVector BasisZ(void) const;

  ///Accesses the elements in the "w-axis" of the matrix, with the "w-axis" 
  ///defined as the w-axis of a pure rotation matrix.
  BasisVector BasisW(void) const;

  ///Accesses the cross vector at the given index, with the cross vector defined
  ///as the elements in the matrix perpendicular to that of the corresponding
  ///basis vector.
  CrossVector Cross(uint index) const;
  void SetBasis(uint index, Vec4Param basisVector);
  void SetBasis(uint index, Vec3Param basisVector3, real w);
  void SetBasis(uint index, real x, Vec3Param basisVector3);
  void SetBasis(uint index, real x, real y, real z, real w);
  void SetCross(uint index, Vec4Param crossVector);
  void SetCross(uint index, Vec3Param crossVector3, real w);
  void SetCross(uint index, real x, real y, real z, real w);

  ///Accesses the 3-D basis vector at the given index, ignores the last element.
  Vector3 Basis3(uint index) const;

  ///Accesses the first 3 elements in the "x-axis" of the matrix, ignoring the
  ///last element.
  Vector3 Basis3X(void) const;

  ///Accesses the first 3 elements in the "y-axis" of the matrix, ignoring the
  ///last element.
  Vector3 Basis3Y(void) const;
  
  ///Accesses the first 3 elements in the "z-axis" of the matrix, ignoring the
  ///last element.
  Vector3 Basis3Z(void) const;

  ///Accesses the first 3 elements in the "w-axis" of the matrix, ignoring the
  ///last element.
  Vector3 Basis3W(void) const;

  ///Accesses the 3-D cross vector at the given index, ignores the last element.
  Vector3 Cross3(uint index) const;

  Vector4& operator[](uint index){return ((Vector4*)this)[index];}
  const Vector4& operator[](uint index)const{return ((Vector4*)this)[index];}

  union 
  {
    struct
    {
#if ColumnBasis == 1
      real m00, m01, m02, m03, 
           m10, m11, m12, m13, 
           m20, m21, m22, m23, 
           m30, m31, m32, m33;
#else
      real m00, m10, m20, m30, 
           m01, m11, m21, m31, 
           m02, m12, m22, m32, 
           m03, m13, m23, m33;
#endif
    };

    real array[16];
  };

  static const Matrix4 cIdentity;
};

Matrix4 operator*(real lhs, Mat4Param rhs);
Matrix4 Concat(Mat4Param lhs, Mat4Param rhs);

Matrix4 BuildTransform(Vec3Param translate, QuatParam rotate, Vec3Param scale);
Matrix4 BuildTransform(Vec3Param translate, Mat3Param rotate, Vec3Param scale);

Vector4 Transform(Mat4Param mat, Vec4Param vector);
void Transform(Mat4Param mat, Vec4Ptr vector);

///Applies transformation with the translation (p.x, p.y, p.z, 1)
Vector3 TransformPoint(Mat4Param matrix, Vec3Param point);

///Applies transformation without the translation (n.x, n.y, n.z, 0)
Vector3 TransformNormal(Mat4Param matrix, Vec3Param normal);

///Applies transform and projects back to (w = 1)
Vector3 TransformPointProjected(Mat4Param matrix, Vec3Param point);

Vector3 TransformNormalCol(Mat4Param matrix, Vec3Param normal);
Vector3 TransformPointCol(Mat4Param matrix, Vec3Param point);
Vector3 TransformPointProjectedCol(Mat4Param matrix, Vec3Param point);
Vector3 TransformPointProjectedCol(Mat4Param matrix, Vec3Param point, real* w);

real Trace(Mat4Param matrix);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Quaternion.hpp
/// Declaration of the Quaternion structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once







namespace Math
{

///Forward declaration
struct Matrix3;
typedef const Matrix3& Mat3Param;
typedef Matrix3& Mat3Ref;

///Forward declaration
struct Matrix4;
typedef const Matrix4& Mat4Param;
typedef Matrix4& Mat4Ref;

struct Quaternion;
typedef const Quaternion& QuatParam;
typedef Quaternion& QuatRef;
typedef Quaternion* QuatPtr;
typedef Quaternion Quat;

//------------------------------------------------------------------- Quaternion
struct Quaternion
{
  static const Quaternion cIdentity;

  Quaternion(void) {};
  explicit Quaternion(real x, real y, real z, real w);

  void operator=(QuatParam rhs);
  void operator+=(QuatParam rhs);
  void operator-=(QuatParam rhs);
  void operator*=(QuatParam rhs);
  void operator*=(real rhs);
  void operator/=(real rhs);

  Quaternion operator-(void) const;

  Quaternion operator*(QuatParam rhs) const;
  Quaternion operator+(QuatParam rhs) const;
  Quaternion operator-(QuatParam rhs) const;
  Quaternion operator*(real rhs) const;
  Quaternion operator/(real rhs) const;

  bool operator==(QuatParam rhs) const;
  bool operator!=(QuatParam rhs) const;

  real& operator[](uint index);
  real operator[](uint index) const;

  void Set(real x, real y, real z, real w);

  void Integrate(Vec3Param vector, real scalar);

  real Normalize(void);
  Quaternion Normalized(void) const;
  real Dot(QuatParam rhs) const;
  real Length(void) const;
  real LengthSq(void) const;

  void Conjugate(void);
  Quaternion Conjugated(void) const;
  void Invert(void);
  Quaternion Inverted(void) const;
  Quaternion Exponent(void) const;
  Quaternion Logarithm(void) const;
  //Quaternion Lerp(QuatParam end, real tValue);
  //Quaternion Slerp(QuatParam end, real tValue);
  void RotateVector(Vec3Ptr vector);
  Vector3 RotatedVector(Vec3Param vector) const;
  void ZeroOut(void);

  bool Valid(void) const;

  Vector3& V3();
  Vector4& V4();
  const Vector3& V3() const;
  const Vector4& V4() const;

  real x, y, z, w;
};

Quaternion operator*(real lhs, QuatParam rhs);

void Normalize(QuatPtr quaternion);
Quaternion Normalized(QuatParam quaternion);
real Dot(QuatParam lhs, QuatParam rhs);
real Length(QuatParam quaternion);
real LengthSq(QuatParam quaternion);
Quaternion Lerp(QuatParam start, QuatParam end, real tValue);
Quaternion Slerp(QuatParam start, QuatParam end, real tValue);
Quaternion CreateDiagonalizer(Mat3Param matrix);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
///  \file EulerAngles.hpp
///  Declaration of the EulerAngle structure, interface referenced from
///  Insomniac Games, implementation referenced from Graphics Gems IV.
///  
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
///  \file EulerOrder.hpp
///  Declaration of the Euler angles order as described in Graphic Gems IV,
///  EulerOrder design referenced from Insomniac Games.
///  
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Math
{

/*
  Ken Shoemake, 1993

  Order type constants, constructors, extractors
    There are 24 possible conventions, designated by:
       - EulAxI = axis used initially
       - EulPar = parity of axis permutation
       - EulRep = repetition of initial axis as last
       - EulFrm = frame from which axes are taken
    Axes I, J, K will be a permutation of X, Y, Z.
    Axis H will be either I or K, depending on EulRep.
    Frame S takes axes from initial static frame.
    If ord = (AxI = X, Par = Even, Rep = No, Frm = S), then
    {a, b, c, ord} means Rz(c)Ry(b)Rx(a), where Rz(c)v
    rotates v around Z by c radians
*/
namespace EulerOrders
{

const uint Safe[4] = { 0, 1, 2, 0 };
const uint Next[4] = { 1, 2, 0, 1 };

///The two different types of reference frames
const uint Static  = 0;
const uint Rotated = 1;

///The two different states of "is there a repeated axis?"
const uint No  = 0;
const uint Yes = 1;

///Two different states of parity
const uint Even = 0;
const uint Odd  = 1;

///CreateOrder creates an order value between 0 and 23 from 4-tuple choices.
#define CreateOrder(axis, parity, repeated, frame) (((((((axis) << 1)      + \
                                                         (parity)) << 1)   + \
                                                         (repeated)) << 1) + \
                                                         (frame))

///Bit fields to describe the different permutations of rotations, reference
///frames, repeated axes, and parity
enum Enum
{
  X = 0,
  Y,
  Z,

  //Static axes
  XYZs = CreateOrder(X, Even, No,  Static),
  XYXs = CreateOrder(X, Even, Yes, Static),
  XZYs = CreateOrder(X, Odd,  No,  Static),
  XZXs = CreateOrder(X, Odd,  Yes, Static),

  YZXs = CreateOrder(Y, Even, No,  Static),
  YZYs = CreateOrder(Y, Even, Yes, Static),
  YXZs = CreateOrder(Y, Odd,  No,  Static),
  YXYs = CreateOrder(Y, Odd,  Yes, Static),
  
  ZXYs = CreateOrder(Z, Even, No,  Static),
  ZXZs = CreateOrder(Z, Even, Yes, Static),
  ZYXs = CreateOrder(Z, Odd,  No,  Static),
  ZYZs = CreateOrder(Z, Odd,  Yes, Static),

  //Rotating axes
  ZYXr = CreateOrder(X, Even, No,  Rotated),
  XYXr = CreateOrder(X, Even, Yes, Rotated),
  YZXr = CreateOrder(X, Odd,  No,  Rotated),
  XZXr = CreateOrder(X, Odd,  Yes, Rotated),
  
  XZYr = CreateOrder(Y, Even, No,  Rotated),
  YZYr = CreateOrder(Y, Even, Yes, Rotated),
  ZXYr = CreateOrder(Y, Odd,  No,  Rotated),
  YXYr = CreateOrder(Y, Odd,  Yes, Rotated),

  YXZr = CreateOrder(Z, Even, No,  Rotated),
  ZXZr = CreateOrder(Z, Even, Yes, Rotated),
  XYZr = CreateOrder(Z, Odd,  No,  Rotated),
  ZYZr = CreateOrder(Z, Odd,  Yes, Rotated)
};

#undef CreateOrder

}// namespace EulerOrders

struct EulerOrder;
typedef EulerOrder&       EulerOrderRef;
typedef const EulerOrder& EulerOrderParam;

///Structure to hold the order of rotations when dealing with Euler angles,
///whether or not there are any repeating angles, and if the rotations are being
///described in a fixed or rotated frame of reference.
struct EulerOrder
{
  EulerOrder(EulerOrders::Enum eulerOrder);

  EulerOrder& operator = (EulerOrderParam rhs);

  bool operator == (EulerOrderParam rhs);
  bool operator != (EulerOrderParam rhs);

  ///Get the index of the first angle in the Euler angle rotation sequence.
  uint I(void) const;

  ///Get the index of the second angle in the Euler angle rotation sequence.
  uint J(void) const;

  ///Get the index of the third angle in the Euler angle rotation sequence.
  uint K(void) const;

  ///Will be I if there are repeating angles, will be K otherwise.
  uint H(void) const;

  bool RepeatingAngles(void) const;
  bool RotatingFrame(void) const;
  bool OddParity(void) const;

  ///Unpacks all useful information about order simultaneously.
  static void GetOrder(EulerOrder order, uint& i, uint& j, uint& k, uint& h, 
                       uint& parity, uint& repeated, uint& frame);

  EulerOrders::Enum Order;
};

}// namespace Math



namespace Math
{

///Forward declaration
struct Matrix3;
typedef const Matrix3& Mat3Param;
typedef Matrix3& Mat3Ref;

///Forward declaration
struct Matrix4;
typedef const Matrix4& Mat4Param;
typedef Matrix4& Mat4Ref;

///Forward declaration
struct Quaternion;
typedef const Quaternion& QuatParam;
typedef Quaternion& QuatRef;

struct EulerAngles;
typedef const EulerAngles&  EulerAnglesParam;
typedef EulerAngles&        EulerAnglesRef;
typedef EulerAngles*        EulerAnglesPtr;

//----------------------------------------------------------------- Euler Angles
///Structure to provide a consistent way to deal with rotations stored as Euler
///angles.
struct EulerAngles
{
  EulerAngles(EulerOrderParam order);
  EulerAngles(Vec3Param xyzRotation, EulerOrderParam order);
  EulerAngles(real xRotation, real yRotation, real zRotation, 
              EulerOrderParam order);
  EulerAngles(Mat3Param matrix, EulerOrderParam order);
  EulerAngles(Mat4Param matrix, EulerOrderParam order);
  EulerAngles(QuatParam quaternion, EulerOrderParam order);

  ///Index operator to access the Angles data directly.
  real operator [] (uint index) const;

  ///Index operator to access the Angles data directly.
  real& operator [] (uint index);


  real I(void) const;
  real J(void) const;
  real K(void) const;
  real H(void) const;

  void I(real i);
  void J(real j);
  void K(real k);
  void H(real h);

  void Reorder(EulerOrderParam newOrder);

  Vector3     Angles;
  EulerOrder  Order;
};

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file IntVector2.hpp
/// Declaration of the IntVector2 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Math
{

struct IntVector2;
typedef IntVector2 IntVec2;
typedef const IntVector2& IntVec2Param;
typedef IntVector2& IntVec2Ref;
typedef IntVector2* IntVec2Ptr;

///2 dimensional integral vector.
struct IntVector2
{
  IntVector2(void) {}
  explicit IntVector2(int x, int y);

  int& operator[](uint index);
  int operator[](uint index) const;

  //Unary Operators
  IntVector2 operator-(void) const;

  //Binary Assignment Operators (integers)
  void operator*=(int rhs);
  void operator/=(int rhs);

  //Binary Operators (integers)
  IntVector2 operator*(int rhs) const;
  IntVector2 operator/(int rhs) const;
  IntVector2 operator%(int rhs) const;

  //Unary operators
  IntVector2& operator++();
  IntVector2& operator--();

  //Binary Assignment Operators (vectors)
  void operator+=(IntVec2Param rhs);
  void operator-=(IntVec2Param rhs);
  void operator*=(IntVec2Param rhs);
  void operator/=(IntVec2Param rhs);

  //Binary Operators (vectors)
  IntVector2 operator+(IntVec2Param rhs) const;
  IntVector2 operator-(IntVec2Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(IntVec2Param rhs) const;
  bool operator!=(IntVec2Param rhs) const;

  //Vector component-wise multiply and divide
  IntVector2 operator*(IntVec2Param rhs) const;
  IntVector2 operator/(IntVec2Param rhs) const;
  IntVector2 operator%(IntVec2Param rhs) const;
  
  //Bitwise operators
  IntVector2  operator~() const;
  IntVector2  operator<< (IntVec2Param rhs) const;
  IntVector2  operator>> (IntVec2Param rhs) const;
  IntVector2  operator|  (IntVec2Param rhs) const;
  IntVector2  operator^  (IntVec2Param rhs) const;
  IntVector2  operator&  (IntVec2Param rhs) const;
  IntVector2& operator<<=(IntVec2Param rhs);
  IntVector2& operator>>=(IntVec2Param rhs);
  IntVector2& operator|= (IntVec2Param rhs);
  IntVector2& operator^= (IntVec2Param rhs);
  IntVector2& operator&= (IntVec2Param rhs);

  //Comparison operators
  BoolVec2 operator< (IntVec2Param rhs) const;
  BoolVec2 operator<=(IntVec2Param rhs) const;
  BoolVec2 operator> (IntVec2Param rhs) const;
  BoolVec2 operator>=(IntVec2Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(int x, int y);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  union
  {
    struct  
    {
      int x, y;
    };
    int array[2];
  };

  static const IntVector2 cZero;
  static const IntVector2 cXAxis;
  static const IntVector2 cYAxis;
};

///Binary Operators (integers)
IntVector2 operator*(int lhs, IntVec2Param rhs);

///Returns a vector with absolute valued elements of the given vector.
IntVector2 Abs(IntVec2Param vec);

///Returns the component-wise minimum vector of the two vectors.
IntVector2 Min(IntVec2Param lhs, IntVec2Param rhs);

///Returns the component-wise maximum vector of the two vectors.
IntVector2 Max(IntVec2Param lhs, IntVec2Param rhs);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file IntVector3.hpp
/// Declaration of the IntVector3 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Math
{

struct IntVector3;
typedef IntVector3 IntVec3;
typedef const IntVector3& IntVec3Param;
typedef IntVector3& IntVec3Ref;
typedef IntVector3* IntVec3Ptr;

///3 dimensional integral vector.
struct IntVector3
{
  IntVector3(void) {}
  explicit IntVector3(int x, int y, int z);

  int& operator[](uint index);
  int operator[](uint index) const;

  //Unary Operators
  IntVector3 operator-(void) const;

  //Binary Assignment Operators (integers)
  void operator*=(int rhs);
  void operator/=(int rhs);

  //Binary Operators (integers)
  IntVector3 operator*(int rhs) const;
  IntVector3 operator/(int rhs) const;
  IntVector3 operator%(int rhs) const;

  //Unary operators
  IntVector3& operator++();
  IntVector3& operator--();

  //Binary Assignment Operators (vectors)
  void operator+=(IntVec3Param rhs);
  void operator-=(IntVec3Param rhs);
  void operator*=(IntVec3Param rhs);
  void operator/=(IntVec3Param rhs);

  //Binary Operators (vectors)
  IntVector3 operator+(IntVec3Param rhs) const;
  IntVector3 operator-(IntVec3Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(IntVec3Param rhs) const;
  bool operator!=(IntVec3Param rhs) const;

  //Vector component-wise multiply and divide
  IntVector3 operator*(IntVec3Param rhs) const;
  IntVector3 operator/(IntVec3Param rhs) const;
  IntVector3 operator%(IntVec3Param rhs) const;
  
  //Bitwise operators
  IntVector3  operator~() const;
  IntVector3  operator<< (IntVec3Param rhs) const;
  IntVector3  operator>> (IntVec3Param rhs) const;
  IntVector3  operator|  (IntVec3Param rhs) const;
  IntVector3  operator^  (IntVec3Param rhs) const;
  IntVector3  operator&  (IntVec3Param rhs) const;
  IntVector3& operator<<=(IntVec3Param rhs);
  IntVector3& operator>>=(IntVec3Param rhs);
  IntVector3& operator|= (IntVec3Param rhs);
  IntVector3& operator^= (IntVec3Param rhs);
  IntVector3& operator&= (IntVec3Param rhs);

  //Comparison operators
  BoolVec3 operator< (IntVec3Param rhs) const;
  BoolVec3 operator<=(IntVec3Param rhs) const;
  BoolVec3 operator> (IntVec3Param rhs) const;
  BoolVec3 operator>=(IntVec3Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(int x, int y, int z);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  union
  {
    struct  
    {
      int x, y, z;
    };
    int array[3];
  };

  static const IntVector3 cZero;
  static const IntVector3 cXAxis;
  static const IntVector3 cYAxis;
  static const IntVector3 cZAxis;
};

///Binary Operators (integers)
IntVector3 operator*(int lhs, IntVec3Param rhs);

///Returns a vector with absolute valued elements of the given vector.
IntVector3 Abs(IntVec3Param vec);

///Returns the component-wise minimum vector of the two vectors.
IntVector3 Min(IntVec3Param lhs, IntVec3Param rhs);

///Returns the component-wise maximum vector of the two vectors.
IntVector3 Max(IntVec3Param lhs, IntVec3Param rhs);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file IntVector4.hpp
/// Declaration of the IntVector4 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Math
{

struct IntVector4;
typedef IntVector4 IntVec4;
typedef const IntVector4& IntVec4Param;
typedef IntVector4& IntVec4Ref;
typedef IntVector4* IntVec4Ptr;

///3 dimensional integral vector.
struct IntVector4
{
  IntVector4(void) {}
  explicit IntVector4(int x, int y, int z, int w);

  int& operator[](uint index);
  int operator[](uint index) const;

  //Unary Operators
  IntVector4 operator-(void) const;

  //Binary Assignment Operators (integers)
  void operator*=(int rhs);
  void operator/=(int rhs);

  //Binary Operators (integers)
  IntVector4 operator*(int rhs) const;
  IntVector4 operator/(int rhs) const;
  IntVector4 operator%(int rhs) const;

  //Unary operators
  IntVector4& operator++();
  IntVector4& operator--();

  //Binary Assignment Operators (vectors)
  void operator+=(IntVec4Param rhs);
  void operator-=(IntVec4Param rhs);
  void operator*=(IntVec4Param rhs);
  void operator/=(IntVec4Param rhs);

  //Binary Operators (vectors)
  IntVector4 operator+(IntVec4Param rhs) const;
  IntVector4 operator-(IntVec4Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(IntVec4Param rhs) const;
  bool operator!=(IntVec4Param rhs) const;

  //Vector component-wise multiply and divide
  IntVector4 operator*(IntVec4Param rhs) const;
  IntVector4 operator/(IntVec4Param rhs) const;
  IntVector4 operator%(IntVec4Param rhs) const;
  
  //Bitwise operators
  IntVector4  operator~() const;
  IntVector4  operator<< (IntVec4Param rhs) const;
  IntVector4  operator>> (IntVec4Param rhs) const;
  IntVector4  operator|  (IntVec4Param rhs) const;
  IntVector4  operator^  (IntVec4Param rhs) const;
  IntVector4  operator&  (IntVec4Param rhs) const;
  IntVector4& operator<<=(IntVec4Param rhs);
  IntVector4& operator>>=(IntVec4Param rhs);
  IntVector4& operator|= (IntVec4Param rhs);
  IntVector4& operator^= (IntVec4Param rhs);
  IntVector4& operator&= (IntVec4Param rhs);

  //Comparison operators
  BoolVec4 operator< (IntVec4Param rhs) const;
  BoolVec4 operator<=(IntVec4Param rhs) const;
  BoolVec4 operator> (IntVec4Param rhs) const;
  BoolVec4 operator>=(IntVec4Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(int x, int y, int z, int w);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  union
  {
    struct  
    {
      int x, y, z, w;
    };
    int array[4];
  };

  static const IntVector4 cZero;
  static const IntVector4 cXAxis;
  static const IntVector4 cYAxis;
  static const IntVector4 cZAxis;
  static const IntVector4 cWAxis;
};

///Binary Operators (integers)
IntVector4 operator*(int lhs, IntVec4Param rhs);

///Returns a vector with absolute valued elements of the given vector.
IntVector4 Abs(IntVec4Param vec);

///Returns the component-wise minimum vector of the two vectors.
IntVector4 Min(IntVec4Param lhs, IntVec4Param rhs);

///Returns the component-wise maximum vector of the two vectors.
IntVector4 Max(IntVec4Param lhs, IntVec4Param rhs);

}// namespace Math


namespace Math
{

///Creates a skew symmetric matrix from the given 3D vector. Multiplying a 
///vector by this matrix is equivalent to the cross product using the input 
///vector.
Matrix3 SkewSymmetric(Vec3Param vec3);

/// Projects the input vector onto a plane (the normal must be normalized)
Vector2 ProjectOnVector(Vec2Param input, Vec2Param normalizedVector);
/// Projects the input vector onto a plane (the normal must be normalized)
Vector3 ProjectOnVector(Vec3Param input, Vec3Param normalizedVector);
/// Projects the input vector onto a plane (the normal must be normalized)
Vector4 ProjectOnVector(Vec4Param input, Vec4Param normalizedVector);
/// Projects the input vector onto the given vector (must be normalized)
Vector2 ProjectOnPlane(Vec2Param input, Vec2Param planeNormal);
/// Projects the input vector onto the given vector (must be normalized)
Vector3 ProjectOnPlane(Vec3Param input, Vec3Param planeNormal);
/// Projects the input vector onto the given vector (must be normalized)
Vector4 ProjectOnPlane(Vec4Param input, Vec4Param planeNormal);

/// Calculates the reflection vector across a given vector.
Vector2 ReflectAcrossVector(Vec2Param input, Vec2Param normalizedVector);
/// Calculates the reflection vector across a given vector.
Vector3 ReflectAcrossVector(Vec3Param input, Vec3Param normalizedVector);
/// Calculates the reflection vector across a given vector.
Vector4 ReflectAcrossVector(Vec4Param input, Vec4Param normalizedVector);
/// Calculates the reflection vector across a given plane.
Vector2 ReflectAcrossPlane(Vec2Param input, Vec2Param planeNormal);
/// Calculates the reflection vector across a given plane.
Vector3 ReflectAcrossPlane(Vec3Param input, Vec3Param planeNormal);
/// Calculates the reflection vector across a given plane.
Vector4 ReflectAcrossPlane(Vec4Param input, Vec4Param planeNormal);

/// Calculates the refraction vector through a plane given a certain index of refraction.
Vector2 Refract(Vec2Param input, Vec2Param planeNormal, real refractionIndex);
/// Calculates the refraction vector through a plane given a certain index of refraction.
Vector3 Refract(Vec3Param input, Vec3Param planeNormal, real refractionIndex);
/// Calculates the refraction vector through a plane given a certain index of refraction.
Vector4 Refract(Vec4Param input, Vec4Param planeNormal, real refractionIndex);

///Converts a quaternion to an axis-angle pair (in radians). Axis is stored in 
///the Vector4's xyz and the angle is stored in the w.
Vector4 ToAxisAngle(QuatParam quaternion);
void ToAxisAngle(QuatParam quaternion, Vec4Ptr axisAngle);

///Converts a quaternion to an axis-angle pair (in radians).
void ToAxisAngle(QuatParam quaternion, Vec3Ptr axis, real* radians);

///Convert a 3x3 matrix to a set of Euler angles (in radians). The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(Mat3Param matrix, 
                          EulerOrders::Enum order = EulerOrders::XYZs);
void ToEulerAngles(Mat3Param matrix, EulerAnglesPtr eulerAngles);

///Convert a 4x4 matrix to a set of Euler angles in radians. The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(Mat4Param matrix,
                          EulerOrders::Enum order = EulerOrders::XYZs);
void ToEulerAngles(Mat4Param matrix, EulerAnglesPtr eulerAngles);

///Convert a quaternion to a set of Euler angles (in radians). The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(QuatParam quaternion, 
                          EulerOrders::Enum order = EulerOrders::XYZs);
void ToEulerAngles(QuatParam quaternion, EulerAnglesPtr eulerAngles);

/// Converts from Vector3 to Vector2, removing the z component of the Vector3.
Vector2 ToVector2(Vec3Param v3);

/// Converts from Vector2 to Vector3, adding the given z component.
Vector3 ToVector3(Vec2Param v, real z = real(0.0));

/// Converts from Vector3 to Vector4, adding the given w component.
inline Vec4 ToVector4(Vec3Param v, real w = real(0.0)){return Vec4(v.x, v.y, v.z, w);}

// Convert from a IntVec2 to a Vec2
inline Vec2 ToVec2(IntVec2 v){return Vec2(real(v.x), real(v.y));}

// Convert from a Vec2 to a IntVec2 standard float to int conversion
inline IntVec2 ToIntVec2(Vec2 vec2){return IntVec2(int(vec2.x), int(vec2.y));}

/// Turns the 3D transformation matrix into 2D.
Matrix3 ProjectXY(Mat4Param mat4);

///Converts an axis-angle pair to a 3x3 (in radians). Axis is stored in the
///Vector4's xyz and the angle is stored in the w. Axis is assumed to be 
///normalized.
Matrix3 ToMatrix3(Vec4Param axisAngle);
void ToMatrix3(Vec4Param axisAngle, Mat3Ptr matrix);

///Converts an axis-angle pair to a 3x3 matrix (in radians). Axis is assumed to
///be normalized.
Matrix3 ToMatrix3(Vec3Param axis, real radians);
void ToMatrix3(Vec3Param axis, real radians, Mat3Ptr matrix);

///Convert a set of Euler angles to a 3x3 matrix (in radians).
Matrix3 ToMatrix3(EulerAnglesParam eulerAngles);
void ToMatrix3(EulerAnglesParam eulerAngles, Mat3Ptr matrix);

///Convert a 4x4 matrix to a 3x3 matrix. Simply copies the 4x4 matrix's upper 
///3x3 matrix (rotation & scale) to the 3x3 matrix.
Matrix3 ToMatrix3(Mat4Param matrix4);
void ToMatrix3(Mat4Param matrix4, Mat3Ptr matrix3);

///Converts a quaternion to a 3x3 rotation matrix (in radians).
Matrix3 ToMatrix3(QuatParam quaternion);
void ToMatrix3(QuatParam quaternion, Mat3Ptr matrix);

Matrix3 ToMatrix3(Vec3Param facing);
Matrix3 ToMatrix3(Vec3Param facing, Vec3Param up);
Matrix3 ToMatrix3(Vec3Param facing, Vec3Param up, Vec3Param right);

///Convert a set of Euler angles to a 4x4 matrix (in radians).
Matrix4 ToMatrix4(EulerAnglesParam eulerAngles);
void ToMatrix4(EulerAnglesParam eulerAngles, Mat4Ptr matrix);

///Convert a 3x3 matrix to a 4x4 matrix. Simply copies the 3x3 matrix's values
///into the rotational part of the 4x4 matrix.
Matrix4 ToMatrix4(Mat3Param matrix3);
void ToMatrix4(Mat3Param matrix3, Mat4Ptr matrix4);

///Converts a quaternion to a 4x4 rotation matrix (in radians).
Matrix4 ToMatrix4(QuatParam quaternion);
void ToMatrix4(QuatParam quaternion, Mat4Ptr matrix);

///Converts an axis-angle pair to a quaternion (in radians). Axis is stored in
///the Vector4's xyz and the angle is stored in the w. Axis is assumed to be 
///normalized.
Quaternion ToQuaternion(Vec4Param axisAngle);
void ToQuaternion(Vec4Param axisAngle, QuatPtr quaternion);

///Converts an axis-angle pair to a quaternion (in radians). Axis is assumed to
///be normalized.
Quaternion ToQuaternion(Vec3Param axis, real radians);
void ToQuaternion(Vec3Param axis, real radians, QuatPtr quaternion);

///Convert a set of Euler angles to a quaternion (in radians).
Quaternion ToQuaternion(Vec3Param eulerVector);

///Convert a set of Euler angles to a quaternion (in radians).
Quaternion ToQuaternion(EulerAnglesParam eulerAngles);
void ToQuaternion(EulerAnglesParam eulerAngles, QuatPtr quaternion);

///Converts a 3x3 matrix to a quaternion (in radians).
Quaternion ToQuaternion(Mat3Param matrix);
void ToQuaternion(Mat3Param matrix, QuatPtr quaternion);

///Converts a 4x4 matrix to a quaternion (in radians).
Quaternion ToQuaternion(Mat4Param matrix);
void ToQuaternion(Mat4Param matrix, QuatPtr quaternion);

Quaternion ToQuaternion(Vec3Param facing, Vec3Param up);
Quaternion ToQuaternion(Vec3Param facing, Vec3Param up, Vec3Param right);
///Generates a quaternion from the x,y,z axis angles.
Quaternion ToQuaternion(real x, real y, real z);
///Generates the quaternion that rotates start to end.
Quaternion RotationQuaternionBetween(Vec3Param start, Vec3Param end);

///Generates a set of orthonormal vectors from the given vectors, modifying u 
///and v.
void GenerateOrthonormalBasis(Vec3Param w, Vec3Ptr u, Vec3Ptr v);

///Doesn't blow up on zero vectors
void DebugGenerateOrthonormalBasis(Vec3Param w, Vec3Ptr u, Vec3Ptr v);

///Perform the dot product with the specified basis vector of the 3x3 matrix and
///the given vector.
real BasisNDot(Mat3Param matrix, uint basisIndex, Vec3Param vector);

///Perform the dot product with the specified basis vector of the 3x3 matrix and
///the given vector.
real BasisNDot(Mat4Param matrix, uint basisIndex, Vec4Param vector);

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the x-axis (if the matrix is pure rotation) and the given vector.
real BasisXDot(Mat3Param matrix, Vec3Param vector);

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the y-axis (if the matrix is pure rotation) and the given vector.
real BasisYDot(Mat3Param matrix, Vec3Param vector);

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the z-axis (if the matrix is pure rotation) and the given vector.
real BasisZDot(Mat3Param matrix, Vec3Param vector);

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the x-axis (if the matrix is pure rotation) and the given vector.
real BasisXDot(Mat4Param matrix, Vec4Param vector);

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the y-axis (if the matrix is pure rotation) and the given vector.
real BasisYDot(Mat4Param matrix, Vec4Param vector);

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the z-axis (if the matrix is pure rotation) and the given vector.
real BasisZDot(Mat4Param matrix, Vec4Param vector);

///Converts a 32-bit float into a compressed 16-bit floating point value;
///referenced from Insomniac Games math library.
half ToHalf(float value);

///Converts a 16-bit compressed floating point value back into a 32-bit float;
///referenced from Insomniac Games math library.
float ToFloat(half value);

//----------------------------------------------------------- Rotation Functions
/// Get angle between two 2D vectors in radians.
real Angle(Vec2Param a, Vec2Param b);

/// Get angle between two 3D vectors in radians.
real Angle(Vec3Param a, Vec3Param b);

/// Get angle between two quaternions in radians.
real Angle(QuatParam a, QuatParam b);

/// Computes the angle about the z-axis between the vector and the x-axis
real Angle2D(Vec3Param a);

/// Spherical linear interpolation for unit 2D vectors.
/// Interpolates along the surface of the unit sphere.
Vector2 Slerp(Vec2Param start, Vec2Param end, real t);
/// Same as slerp except this function deals correctly with
/// invalid vectors. Used for binding to scripting languages.
Vector2 SafeSlerp(Vec2Param start, Vec2Param end, real t);

/// Spherical linear interpolation for unit 3D vectors.
/// Interpolates along the surface of the unit sphere.
Vector3 Slerp(Vec3Param start, Vec3Param end, real t);
/// Same as slerp except this function deals correctly with
/// invalid vectors. Used for binding to scripting languages.
Vector3 SafeSlerp(Vec3Param start, Vec3Param end, real t);

/// Rotate a 2D vector towards another 2D vector changing at most maxAngle,
/// maxAngle is in radians.
Vector2 RotateTowards(Vec2Param a, Vec2Param b, real maxAngle);
/// Same as RotateTowards except this function deals correctly with
/// invalid vectors. Used for binding to scripting languages.
Vector2 SafeRotateTowards(Vec2Param a, Vec2Param b, real maxAngle);

/// Rotate a 3D vector towards another 3D vector changing at most maxAngle,
/// maxAngle is in radians.
Vector3 RotateTowards(Vec3Param a, Vec3Param b, real maxAngle);
/// Same as RotateTowards except this function deals correctly with
/// invalid vectors. Used for binding to scripting languages.
Vector3 SafeRotateTowards(Vec3Param a, Vec3Param b, real maxAngle);

/// Rotate a quaternion towards another quaternion changing at most maxAngle,
/// maxAngle is in radians.
Quat RotateTowards(QuatParam a, QuatParam b, real maxAngle);

/// Get the rotation angle between two vectors in radians.
real SignedAngle(Vec3Param a, Vec3Param b, Vec3Param up);

/// Rotate a vector about an axis by the given angle.
Vector3 RotateVector(Vec3Param a, Vec3Param axis, real radians);

/// Converts Euler degrees to a quaternion.
Quat EulerDegreesToQuat(Vec3Param eulerDegrees);

/// Converts a quaternion to Euler degrees.
Vector3 QuatToEulerDegrees(QuatParam rotation);

}// namespace Math


// Bring Zero primitives into the Zilch namespace
namespace Zilch
{
  // Zero types
  using Zero::AutoHandle;
  using Zero::Array;
  using Zero::BaseInList;
  using Zero::BuildString;
  using Zero::EqualTo;
  using Zero::ErrorSignaler;
  using Zero::ExternalLibrary;
  using Zero::File;
  using Zero::FixedArray;
  using Zero::FixedString;
  using Zero::FindFirstIndex;
  using Zero::HashMap;
  using Zero::HashPolicy;
  using Zero::HashSet;
  using Zero::HashString;
  using Zero::InList;
  using Zero::JoinStrings;
  using Zero::Link;
  using Zero::Memory::Shutdown;
  using Zero::NullPointerType;
  using Zero::OsEvent;
  using Zero::OsInt;
  using Zero::OwnedArray;
  using Zero::PodArray;
  using Zero::Pair;
  using Zero::PodBlockArray;
  using Zero::Semaphore;
  using Zero::Socket;
  using Zero::SocketAddress;
  using Zero::sort;
  using Zero::StandardTraits;
  using Zero::Status;
  using Zero::String;
  using Zero::StringRange;
  using Zero::StringBuilder;
  using Zero::Thread;
  using Zero::ThreadLock;
  using Zero::ToValue;
  using Zero::UniquePointer;
  using Zero::ZeroMove;

  // Math types
  typedef Math::BoolVector2 Boolean2;
  typedef Math::BoolVector3 Boolean3;
  typedef Math::BoolVector4 Boolean4;
  typedef Math::IntVector2 Integer2;
  typedef Math::IntVector3 Integer3;
  typedef Math::IntVector4 Integer4;
  typedef Math::Vector2 Real2;
  typedef Math::Vector3 Real3;
  typedef Math::Vector4 Real4;
  typedef Math::Quaternion Quaternion;

  // The type we'll use for operands
  typedef signed int          OperandIndex;
  typedef signed int          OperandLocal;
  typedef signed int          ByteCodeOffset;
  typedef unsigned long long  GuidType;

  // Type-defines for the primitive language types
  typedef unsigned char       Byte;
  typedef int                 Integer;
  typedef long long int       DoubleInteger;
  typedef float               Real;
  typedef double              DoubleReal;
  typedef bool                Boolean;

  // For efficiency
  typedef const Boolean2& Boolean2Param;
  typedef const Boolean3& Boolean3Param;
  typedef const Boolean4& Boolean4Param;
  typedef const Integer2& Integer2Param;
  typedef const Integer3& Integer3Param;
  typedef const Integer4& Integer4Param;
  typedef const Real2& Real2Param;
  typedef const Real3& Real3Param;
  typedef const Real4& Real4Param;
  typedef const String& StringParam;
  typedef const Quaternion& QuaternionParam;

  // Math functions
  using Math::EulerAngles;
  using Math::ToAxisAngle;
  using Math::ToEulerAngles;
  using Math::ToQuaternion;

  // Standard types / functions
  using std::numeric_limits;
  using std::clock;
  using std::clock_t;
}

// Special macros
#define ZilchForEach(VariableName, Range) forRange(VariableName, Range)
#define ZilchForRange(VariableName, RangeName, Range) ZeroForRangeVar(VariableName, RangeName, Range)

// Zilch Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_FORWARD_DECLARATIONS_HPP
#define ZILCH_FORWARD_DECLARATIONS_HPP

namespace Zilch
{
  // Forward declarations
  class Any;
  class AnyType;
  class AttributeNode;
  class BinaryOperator;
  class BinaryOperatorNode;
  class BoundSyntaxType;
  class BoundType;
  class BreakNode;
  class Call;
  class CastOperator;
  class ClassContext;
  class ClassNode;
  class ClassType;
  class CodeFormat;
  class CodeFormatter;
  class CodeGenerator;
  class CodeLocation;
  class CollectorContext;
  class CompilationErrors;
  class ConditionalLoopNode;
  class ConstructorNode;
  class ContinueNode;
  class DebugBreakNode;
  class Debugger;
  class Delegate;
  class DelegateSyntaxParameter;
  class DelegateSyntaxType;
  class DelegateType;
  class DeleteNode;
  class DestructorNode;
  class DocumentedObject;
  class DoWhileNode;
  class EnumNode;
  class EnumValueNode;
  class EventHandler;
  class Exception;
  class ExceptionEvent;
  class ExceptionReport;
  class ExecutableState;
  class ExpressionInitializerNode;
  class ExpressionNode;
  class FatalErrorEvent;
  class Field;
  class ForEachNode;
  class ForNode;
  class Function;
  class FunctionCallNode;
  class FunctionNode;
  class GeneratorContext;
  class GeneratorWalkerDatabase;
  class GenericFunctionNode;
  class Handle;
  class HandleManager;
  class HeapManager;
  class IdentifierNode;
  class IfNode;
  class IfRootNode;
  class IndexerCallNode;
  class IndirectionSyntaxType;
  class IndirectionType;
  class InitializerNode;
  class JsonBuilder;
  class JsonValue;
  class Library;
  class LibraryBuilder;
  class LocalVariableNode;
  class LocalVariableReferenceNode;
  class LoopNode;
  class LoopScopeNode;
  class MemberAccessNode;
  class MemberVariableNode;
  class MemoryLeakEvent;
  class Module;
  class MultiExpressionNode;
  class Opcode;
  class OpcodeEvent;
  class Operand;
  class ParameterNode;
  class PerFrameData;
  class PerScopeData;
  class Plugin;
  class PointerManager;
  class PostExpressionNode;
  class Project;
  class Property;
  class PropertyDelegateOperatorNode;
  class RelativeJumpOpcode;
  class Resolver;
  class ReturnNode;
  class RootNode;
  class ScopeNode;
  class ScriptingEnginePrivateData;
  class SendsEvent;
  class SendsEventNode;
  class StackData;
  class StackManager;
  class StatementNode;
  class StaticLibrary;
  class StaticTypeNode;
  class StringBuilderClass;
  class StringInterpolantNode;
  class StringManager;
  class Syntaxer;
  class SyntaxNode;
  class SyntaxTree;
  class SyntaxType;
  class ThrowNode;
  class TimeoutNode;
  class Tokenizer;
  class Type;
  class TypeBinding;
  class TypeCastNode;
  class TypeIdNode;
  class TypingContext;
  class UnaryOperator;
  class UnaryOperatorNode;
  class UnnamedOperandNode;
  class UserToken;
  class ValueNode;
  class Variable;
  class VariableNode;
  class WhileNode;
  class ZilchCodeBuilder;
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SHARED_REFERENCE_HPP
#define ZILCH_SHARED_REFERENCE_HPP

namespace Zilch
{
  // A standard deletion policy
  template <typename Type>
  class StandardDelete
  {
  public:
    void operator()(Type* object)
    {
      // Use the standard delete operator
      delete object;
    }
  };

  // An array deletion policy
  template <typename Type>
  class ArrayDelete
  {
  public:
    void operator()(Type* object)
    {
      // Use the array delete operator
      delete[] object;
    }
  };

  class WeakPolicy
  {
  public:
    template <typename RefType>
    void AddLinkToList(RefType* ref)
    {
      // This is a hack we have to do because member pointers are stupid and don't respect the mutable flag
      // We basically use this typedef and cast our reference type to a different type then it really is
      typedef typename RefType::ReferencedType::RefLinkType::WeakType ChangedType;

      // Add ourself to the object's list of shared references
      // This will initialize our link and add it intrusively
      ref->Object->Referencers.WeakReferences.push_back((ChangedType*)ref);
    }

    template <typename RefType>
    void RemoveLinkFromList(RefType* ref)
    {
      // This is a hack we have to do because member pointers are stupid and don't respect the mutable flag
      // We basically use this typedef and cast our reference type to a different type then it really is
      typedef typename RefType::ReferencedType::RefLinkType::WeakType ChangedType;

      // Unlink ourselves from the list
      InList<ChangedType, &ChangedType::InternalLink>::Unlink((ChangedType*)ref);
    }
  };

  class NormalPolicy
  {
  public:
    template <typename RefType>
    void AddLinkToList(RefType* ref)
    {
      // This is a hack we have to do because member pointers are stupid and don't respect the mutable flag
      // We basically use this typedef and cast our reference type to a different type then it really is
      typedef typename RefType::ReferencedType::RefLinkType::SharedType ChangedRefType;
      typedef typename RefType::ReferencedType::RefLinkType::ForType ChangedType;

      ChangedRefType* changedRef = (ChangedRefType*)ref;

      // Add ourself to the object's list of shared references
      // This will initialize our link and add it intrusively
      ref->Object->Referencers.SharedReferences.push_back(changedRef);
    }

    template <typename RefType>
    void RemoveLinkFromList(RefType* ref)
    {
      // This is a hack we have to do because member pointers are stupid and don't respect the mutable flag
      // We basically use this typedef and cast our reference type to a different type then it really is
      typedef typename RefType::ReferencedType::RefLinkType::SharedType ChangedType;

      // Unlink ourselves from the list
      InList<ChangedType, &ChangedType::InternalLink>::Unlink((ChangedType*)ref);

      // If nobody else is referencing this object...
      if (ref->Object->Referencers.SharedReferences.empty())
      {
        // Get a range so we can walk over all weak references
        ZilchAutoVal(weakRefs, ref->Object->Referencers.WeakReferences.all());

        // Loop until we run out of weak references
        while (weakRefs.empty() == false)
        {
          // Get the current weak reference and iterate to the next one
          ZilchAutoRef(weakRef, weakRefs.front());
          weakRefs.popFront();

          // Set the weak reference's object to null
          weakRef.Object = nullptr;
        }

        // Clear out the weak reference list
        ref->Object->Referencers.WeakReferences.clear();

        // Invoke the deletor on the object
        ref->Deletor(ref->Object);
      }
    }
  };

  // The virtual type is used primarily for debugging
  class VirtualType
  {
  public:
    virtual ~VirtualType() = 0;
  };

  // A shared reference to a particular object
  // The shared reference requires that your class contains a
  // 'ZilchRefLink(YourClass);' member, which is intrusively
  // used as the reference count. This approach decreases memory
  // allocation and adds very little to the shared object itself
  template <typename Type, typename ModePolicy = NormalPolicy, typename DeletePolicy = StandardDelete<Type> >
  class ZeroSharedTemplate Ref
  {
  public:

    // Type-defines
    typedef Type ReferencedType;
    
    // Default constructor results in an empty reference
    Ref()
    {
      this->Object = nullptr;
    }

    // Construct the object that we are going to point to and pass it in
    Ref(Type* object, DeletePolicy deletor = DeletePolicy(), ModePolicy mode = ModePolicy())
    {
      // Store the deletor away so we can use it later
      this->Deletor = deletor;

      // Store away the mode policy
      this->Mode = mode;

      // Store the object
      this->Object = object;

      // If the object was a non null object
      if (object != nullptr)
      {
        // Add ourselves to whatever list we belong to (controlled by the policy)
        mode.AddLinkToList(this);
      }
    }

    // Copy constructor (for ourselves, apparently ours wont get called even with the template version below)
    Ref(const Ref& other)
    {
      // Copy over the information, and increment the
      // reference count since we now point at it
      CopyFrom(other);
    }

    // Move constructor
    Ref(Zero::MoveReference<Ref> move)
    {
      Ref& other = *move;
      this->Deletor = other.Deletor;
      this->Mode = other.Mode;
      CopyFrom<Type>(other);
      other.Clear();
    }

    // Move assignment
    Ref& operator=(Zero::MoveReference<Ref> move)
    {
      Ref& other = *move;
      this->Deletor = other.Deletor;
      this->Mode = other.Mode;
      CopyFrom<Type>(other);
      other.Clear();
      return *this;
    }
  
    // Copy constructor
    template <typename TypeOrDerived, typename OtherModePolicy>
    Ref(const Ref<TypeOrDerived, OtherModePolicy>& other)
    {
      // Copy over the information, and increment the
      // reference count since we now point at it
      CopyFrom(other);
    }
  
    // Destructor (decrements the reference count and potentially cleans up memory)
    ~Ref()
    {
      // Clear the object this is referencing (which also can delete the object)
      Clear();
    }

    // When hashed, we just return the function pointer hash
    size_t Hash() const
    {
      // Use pointer hashing
      return HashPolicy<Type*>()(this->Object);
    }

    // Assignment operator (for ourselves, apparently ours wont get called even with the template version below)
    Ref& operator=(const Ref& other)
    {
      return this->operator=<Type>(other);
    }

    // Assignment operator
    template <typename TypeOrDerived, typename OtherModePolicy>
    Ref& operator=(const Ref<TypeOrDerived, OtherModePolicy>& other)
    {
      // Check for assignment to the same object (or ourselves)
      if (this->Object == other.Object)
        return *this;

      // Clear the object we're referencing, since we're changing references
      Clear();

      // Copy over the information, and increment the
      // reference count since we now point at it
      CopyFrom(other);

      // Return ourself for chaining
      return *this;
    }

    // Compare two shared references
    template <typename TypeOrDerived, typename OtherModePolicy>
    bool operator==(const Ref<TypeOrDerived, OtherModePolicy>& other) const
    {
      return this->Object == other.Object;
    }

    // Compare the pointers
    bool operator==(const Type* other) const
    {
      return this->Object == other;
    }

    // Compare two shared references
    template <typename TypeOrDerived, typename OtherModePolicy>
    bool operator!=(const Ref<TypeOrDerived, OtherModePolicy>& other) const
    {
      return this->Object != other.Object;
    }

    // Compare the pointers
    bool operator!=(const Type* other) const
    {
      return this->Object != other;
    }

    // Return if we have an object or not
    inline operator Type*() const
    {
      return this->Object;
    }

    // Access the object via arrow operator
    inline Type* operator->() const
    {
      return this->Object;
    }

    // Dereference the shared reference to get the object
    inline Type& operator*() const
    {
      return *this->Object;
    }

    // Get the underlying object. This should only be used for optimization
    // and in cases where you know the object's lifetime is guaranteeed
    inline Type* GetObject() const
    {
      return this->Object;
    }

    // Clear the object this pointer is referencing
    void Clear()
    {
      // If the object is not null
      if (this->Object != nullptr)
      {
        // Unlink ourselves from the list (and potentially delete the object)
        this->Mode.RemoveLinkFromList(this);

        // Null out the object and the count
        this->Object = nullptr;
      }
    }

  public:

    // Copy over the information from another object and increment the reference to it
    inline void CopyFrom(const Ref& other)
    {
      // Straight up copy over the info we need
      this->Deletor = other.Deletor;
      this->Mode = other.Mode;
      CopyFrom<Type>(other);
    }

    // Copy over the information from another object and increment the reference to it
    template <typename TypeOrDerived, typename OtherModePolicy, typename OtherDeletePolicy>
    inline void CopyFrom(const Ref<TypeOrDerived, OtherModePolicy, OtherDeletePolicy>& other)
    {
      // Straight up copy over the info we need
      this->Object = other.Object;

      // Do we actually need to copy the deletor from derived to base?
      // this->Deletor = other.Deletor;

      // If the object was non null (as in we didn't just copy a null ref)
      if (this->Object != nullptr)
      {
        // Add ourselves to whatever list we belong to (controlled by the policy)
        this->Mode.AddLinkToList(this);
      }
    }

  public:

    // Store the deletion policy
    DeletePolicy Deletor;

    // The mode that this reference is in
    ModePolicy Mode;

    // A pointer back to the object
    Type* Object;

    // Store our intrusive link
    IntrusiveLink(Ref, InternalLink);
  };


  // This structure should be placed as a mutable member of your class
  template <typename Type, typename DeletePolicy = StandardDelete<Type> >
  class RefLink
  {
  public:

    // Type-defines
    typedef Type ForType;
    typedef Ref<Type, NormalPolicy, DeletePolicy>         SharedType;
    typedef Ref<Type, WeakPolicy,   DeletePolicy>         WeakType;
    typedef InList<SharedType, &SharedType::InternalLink> SharedInList;
    typedef InList<WeakType, &WeakType::InternalLink>     WeakInList;

    // Store the list of shared references to our object
    SharedInList SharedReferences;

    // Store the list of weak references to our object
    // (they will not keep us alive, but we will null them out if we die)
    WeakInList WeakReferences;
  };

// A macro that creates an intrusive reference link
// This is typically placed at the end of your class
#define ZilchRefLink(type)                  \
  public:                                   \
  typedef RefLink<const type> RefLinkType;  \
  mutable RefLinkType Referencers;

// If a particular object is going to be used as a referencer,
// we use a trick that lets the Visual Studio debugger show our
// object, but it needs to be virtual for the trick to work
#define ZilchDebuggableReferencer() \
  virtual void z() const {}
}

// End header protection
#endif


// Standard Zilch Type-defines
namespace Zilch
{
  typedef Array<Function*>                                FunctionArray;
  typedef FunctionArray::range                            FunctionArrayRange;
  typedef HashMap<String, Variable*>                      VariableMap;
  typedef VariableMap::range                              VariableRange;
  typedef VariableMap::valuerange                         VariableValueRange;
  typedef HashMap<String, FunctionArray>                  FunctionMultiMap;
  typedef FunctionMultiMap::range                         FunctionMultiRange;
  typedef FunctionMultiMap::valuerange                    FunctionMultiValueRange;
  typedef HashMap<String, Field*>                         FieldMap;
  typedef FieldMap::range                                 FieldMapRange;
  typedef FieldMap::valuerange                            FieldMapValueRange;
  typedef HashMap<String, Property*>                      PropertyMap;
  typedef PropertyMap::range                              PropertyMapRange;
  typedef PropertyMap::valuerange                         PropertyMapValueRange;
  typedef Array<Property*>                                PropertyArray;
  typedef PropertyArray::range                            PropertyArrayRange;
  typedef Array<SendsEvent>                               SendsEventArray;
  typedef SendsEventArray::range                          SendsEventRange;
  typedef HashMap<GuidType, Function*>                    FunctionGuidMap;
  typedef FunctionGuidMap::range                          FunctionGuidRange;
  typedef HashMap<String, BoundType*>                     BoundTypeMap;
  typedef BoundTypeMap::pair                              BoundTypePair;
  typedef BoundTypeMap::range                             BoundTypeRange;
  typedef BoundTypeMap::valuerange                        BoundTypeValueRange;
  typedef Array<Type*>                                    TypeArray;
  typedef Array<BoundType*>                               BoundTypeArray;
  typedef HashMap<GuidType, Type*>                        TypeGuidMap;
  typedef TypeGuidMap::range                              TypeGuidRange;
  typedef Array<String>                                   StringArray;
  typedef StringArray::range                              StringArrayRange;
  typedef HashMap<GuidType, FunctionMultiMap>             FunctionExtensionMap;
  typedef FunctionExtensionMap::range                     FunctionExtensionRange;
  typedef HashMap<GuidType, PropertyMap>                  PropertyExtensionMap;
  typedef PropertyExtensionMap::range                     PropertyExtensionRange;
  typedef HashMap<BoundType*, IndirectionType*>           TypeToIndirect;
  typedef TypeToIndirect::range                           TypeToIndirectRange;

  typedef Function*                   (BoundType::*GetFunctionFn)            (StringParam name) const;
  typedef const FunctionArray*        (BoundType::*GetOverloadedFunctionsFn) (StringParam name) const;
  typedef Field*                      (BoundType::*GetFieldFn)               (StringParam name) const;
  typedef Property*                   (BoundType::*GetPropertyFn)            (StringParam name) const;

  typedef void (*PostDestructorFn)(BoundType* boundType, byte* objectData);
  typedef void (*ThreadLockFn)(bool lock);

  // The C++ function that's bound to the script function
  typedef void (*BoundFn)(Call& call, ExceptionReport& report);
  
  // Every time we created a handle manager, we expect an index back of this type
  typedef size_t HandleManagerId;

  // How a type gets copied
  namespace TypeCopyMode
  {
    enum Enum
    {
      // Value types are considered memory copyable,
      // and can therefore not contain any sort of handles
      ValueType,

      // Reference types are never copied (which means that we only ever copy
      // the handle to the reference, and not the object itself).
      ReferenceType
    };
  }

  // The user can define 'ZilchNoDocumentation' globally to disable all processing of documentation strings in Zilch (freeing up memory)
  // If the user wants to make a single build of an executable, but optionally choose whether to enable documentation or not, they can pass in
  // These functions will return an empty string in the case that runtime documentation is disabled (which is implied by compile time disabling)
  String GetDocumentationStringOrEmpty(StringParam string);
  String GetDocumentationCStringOrEmpty(cstr string);

  // If the user disabled documentation at compile-time...
  #if defined(ZilchNoDocumentation)
    // Defines a documentation string and allows users to easily disable documentation via globally defining 'ZilchNoDocumentation'
    #define ZilchDocumentString(DocumentationString) Zilch::String()

    // Defines a static member function that allows us to query the documentation for a particular member (including properties, functions, and fields)
    #define ZilchDocument(Member, DocumentationString) static Zilch::String Member##Documentation() { return Zilch::String(); }
  #else
    // Defines a documentation string and allows users to easily disable documentation via globally defining 'ZilchNoDocumentation'
    #define ZilchDocumentString(DocumentationString) Zilch::GetDocumentationStringOrEmpty(DocumentationString)

    // Defines a global function that allows us to query the documentation for a particular type including classes, enums, primitives, etc)
    #define ZilchDocument(Name, DocumentationString)                                              \
      static Zilch::String Name##Documentation()                                                  \
      {                                                                                           \
        static Zilch::String Documentation = GetDocumentationCStringOrEmpty(DocumentationString); \
        return Documentation;                                                                     \
      }
  #endif
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_ANY_HPP
#define ZILCH_ANY_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_DELEGATE_HPP
#define ZILCH_DELEGATE_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_HANDLE_HPP
#define ZILCH_HANDLE_HPP

// Enable this to add extra debugging support (for Zilch internal use, such as working on the compiler)
// Warning: This will make Zilch run significantly slower
//#define ZILCH_HANDLE_DEBUG

namespace Zilch
{
  // A unique id that lets us identify objects
  typedef unsigned Uid;

  // A special code that signifies that a Uid is not set or invalid
  const unsigned InvalidUid = 0xFFFFFFFF;

  // The user has to be able to fit their entire handle inside of the user data on the handle
  // If the user cannot fit the data inside the handle, then they must create another object
  // that acts as a reference to their object
  const size_t HandleUserDataSize = 24;

  // Any flags we put on the handle
  namespace HandleFlags
  {
    enum Enum
    {
      // No flags
      None = 0,

      // In this mode, we don't do reference counting (this is a useful optimization for handles!)
      // This flag is also set when we're deleting a handle so that it can be passed into a destructor without
      // increasing or decreasing reference counts (this is safe because the handle is already going to be deleted)
      NoReferenceCounting = 1,

      // This flag is set only if ZILCH_HANDLE_DEBUG is enabled
      // This is used to track which handles need be removed from the intrusive linked list of all handles
      // If a handle was purely initialized via memory setting to zero, we ignore it
      InitializedByConstructor = 2,
    };
    typedef byte Compact;
  }

  // A handle is an object that has the ability to point at an object
  // (both on the heap, as a member of an object on the heap, etc)
  class ZeroShared Handle
  {
  public:
    // Friends
    friend class VirtualMachine;
    friend class ExecutableState;

    // Constructor that creates a null handle
    Handle();

    // Destructor
    ~Handle();

    // Copy constructor for a handle
    Handle(const Handle& rhs);

    // Constructs a handle from a type and a data pointer
    // This will invoke ObjectToHandle on the handle manager
    // The 'data' passed in should be a pointer to the object (the same as that returned from Dereference)
    Handle(ExecutableState* state, BoundType* type, const byte* data);

    // Copy from assignment
    Handle& operator=(const Handle& rhs);

    // Are two handles the exact same?
    bool operator==(const Handle& rhs) const;

    // Are two handles different?
    bool operator!=(const Handle& rhs) const;

    // Hashes a handle (generally used by hashable containers)
    int Hash() const;

    // Is the handle null?
    // It is recommended for performance that you just call Dereference and
    // check if it returns a null if you need to use the dereferenced value
    bool IsNull() const;

    // Checks to see if this handle is reference counted, or if it's just a standard handle
    inline bool IsReferenceCounted();

    // Get a pointer to the data, or return null if it isn't valid
    byte* Dereference() const;

    // Attempts to delete the object pointed at by the handle
    // Returns true if the object was deleted, or if the handle was already null
    // If the object is deleted, this handle will be cleared to null
    // It is possible for the destructor to throw an exception (though not highly recommended)
    bool Delete();

  private:
    // Clear the handle to a null handle
    // Warning: This does not do reference counting or properly delete the object!
    void Clear();

    // Called only when we know it's ok to delete the object
    void DestructAndDelete();

    // Increment the reference count (only if we're counted)
    void AddReference();

    // Decrement the reference count (only if we're counted), and destruct/delete the object if necessary
    void ReleaseReference();

  public:

#ifdef ZILCH_HANDLE_DEBUG
    // In order to verify that handles are valid, we keep a global list of all handles
    // and we check to see if any of them are ever improperly destructed or get written over
    Handle* DebugNext;
    Handle* DebugPrev;
    static Handle* DebugHead;
    static Handle* DebugTail;
    static void ValidateAllHandles();
    void Validate() const;
    void DebugLink();
    void DebugUnlink();
#endif

    // The type of this handle (if the type is a valud type, then it means we were assigned via ref/indirection type)
    // Unlike most OOP designs, our handle actually contains the type (or the v-table)
    // rather than it being on the object itself. This allows us to invoke interface
    // functions on a stack object via a handle, rather than by boxing the value type
    BoundType* Type;
    //DebugPlaceholder<BoundType*> Type;

    // The manager controls the lifetime of the handle, and how we interface with it
    HandleManager* Manager;

    // An offset from the base of the handle (used in dereferencing)
    size_t Offset;

    // The user data stored on the handle (of a fixed size)
    byte Data[HandleUserDataSize];

    // Flags we put on the handle
    HandleFlags::Compact Flags;
  };
}

// End header protection
#endif


namespace Zilch
{
  // Invalid constants
  const size_t InvalidOpcodeLocation = (size_t)-1;

  // A delegate is a simple type that consists of an index for a function, as well as the this pointer object
  class ZeroShared Delegate
  {
  public:

    // Constructor
    Delegate();

    // Are two handles the exact same?
    bool operator==(const Delegate& rhs) const;

    // Are two handles different?
    bool operator!=(const Delegate& rhs) const;

    // Hashes a handle (generally used by hashable containers)
    int Hash() const;

  public:
    // The function we run when invoking this delegate
    Function* BoundFunction;

    // The handle for the delegate
    Handle ThisHandle;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_EXECUTABLE_STATE_HPP
#define ZILCH_EXECUTABLE_STATE_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_FUNCTION_HPP
#define ZILCH_FUNCTION_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_THREE_ADDRESS_OPCODE_HPP
#define ZILCH_THREE_ADDRESS_OPCODE_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_CODE_LOCATION_HPP
#define ZILCH_CODE_LOCATION_HPP

namespace Zilch
{
  // We can print Zilch messages in many different formats
  // This is used for printing errors, exceptions, and general code location information
  namespace MessageFormat
  {
    enum Enum
    {
      // This is the standard format we use to print Zilch error messages
      // We try to be very descriptive about where our errors occur
      // Style: 'In <origin> at line <line>, character <character> (within function <function>)'
      //        '  <message>'
      Zilch,
      
      // Style: '  File "<origin>", line <line>, in <function>'
      //        '    <message>'
      Python,
      
      // Msvc errors are useful when editing Zilch inside of Visual Studio,
      // because you can double click the error and go directly to the file
      // Style: '<origin>(<line>): <message>'
      MsvcCpp
    };
  }

  // A code location provides us with a context of where something occurred
  class ZeroShared CodeLocation
  {
  public:
    // Default constructor
    CodeLocation();

    // Checks if this location was ever set to a valid value
    bool IsValid();

    // Get a formatted message that includes this location (may include newlines depending on the format)
    String GetFormattedStringWithMessage(MessageFormat::Enum format, StringParam message) const;

    // Get this location formatted in different styles (does not include newlines)
    String GetFormattedString(MessageFormat::Enum format) const;

    // Creates a code location that is strictly at the start of this location
    CodeLocation GetStartOnlyLocation();

    // Creates a code location that is strictly at the end of this location
    CodeLocation GetEndOnlyLocation();

    // This hash matches the hash used in the CodeEntry, and can generally be used to map back to files
    size_t GetHash();

    // Every file and code string compiled gets a unique id
    String Code;
    
    // Note: Primary is a location that we generally use when displaying errors or other visualizations
    // For example, in a binary operator the location Start/End encompasses both the Left/Right operands
    // however the primary location is the operator itself
    // Primary should always be between start and end

    // The line range that the node originated from
    // Lines start at a value of 1 (a value of 0 is invalid)
    size_t StartLine;
    size_t PrimaryLine;
    size_t EndLine;

    // The character range that the node originated from (relative to the start of the line)
    // Characters start at a value of 1 (a value of 0 is invalid)
    size_t StartCharacter;
    size_t PrimaryCharacter;
    size_t EndCharacter;

    // The zero-based character position from the associated code
    size_t StartPosition;
    size_t PrimaryPosition;
    size_t EndPosition;

    // The file/script this node originated from
    String Origin;

    // This is an optional library that we're from (typically filled out in the syntaxer phase)
    String Library;

    // This is an optional class that we're from (typically filled out in the syntaxer phase)
    String Class;

    // This is an optional function that we're from (typically filled out in the syntaxer phase)
    String Function;

    // Tells us if the location is within C++, which
    // means that it cannot be debugged or visualized
    bool IsNative;

    // When the user provides a code block to the project to be compiled
    // they have the option of providing user-data. This user-data is the
    // same data that they passed in
    mutable const void* CodeUserData;
  };

  // Every time we add code to the project we do it through this
  // This is also stored on the library that gets generated out of the project
  class CodeEntry
  {
  public:
    // Constructor
    CodeEntry();

    String Code;
    String Origin;
    void* CodeUserData;

    // Gets a hash that we can use to uniquely identify this code
    // This includes the code and its origin
    // If a file changes names, this will no longer map up to that same file
    size_t GetHash();
  };
}

// Explicit specializations
namespace Zero
{
  // Code locations should be directly memory movable
  // String would technically just increment a reference and then decrement, so skip it!
  // WARNING: If this ever becomes non-movable, then be sure to update UserToken!
  template <>
  struct MoveWithoutDestructionOperator<Zilch::CodeLocation>
  {
    static inline void MoveWithoutDestruction(Zilch::CodeLocation* dest, Zilch::CodeLocation* source)
    {
      memcpy(dest, source, sizeof(*source));
    }
  };
}

// End header protection
#endif



namespace Zilch
{
  // Forward declaration
  class SyntaxTree;

  // The actual instructions that we can execute
  namespace Instruction
  {
    typedef int AlignedEnum;

    enum Enum
    {
      #define ZilchEnumValue(value) value,
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Note: These macros mirror those inside of Shared and VirtualMachine (for generation of instructions)

// Copy
#define ZilchCopyInstructions(Type)               \
  ZilchEnumValue(Copy##Type)

// Equality and inequality
#define ZilchEqualityInstructions(Type)           \
  ZilchEnumValue(TestInequality##Type)            \
  ZilchEnumValue(TestEquality##Type)

// Less and greater comparison
#define ZilchComparisonInstructions(Type)         \
  ZilchEnumValue(TestLessThan##Type)              \
  ZilchEnumValue(TestLessThanOrEqualTo##Type)     \
  ZilchEnumValue(TestGreaterThan##Type)           \
  ZilchEnumValue(TestGreaterThanOrEqualTo##Type)

// Generic numeric operators, copy, equality
#define ZilchNumericInstructions(Type)            \
  ZilchCopyInstructions(Type)                     \
  ZilchEqualityInstructions(Type)                 \
  /* No instruction for unary plus */             \
  ZilchEnumValue(Negate##Type)                    \
  ZilchEnumValue(Increment##Type)                 \
  ZilchEnumValue(Decrement##Type)                 \
  ZilchEnumValue(Add##Type)                       \
  ZilchEnumValue(Subtract##Type)                  \
  ZilchEnumValue(Multiply##Type)                  \
  ZilchEnumValue(Divide##Type)                    \
  ZilchEnumValue(Modulo##Type)                    \
  ZilchEnumValue(Pow##Type)                       \
  ZilchEnumValue(AssignmentAdd##Type)             \
  ZilchEnumValue(AssignmentSubtract##Type)        \
  ZilchEnumValue(AssignmentMultiply##Type)        \
  ZilchEnumValue(AssignmentDivide##Type)          \
  ZilchEnumValue(AssignmentModulo##Type)          \
  ZilchEnumValue(AssignmentPow##Type)

// Generic numeric operators, copy, equality, comparison
#define ZilchScalarInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)

// Vector operations, generic numeric operators, copy, equality
#define ZilchVectorInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)               \
  ZilchEnumValue(ScalarMultiply##Type)            \
  ZilchEnumValue(ScalarDivide##Type)              \
  ZilchEnumValue(ScalarModulo##Type)              \
  ZilchEnumValue(ScalarPow##Type)                 \
  ZilchEnumValue(AssignmentScalarMultiply##Type)  \
  ZilchEnumValue(AssignmentScalarDivide##Type)    \
  ZilchEnumValue(AssignmentScalarModulo##Type)    \
  ZilchEnumValue(AssignmentScalarPow##Type)

// Special integral operators, generic numeric operators, copy, equality, and comparison
#define ZilchIntegralInstructions(Type)           \
  ZilchEnumValue(BitwiseNot##Type)                \
  ZilchEnumValue(BitshiftLeft##Type)              \
  ZilchEnumValue(BitshiftRight##Type)             \
  ZilchEnumValue(BitwiseOr##Type)                 \
  ZilchEnumValue(BitwiseXor##Type)                \
  ZilchEnumValue(BitwiseAnd##Type)                \
  ZilchEnumValue(AssignmentBitshiftLeft##Type)    \
  ZilchEnumValue(AssignmentBitshiftRight##Type)   \
  ZilchEnumValue(AssignmentBitwiseOr##Type)       \
  ZilchEnumValue(AssignmentBitwiseXor##Type)      \
  ZilchEnumValue(AssignmentBitwiseAnd##Type)


// Core instructions
ZilchEnumValue(InvalidInstruction)

ZilchEnumValue(InternalDebugBreakpoint)
ZilchEnumValue(ThrowException)
ZilchEnumValue(PropertyDelegate)

ZilchEnumValue(TypeId)

ZilchEnumValue(BeginTimeout)
ZilchEnumValue(EndTimeout)

ZilchEnumValue(BeginScope)
ZilchEnumValue(EndScope)

ZilchEnumValue(ToHandle)

ZilchEnumValue(BeginStringBuilder)
ZilchEnumValue(EndStringBuilder)
ZilchEnumValue(AddToStringBuilder)

ZilchEnumValue(CreateInstanceDelegate)
ZilchEnumValue(CreateStaticDelegate)

ZilchEnumValue(IfFalseRelativeGoTo)
ZilchEnumValue(IfTrueRelativeGoTo)
ZilchEnumValue(RelativeGoTo)

ZilchEnumValue(Return)
ZilchEnumValue(PrepForFunctionCall)
ZilchEnumValue(FunctionCall)

ZilchEnumValue(NewObject)
ZilchEnumValue(LocalObject)
ZilchEnumValue(DeleteObject)

// Primitive type instructions
ZilchIntegralInstructions(Byte)
ZilchScalarInstructions(Byte)
ZilchIntegralInstructions(Integer)
ZilchScalarInstructions(Integer)
ZilchVectorInstructions(Integer2)
ZilchVectorInstructions(Integer3)
ZilchVectorInstructions(Integer4)
ZilchIntegralInstructions(Integer2)
ZilchIntegralInstructions(Integer3)
ZilchIntegralInstructions(Integer4)
ZilchScalarInstructions(Real)
ZilchVectorInstructions(Real2)
ZilchVectorInstructions(Real3)
ZilchVectorInstructions(Real4)
ZilchScalarInstructions(DoubleReal)
ZilchIntegralInstructions(DoubleInteger)
ZilchScalarInstructions(DoubleInteger)

ZilchEqualityInstructions(Boolean)
ZilchEqualityInstructions(Handle)
ZilchEqualityInstructions(Delegate)
ZilchEqualityInstructions(Any)
ZilchEqualityInstructions(Value)

ZilchCopyInstructions(Boolean)
ZilchCopyInstructions(Any)
ZilchCopyInstructions(Handle)
ZilchCopyInstructions(Delegate)
ZilchCopyInstructions(Value)

ZilchEnumValue(LogicalNotBoolean)

ZilchEnumValue(ConvertByteToReal)
ZilchEnumValue(ConvertByteToBoolean)
ZilchEnumValue(ConvertByteToInteger)
ZilchEnumValue(ConvertByteToDoubleInteger)
ZilchEnumValue(ConvertByteToDoubleReal)
ZilchEnumValue(ConvertIntegerToReal)
ZilchEnumValue(ConvertIntegerToBoolean)
ZilchEnumValue(ConvertIntegerToByte)
ZilchEnumValue(ConvertIntegerToDoubleInteger)
ZilchEnumValue(ConvertIntegerToDoubleReal)
ZilchEnumValue(ConvertRealToInteger)
ZilchEnumValue(ConvertRealToBoolean)
ZilchEnumValue(ConvertRealToByte)
ZilchEnumValue(ConvertRealToDoubleInteger)
ZilchEnumValue(ConvertRealToDoubleReal)
ZilchEnumValue(ConvertBooleanToInteger)
ZilchEnumValue(ConvertBooleanToReal)
ZilchEnumValue(ConvertBooleanToByte)
ZilchEnumValue(ConvertBooleanToDoubleInteger)
ZilchEnumValue(ConvertBooleanToDoubleReal)
ZilchEnumValue(ConvertDoubleIntegerToReal)
ZilchEnumValue(ConvertDoubleIntegerToBoolean)
ZilchEnumValue(ConvertDoubleIntegerToByte)
ZilchEnumValue(ConvertDoubleIntegerToInteger)
ZilchEnumValue(ConvertDoubleIntegerToDoubleReal)
ZilchEnumValue(ConvertDoubleRealToReal)
ZilchEnumValue(ConvertDoubleRealToBoolean)
ZilchEnumValue(ConvertDoubleRealToByte)
ZilchEnumValue(ConvertDoubleRealToInteger)
ZilchEnumValue(ConvertDoubleRealToDoubleInteger)

ZilchEnumValue(ConvertInteger2ToReal2)
ZilchEnumValue(ConvertInteger2ToBoolean2)
ZilchEnumValue(ConvertReal2ToInteger2)
ZilchEnumValue(ConvertReal2ToBoolean2)
ZilchEnumValue(ConvertBoolean2ToInteger2)
ZilchEnumValue(ConvertBoolean2ToReal2)

ZilchEnumValue(ConvertInteger3ToReal3)
ZilchEnumValue(ConvertInteger3ToBoolean3)
ZilchEnumValue(ConvertReal3ToInteger3)
ZilchEnumValue(ConvertReal3ToBoolean3)
ZilchEnumValue(ConvertBoolean3ToInteger3)
ZilchEnumValue(ConvertBoolean3ToReal3)

ZilchEnumValue(ConvertInteger4ToReal4)
ZilchEnumValue(ConvertInteger4ToBoolean4)
ZilchEnumValue(ConvertReal4ToInteger4)
ZilchEnumValue(ConvertReal4ToBoolean4)
ZilchEnumValue(ConvertBoolean4ToInteger4)
ZilchEnumValue(ConvertBoolean4ToReal4)

ZilchEnumValue(ConvertStringToStringRangeExtended)

ZilchEnumValue(ConvertDowncast)
ZilchEnumValue(ConvertToAny)
ZilchEnumValue(ConvertFromAny)
ZilchEnumValue(AnyDynamicMemberGet)
ZilchEnumValue(AnyDynamicMemberSet)

      #undef ZilchEnumValue
      Count
    };

    // The names of the instructions (for reflection and debugging)
    extern const char* Names[];
  }

  namespace DebugOrigin
  {
    enum Enum
    {
      MemberVariable,
      LocalVariable,
      Scope,
      Timeout,
      If,
      While,
      For,
      DoWhile,
      Loop,
      Break,
      Continue,
      PropertyDelegate,
      DebugBreak,
      BinaryOperation,
      UnaryOperation,
      DataMemberAccess,
      TypeCast,
      ReturnValue,
      FunctionCall,
      FunctionContext,
      DeleteObject,
      ThrowException,
      NewObject,
      LocalObject,
      TypeId,
      FunctionMemberAccess,
      PropertyGetMemberAccess,
      PropertySetMemberAccess,
      FunctionCallConstructor,
      StringInterpolant
    };
  }

  // This is the form that the intermediate three-address opcode will take
  // An opcode is basically a single instruction with its operand (like an assembly command)
  class Opcode
  {
  public:
    // Constructor (gets rid of the annoying warning about POD constructors)
    Opcode() {}

    // The instruction to be generated
    Instruction::AlignedEnum Instruction;

#ifdef _DEBUG
    // Make the class virtual in debug mode so that we can view a list of opcodes easily
    // Having a vtable in visual studio also gives us a reflected view of the derived class
    virtual ~Opcode() { }
    
    // The origin of the instruction for debugging purposes (who created it)
    DebugOrigin::Enum DebugOrigin;
#endif
  };

  // The type of an operand
  // This generally tells us how we read/write to a particular expression
  // For example, if we're going to a property, we must call set, whereas
  // a local variable we can just write to directly on the stack
  namespace OperandType
  {
    enum Enum
    {
      NotSet,       // If the access type was not set, we know we have a bug
      Constant,     // The value is read only and cannot be assigned to
      Local,        // The value is a local variable and can be assigned to
      Field,        // The value is a member variable (field) and can be assigned to
      StaticField,  // Static values are looked up in a map by the Field*
      Property      // The value is a property and uses get/set (not really used)
    };
  }

  // An operand is used inside of an opcode,
  // for when it needs to refer to any bit of memory
  class Operand
  {
  public:
    // Default constructor
    Operand();

    // Construct from an index on the current stack
    explicit Operand(OperandIndex local);

    // Construct from a primary index, secondary index, and an access type
    Operand(OperandIndex handleConstantLocal, size_t field, OperandType::Enum type);

    // What type of operand are we trying to access?
    OperandType::Enum Type;

    union
    {
      // An offset to:
      //  - A handle on the stack
      //  - A constant within a function's constant space
      //  - A local on the stack
      OperandIndex HandleConstantLocal;

      // A pointer to a field that is static
      Field* StaticField;
    };
    
    // When going through a handle, this can be a field offset onto the derefenced handle (a member)
    // This also works with stack localss and even constants (as well as static fields!)
    size_t FieldOffset;
  };

  // Opcode for the creation of a handle from a local
  class TimeoutOpcode : public Opcode
  {
  public:
    // Even though it might be more efficient to store this in ticks
    // Technically if want this format to be savable and platform independent, it's better
    // to save it in seconds
    size_t LengthSeconds;
  };

  // Opcode for the creation of a handle from a local
  class ToHandleOpcode : public Opcode
  {
  public:
    Operand ToHandle;
    OperandLocal SaveLocal;
    BoundType* Type;
  };

  // Opcode for the creation of generic delegates (never used directly)
  class CreateDelegateOpcode : public Opcode
  {
  public:
    Function* BoundFunction;
    OperandLocal SaveLocal;
  };

  // Opcode for the creation of static delegates
  // Note that this opcode always saves to a local
  // (anyone that wants to store the value just copies it from a local)
  class CreateStaticDelegateOpcode : public CreateDelegateOpcode
  {
  public:
  };

  // Opcode for the creation of instance delegates
  // Note that this opcode always saves to a local
  // (anyone that wants to store the value just copies it from a local)
  class CreateInstanceDelegateOpcode : public CreateDelegateOpcode
  {
  public:
    Operand ThisHandle;
    bool CanBeVirtual;
  };

  // Opcode for the if-instruction
  class IfOpcode : public Opcode
  {
  public:
    Operand Condition;
    ByteCodeOffset JumpOffset;
  };

  // Opcode for the relative jump instruction
  class RelativeJumpOpcode : public Opcode
  {
  public:
    ByteCodeOffset JumpOffset;
  };

  // Opcode for the prep for function call instruction
  class PrepForFunctionCallOpcode : public Opcode
  {
  public:
    Operand Delegate;
    ByteCodeOffset JumpOffsetIfStatic;
  };

  // Creates a fresh string builder that we use for efficient concatenation of strings
  class BeginStringBuilderOpcode : public Opcode
  {
  public:
  };

  // Finishes off a string builder and outputs the string to a given stack local
  class EndStringBuilderOpcode : public Opcode
  {
  public:
    OperandLocal SaveStringHandleLocal;
  };

  // Creates a fresh string builder that we use for efficient concatenation of strings
  class AddToStringBuilderOpcode : public Opcode
  {
  public:
    const Type* TypeToConvert;
    Operand Value;
  };

  // Gets the virtual type (most derived) of an expression
  class TypeIdOpcode : public Opcode
  {
  public:
    const Type* CompileTimeType;
    OperandLocal SaveTypeHandleLocal;
    Operand Expression;
  };

  // Opcode for generic creation of an object
  // Note that this opcode always creates a handle at the given local position
  class CreateTypeOpcode : public Opcode
  {
  public:
    BoundType* CreatedType;
    OperandLocal SaveHandleLocal;
  };

  // Opcode for local creation of an object
  class CreateLocalTypeOpcode : public CreateTypeOpcode
  {
  public:
    OperandLocal StackLocal;
  };

  // Opcode for the creation of a property delegate (a reference object)
  class CreatePropertyDelegateOpcode : public CreateTypeOpcode
  {
  public:
    OperandLocal ThisHandleLocal;
    Function* Get;
    Function* Set;
  };

  // Opcode for the delete object instruction
  class DeleteObjectOpcode : public Opcode
  {
  public:
    Operand Object;
  };

  // Opcode for the throw exception instruction
  class ThrowExceptionOpcode : public Opcode
  {
  public:
    Operand Exception;
  };

  // Binary operation between two operands (this instruction has no side effects
  // and is only used with value types, and therefore the output is always local)
  class BinaryRValueOpcode : public Opcode
  {
  public:
    Operand Left;
    Operand Right;
    OperandLocal Output;
    size_t Size;
  };

  // A side effect operator (such as assignment)
  class BinaryLValueOpcode : public Opcode
  {
  public:
    Operand Output;
    Operand Right;
  };

  // Unary operation for a single operand (this instruction has no side effects
  // and is only used with value types, and therefore the output is always local)
  class UnaryRValueOpcode : public Opcode
  {
  public:
    Operand SingleOperand;
    OperandLocal Output;
  };

  // A side effect operator (such as increment)
  class UnaryLValueOpcode : public Opcode
  {
  public:
    Operand SingleOperand;
  };

  // Convert one value to another (this instruction has no side effects and
  // is only used with value types, and therefore the output is always local)
  class ConversionOpcode : public Opcode
  {
  public:
    Operand ToConvert;
    OperandLocal Output;
  };

  // Convert a type into the 'Any' type (which means copying it's value into the variant)
  class AnyConversionOpcode : public ConversionOpcode
  {
  public:
    // For ConvertToAny:
    // The type we're going to be putting into the Any
    // Note that we may actually do extra introspection to find a more derived type
    // As an example, if we attempt to store an Animal into the Any, the type stored on
    // this opcode would be the Animal, even if the underlying value was really a Cat
    // however, when we actually do the operation, we'll know if it's a handle type
    // and then we'll pull the derived type Cat out and store that on the Any

    // For ConvertFromAny:
    // We compare the type stored within the Any to this type to ensure that
    // we only pull out the correct type, otherwise we throw an exception
    Type* RelatedType;
  };

  // When we cast between a base type and derived handles
  class DowncastConversionOpcode : public ConversionOpcode
  {
  public:
    // We check to make sure the type stored in the handle is a type that is either
    // more derived or the same as this related type
    Type* ToType;
  };

  // Describes how to get a value out of a value stored by the 'any' type
  class AnyDynamicGet : public Opcode
  {
  public:
    // An index into the constant table where the member's name lives (as a string)
    OperandIndex StringConstant;
  };

  namespace CopyMode
  {
    enum Enum
    {
      Assignment,
      Initialize,
      ToParameter,
      FromReturn,
      ToReturn,
    };
  }

  // Copy a value from one place to another
  class CopyOpcode : public Opcode
  {
  public:
    Operand Source;
    Operand Destination;
    size_t Size;
    CopyMode::Enum Mode;
  };

  namespace DebugPrimitive
  {
    enum Enum
    {
      Integer,
      Boolean,
      Real,
      Real2,
      Real3,
      Real4,
      Handle,
      Delegate,
      Memory
    };
  }

  class DebugOperand
  {
  public:
    DebugOperand();
    DebugOperand(size_t offset, DebugPrimitive::Enum primitive, bool isLocal, StringParam name);
    size_t OperandOffset;
    DebugPrimitive::Enum Primitive;
    bool IsLocalOnly;
    String Name;
  };

  class DebugInstruction
  {
  public:
    DebugInstruction();

    Array<DebugOperand> ReadOperands;
    Array<DebugOperand> WriteOperands;
    Array<size_t> Sizes;
    Array<size_t> OpcodeOffsets;
    Array<size_t> FunctionPointers;
    Array<size_t> TypePointers;
    Array<size_t> Options;
    bool IsCopy;
  };

  // Generate debug info per instruction
  void GenerateDebugInstructionInfo(Array<DebugInstruction>& debugOut);
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_UNTYPED_BLOCK_ARRAY_HPP
#define ZILCH_UNTYPED_BLOCK_ARRAY_HPP

namespace Zilch
{
  // A block array (except it is untyped, and therefore works mostly with copyable structs)
  template <size_t BlockSize>
  class ZeroSharedTemplate UntypedBlockArray
  {
  public:

    // Constructor
    UntypedBlockArray()
    {
      this->CompactedSize = 0;
    }

    // Copy constructor
    UntypedBlockArray(const UntypedBlockArray& from) :
      CompactedSize(from.CompactedSize)
    {
      // Loop through all the blocks allocated by the source
      for (size_t i = 0; i < from.Blocks.size(); ++i)
      {
        // Grab the current source block
        const Block& fromBlock = from.Blocks[i];

        // Add the block to ourselves and copy all the information over
        Block& toBlock = this->CreateBlock();
        toBlock.LengthWritten = fromBlock.LengthWritten;
        memcpy(toBlock.Data, fromBlock.Data, BlockSize);
      }
    }

    // Destructor
    ~UntypedBlockArray()
    {
      // Clear out the block array
      Clear();
    }

    // Efficiently compact all the data into one output buffer
    // This will wipe out any empty space between the blocks
    void RelativeCompact(byte* output)
    {
      // Loop through all the blocks
      for (size_t i = 0; i < this->Blocks.size(); ++i)
      {
        // Get the current block
        Block& block = this->Blocks[i];

        // Copy all the block's data to the output
        memcpy(output, block.Data, block.LengthWritten);

        // Move the pointer forward so we can copy the next block
        output += block.LengthWritten;
      }
    }

    // Gets an element in a block given an exact location
    byte* GetAbsoluteElement(size_t index)
    {
      // Determine the block index and offset into that block
      size_t blockIndex = index / BlockSize;
      size_t blockOffset = index % BlockSize;

      // Get the current block
      Block& block = this->Blocks[blockIndex];

      // Return a pointer to that location
      return block.Data + blockOffset;
    }

    // Get an element by index (note that this is not a constant time operation)
    byte* GetRelativeElement(size_t index)
    {
      // Note: This could potentially be optimized using a few key facts
      // We know that we will probably mostly fill up each block, so block sizes
      // very close to the LengthWritten for any given full block
      // Each block could then store all the previous size up to that point
      // We could use the index to guess a block (index / BlockSize) and we know
      // that the element is either in that block or in a previous one close by

      // More than likely, it's not a problem since our block array
      // will be so big that worst case scenario, we're probably 
      // indexing into the second or third block (near constant time)

      // Loop through all the blocks
      for (size_t i = 0; i < this->Blocks.size(); ++i)
      {
        // Get the current block
        Block& block = this->Blocks[i];

        // If the index is within this block
        if (index < block.LengthWritten)
        {
          // Return the element
          return block.Data + index;
        }
        else
        {
          // Move the index back by the amount written to this block
          index -= block.LengthWritten;
        }
      }

      // We didn't find it?
      Error("Unable to find a given element by index");
      return nullptr;
    }
    
    // Get the total size
    size_t RelativeSize()
    {
      return this->CompactedSize;
    }
    
    // Get the total size
    // Note: Do NOT use this as an absolute index, as it's possible that the next element
    // that's added to the block array will get pushed into another block (wrong index...)
    size_t AbsoluteSize()
    {
      if (this->Blocks.empty())
      {
        return 0;
      }
      else
      {
        return (this->Blocks.size() - 1) * BlockSize + this->Blocks.back().LengthWritten;
      }
    }

    // Clear all the of blocks out
    void Clear()
    {
      // Reset the size since we now store nothing
      this->CompactedSize = 0;

      // Loop through all the blocks
      for (size_t i = 0; i < this->Blocks.size(); ++i)
      {
        // Delete the block memory
        delete[] this->Blocks[i].Data;
      }

      // Clear the blocks out too
      this->Blocks.clear();
    }

    // Request a chunk of memory of a given size, and return a pointer to the beginning of it
    byte* RequestElementOfSize(size_t size, size_t* absoluteIndexOut = nullptr)
    {
      // Error checking and handling
      ReturnIf(size > BlockSize, nullptr, "The element that was being allocated was larger than the block size");
      
      // We know that we'll add that size below (we have to!)
      this->CompactedSize += size;

      // If we have no blocks...
      if (this->Blocks.empty())
      {
        // Create our first block since we have none
        this->CreateBlock();
      }

      // Call the recursive version
      return this->RequestElementOfSizeRecursive(size, absoluteIndexOut);
    }

  private:

    // A block of opcodes
    class Block
    {
    public:
      // A pointer to the data that each block stores
      byte* Data;
      
      // The length that we've written into the data block
      // Note that the size of the memory pointed at by 'Data' is the BlockSize, however,
      // we may not have written all the way up to the end due to different opcode sizes
      size_t LengthWritten;
    };

    // Recursive version of requesting an element (we only recurse once)
    byte* RequestElementOfSizeRecursive(size_t size, size_t* absoluteIndexOut = nullptr)
    {
      // Get the last block (the only one we should be writing to)
      Block& last = this->Blocks.back();

      // Check if the last block has enough space for this element
      if (BlockSize - last.LengthWritten > size)
      {
        // Get a pointer to the element data
        byte* element = last.Data + last.LengthWritten;

        // If the user wants an absolute index back...
        if (absoluteIndexOut != nullptr)
        {
          // Return the index where we wrote the data
          *absoluteIndexOut = (this->Blocks.size() - 1) * BlockSize + last.LengthWritten;
        }

        // We've now 'written' more to the last block
        last.LengthWritten += size;

        // Return the element
        return element;
      }
      else
      {
        // Otherwise, we need to create a fresh new block
        this->CreateBlock();

        // Invoke the function again
        return this->RequestElementOfSizeRecursive(size, absoluteIndexOut);
      }
    }

    // Create another block at the end of the block array
    Block& CreateBlock()
    {
      // Create a new block
      Block& block = this->Blocks.push_back();

      // Create the block of data
      block.Data = new byte[BlockSize];

      // We haven't written anything yet
      block.LengthWritten = 0;
      return block;
    }

  private:

    // Store an array of all the blocks that we use
    PodArray<Block> Blocks;

    // Store the total size overall
    size_t CompactedSize;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_BINDING_HPP
#define ZILCH_BINDING_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TRAITS_HPP
#define ZILCH_TRAITS_HPP

// Includes


namespace Zilch
{
  template <typename T>
  class StaticDereference
  {
  public:
    typedef T Type;
  };

  template <typename T>
  class StaticDereference<T*>
  {
  public:
    typedef T Type;
  };

  // Tells us whether a type is a primitive (built in type)
  template <typename T>
  class IsPrimitive
  {
  public:
    static const bool Value = false;
    typedef void FalseType;
  };

  // Mark all the basic types that we know of as primtiive
  template <> class IsPrimitive<          bool     > { public: static const bool Value = true; };
  template <> class IsPrimitive<          float    > { public: static const bool Value = true; };
  template <> class IsPrimitive<          double   > { public: static const bool Value = true; };
  template <> class IsPrimitive<          char     > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    char     > { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  char     > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    short    > { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  short    > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    int      > { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  int      > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    long     > { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  long     > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    long long> { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  long long> { public: static const bool Value = true; };
}

// End header protection
#endif


namespace Zilch
{
  /****************************** CONTAINER RANGE ********************************/
  // We bind container types as a ranges to Zilch (can use foreach)
  // Note: This won't work with Pair ranges unless the pair is also explicitly
  // bound as an external type (before the definition is seen here)
  // The range makes a copy of the container for safety purposes
  template <typename ContainerType, typename RangeType, typename ElementType>
  class ContainerRange
  {
  public:

    // The container that we're iterating through (a copy)
    ContainerType Container;
  };

  /*************************** VIRTUAL DERIVED TYPE ******************************/

  // Derive from object
  class ZeroShared IZilchObject
  {
  public:
    // Declare a virtual destructor
    virtual ~IZilchObject() {}

    // Get the most derived type from an instance of the class (probably a base pointer)
    virtual BoundType* ZilchGetDerivedType() const = 0;
  };

  // This type is used in the case where we have no base type (base type gets defined as this)
  class ZeroShared NoType : public IZilchObject
  {
  public:

    static const TypeCopyMode::Enum ZilchCopyMode = TypeCopyMode::ReferenceType;

    static BoundType* ZilchGetStaticType()
    {
      return nullptr;
    }
    virtual BoundType* ZilchGetDerivedType() const
    {
      return nullptr;
    }
    static void ZilchInitializeStaticType()
    {
    }
    static void ZilchDebugDerivedHasNotBeenDeclared()
    {
    }
    static void ZilchDebugBaseHasNotBeenDeclared()
    {
    }
  };

  
  /********************************** BINDING ************************************/

  // Helper macros for accessing these types
  #define ZilchStaticType(Type) Zilch::TypeBinding::StaticTypeId<Type>
  #define ZilchTypeId(Type) (ZilchStaticType(Type)::Get())
  #define ZilchBindingType(Type) typename ZilchStaticType(Type)::BindingType

  // All things relevant to binding types
  class ZeroShared TypeBinding
  {
  public:

    // Check if a type is derived from a given base
    static bool IsA(BoundType* type, BoundType* base);

    // Check if a type is derived from a given base
    static bool IndirectionIsA(IndirectionType* type, IndirectionType* base);

    // Check if a type is derived from a given base
    static bool GenericIsA(Type* type, Type* base);

    // Dynamically cast a base type into a derived type
    template <typename Derived, typename Base>
    static Derived* DynamicCastEx(Base* baseClassPointer)
    {
      // Do some error checking (these calls will give somewhat intuitive errors if they don't exist)
      #if _DEBUG
      Base::ZilchDebugBaseHasNotBeenDeclared();
      Derived::ZilchDebugDerivedHasNotBeenDeclared();
      #endif

      // If the passed in pointer was null, then return null
      if (baseClassPointer == nullptr)
      {
        // We can't possibly cast it or know what it even is...
        return nullptr;
      }

      // If the cast is safe...
      if (IsA(baseClassPointer->ZilchGetDerivedType(), ZilchTypeId(Derived)))
      {
        // Get the base class pointer
        return static_cast<Derived*>(baseClassPointer);
      }

      // Otherwise the cast failed, return a null pointer
      return nullptr;
    }

    // Dynamically cast a base type into a derived type
    template <typename Derived, typename Base>
    static Derived DynamicCast(Base baseClassPointer)
    {
      return DynamicCastEx<typename StaticDereference<Derived>::Type, typename StaticDereference<Base>::Type>(baseClassPointer);
    }

    // Using SFINAE we can detect if we have the 'ZilchGetDerivedType' method on a type T
    template <typename T>
    class CanGetDerivedType
    {
    private:
      typedef char Yes[1];
      typedef char No[2];

      template <typename U, U>
      class GenericTemplate;

      template <typename C>
      static Yes& Test(GenericTemplate<BoundType* (C::*)() const, &C::ZilchGetDerivedType>*);

      template <typename>
      static No& Test(...);

    public:
        static bool const Result = sizeof(Test<T>(0)) == sizeof(Yes);
    };

    // The macro ZilchVirtualTypeId will create this template using the above SFINAE template (checking for ZilchGetDerivedType)
    // If the method does not exist on type T, then this one will get called (just resulting in the static typeid)
    template <typename T, bool HasZilchGetDerivedType>
    class DiscoverDerivedType
    {
    public:
      static BoundType* Get(T* object)
      {
        return ZilchTypeId(T);
      }
    };

    // If the type T has ZilchGetDerivedType when invoking the macro ZilchVirtualTypeId, this one will get chosen, and will actually invoke ZilchGetDerivedType
    template <typename T>
    class DiscoverDerivedType<T, true>
    {
    public:
      static BoundType* Get(T* object)
      {
        if (object != nullptr)
          return object->ZilchGetDerivedType();
        return ZilchTypeId(T);
      }
    };

    // Get the type of the pointer (using virtual behavior if possible)
    #define ZilchVirtualTypeId(Pointer) Zilch::TypeBinding::DiscoverDerivedType<ZilchStrip(ZilchTypeOf(Pointer)), Zilch::TypeBinding::CanGetDerivedType<ZilchStrip(ZilchTypeOf(Pointer))>::Result>::Get(Pointer)


    template <typename T>
    class StripQualifiers
    {
    public:
      typedef T Type;
    };

    template <typename T>
    class StripQualifiers<T*>
    {
    public:
      // Use template recursion to strip all qualifiers
      typedef typename StripQualifiers<T>::Type Type;
    };

    template <typename T>
    class StripQualifiers<T&>
    {
    public:
      // Use template recursion to strip all qualifiers
      typedef typename StripQualifiers<T>::Type Type;
    };

    template <typename T>
    class StripQualifiers<const T>
    {
    public:
      // Use template recursion to strip all qualifiers
      typedef typename StripQualifiers<T>::Type Type;
    };

    template <typename T>
    class StripQualifiers<volatile T>
    {
    public:
      // Use template recursion to strip all qualifiers
      typedef typename StripQualifiers<T>::Type Type;
    };

    // Strip all const, pointer, reference, and volatile qualifiers from a type to get its core
    #define ZilchStrip(T) typename Zilch::TypeBinding::StripQualifiers<T>::Type

    // Handles:
    //  int
    //  const int
    //  int&
    //  const int&
    template <typename T>
    static T* InternalToPointer(const T& value)
    {
      return (T*)&value;
    }

    // Handles:
    //  int*
    //  const int*
    //  int*&
    //  const int*&
    //  int* const
    //  const int* const
    //  int* const&
    //  const int* const&
    template <typename T>
    static T* InternalToPointer(const T* value)
    {
      return (T*)value;
    }

    // Handles:
    //  const int**
    //  const int**&
    template <typename T>
    static T* InternalToPointer(const T** value)
    {
      return (T*)*value;
    }

    // Handles:
    //  int**
    //  int**&
    template <typename T>
    static T* InternalToPointer(T* const* value)
    {
      return (T*)*value;
    }

    // Takes any expression and turns it into a pointer of the core type
    // Examples: const int** -> int*, or const int& -> int*
    // To just get the type as a pointer rather than the expression, use ZilchStrip(T)*
    #define ZilchToPointer(Expression) (Zilch::TypeBinding::InternalToPointer<ZilchStrip(ZilchTypeOf(Expression))>(Expression))


    // Strips all forms of const from a type
    template <typename T>
    class StripConst
    {
    public:
      typedef T Type;
    };

    template <typename T>
    class StripConst<const T> : public StripConst<T>
    {
    };

    template <typename T>
    class StripConst<const T&> : public StripConst<typename StripConst<T>::Type&>
    {
    };

    // Value to value
    template <typename From, typename To> class ReferenceCast              { public: static To  Cast(From   from) { return  from; } };
    // Value to pointer (illegal)
    template <typename From, typename To> class ReferenceCast<From  , To*> { public: static To* Cast(From   from) { return "IllegalConversionFromValueToPointer"; } };
    // Value to reference (illegal)
    template <typename From, typename To> class ReferenceCast<From  , To&> { public: static To& Cast(From   from) { return "IllegalConversionFromValueToReference"; } };
    // Pointer to pointer
    template <typename From, typename To> class ReferenceCast<From* , To*> { public: static To* Cast(From*  from) { return  from; } };
    // Pointer to reference
    template <typename From, typename To> class ReferenceCast<From* , To&> { public: static To& Cast(From*  from) { return *from; } };
    // Pointer to value (only works because we specialized pointer and reference above)
    template <typename From, typename To> class ReferenceCast<From* , To > { public: static To  Cast(From*  from) { return *from; } };
    // Reference to reference
    template <typename From, typename To> class ReferenceCast<From& , To&> { public: static To& Cast(From&  from) { return  from; } };
    // Reference to pointer
    template <typename From, typename To> class ReferenceCast<From& , To*> { public: static To* Cast(From&  from) { return &from; } };
    // Reference to value
    template <typename From, typename To> class ReferenceCast<From& , To > { public: static To  Cast(From&  from) { return  from; } };
    // Reference to a pointer to pointer
    template <typename From, typename To> class ReferenceCast<From*&, To*> { public: static To* Cast(From*& from) { return  from; } };
    // Reference to a pointer to reference
    template <typename From, typename To> class ReferenceCast<From*&, To&> { public: static To& Cast(From*& from) { return *from; } };

    template <typename T>
    class FromDataPointer
    {
    public:
      static T Cast(byte* data)
      {
        return *(T*)data;
      }
    };

    template <typename T>
    class FromDataPointer<T*>
    {
    public:
      static T* Cast(byte* data)
      {
        return (T*)data;
      }
    };

    template <typename T>
    class FromDataPointer<T&>
    {
    public:
      static T& Cast(byte* data)
      {
        return *(T*)data;
      }
    };

    template <typename T>
    class ToDataPointer
    {
    public:
      static byte* Cast(const T& value)
      {
        return (byte*)&value;
      }
    };

    template <typename T>
    class ToDataPointer<T*>
    {
    public:
      static byte* Cast(T* value)
      {
        return (byte*)value;
      }
    };

    template <typename T>
    class ToDataPointer<T&>
    {
    public:
      static byte* Cast(T& value)
      {
        return (byte*)&value;
      }
    };

    // Lets us choose one type or the other based the condition (eg TypeChooser<int, float, false>::Type will be float)
    template <typename IfTrueType, typename IfFalseType, bool condition>
    class TypeChooser
    {
    public:
    };

    template <typename IfTrueType, typename IfFalseType>
    class TypeChooser<IfTrueType, IfFalseType, true>
    {
    public:
      typedef IfTrueType Type;
    };

    template <typename IfTrueType, typename IfFalseType>
    class TypeChooser<IfTrueType, IfFalseType, false>
    {
    public:
      typedef IfFalseType Type;
    };

    // A template for grabbing a TypeInfo given a template type
    // (This template can be specialized using macros)
    // Tthis is to allow Rtti for pre-defined types such as int, via specialization
    template <typename T>
    class ZeroSharedTemplate StaticTypeId
    {
    public:
      // Lets us know at compile time whether this is a value/complex type
      static const TypeCopyMode::Enum CopyMode = T::ZilchCopyMode;

      // The T type (and because partial specializations of 'StaticTypeId', this will always be a stripped type)
      typedef T UnqualifiedType;

      // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
      typedef T QualifiedType;

      // The type we use in any generated binding. This is generally the QualifiedType, however if the type is a redirect, it will be unqualified
      typedef T BindingType;

      // This is the type that we represent when written to the stack
      // (as a value type) or dereferenced from a handle (as a reference type)
      typedef T RepresentedType;

      // Because our representation is the exact same (whether in C++ or on the stack/in a handle)
      // then our resulting type when read is just a reference (not the case in all specializations!)
      typedef T& ReadType;
      
      // Since our representation is the exact same (as mentioned above) this will be a direct read
      static const bool DirectRead = true;
      
      // Read our object representation from either stack data or handle data
      static ReadType Read(byte* from)
      {
        // Reading and writing by default should just be pulling the object out directly
        return *(T*)from;
      }

      // Write our object representation to either stack data or handle data
      static void Write(const T& value, byte* to)
      {
        // Copy construct our object direclty into the memory location
        Error("This should detect copy constructors, or we should make the user specify non-copyable");
        const void* valueMemory = &value;
        memcpy(to, valueMemory, sizeof(T));
        //new (to) T(value);
      }

      static BoundType* Get()
      {
        // If no specialization was made, then we expect that the class we're trying
        // to get a type-info from has a 'GetStaticType' function
        return T::ZilchGetStaticType();
      }

      static void InitializeStaticType()
      {
        // This can be specialized to invoke other initialize functions
        T::ZilchInitializeStaticType();
      }
    };

    // A partial specialization for reference types
    template <typename T>
    class ZeroSharedTemplate StaticTypeId<T&> : public StaticTypeId<T>
    {
    public:
      // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
      typedef T& QualifiedType;

      // Based on whether this object supports direct reading or not, we choose to use the qualified or unqualified type in binding
      typedef typename TypeChooser<QualifiedType, typename StaticTypeId<T>::UnqualifiedType, StaticTypeId<T>::DirectRead>::Type BindingType;
    };

    // A partial specialization for reference types
    template <typename T>
    class ZeroSharedTemplate StaticTypeId<const T> : public StaticTypeId<T>
    {
    public:
      // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
      typedef const T QualifiedType;

      // Based on whether this object supports direct reading or not, we choose to use the qualified or unqualified type in binding
      typedef typename TypeChooser<QualifiedType, typename StaticTypeId<T>::UnqualifiedType, StaticTypeId<T>::DirectRead>::Type BindingType;
    };

    // A partial specialization for pointer types
    template <typename T>
    class ZeroSharedTemplate StaticTypeId<T*> : public StaticTypeId<T>
    {
    public:
      // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
      typedef T* QualifiedType;

      // Based on whether this object supports direct reading or not, we choose to use the qualified or unqualified type in binding
      typedef typename TypeChooser<QualifiedType, typename StaticTypeId<T>::UnqualifiedType, StaticTypeId<T>::DirectRead>::Type BindingType;
    };

    // Used to count virtual table functions or get a virtual method index
    class VirtualTableCounter
    {
    public:

      // Constructor
      VirtualTableCounter();

      // A helper to tell us whether or not a method being tested is virtual 
      static bool StaticDebugIsVirtual;

      // An extra helper to tell us whether or not a method being tested is virtual
      bool InstanceDebugIsVirtual;

      // Checks if the function we were testing was virtual or not
      void AssertIfNotVirtual();

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

virtual size_t Get0()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 0;
}

virtual size_t Get1()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 1;
}

virtual size_t Get2()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 2;
}

virtual size_t Get3()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 3;
}

virtual size_t Get4()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 4;
}

virtual size_t Get5()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 5;
}

virtual size_t Get6()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 6;
}

virtual size_t Get7()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 7;
}

virtual size_t Get8()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 8;
}

virtual size_t Get9()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 9;
}

virtual size_t Get10()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 10;
}

virtual size_t Get11()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 11;
}

virtual size_t Get12()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 12;
}

virtual size_t Get13()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 13;
}

virtual size_t Get14()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 14;
}

virtual size_t Get15()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 15;
}

virtual size_t Get16()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 16;
}

virtual size_t Get17()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 17;
}

virtual size_t Get18()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 18;
}

virtual size_t Get19()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 19;
}

virtual size_t Get20()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 20;
}

virtual size_t Get21()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 21;
}

virtual size_t Get22()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 22;
}

virtual size_t Get23()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 23;
}

virtual size_t Get24()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 24;
}

virtual size_t Get25()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 25;
}

virtual size_t Get26()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 26;
}

virtual size_t Get27()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 27;
}

virtual size_t Get28()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 28;
}

virtual size_t Get29()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 29;
}

virtual size_t Get30()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 30;
}

virtual size_t Get31()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 31;
}

virtual size_t Get32()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 32;
}

virtual size_t Get33()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 33;
}

virtual size_t Get34()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 34;
}

virtual size_t Get35()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 35;
}

virtual size_t Get36()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 36;
}

virtual size_t Get37()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 37;
}

virtual size_t Get38()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 38;
}

virtual size_t Get39()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 39;
}

virtual size_t Get40()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 40;
}

virtual size_t Get41()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 41;
}

virtual size_t Get42()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 42;
}

virtual size_t Get43()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 43;
}

virtual size_t Get44()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 44;
}

virtual size_t Get45()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 45;
}

virtual size_t Get46()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 46;
}

virtual size_t Get47()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 47;
}

virtual size_t Get48()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 48;
}

virtual size_t Get49()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 49;
}

virtual size_t Get50()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 50;
}

virtual size_t Get51()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 51;
}

virtual size_t Get52()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 52;
}

virtual size_t Get53()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 53;
}

virtual size_t Get54()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 54;
}

virtual size_t Get55()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 55;
}

virtual size_t Get56()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 56;
}

virtual size_t Get57()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 57;
}

virtual size_t Get58()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 58;
}

virtual size_t Get59()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 59;
}

virtual size_t Get60()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 60;
}

virtual size_t Get61()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 61;
}

virtual size_t Get62()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 62;
}

virtual size_t Get63()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 63;
}

virtual size_t Get64()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 64;
}

virtual size_t Get65()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 65;
}

virtual size_t Get66()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 66;
}

virtual size_t Get67()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 67;
}

virtual size_t Get68()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 68;
}

virtual size_t Get69()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 69;
}

virtual size_t Get70()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 70;
}

virtual size_t Get71()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 71;
}

virtual size_t Get72()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 72;
}

virtual size_t Get73()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 73;
}

virtual size_t Get74()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 74;
}

virtual size_t Get75()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 75;
}

virtual size_t Get76()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 76;
}

virtual size_t Get77()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 77;
}

virtual size_t Get78()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 78;
}

virtual size_t Get79()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 79;
}

virtual size_t Get80()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 80;
}

virtual size_t Get81()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 81;
}

virtual size_t Get82()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 82;
}

virtual size_t Get83()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 83;
}

virtual size_t Get84()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 84;
}

virtual size_t Get85()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 85;
}

virtual size_t Get86()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 86;
}

virtual size_t Get87()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 87;
}

virtual size_t Get88()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 88;
}

virtual size_t Get89()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 89;
}

virtual size_t Get90()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 90;
}

virtual size_t Get91()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 91;
}

virtual size_t Get92()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 92;
}

virtual size_t Get93()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 93;
}

virtual size_t Get94()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 94;
}

virtual size_t Get95()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 95;
}

virtual size_t Get96()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 96;
}

virtual size_t Get97()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 97;
}

virtual size_t Get98()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 98;
}

virtual size_t Get99()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 99;
}

virtual size_t Get100()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 100;
}

virtual size_t Get101()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 101;
}

virtual size_t Get102()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 102;
}

virtual size_t Get103()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 103;
}

virtual size_t Get104()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 104;
}

virtual size_t Get105()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 105;
}

virtual size_t Get106()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 106;
}

virtual size_t Get107()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 107;
}

virtual size_t Get108()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 108;
}

virtual size_t Get109()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 109;
}

virtual size_t Get110()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 110;
}

virtual size_t Get111()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 111;
}

virtual size_t Get112()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 112;
}

virtual size_t Get113()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 113;
}

virtual size_t Get114()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 114;
}

virtual size_t Get115()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 115;
}

virtual size_t Get116()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 116;
}

virtual size_t Get117()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 117;
}

virtual size_t Get118()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 118;
}

virtual size_t Get119()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 119;
}

virtual size_t Get120()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 120;
}

virtual size_t Get121()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 121;
}

virtual size_t Get122()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 122;
}

virtual size_t Get123()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 123;
}

virtual size_t Get124()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 124;
}

virtual size_t Get125()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 125;
}

virtual size_t Get126()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 126;
}

virtual size_t Get127()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 127;
}

virtual size_t Get128()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 128;
}

virtual size_t Get129()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 129;
}

virtual size_t Get130()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 130;
}

virtual size_t Get131()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 131;
}

virtual size_t Get132()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 132;
}

virtual size_t Get133()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 133;
}

virtual size_t Get134()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 134;
}

virtual size_t Get135()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 135;
}

virtual size_t Get136()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 136;
}

virtual size_t Get137()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 137;
}

virtual size_t Get138()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 138;
}

virtual size_t Get139()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 139;
}

virtual size_t Get140()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 140;
}

virtual size_t Get141()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 141;
}

virtual size_t Get142()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 142;
}

virtual size_t Get143()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 143;
}

virtual size_t Get144()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 144;
}

virtual size_t Get145()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 145;
}

virtual size_t Get146()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 146;
}

virtual size_t Get147()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 147;
}

virtual size_t Get148()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 148;
}

virtual size_t Get149()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 149;
}

virtual size_t Get150()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 150;
}

virtual size_t Get151()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 151;
}

virtual size_t Get152()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 152;
}

virtual size_t Get153()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 153;
}

virtual size_t Get154()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 154;
}

virtual size_t Get155()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 155;
}

virtual size_t Get156()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 156;
}

virtual size_t Get157()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 157;
}

virtual size_t Get158()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 158;
}

virtual size_t Get159()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 159;
}

virtual size_t Get160()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 160;
}

virtual size_t Get161()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 161;
}

virtual size_t Get162()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 162;
}

virtual size_t Get163()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 163;
}

virtual size_t Get164()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 164;
}

virtual size_t Get165()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 165;
}

virtual size_t Get166()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 166;
}

virtual size_t Get167()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 167;
}

virtual size_t Get168()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 168;
}

virtual size_t Get169()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 169;
}

virtual size_t Get170()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 170;
}

virtual size_t Get171()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 171;
}

virtual size_t Get172()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 172;
}

virtual size_t Get173()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 173;
}

virtual size_t Get174()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 174;
}

virtual size_t Get175()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 175;
}

virtual size_t Get176()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 176;
}

virtual size_t Get177()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 177;
}

virtual size_t Get178()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 178;
}

virtual size_t Get179()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 179;
}

virtual size_t Get180()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 180;
}

virtual size_t Get181()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 181;
}

virtual size_t Get182()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 182;
}

virtual size_t Get183()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 183;
}

virtual size_t Get184()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 184;
}

virtual size_t Get185()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 185;
}

virtual size_t Get186()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 186;
}

virtual size_t Get187()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 187;
}

virtual size_t Get188()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 188;
}

virtual size_t Get189()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 189;
}

virtual size_t Get190()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 190;
}

virtual size_t Get191()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 191;
}

virtual size_t Get192()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 192;
}

virtual size_t Get193()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 193;
}

virtual size_t Get194()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 194;
}

virtual size_t Get195()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 195;
}

virtual size_t Get196()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 196;
}

virtual size_t Get197()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 197;
}

virtual size_t Get198()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 198;
}

virtual size_t Get199()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 199;
}

virtual size_t Get200()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 200;
}

virtual size_t Get201()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 201;
}

virtual size_t Get202()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 202;
}

virtual size_t Get203()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 203;
}

virtual size_t Get204()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 204;
}

virtual size_t Get205()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 205;
}

virtual size_t Get206()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 206;
}

virtual size_t Get207()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 207;
}

virtual size_t Get208()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 208;
}

virtual size_t Get209()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 209;
}

virtual size_t Get210()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 210;
}

virtual size_t Get211()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 211;
}

virtual size_t Get212()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 212;
}

virtual size_t Get213()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 213;
}

virtual size_t Get214()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 214;
}

virtual size_t Get215()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 215;
}

virtual size_t Get216()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 216;
}

virtual size_t Get217()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 217;
}

virtual size_t Get218()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 218;
}

virtual size_t Get219()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 219;
}

virtual size_t Get220()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 220;
}

virtual size_t Get221()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 221;
}

virtual size_t Get222()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 222;
}

virtual size_t Get223()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 223;
}

virtual size_t Get224()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 224;
}

virtual size_t Get225()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 225;
}

virtual size_t Get226()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 226;
}

virtual size_t Get227()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 227;
}

virtual size_t Get228()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 228;
}

virtual size_t Get229()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 229;
}

virtual size_t Get230()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 230;
}

virtual size_t Get231()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 231;
}

virtual size_t Get232()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 232;
}

virtual size_t Get233()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 233;
}

virtual size_t Get234()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 234;
}

virtual size_t Get235()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 235;
}

virtual size_t Get236()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 236;
}

virtual size_t Get237()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 237;
}

virtual size_t Get238()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 238;
}

virtual size_t Get239()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 239;
}

virtual size_t Get240()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 240;
}

virtual size_t Get241()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 241;
}

virtual size_t Get242()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 242;
}

virtual size_t Get243()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 243;
}

virtual size_t Get244()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 244;
}

virtual size_t Get245()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 245;
}

virtual size_t Get246()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 246;
}

virtual size_t Get247()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 247;
}

virtual size_t Get248()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 248;
}

virtual size_t Get249()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 249;
}

virtual size_t Get250()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 250;
}

virtual size_t Get251()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 251;
}

virtual size_t Get252()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 252;
}

virtual size_t Get253()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 253;
}

virtual size_t Get254()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 254;
}

virtual size_t Get255()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 255;
}

virtual size_t Get256()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 256;
}

virtual size_t Get257()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 257;
}

virtual size_t Get258()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 258;
}

virtual size_t Get259()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 259;
}

virtual size_t Get260()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 260;
}

virtual size_t Get261()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 261;
}

virtual size_t Get262()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 262;
}

virtual size_t Get263()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 263;
}

virtual size_t Get264()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 264;
}

virtual size_t Get265()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 265;
}

virtual size_t Get266()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 266;
}

virtual size_t Get267()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 267;
}

virtual size_t Get268()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 268;
}

virtual size_t Get269()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 269;
}

virtual size_t Get270()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 270;
}

virtual size_t Get271()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 271;
}

virtual size_t Get272()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 272;
}

virtual size_t Get273()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 273;
}

virtual size_t Get274()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 274;
}

virtual size_t Get275()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 275;
}

virtual size_t Get276()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 276;
}

virtual size_t Get277()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 277;
}

virtual size_t Get278()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 278;
}

virtual size_t Get279()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 279;
}

virtual size_t Get280()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 280;
}

virtual size_t Get281()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 281;
}

virtual size_t Get282()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 282;
}

virtual size_t Get283()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 283;
}

virtual size_t Get284()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 284;
}

virtual size_t Get285()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 285;
}

virtual size_t Get286()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 286;
}

virtual size_t Get287()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 287;
}

virtual size_t Get288()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 288;
}

virtual size_t Get289()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 289;
}

virtual size_t Get290()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 290;
}

virtual size_t Get291()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 291;
}

virtual size_t Get292()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 292;
}

virtual size_t Get293()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 293;
}

virtual size_t Get294()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 294;
}

virtual size_t Get295()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 295;
}

virtual size_t Get296()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 296;
}

virtual size_t Get297()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 297;
}

virtual size_t Get298()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 298;
}

virtual size_t Get299()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 299;
}

virtual size_t Get300()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 300;
}

virtual size_t Get301()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 301;
}

virtual size_t Get302()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 302;
}

virtual size_t Get303()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 303;
}

virtual size_t Get304()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 304;
}

virtual size_t Get305()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 305;
}

virtual size_t Get306()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 306;
}

virtual size_t Get307()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 307;
}

virtual size_t Get308()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 308;
}

virtual size_t Get309()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 309;
}

virtual size_t Get310()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 310;
}

virtual size_t Get311()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 311;
}

virtual size_t Get312()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 312;
}

virtual size_t Get313()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 313;
}

virtual size_t Get314()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 314;
}

virtual size_t Get315()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 315;
}

virtual size_t Get316()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 316;
}

virtual size_t Get317()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 317;
}

virtual size_t Get318()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 318;
}

virtual size_t Get319()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 319;
}

virtual size_t Get320()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 320;
}

virtual size_t Get321()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 321;
}

virtual size_t Get322()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 322;
}

virtual size_t Get323()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 323;
}

virtual size_t Get324()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 324;
}

virtual size_t Get325()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 325;
}

virtual size_t Get326()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 326;
}

virtual size_t Get327()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 327;
}

virtual size_t Get328()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 328;
}

virtual size_t Get329()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 329;
}

virtual size_t Get330()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 330;
}

virtual size_t Get331()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 331;
}

virtual size_t Get332()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 332;
}

virtual size_t Get333()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 333;
}

virtual size_t Get334()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 334;
}

virtual size_t Get335()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 335;
}

virtual size_t Get336()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 336;
}

virtual size_t Get337()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 337;
}

virtual size_t Get338()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 338;
}

virtual size_t Get339()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 339;
}

virtual size_t Get340()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 340;
}

virtual size_t Get341()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 341;
}

virtual size_t Get342()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 342;
}

virtual size_t Get343()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 343;
}

virtual size_t Get344()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 344;
}

virtual size_t Get345()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 345;
}

virtual size_t Get346()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 346;
}

virtual size_t Get347()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 347;
}

virtual size_t Get348()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 348;
}

virtual size_t Get349()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 349;
}

virtual size_t Get350()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 350;
}

virtual size_t Get351()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 351;
}

virtual size_t Get352()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 352;
}

virtual size_t Get353()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 353;
}

virtual size_t Get354()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 354;
}

virtual size_t Get355()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 355;
}

virtual size_t Get356()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 356;
}

virtual size_t Get357()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 357;
}

virtual size_t Get358()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 358;
}

virtual size_t Get359()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 359;
}

virtual size_t Get360()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 360;
}

virtual size_t Get361()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 361;
}

virtual size_t Get362()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 362;
}

virtual size_t Get363()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 363;
}

virtual size_t Get364()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 364;
}

virtual size_t Get365()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 365;
}

virtual size_t Get366()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 366;
}

virtual size_t Get367()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 367;
}

virtual size_t Get368()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 368;
}

virtual size_t Get369()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 369;
}

virtual size_t Get370()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 370;
}

virtual size_t Get371()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 371;
}

virtual size_t Get372()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 372;
}

virtual size_t Get373()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 373;
}

virtual size_t Get374()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 374;
}

virtual size_t Get375()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 375;
}

virtual size_t Get376()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 376;
}

virtual size_t Get377()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 377;
}

virtual size_t Get378()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 378;
}

virtual size_t Get379()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 379;
}

virtual size_t Get380()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 380;
}

virtual size_t Get381()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 381;
}

virtual size_t Get382()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 382;
}

virtual size_t Get383()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 383;
}

virtual size_t Get384()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 384;
}

virtual size_t Get385()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 385;
}

virtual size_t Get386()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 386;
}

virtual size_t Get387()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 387;
}

virtual size_t Get388()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 388;
}

virtual size_t Get389()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 389;
}

virtual size_t Get390()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 390;
}

virtual size_t Get391()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 391;
}

virtual size_t Get392()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 392;
}

virtual size_t Get393()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 393;
}

virtual size_t Get394()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 394;
}

virtual size_t Get395()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 395;
}

virtual size_t Get396()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 396;
}

virtual size_t Get397()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 397;
}

virtual size_t Get398()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 398;
}

virtual size_t Get399()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 399;
}

virtual size_t Get400()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 400;
}

virtual size_t Get401()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 401;
}

virtual size_t Get402()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 402;
}

virtual size_t Get403()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 403;
}

virtual size_t Get404()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 404;
}

virtual size_t Get405()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 405;
}

virtual size_t Get406()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 406;
}

virtual size_t Get407()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 407;
}

virtual size_t Get408()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 408;
}

virtual size_t Get409()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 409;
}

virtual size_t Get410()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 410;
}

virtual size_t Get411()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 411;
}

virtual size_t Get412()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 412;
}

virtual size_t Get413()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 413;
}

virtual size_t Get414()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 414;
}

virtual size_t Get415()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 415;
}

virtual size_t Get416()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 416;
}

virtual size_t Get417()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 417;
}

virtual size_t Get418()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 418;
}

virtual size_t Get419()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 419;
}

virtual size_t Get420()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 420;
}

virtual size_t Get421()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 421;
}

virtual size_t Get422()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 422;
}

virtual size_t Get423()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 423;
}

virtual size_t Get424()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 424;
}

virtual size_t Get425()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 425;
}

virtual size_t Get426()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 426;
}

virtual size_t Get427()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 427;
}

virtual size_t Get428()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 428;
}

virtual size_t Get429()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 429;
}

virtual size_t Get430()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 430;
}

virtual size_t Get431()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 431;
}

virtual size_t Get432()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 432;
}

virtual size_t Get433()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 433;
}

virtual size_t Get434()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 434;
}

virtual size_t Get435()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 435;
}

virtual size_t Get436()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 436;
}

virtual size_t Get437()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 437;
}

virtual size_t Get438()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 438;
}

virtual size_t Get439()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 439;
}

virtual size_t Get440()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 440;
}

virtual size_t Get441()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 441;
}

virtual size_t Get442()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 442;
}

virtual size_t Get443()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 443;
}

virtual size_t Get444()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 444;
}

virtual size_t Get445()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 445;
}

virtual size_t Get446()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 446;
}

virtual size_t Get447()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 447;
}

virtual size_t Get448()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 448;
}

virtual size_t Get449()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 449;
}

virtual size_t Get450()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 450;
}

virtual size_t Get451()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 451;
}

virtual size_t Get452()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 452;
}

virtual size_t Get453()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 453;
}

virtual size_t Get454()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 454;
}

virtual size_t Get455()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 455;
}

virtual size_t Get456()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 456;
}

virtual size_t Get457()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 457;
}

virtual size_t Get458()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 458;
}

virtual size_t Get459()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 459;
}

virtual size_t Get460()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 460;
}

virtual size_t Get461()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 461;
}

virtual size_t Get462()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 462;
}

virtual size_t Get463()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 463;
}

virtual size_t Get464()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 464;
}

virtual size_t Get465()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 465;
}

virtual size_t Get466()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 466;
}

virtual size_t Get467()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 467;
}

virtual size_t Get468()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 468;
}

virtual size_t Get469()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 469;
}

virtual size_t Get470()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 470;
}

virtual size_t Get471()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 471;
}

virtual size_t Get472()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 472;
}

virtual size_t Get473()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 473;
}

virtual size_t Get474()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 474;
}

virtual size_t Get475()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 475;
}

virtual size_t Get476()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 476;
}

virtual size_t Get477()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 477;
}

virtual size_t Get478()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 478;
}

virtual size_t Get479()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 479;
}

virtual size_t Get480()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 480;
}

virtual size_t Get481()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 481;
}

virtual size_t Get482()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 482;
}

virtual size_t Get483()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 483;
}

virtual size_t Get484()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 484;
}

virtual size_t Get485()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 485;
}

virtual size_t Get486()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 486;
}

virtual size_t Get487()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 487;
}

virtual size_t Get488()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 488;
}

virtual size_t Get489()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 489;
}

virtual size_t Get490()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 490;
}

virtual size_t Get491()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 491;
}

virtual size_t Get492()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 492;
}

virtual size_t Get493()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 493;
}

virtual size_t Get494()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 494;
}

virtual size_t Get495()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 495;
}

virtual size_t Get496()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 496;
}

virtual size_t Get497()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 497;
}

virtual size_t Get498()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 498;
}

virtual size_t Get499()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 499;
}

virtual size_t Get500()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 500;
}

virtual size_t Get501()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 501;
}

virtual size_t Get502()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 502;
}

virtual size_t Get503()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 503;
}

virtual size_t Get504()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 504;
}

virtual size_t Get505()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 505;
}

virtual size_t Get506()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 506;
}

virtual size_t Get507()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 507;
}

virtual size_t Get508()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 508;
}

virtual size_t Get509()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 509;
}

virtual size_t Get510()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 510;
}

virtual size_t Get511()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 511;
}

virtual size_t Get512()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 512;
}

virtual size_t Get513()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 513;
}

virtual size_t Get514()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 514;
}

virtual size_t Get515()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 515;
}

virtual size_t Get516()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 516;
}

virtual size_t Get517()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 517;
}

virtual size_t Get518()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 518;
}

virtual size_t Get519()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 519;
}

virtual size_t Get520()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 520;
}

virtual size_t Get521()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 521;
}

virtual size_t Get522()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 522;
}

virtual size_t Get523()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 523;
}

virtual size_t Get524()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 524;
}

virtual size_t Get525()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 525;
}

virtual size_t Get526()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 526;
}

virtual size_t Get527()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 527;
}

virtual size_t Get528()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 528;
}

virtual size_t Get529()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 529;
}

virtual size_t Get530()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 530;
}

virtual size_t Get531()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 531;
}

virtual size_t Get532()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 532;
}

virtual size_t Get533()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 533;
}

virtual size_t Get534()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 534;
}

virtual size_t Get535()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 535;
}

virtual size_t Get536()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 536;
}

virtual size_t Get537()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 537;
}

virtual size_t Get538()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 538;
}

virtual size_t Get539()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 539;
}

virtual size_t Get540()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 540;
}

virtual size_t Get541()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 541;
}

virtual size_t Get542()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 542;
}

virtual size_t Get543()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 543;
}

virtual size_t Get544()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 544;
}

virtual size_t Get545()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 545;
}

virtual size_t Get546()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 546;
}

virtual size_t Get547()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 547;
}

virtual size_t Get548()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 548;
}

virtual size_t Get549()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 549;
}

virtual size_t Get550()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 550;
}

virtual size_t Get551()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 551;
}

virtual size_t Get552()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 552;
}

virtual size_t Get553()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 553;
}

virtual size_t Get554()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 554;
}

virtual size_t Get555()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 555;
}

virtual size_t Get556()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 556;
}

virtual size_t Get557()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 557;
}

virtual size_t Get558()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 558;
}

virtual size_t Get559()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 559;
}

virtual size_t Get560()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 560;
}

virtual size_t Get561()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 561;
}

virtual size_t Get562()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 562;
}

virtual size_t Get563()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 563;
}

virtual size_t Get564()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 564;
}

virtual size_t Get565()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 565;
}

virtual size_t Get566()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 566;
}

virtual size_t Get567()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 567;
}

virtual size_t Get568()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 568;
}

virtual size_t Get569()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 569;
}

virtual size_t Get570()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 570;
}

virtual size_t Get571()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 571;
}

virtual size_t Get572()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 572;
}

virtual size_t Get573()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 573;
}

virtual size_t Get574()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 574;
}

virtual size_t Get575()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 575;
}

virtual size_t Get576()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 576;
}

virtual size_t Get577()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 577;
}

virtual size_t Get578()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 578;
}

virtual size_t Get579()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 579;
}

virtual size_t Get580()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 580;
}

virtual size_t Get581()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 581;
}

virtual size_t Get582()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 582;
}

virtual size_t Get583()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 583;
}

virtual size_t Get584()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 584;
}

virtual size_t Get585()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 585;
}

virtual size_t Get586()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 586;
}

virtual size_t Get587()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 587;
}

virtual size_t Get588()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 588;
}

virtual size_t Get589()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 589;
}

virtual size_t Get590()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 590;
}

virtual size_t Get591()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 591;
}

virtual size_t Get592()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 592;
}

virtual size_t Get593()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 593;
}

virtual size_t Get594()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 594;
}

virtual size_t Get595()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 595;
}

virtual size_t Get596()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 596;
}

virtual size_t Get597()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 597;
}

virtual size_t Get598()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 598;
}

virtual size_t Get599()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 599;
}

virtual size_t Get600()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 600;
}

virtual size_t Get601()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 601;
}

virtual size_t Get602()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 602;
}

virtual size_t Get603()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 603;
}

virtual size_t Get604()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 604;
}

virtual size_t Get605()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 605;
}

virtual size_t Get606()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 606;
}

virtual size_t Get607()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 607;
}

virtual size_t Get608()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 608;
}

virtual size_t Get609()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 609;
}

virtual size_t Get610()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 610;
}

virtual size_t Get611()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 611;
}

virtual size_t Get612()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 612;
}

virtual size_t Get613()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 613;
}

virtual size_t Get614()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 614;
}

virtual size_t Get615()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 615;
}

virtual size_t Get616()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 616;
}

virtual size_t Get617()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 617;
}

virtual size_t Get618()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 618;
}

virtual size_t Get619()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 619;
}

virtual size_t Get620()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 620;
}

virtual size_t Get621()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 621;
}

virtual size_t Get622()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 622;
}

virtual size_t Get623()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 623;
}

virtual size_t Get624()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 624;
}

virtual size_t Get625()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 625;
}

virtual size_t Get626()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 626;
}

virtual size_t Get627()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 627;
}

virtual size_t Get628()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 628;
}

virtual size_t Get629()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 629;
}

virtual size_t Get630()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 630;
}

virtual size_t Get631()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 631;
}

virtual size_t Get632()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 632;
}

virtual size_t Get633()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 633;
}

virtual size_t Get634()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 634;
}

virtual size_t Get635()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 635;
}

virtual size_t Get636()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 636;
}

virtual size_t Get637()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 637;
}

virtual size_t Get638()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 638;
}

virtual size_t Get639()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 639;
}

virtual size_t Get640()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 640;
}

virtual size_t Get641()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 641;
}

virtual size_t Get642()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 642;
}

virtual size_t Get643()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 643;
}

virtual size_t Get644()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 644;
}

virtual size_t Get645()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 645;
}

virtual size_t Get646()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 646;
}

virtual size_t Get647()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 647;
}

virtual size_t Get648()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 648;
}

virtual size_t Get649()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 649;
}

virtual size_t Get650()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 650;
}

virtual size_t Get651()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 651;
}

virtual size_t Get652()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 652;
}

virtual size_t Get653()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 653;
}

virtual size_t Get654()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 654;
}

virtual size_t Get655()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 655;
}

virtual size_t Get656()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 656;
}

virtual size_t Get657()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 657;
}

virtual size_t Get658()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 658;
}

virtual size_t Get659()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 659;
}

virtual size_t Get660()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 660;
}

virtual size_t Get661()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 661;
}

virtual size_t Get662()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 662;
}

virtual size_t Get663()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 663;
}

virtual size_t Get664()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 664;
}

virtual size_t Get665()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 665;
}

virtual size_t Get666()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 666;
}

virtual size_t Get667()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 667;
}

virtual size_t Get668()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 668;
}

virtual size_t Get669()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 669;
}

virtual size_t Get670()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 670;
}

virtual size_t Get671()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 671;
}

virtual size_t Get672()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 672;
}

virtual size_t Get673()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 673;
}

virtual size_t Get674()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 674;
}

virtual size_t Get675()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 675;
}

virtual size_t Get676()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 676;
}

virtual size_t Get677()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 677;
}

virtual size_t Get678()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 678;
}

virtual size_t Get679()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 679;
}

virtual size_t Get680()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 680;
}

virtual size_t Get681()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 681;
}

virtual size_t Get682()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 682;
}

virtual size_t Get683()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 683;
}

virtual size_t Get684()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 684;
}

virtual size_t Get685()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 685;
}

virtual size_t Get686()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 686;
}

virtual size_t Get687()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 687;
}

virtual size_t Get688()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 688;
}

virtual size_t Get689()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 689;
}

virtual size_t Get690()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 690;
}

virtual size_t Get691()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 691;
}

virtual size_t Get692()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 692;
}

virtual size_t Get693()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 693;
}

virtual size_t Get694()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 694;
}

virtual size_t Get695()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 695;
}

virtual size_t Get696()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 696;
}

virtual size_t Get697()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 697;
}

virtual size_t Get698()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 698;
}

virtual size_t Get699()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 699;
}

virtual size_t Get700()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 700;
}

virtual size_t Get701()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 701;
}

virtual size_t Get702()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 702;
}

virtual size_t Get703()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 703;
}

virtual size_t Get704()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 704;
}

virtual size_t Get705()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 705;
}

virtual size_t Get706()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 706;
}

virtual size_t Get707()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 707;
}

virtual size_t Get708()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 708;
}

virtual size_t Get709()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 709;
}

virtual size_t Get710()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 710;
}

virtual size_t Get711()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 711;
}

virtual size_t Get712()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 712;
}

virtual size_t Get713()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 713;
}

virtual size_t Get714()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 714;
}

virtual size_t Get715()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 715;
}

virtual size_t Get716()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 716;
}

virtual size_t Get717()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 717;
}

virtual size_t Get718()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 718;
}

virtual size_t Get719()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 719;
}

virtual size_t Get720()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 720;
}

virtual size_t Get721()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 721;
}

virtual size_t Get722()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 722;
}

virtual size_t Get723()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 723;
}

virtual size_t Get724()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 724;
}

virtual size_t Get725()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 725;
}

virtual size_t Get726()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 726;
}

virtual size_t Get727()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 727;
}

virtual size_t Get728()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 728;
}

virtual size_t Get729()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 729;
}

virtual size_t Get730()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 730;
}

virtual size_t Get731()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 731;
}

virtual size_t Get732()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 732;
}

virtual size_t Get733()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 733;
}

virtual size_t Get734()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 734;
}

virtual size_t Get735()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 735;
}

virtual size_t Get736()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 736;
}

virtual size_t Get737()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 737;
}

virtual size_t Get738()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 738;
}

virtual size_t Get739()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 739;
}

virtual size_t Get740()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 740;
}

virtual size_t Get741()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 741;
}

virtual size_t Get742()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 742;
}

virtual size_t Get743()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 743;
}

virtual size_t Get744()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 744;
}

virtual size_t Get745()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 745;
}

virtual size_t Get746()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 746;
}

virtual size_t Get747()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 747;
}

virtual size_t Get748()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 748;
}

virtual size_t Get749()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 749;
}

virtual size_t Get750()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 750;
}

virtual size_t Get751()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 751;
}

virtual size_t Get752()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 752;
}

virtual size_t Get753()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 753;
}

virtual size_t Get754()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 754;
}

virtual size_t Get755()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 755;
}

virtual size_t Get756()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 756;
}

virtual size_t Get757()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 757;
}

virtual size_t Get758()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 758;
}

virtual size_t Get759()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 759;
}

virtual size_t Get760()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 760;
}

virtual size_t Get761()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 761;
}

virtual size_t Get762()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 762;
}

virtual size_t Get763()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 763;
}

virtual size_t Get764()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 764;
}

virtual size_t Get765()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 765;
}

virtual size_t Get766()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 766;
}

virtual size_t Get767()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 767;
}

virtual size_t Get768()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 768;
}

virtual size_t Get769()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 769;
}

virtual size_t Get770()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 770;
}

virtual size_t Get771()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 771;
}

virtual size_t Get772()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 772;
}

virtual size_t Get773()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 773;
}

virtual size_t Get774()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 774;
}

virtual size_t Get775()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 775;
}

virtual size_t Get776()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 776;
}

virtual size_t Get777()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 777;
}

virtual size_t Get778()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 778;
}

virtual size_t Get779()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 779;
}

virtual size_t Get780()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 780;
}

virtual size_t Get781()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 781;
}

virtual size_t Get782()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 782;
}

virtual size_t Get783()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 783;
}

virtual size_t Get784()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 784;
}

virtual size_t Get785()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 785;
}

virtual size_t Get786()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 786;
}

virtual size_t Get787()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 787;
}

virtual size_t Get788()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 788;
}

virtual size_t Get789()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 789;
}

virtual size_t Get790()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 790;
}

virtual size_t Get791()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 791;
}

virtual size_t Get792()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 792;
}

virtual size_t Get793()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 793;
}

virtual size_t Get794()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 794;
}

virtual size_t Get795()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 795;
}

virtual size_t Get796()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 796;
}

virtual size_t Get797()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 797;
}

virtual size_t Get798()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 798;
}

virtual size_t Get799()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 799;
}

virtual size_t Get800()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 800;
}

virtual size_t Get801()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 801;
}

virtual size_t Get802()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 802;
}

virtual size_t Get803()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 803;
}

virtual size_t Get804()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 804;
}

virtual size_t Get805()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 805;
}

virtual size_t Get806()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 806;
}

virtual size_t Get807()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 807;
}

virtual size_t Get808()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 808;
}

virtual size_t Get809()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 809;
}

virtual size_t Get810()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 810;
}

virtual size_t Get811()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 811;
}

virtual size_t Get812()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 812;
}

virtual size_t Get813()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 813;
}

virtual size_t Get814()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 814;
}

virtual size_t Get815()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 815;
}

virtual size_t Get816()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 816;
}

virtual size_t Get817()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 817;
}

virtual size_t Get818()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 818;
}

virtual size_t Get819()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 819;
}

virtual size_t Get820()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 820;
}

virtual size_t Get821()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 821;
}

virtual size_t Get822()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 822;
}

virtual size_t Get823()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 823;
}

virtual size_t Get824()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 824;
}

virtual size_t Get825()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 825;
}

virtual size_t Get826()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 826;
}

virtual size_t Get827()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 827;
}

virtual size_t Get828()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 828;
}

virtual size_t Get829()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 829;
}

virtual size_t Get830()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 830;
}

virtual size_t Get831()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 831;
}

virtual size_t Get832()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 832;
}

virtual size_t Get833()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 833;
}

virtual size_t Get834()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 834;
}

virtual size_t Get835()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 835;
}

virtual size_t Get836()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 836;
}

virtual size_t Get837()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 837;
}

virtual size_t Get838()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 838;
}

virtual size_t Get839()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 839;
}

virtual size_t Get840()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 840;
}

virtual size_t Get841()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 841;
}

virtual size_t Get842()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 842;
}

virtual size_t Get843()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 843;
}

virtual size_t Get844()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 844;
}

virtual size_t Get845()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 845;
}

virtual size_t Get846()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 846;
}

virtual size_t Get847()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 847;
}

virtual size_t Get848()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 848;
}

virtual size_t Get849()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 849;
}

virtual size_t Get850()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 850;
}

virtual size_t Get851()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 851;
}

virtual size_t Get852()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 852;
}

virtual size_t Get853()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 853;
}

virtual size_t Get854()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 854;
}

virtual size_t Get855()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 855;
}

virtual size_t Get856()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 856;
}

virtual size_t Get857()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 857;
}

virtual size_t Get858()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 858;
}

virtual size_t Get859()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 859;
}

virtual size_t Get860()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 860;
}

virtual size_t Get861()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 861;
}

virtual size_t Get862()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 862;
}

virtual size_t Get863()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 863;
}

virtual size_t Get864()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 864;
}

virtual size_t Get865()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 865;
}

virtual size_t Get866()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 866;
}

virtual size_t Get867()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 867;
}

virtual size_t Get868()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 868;
}

virtual size_t Get869()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 869;
}

virtual size_t Get870()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 870;
}

virtual size_t Get871()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 871;
}

virtual size_t Get872()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 872;
}

virtual size_t Get873()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 873;
}

virtual size_t Get874()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 874;
}

virtual size_t Get875()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 875;
}

virtual size_t Get876()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 876;
}

virtual size_t Get877()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 877;
}

virtual size_t Get878()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 878;
}

virtual size_t Get879()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 879;
}

virtual size_t Get880()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 880;
}

virtual size_t Get881()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 881;
}

virtual size_t Get882()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 882;
}

virtual size_t Get883()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 883;
}

virtual size_t Get884()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 884;
}

virtual size_t Get885()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 885;
}

virtual size_t Get886()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 886;
}

virtual size_t Get887()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 887;
}

virtual size_t Get888()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 888;
}

virtual size_t Get889()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 889;
}

virtual size_t Get890()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 890;
}

virtual size_t Get891()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 891;
}

virtual size_t Get892()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 892;
}

virtual size_t Get893()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 893;
}

virtual size_t Get894()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 894;
}

virtual size_t Get895()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 895;
}

virtual size_t Get896()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 896;
}

virtual size_t Get897()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 897;
}

virtual size_t Get898()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 898;
}

virtual size_t Get899()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 899;
}

virtual size_t Get900()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 900;
}

virtual size_t Get901()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 901;
}

virtual size_t Get902()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 902;
}

virtual size_t Get903()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 903;
}

virtual size_t Get904()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 904;
}

virtual size_t Get905()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 905;
}

virtual size_t Get906()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 906;
}

virtual size_t Get907()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 907;
}

virtual size_t Get908()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 908;
}

virtual size_t Get909()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 909;
}

virtual size_t Get910()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 910;
}

virtual size_t Get911()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 911;
}

virtual size_t Get912()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 912;
}

virtual size_t Get913()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 913;
}

virtual size_t Get914()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 914;
}

virtual size_t Get915()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 915;
}

virtual size_t Get916()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 916;
}

virtual size_t Get917()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 917;
}

virtual size_t Get918()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 918;
}

virtual size_t Get919()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 919;
}

virtual size_t Get920()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 920;
}

virtual size_t Get921()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 921;
}

virtual size_t Get922()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 922;
}

virtual size_t Get923()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 923;
}

virtual size_t Get924()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 924;
}

virtual size_t Get925()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 925;
}

virtual size_t Get926()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 926;
}

virtual size_t Get927()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 927;
}

virtual size_t Get928()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 928;
}

virtual size_t Get929()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 929;
}

virtual size_t Get930()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 930;
}

virtual size_t Get931()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 931;
}

virtual size_t Get932()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 932;
}

virtual size_t Get933()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 933;
}

virtual size_t Get934()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 934;
}

virtual size_t Get935()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 935;
}

virtual size_t Get936()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 936;
}

virtual size_t Get937()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 937;
}

virtual size_t Get938()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 938;
}

virtual size_t Get939()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 939;
}

virtual size_t Get940()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 940;
}

virtual size_t Get941()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 941;
}

virtual size_t Get942()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 942;
}

virtual size_t Get943()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 943;
}

virtual size_t Get944()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 944;
}

virtual size_t Get945()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 945;
}

virtual size_t Get946()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 946;
}

virtual size_t Get947()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 947;
}

virtual size_t Get948()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 948;
}

virtual size_t Get949()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 949;
}

virtual size_t Get950()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 950;
}

virtual size_t Get951()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 951;
}

virtual size_t Get952()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 952;
}

virtual size_t Get953()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 953;
}

virtual size_t Get954()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 954;
}

virtual size_t Get955()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 955;
}

virtual size_t Get956()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 956;
}

virtual size_t Get957()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 957;
}

virtual size_t Get958()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 958;
}

virtual size_t Get959()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 959;
}

virtual size_t Get960()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 960;
}

virtual size_t Get961()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 961;
}

virtual size_t Get962()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 962;
}

virtual size_t Get963()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 963;
}

virtual size_t Get964()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 964;
}

virtual size_t Get965()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 965;
}

virtual size_t Get966()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 966;
}

virtual size_t Get967()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 967;
}

virtual size_t Get968()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 968;
}

virtual size_t Get969()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 969;
}

virtual size_t Get970()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 970;
}

virtual size_t Get971()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 971;
}

virtual size_t Get972()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 972;
}

virtual size_t Get973()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 973;
}

virtual size_t Get974()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 974;
}

virtual size_t Get975()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 975;
}

virtual size_t Get976()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 976;
}

virtual size_t Get977()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 977;
}

virtual size_t Get978()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 978;
}

virtual size_t Get979()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 979;
}

virtual size_t Get980()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 980;
}

virtual size_t Get981()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 981;
}

virtual size_t Get982()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 982;
}

virtual size_t Get983()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 983;
}

virtual size_t Get984()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 984;
}

virtual size_t Get985()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 985;
}

virtual size_t Get986()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 986;
}

virtual size_t Get987()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 987;
}

virtual size_t Get988()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 988;
}

virtual size_t Get989()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 989;
}

virtual size_t Get990()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 990;
}

virtual size_t Get991()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 991;
}

virtual size_t Get992()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 992;
}

virtual size_t Get993()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 993;
}

virtual size_t Get994()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 994;
}

virtual size_t Get995()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 995;
}

virtual size_t Get996()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 996;
}

virtual size_t Get997()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 997;
}

virtual size_t Get998()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 998;
}

virtual size_t Get999()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 999;
}

virtual size_t Get1000()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 1000;
}


    };

    // The signature / size that this compiler uses for function pointers in a virtual-table
    typedef void (TypeBinding::*VirtualTableFn)();

    // Get the number of entries in a class' virtual-table
    template <typename T>
    static size_t GetVirtualTableCount(typename IsPrimitive<T>::FalseType)
    {
      // We use a trick where we derive from the given type and add a single virtual function,
      // which when invoked on a 'counter' class will return us the index of the last function (eg the count)
      class Derived : public T
      {
      public:

        // The last function in the virtual-table, which when reinterpreted and called gives us the count
        virtual size_t GetVirtualTableCount()
        {
          // We can really return anything here, it should never be called
          Error("This should never be called!");
          return (size_t)-1;
        }
      };

      // This class has a virtual-table where every function returns its own index
      VirtualTableCounter counter;

      // Reinterpret the counter class as the derived class, and invoke
      // the last function (which will actually return the count)
      size_t count = reinterpret_cast<Derived*>(&counter)->GetVirtualTableCount();
      
      // Ensure the function we invoked a virtual function (this should always be the case)
      counter.AssertIfNotVirtual();

      // Return the count we got from the virtual table
      return count;
    }

    template <typename T>
    static size_t GetVirtualTableCount()
    {
      return 0;
    }

    // Checks if a class has a virtual-table by counting it's virtual functions
    template <typename T>
    static bool HasVirtualTable()
    {
      return GetVirtualTableCount<T>() != 0;
    }

    // Gets the index of a given virtual method pointer
    // The method SHOULD be virtual, otherwise corruption can occur!
    template <typename Method>
    static size_t GetVirtualMethodIndex(Method methodPtr)
    {
      // Make another method that looks like our counter class methods
      typedef size_t (VirtualTableCounter::*IndexFn)();

      // Reinterpret cast the given method into our counter method
      // Because the method SHOULD be virtual, calling this on the counter will return its index
      // NOTE: If the function given is actually not virtual, this will call the function on a BAD instance!
      // If this occurs, memory may be corrupted (we can't really counter this very well currently...)
      IndexFn indexMethodPtr = reinterpret_cast<IndexFn>(methodPtr);

      // This class has a virtual-table where every function returns its own index
      VirtualTableCounter counter;

      // Invoke the virtual method on our counter class (it better be virtual!)
      size_t index = (counter.*indexMethodPtr)();

      // Ensure the function we invoked a virtual function (if it hasn't already been corrupted by this point)
      counter.AssertIfNotVirtual();

      // Return the index of the virtual function
      return index;
    }

    // A guid generator for functions (primarily virtual)
    static GuidType& GetFunctionCounter()
    {
      static GuidType counter = 0;
      return counter;
    }

    // Gives a unique id to a function (primarily used for virtual function thunks)
    template <typename Function, Function function>
    static GuidType GetFunctionUniqueId()
    {
      static GuidType guid = GetFunctionCounter()++;
      return guid;
    };
  };
  
  /************************************ VOID *************************************/
  template <>
  class ZeroShared TypeBinding::StaticTypeId<void>
  {
  public:
    static BoundType* Get();
  };

  /************************************ NULL POINTER *************************************/
  template <>
  class ZeroShared TypeBinding::StaticTypeId<NullPointerType>
  {
  public:
    static BoundType* Get();
  };

  /************************************ ANY *************************************/
  template <>
  class ZeroShared TypeBinding::StaticTypeId<Any>
  {
  public:

    // The T type (and because partial specializations of 'StaticTypeId', this will always be a stripped type)
    typedef Any UnqualifiedType;

    // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
    typedef Any QualifiedType;

    // The type we use in any generated binding. This is generally the QualifiedType, however if the type is a redirect, it will be unqualified
    typedef Any BindingType;

    // This is the type that we represent when written to the stack
    // (as a value type) or dereferenced from a handle (as a reference type)
    typedef Any RepresentedType;

    // Because our representation is the exact same (whether in C++ or on the stack/in a handle)
    // then our resulting type when read is just a reference (not the case in all specializations!)
    typedef Any& ReadType;
      
    // Since our representation is the exact same (as mentioned above) this will be a direct read
    static const bool DirectRead = true;
      
    static AnyType* Get();
  };

  /************************************ ANY DELEGATE *************************************/
  template <>
  class ZeroShared TypeBinding::StaticTypeId<Delegate>
  {
  public:

    // The T type (and because partial specializations of 'StaticTypeId', this will always be a stripped type)
    typedef Delegate UnqualifiedType;

    // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
    typedef Delegate QualifiedType;

    // The type we use in any generated binding. This is generally the QualifiedType, however if the type is a redirect, it will be unqualified
    typedef Delegate BindingType;

    // This is the type that we represent when written to the stack
    // (as a value type) or dereferenced from a handle (as a reference type)
    typedef Delegate RepresentedType;

    // Because our representation is the exact same (whether in C++ or on the stack/in a handle)
    // then our resulting type when read is just a reference (not the case in all specializations!)
    typedef Delegate& ReadType;
      
    // Since our representation is the exact same (as mentioned above) this will be a direct read
    static const bool DirectRead = true;
      
    static DelegateType* Get();
  };

  /************************************ ANY HANDLE *************************************/
  template <>
  class ZeroShared TypeBinding::StaticTypeId<Handle>
  {
  public:

    // The T type (and because partial specializations of 'StaticTypeId', this will always be a stripped type)
    typedef Handle UnqualifiedType;

    // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
    typedef Handle QualifiedType;

    // The type we use in any generated binding. This is generally the QualifiedType, however if the type is a redirect, it will be unqualified
    typedef Handle BindingType;

    // This is the type that we represent when written to the stack
    // (as a value type) or dereferenced from a handle (as a reference type)
    typedef Handle RepresentedType;

    // Because our representation is the exact same (whether in C++ or on the stack/in a handle)
    // then our resulting type when read is just a reference (not the case in all specializations!)
    typedef Handle& ReadType;
      
    // Since our representation is the exact same (as mentioned above) this will be a direct read
    static const bool DirectRead = true;
      
    static BoundType* Get();
  };
  
  
  /*********************************** TRAITS ************************************/
  
  template <typename SelfType, typename BaseType>
  class CheckTypesAreRelated
  {
  public:
    static void Test()
    {
      // Check that the derived type is bigger than the
      // base type (should be since we have Debug_SizeTest)
      ZilchStaticAssert
      (
        sizeof(SelfType) > sizeof(BaseType),
        "It appears either the derived class or parent class is incorrect",
        TypeNotRelatedDerivedOrBase
      );

      // Attempt a static cast to ensure the types given were related
      // We need to use an invalid pointer (but not null) to avoid this getting compiled out
      BaseType* type1 = (BaseType*)0x00000001;
      SelfType* type2 = (SelfType*)0x00000001;
      type2 = static_cast<SelfType*>(type1);
      type1 = static_cast<BaseType*>(type2);
    }
  };
  
  template <typename SelfType>
  class CheckTypesAreRelated<SelfType, NoType>
  {
  public:
    static void Test()
    {
    }
  };

  class ZeroShared DebugSize
  {
  public:
    DebugSize();
    const char* Text;
  };

  /*********************************** CHECKS ************************************/

// If we're in debug mode, add extra checks...
#if _DEBUG
  // Checks used in the declaration of a C++ type exposed to Zilch
  #define ZilchDeclareChecks(SelfType, BaseType)                                                                          \
    /* Enforce that derived classes will always be bigger (only in debug) */                                              \
    Zilch::DebugSize ZilchCheckBase;                                                                                      \
    /* Do a series of debug checks to ensure the user is using the macros correctly */                                    \
    void ZilchDebugChecks()                                                                                               \
    {                                                                                                                     \
      /* Check that the sizes of the type we declared as 'our type' is the same as the size of the this reference */      \
      ZilchStaticAssert(sizeof(SelfType) == sizeof(*this),                                                                \
        "The type passed into the macro wasn't the same as the class it was declared in",                                 \
        TypeNotTheSameAsDeclared);                                                                                        \
      /* Check that the two types are related via static casting */                                                       \
      Zilch::CheckTypesAreRelated<SelfType, BaseType>::Test();                                                            \
    }                                                                                                                     \
    static void ZilchDebugDerivedHasNotBeenDeclared() {}                                                                  \
    static void ZilchDebugBaseHasNotBeenDeclared() {}
#else
  #define ZilchDeclareChecks(SelfType, BaseType)
  #define ZilchDefineChecks(SelfType, BaseType)
#endif

  
  /********************************** EXTERNAL ***********************************/
  // Declare an external type
  #define ZilchDeclareExternalHelper(SelfType, BaseType, TypeCopy)                      \
    /* A specialization so we know that type info exists for this type */               \
    template <>                                                                         \
    class ZeroShared ZilchStaticType(SelfType)                                          \
    {                                                                                   \
    public:                                                                             \
      static const TypeCopyMode::Enum CopyMode = TypeCopy;                              \
      typedef SelfType UnqualifiedType;                                                 \
      typedef SelfType QualifiedType;                                                   \
      typedef SelfType BindingType;                                                     \
      typedef SelfType RepresentedType;                                                 \
      typedef SelfType& ReadType;                                                       \
      static const bool DirectRead = true;                                              \
      static int Init;                                                                  \
      static Zilch::BoundType* SelfBoundType;                                           \
      static Zilch::BoundType* Get();                                                   \
      /* Binding macros need the current class being bound */                           \
      typedef BaseType  Base;                                                           \
      typedef BaseType* BasePtr;                                                        \
      typedef SelfType  Self;                                                           \
      typedef SelfType* SelfPtr;                                                        \
      /* Creates the static type (our reflected type) */                                \
      static void InitializeStaticType();                                               \
      /* External types still need a way to setup thier bindings */                     \
      static void SetupType(Zilch::LibraryBuilder& builder, Zilch::BoundType* type);    \
      /* Read and write values from stack data and dereferenced handle data */          \
      static ReadType Read(byte* from);                                                 \
      static void Write(const SelfType& value, byte* to);                               \
    };

  // Declare an external base type (belongs inside the type definition)
  #define ZilchDeclareExternalBaseType(SelfType, TypeCopy)                              \
    ZilchDeclareExternalHelper(SelfType, NoType, TypeCopy)

  // Declare an external derived type (belongs inside the type definition)
  #define ZilchDeclareExternalDerivedType(SelfType, BaseType, TypeCopy)                 \
    ZilchDeclareExternalHelper(SelfType, BaseType, TypeCopy)

  // Define an external type with a given name and specify the bound type (could be null)
  #define ZilchDefineExternalGiven(SelfType, Name, GivenType, Library, builder, type)   \
    /* We store the Zilch type, but ideally this would be not accessible */             \
    Zilch::BoundType* ZilchStaticType(SelfType)::SelfBoundType = nullptr;               \
    /* Implementation of the 'get type' specialization */                               \
    Zilch::BoundType* ZilchStaticType(SelfType)::Get()                                  \
    {                                                                                   \
      if (SelfBoundType == nullptr)                                                     \
      {                                                                                 \
        Library& library = Library::GetInstance();                                      \
        if (library.CanBuildTypes())                                                    \
        {                                                                               \
          InitializeStaticType();                                                       \
        }                                                                               \
        else                                                                            \
        {                                                                               \
          Error("The type '" #SelfType "' has not yet been initialized. "               \
            "Call '" #Library "::GetInstance().BuildLibrary()' and make sure you "      \
            "called ZilchInitializeType(" #SelfType "); inside your "                   \
            "ZilchDefineStaticLibrary(" #Library ") or SetupBinding function.");        \
        }                                                                               \
      }                                                                                 \
      return SelfBoundType;                                                             \
    }                                                                                   \
    /* Read our object representation from either stack data or handle data */          \
    ZilchStaticType(SelfType)::ReadType ZilchStaticType(SelfType)::Read(byte* from)     \
    {                                                                                   \
      return *(SelfType*)from;                                                          \
    }                                                                                   \
    /* Write our object representation to either stack data or handle data */           \
    void ZilchStaticType(SelfType)::Write(const SelfType& value, byte* to)              \
    {                                                                                   \
      new (to) SelfType(value);                                                         \
    }                                                                                   \
    /* This function gets called when the static library we belong to is built */       \
    void ZilchStaticType(SelfType)::InitializeStaticType()                              \
    {                                                                                   \
      /* Check if we've already been initialized */                                     \
      if (SelfBoundType != nullptr)                                                     \
        return;                                                                         \
      Library& library = Library::GetInstance();                                        \
      library.BuildLibrary();                                                           \
      LibraryBuilder& builder = *library.GetBuilder();                                  \
      SelfBoundType = (GivenType);                                                      \
      /* Check if the given type initialized the bound type... */                       \
      if (SelfBoundType != nullptr)                                                     \
        return;                                                                         \
      typedef ZilchStaticType(SelfType) InitType;                                       \
      /* First initialize our base type... */                                           \
      ZilchStaticType(Base)::InitializeStaticType();                                    \
      /* Actually create and bind our type */                                           \
      SelfBoundType = library.MakeType                                                  \
      (                                                                                 \
        Name,                                                                           \
        sizeof(SelfType),                                                               \
        InitType::CopyMode,                                                             \
        ZilchTypeId(InitType::Base),                                                    \
        Zilch::TypeBinding::GetVirtualTableCount<SelfType>()                            \
      );                                                                                \
      InitType::SetupType(*library.GetBuilder(), SelfBoundType);                        \
    }                                                                                   \
    /* Implementation of the binding (the user provides the body) */                    \
    void ZilchStaticType(SelfType)::                                                    \
      SetupType(Zilch::LibraryBuilder& builder, Zilch::BoundType* type)

  // Define an external type with a given name
  #define ZilchDefineExternalType(SelfType, Name, Library, builder, type)               \
    ZilchDefineExternalGiven(SelfType, Name, nullptr, Library, builder, type)

  /**************************** EXTERNAL REDIRECTION *****************************/
  // Declare an external type
  #define ZilchDeclareRedirectType(SelfType, RedirectType)                              \
    /* A specialization so we know that type info exists for this type */               \
    template <>                                                                         \
    class ZeroShared ZilchStaticType(SelfType)                                          \
    {                                                                                   \
    public:                                                                             \
      static const TypeCopyMode::Enum CopyMode = StaticTypeId<RedirectType>::CopyMode;  \
      typedef SelfType UnqualifiedType;                                                 \
      typedef SelfType QualifiedType;                                                   \
      typedef SelfType BindingType;                                                     \
      typedef RedirectType RepresentedType;                                             \
      typedef SelfType ReadType;                                                        \
      static const bool DirectRead = false;                                             \
      static Zilch::BoundType* Get();                                                   \
      /* Read and write values from stack data and dereferenced handle data */          \
      static ReadType Read(byte* from);                                                 \
      static void Write(const SelfType& value, byte* to);                               \
    };

  // (Helper) Define an external type with a given name
  #define ZilchDefineRedirectType(SelfType, ConvertFromRedirect, ConvertToRedirect)     \
    /* Implementation of the 'get type' specialization */                               \
    Zilch::BoundType* ZilchStaticType(SelfType)::Get()                                  \
    {                                                                                   \
      return ZilchTypeId(RepresentedType);                                              \
    }                                                                                   \
    /* Read our object representation from either stack data or handle data */          \
    ZilchStaticType(SelfType)::ReadType ZilchStaticType(SelfType)::Read(byte* from)     \
    {                                                                                   \
      return ConvertToRedirect(*(RepresentedType*)from);                                \
    }                                                                                   \
    /* Write our object representation to either stack data or handle data */           \
    void ZilchStaticType(SelfType)::Write(const SelfType& value, byte* to)              \
    {                                                                                   \
      new (to) RepresentedType(ConvertFromRedirect(value));                             \
    }

  // Can be used by redirection macros to support changing of a type to another type
  template <typename From, typename To>
  To StaticCast(const From& from)
  {
    return static_cast<To>(from);
  }

  // Define an external type with a given name that can be statically casted to our redirected type
  #define ZilchDefineImplicitRedirectType(SelfType)                                     \
    ZilchDefineRedirectType(SelfType,                                                   \
    (StaticCast<SelfType, ZilchStaticType(SelfType)::RepresentedType>),                 \
    (StaticCast<ZilchStaticType(SelfType)::RepresentedType, SelfType>))

  /********************************** INTERNAL ***********************************/
  // Declare a type (belongs inside the type definition)
  #define ZilchDeclareHelper(SelfType, BaseType, TypeCopy)                              \
    ZilchDeclareChecks(SelfType, BaseType)                                              \
    public:                                                                             \
    /* Get the most derived type from an instance of the class */                       \
    /* Inheriting from 'IZilchObject' will make these virtual */                        \
    /*virtual*/ Zilch::BoundType* ZilchGetDerivedType() const;                          \
    /* Get the static type id from the object */                                        \
    static Zilch::BoundType* ZilchGetStaticType();                                      \
    static const Zilch::TypeCopyMode::Enum ZilchCopyMode = TypeCopy;                    \
    /* Binding macros need the current class being bound */                             \
    typedef BaseType  ZilchBase;                                                        \
    typedef BaseType* ZilchBasePtr;                                                     \
    typedef SelfType  ZilchSelf;                                                        \
    typedef SelfType* ZilchSelfPtr;                                                     \
    /* Creates the static type (our reflected type) */                                  \
    static void ZilchInitializeStaticType();                                            \
    /* Setup any bindings that may be necessary for this type */                        \
    static void ZilchSetupType(Zilch::LibraryBuilder& builder, Zilch::BoundType* type);

  // Declare a base type (belongs inside the type definition)
  #define ZilchDeclareBaseType(SelfType, CopyType)                                      \
    ZilchDeclareHelper(SelfType, Zilch::NoType, CopyType)

  // Declare a derived type (belongs inside the type definition)
  #define ZilchDeclareDerivedType(SelfType, BaseType)                                   \
    ZilchDeclareHelper(SelfType, BaseType, BaseType::ZilchCopyMode)

  // (Helper) Define a type
  #define ZilchDefineType(SelfType, Name, Library, builder, type)                       \
    /* We store the Zilch type, but ideally this would be not accessible */             \
    Zilch::BoundType* __##SelfType##Type = nullptr;                                     \
    /* Implementation of the get derived type function */                               \
    Zilch::BoundType* SelfType::ZilchGetDerivedType() const                             \
    {                                                                                   \
      return SelfType::ZilchGetStaticType();                                            \
    }                                                                                   \
    /* Get the static type id from the object */                                        \
    Zilch::BoundType* SelfType::ZilchGetStaticType()                                    \
    {                                                                                   \
      Library& library = Library::GetInstance();                                        \
      if (__##SelfType##Type == nullptr)                                                \
      {                                                                                 \
        if (library.CanBuildTypes())                                                    \
        {                                                                               \
          ZilchInitializeStaticType();                                                  \
        }                                                                               \
        else                                                                            \
        {                                                                               \
          Error("The type '" #SelfType "' has not yet been initialized. "               \
            "Call '" #Library "::GetInstance().BuildLibrary()' and make sure you "      \
            "called ZilchInitializeType(" #SelfType "); inside your "                   \
            "ZilchDefineStaticLibrary(" #Library ") or SetupBinding function.");        \
        }                                                                               \
      }                                                                                 \
      return __##SelfType##Type;                                                        \
    }                                                                                   \
    /* This function gets called when the static library we belong to is built */       \
    void SelfType::ZilchInitializeStaticType()                                          \
    {                                                                                   \
      /* Check if we've already been initialized */                                     \
      if (__##SelfType##Type != nullptr)                                                \
        return;                                                                         \
      /* First initialize our base type... */                                           \
      Library& library = Library::GetInstance();                                        \
      library.BuildLibrary();                                                           \
      ZilchStaticType(ZilchBase)::InitializeStaticType();                               \
      /* Actually create and bind our type */                                           \
      __##SelfType##Type = library.MakeType                                             \
      (                                                                                 \
        Name,                                                                           \
        sizeof(SelfType),                                                               \
        ZilchCopyMode,                                                                  \
        ZilchTypeId(ZilchBase),                                                         \
        Zilch::TypeBinding::GetVirtualTableCount<SelfType>()                            \
      );                                                                                \
      ZilchSetupType(*library.GetBuilder(), __##SelfType##Type);                        \
    }                                                                                   \
    /* Implementation of the binding (the user provides the body) */                    \
    void SelfType::ZilchSetupType                                                       \
      (Zilch::LibraryBuilder& builder, Zilch::BoundType* type)

  // A helper for initializign types that belong to a library
  #define ZilchInitializeType(Type) ZilchStaticType(Type)::InitializeStaticType()

  /********************************** PRIMITIVE **********************************/
  // Declaration of all primitive types (these MUST be seen by anything
  // using type-binding, and therefore they are declared within this file)
  ZilchDeclareExternalBaseType(Boolean,       TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Boolean2,      TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Boolean3,      TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Boolean4,      TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(Byte,          TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(Integer,       TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Integer2,      TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Integer3,      TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Integer4,      TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(Real,          TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Real2,         TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Real3,         TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Real4,         TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(Quaternion,    TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(String,        TypeCopyMode::ReferenceType);
  
  ZilchDeclareExternalBaseType(DoubleReal,    TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(DoubleInteger, TypeCopyMode::ValueType);

  // All the redirection types
  ZilchDeclareRedirectType(char,                Integer);
  ZilchDeclareRedirectType(signed   char,       Integer);
  ZilchDeclareRedirectType(signed   short,      Integer);
  ZilchDeclareRedirectType(unsigned short,      Integer);
  
  ZilchDeclareRedirectType(unsigned int,        Integer);
  ZilchDeclareRedirectType(signed   long,       Integer);
  ZilchDeclareRedirectType(unsigned long,       Integer);

  ZilchDeclareRedirectType(unsigned long long,  DoubleInteger);
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_DESTRUCTiBLE_BUFFER_HPP
#define ZILCH_DESTRUCTiBLE_BUFFER_HPP

// Includes


namespace Zilch
{
  // Aligns a number to a machine byte boundary (either the same or a larger value)
  size_t AlignToBusWidth(size_t value);

  // A function that will invoke the destructor on an object (does not call delete or free!)
  typedef void (*DestructFn) (void* object);

  // A function that will invoke the copy constructor from one object to another uninitialized place in memory
  typedef void (*CopyConstructFn) (const void* from, void* to);

  // A function for wrapping a destructor of any object in the above signature
  template <typename T>
  void DestructorWrapper(void* object)
  {
    // Cast the object pointer we got into our own object type
    T* objectTyped = (T*)object;

    // Invoke the destructor on the object
    // Note: We do not call free or delete on the object memory, it isn't ours!
    objectTyped->~T();
  }

  // Get the destructor for a type, or null for pod types...
  template <typename T>
  DestructFn GetDestructor()
  {
    // If the type is considered to be pod, ignore the destructor
    if (StandardTraits<T>::is_pod_::value)
    {
      return nullptr;
    }
    else
    {
      // Otherwise we wrap the destructor into our own signature
      return DestructorWrapper<T>;
    }
  }

  // A function for wrapping a copy constructor of any object in the above signature
  template <typename T>
  void CopyConstructorWrapper(const void* from, void* to)
  {
    // Use placement new to construct the object at the 'to' location (but invoke the copy constructor using the from object reference)
    new (to) T(*(T*)from);
  }

  // Get the copy constructor for a type, or null for pod types...
  template <typename T>
  CopyConstructFn GetCopyConstructor()
  {
    // If the type is considered to be pod, ignore the destructor
    if (StandardTraits<T>::is_pod_::value)
    {
      return nullptr;
    }
    else
    {
      // Otherwise we wrap the copy constructor into our own signature
      return CopyConstructorWrapper<T>;
    }
  }

  // Used to write arbitrary data to a buffer where some of the data could be destructed
  class ZeroShared DestructibleBuffer
  {
  public:

    // The block size we use for allocations
    static const size_t BlockSize = 512;

    // Default contstructor (empty)
    DestructibleBuffer();

    // Copy constructor (copies all internally written elements properly)
    DestructibleBuffer(const DestructibleBuffer& from);
    
    // Destructor
    ~DestructibleBuffer();

    // Assignment from one to another
    DestructibleBuffer& operator=(const DestructibleBuffer& from);

    // Get the absolute size of the data
    // Note: Do NOT use this as an index in 'Read' or 'GetElement'
    size_t GetSize();

    // Clears the entire buffer, invoking all the destructors as needed
    void Clear();

    // Allocates writable memory that the user can work with
    // If the destructor passed in is null, then no destructor will be pushed
    byte* Allocate(size_t size, DestructFn destructor = nullptr, CopyConstructFn copyConstructor = nullptr, size_t* positionOut = nullptr);

    // Writes memory directly to the buffer
    // If the destructor passed in is null, then no destructor will be pushed
    byte* WriteMemory(void* source, size_t size, DestructFn destructor = nullptr);

    // Writes an object directly to the buffer
    // If the object is POD, no destructor will be pushed
    template <typename T>
    T& WriteObject(const T& value, size_t* positionOut = nullptr)
    {
      // Allocate the memory for the object and push a wrapper around it's destructor
      byte* newData = this->Allocate(sizeof(T), GetDestructor<T>(), GetCopyConstructor<T>(), positionOut);

      // Copy the object we got into the allocated data and return it
      return *new (newData) T(value);
    }

    // Creates an object with a default constructor directly
    // to the buffer and pushes the destructor
    template <typename T>
    T& CreateObject(size_t* positionOut = nullptr)
    {
      // Allocate the memory for the object and push a wrapper around it's destructor
      byte* newData = this->Allocate(sizeof(T), GetDestructor<T>(), GetCopyConstructor<T>(), positionOut);

      // Default construct the type into the allocated data and return it
      return *new (newData) T();
    }

    // Reads an amount of data starting from the given position
    // and can optionally return the next position to read from
    byte* Read(size_t position, size_t length, size_t* nextPositionOut = nullptr);

    // Reads an object from the data and moves the position forward by its size
    template <typename T>
    T& ReadObject(size_t position, size_t* nextPositionOut = nullptr)
    {
      // Read the data using the size of the given class
      return *(T*)this->Read(position, sizeof(T), nextPositionOut);
    }

    // Get the element at the given position
    byte* GetElement(size_t position);

  private:

    // Represents any bit of destructible data in our buffer
    class Entry
    {
    public:
      // The position in the buffer where the object lives
      size_t AbsolutePosition;

      // The destructor (typically wrapped) to call on the object's memory
      // This destrcutor should never call free or delete, just the class destructor
      DestructFn Destructor;

      // When we copy construct the entire buffer, we'll walk through and copy construct its entries
      CopyConstructFn CopyConstructor;
    };

    // All the bits of data in the buffer that must be destructed/copied
    PodArray<Entry> Entries;

    // The internal data
    UntypedBlockArray<BlockSize> Data;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_MEMBERS_HPP
#define ZILCH_MEMBERS_HPP

// Includes




namespace Zilch
{
  // The types of attribute parameters we support
  namespace AttributeType
  {
    enum Enum
    {
      Null,
      String,
      Number,
      Boolean,
      Type
    };
  }

  // An attribute parameter can be any of the literal types we support
  class AttributeParameter
  {
  public:
    // Default constructor
    AttributeParameter();

    // An optional name given to the parameter (if the user used name parameter calling)
    String Name;

    // The type of the attribute parameter (literals only, default Null)
    AttributeType::Enum Type;

    // The original value, unparsed (for strings this includes quotes and escape sequences)
    // If this is a Type, this will be the full name of the type (same as StringValue)
    String Token;

    // When Type is String, this will be the fully unescaped version of the string (default empty)
    // When Type is Type, this will be the full name of the type
    String StringValue;
    
    // When Type is Number, this will be the parsed number value (default 0.0)
    // Note: Even integers will be stored as a number, and can just be cast out
    double NumberValue;
    
    // When Type is Boolean, this will be set to true or false (default false)
    bool BooleanValue;
  };

  // An attribute provides extra data about classes, functions, fields,
  // properties, etc that the language normally does not provide
  // An example would be marking a property as have a range of values from 1 to 100 eg [Range(1, 100)]
  class Attribute
  {
  public:
    // The name of the attribute
    String Name;

    // All the parameters we parsed from the attributes in the order they were given
    Array<AttributeParameter> Parameters;
  };

  // Provides a description
  class ZeroShared DocumentedObject : public IZilchObject
  {
  public:
    // Constructor
    DocumentedObject();

    // Checks to see if an attribute exists
    bool HasAttribute(StringParam name);

    // Gets the library that owns our documented object
    virtual Library* GetOwningLibrary() = 0;

    // If this documented object has a resulting type (or represents a type) this will return it
    virtual Type* GetTypeOrNull();

    // The location of just the name/identifier for this document object
    // This is what gets selected in common IDE commands such as Go-To-Definition
    CodeLocation NameLocation;

    // A basic description for the type (typically parsed from comments)
    String Description;
    
    // Any samples or remarks about the usage of a particular object or member
    StringArray Remarks;

    // All the attributes attached to this type
    Array<Attribute> Attributes;

    // All documented objects can be hidden (for things parsed in language, use the [Hidden] attribute)
    bool IsHidden;

    // The code location at which the object was defined
    CodeLocation Location;
  };

  // All primitives that appear on types (properties, fields, functions, etc) are members
  class ZeroShared Member : public DocumentedObject
  {
  public:

    // Default constructor
    Member();

    // DocumentedObject interface
    Library* GetOwningLibrary() override;

    // The owning type that this member belongs to
    BoundType* Owner;
  };

  // A class property basically consists of two functions that let us get and set a variable
  class ZeroShared Property : public Member
  {
  public:
    ZilchDeclareBaseType(Property, TypeCopyMode::ReferenceType);

    // Constructor
    Property();

    // DocumentedObject interface
    Type* GetTypeOrNull() override;

    // The name of the property
    String Name;

    // Whether or not the property is considered static
    bool IsStatic;

    // Mark if this property is hidden when null (useful for showing things like optional components)
    // This only applies to nullable types like handles and delegates
    bool IsHiddenWhenNull;

    // The type and offset into the class it belongs to
    Function* Get;
    Function* Set;

    // The type that we represent
    Type* PropertyType;
  };

  // A class field basically consists of the type, as well as the offset into the memory block
  class ZeroShared Field : public Property
  {
  public:
    ZilchDeclareDerivedType(Field, Property);

    // Constructor
    Field();

    // The offset into the class it belongs to
    size_t Offset;

    // Used to initialize this field only
    // This functionality is used by on the fly patching of classes, as well as by static fields (which are initialized upon the first use)
    // This function generally contains the initializer expression and a return opcode (no arguments, no return value)
    // WARNING: Field initializers do not assume a value exists in its previous place and will NOT destruct any previous values
    // If the intializer does not exist then it is generally acceptable to call GenericDefaultConstruct (which will typically just zero out memory)
    // Instance field initializers must be given a valid instance of the object that contains the field (for the 'this' parameter)
    Function* Initializer;
  };

  // Store information about a variable inside a function
  class ZeroShared Variable : public DocumentedObject
  {
  public:
    ZilchDeclareBaseType(Variable, TypeCopyMode::ReferenceType);

    // Constructor
    Variable();

    // DocumentedObject interface
    Library* GetOwningLibrary() override;
    Type* GetTypeOrNull() override;

    // The function that owns this variable
    Function* Owner;

    // The relative position on the stack that this variable exists
    OperandLocal Local;

    // The type of the variable
    Type* ResultType;

    // Store the name of the variable
    String Name;
  };

  // Information about events sent by a class or struct
  class ZeroShared SendsEvent
  {
  public:
    // Constructor
    SendsEvent();

    // The name of the event that is being sent
    String Name;

    // The type of event being sent
    Type* ResultType;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_STRING_CONSTANTS_HPP
#define ZILCH_STRING_CONSTANTS_HPP

namespace Zilch
{
  // Constants
  extern const String ThisKeyword;
  extern const String ValueKeyword;
  extern const String PreConstructorName;
  extern const String ConstructorName;
  extern const String DestructorName;
  extern const String FieldInitializerName;
  extern const String ExpressionLibrary;
  extern const String ExpressionProgram;
  extern const String ExpressionMain;
  extern const String PropertyDelegateName;
  extern const String StaticAttribute;
  extern const String OverrideAttribute;
  extern const String VirtualAttribute;
  extern const String HiddenAttribute;
  extern const String ExtensionAttribute;
  extern const String CodeString;
  extern const String ExpressionInitializerLocal;
  extern const String OperatorInsert;
  extern const String OperatorGet;
  extern const String OperatorSet;
  extern const String UnknownOrigin;
  extern const String EmptyLowerIdentifier;
  extern const String EmptyUpperIdentifier;
  extern const String DefaultLibraryName;

  // Helper functions
  String BuildGetterName(String name);
  String BuildSetterName(String name);

  // Perform string escape replacements
  String ReplaceStringEscapes(StringRange input);

  // Strip outlining quotes (directly used for string literals)
  StringRange StripStringQuotes(StringRange input);

  // Perform string escape replacements and outlining quotes (directly used for string literals)
  String ReplaceStringEscapesAndStripQuotes(StringRange input);

  // Change an identifier between lower and upper camel cases (just modifies the first letter)
  String ToLowerCamelCase(StringRange input);
  String ToUpperCamelCase(StringRange input);
}

// End header protection
#endif


namespace Zilch
{
  // Information we hand to the 
  class ZeroShared NativeVirtualInfo
  {
  public:
    // A special index that means that a function is non-virtual
    static const size_t NonVirtual = (size_t)-1;
    static const GuidType InvalidGuid = (GuidType)-1;

    // Constructor
    NativeVirtualInfo();

    // Validates that the given data is valid (returns false if it's invalid)
    bool Validate();

    // Is this method defined natively as a virtual function? (was it bound as a virtual function?)
    // If so, then this represents the index into the virtual table for the C++ type
    // If this function is not natively virtual, it will be set to 'NonVirtual'
    size_t Index;

    // In the case that this function is considered to be virtual
    // this will be set to the thunk function that actually invokes Zilch
    // from a native virtual call (or null if it's non-virtual)
    TypeBinding::VirtualTableFn Thunk;

    // In order to map a native function thunk back to it's Zilch function, we need
    // every bound virtual function to have it's own guid that we use in a map
    GuidType Guid;
  };

  // A base function
  class ZeroShared Function : public Member
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareBaseType(Function, TypeCopyMode::ReferenceType);

    // Constructor
    Function();

    // DocumentedObject interface
    Type* GetTypeOrNull() override;

    // Hash the function
    GuidType Hash() const;

    // Get the function in string form
    String ToString() const;

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructibleBuffer ComplexUserData;
    
    // Gets the code location from a given program counter location
    // If the program counter is for a native function (or non active), this will return null
    CodeLocation* GetCodeLocationFromProgramCounter(size_t programCounter);

    // Allocate an argumentless opcode
    Opcode& AllocateArgumentFreeOpcode(Instruction::Enum instruction, DebugOrigin::Enum debugOrigin, const CodeLocation& debugLocation);

    // Allocate an opcode of type T
    template <typename T>
    T& AllocateOpcode(Instruction::Enum instruction, DebugOrigin::Enum debugOrigin, const CodeLocation& debugLocation)
    {
      // Get the compacted index
      size_t compactedIndex = this->OpcodeBuilder.RelativeSize();

      // Get an element of memory with the size of the opcode
      byte* element = this->OpcodeBuilder.RequestElementOfSize(sizeof(T));

      // Get a reference to the opcode
      T& opcode = *new (element) T();

      // Make sure this opcode location is valid...
      ErrorIf(debugLocation.Origin == UnknownOrigin,
        "A code location given for an opcode was from an unknown location (opcode always gets generated from real code!)");

      // For debugging, we need to know from an opcode index where it originated from
      this->OpcodeLocationToCodeLocation.insert(compactedIndex, debugLocation);

      // We use the compacted indices for debugging
      this->OpcodeCompactedIndices.push_back(compactedIndex);

#ifdef _DEBUG
      // Add the debug info to the list
      this->OpcodeDebug.push_back(&opcode);
      opcode.DebugOrigin = debugOrigin;
#endif

      // Set the instruction
      opcode.Instruction = instruction;

      // Return the opcode to be filled in
      return opcode;
    }

    // Allocates a register and returns its index
    OperandIndex AllocateRegister(size_t size);

    // Allocates a constant and returns its index
    template <typename T>
    T& AllocateConstant(size_t constantSize, OperandIndex& indexOut)
    {
      // Allocate the spot in the constants
      size_t largeIndex;
      T& constant = this->Constants.CreateObject<T>(&largeIndex);
      
      // Get the index where we allocated the constant
      indexOut = (OperandIndex)largeIndex;

      // Return the constant to the user
      return constant;
    }

    // Get the current index into the opcode
    size_t GetCurrentOpcodeIndex();

    // Now that opcode has been compacted, set the
    // debug opcode to point at the compacted opcode
    void SetupCompactedOpcodeDebug();

  public:

    // Documentation for each of the parameters (should match the number of parameters in the DelegateType)
    Array<String> ParameterDescriptions;

    // Store the name of the function
    String Name;

    // The bound function is the function that gets called when this function is invoked
    BoundFn BoundFunction;

    // When we're binding a native constructor, we need our actual 'BoundFunction' to run
    // special code that lets us know the object reached native construction
    // We store the actual constructor here (in that case, the above BoundFunction just invokes the NativeConstructor)
    // This will be initialized in AddBoundConstructor on the LibraryBuilder
    BoundFn NativeConstructor;

    // The variables associated with this function
    Array<Variable*> Variables;

    // Store the type of the function
    DelegateType* FunctionType;

    // In order to invoke this function, a given amount of stack space is required
    // For example, all the parameters need space on the stack, and the return also needs space
    // Moreover, any local variables in a compiled function also need space on the stack
    // For a user bound function, the required space only includes the parameters and returns,
    // because any locals they will store will be on the actual C++ stack, not on ours
    size_t RequiredStackSpace;

    // A pointer the 'this' variable (or null if it is static)
    // Note that the current calling convention is that the this pointer is the
    // last parameter passed on the stack, which means this should point to the end of
    // the required stack space
    Variable* This;

    // Store the parent library from which the function originated
    // This information is generally used for linking purposes. When we call a
    // function we need the library it came from so we can re-link it back up
    Library* SourceLibrary;

    // Any information related to this function being native and virtual
    NativeVirtualInfo NativeVirtual;

    // If this function is a property getter or setter
    bool IsPropertyGetOrSet;

    // If this function is virtual or not (whether it can be overridden)
    // All overriding functions are also marked as virtual
    bool IsVirtual;

    // All the constants used in this function (only used for compiled functions)
    DestructibleBuffer Constants;

    // A temporary buffer for storing opcode
    UntypedBlockArray<1024> OpcodeBuilder;

    // The opcode for this function compacted into a linear array
    Array<byte> CompactedOpcode;

    // Store a list of pointers to opcodes for debugging purposes
    Array<size_t> OpcodeCompactedIndices;

    // Maps from an opcode offset to a code location (so we can determine where we are in debugging)
    HashMap<size_t, CodeLocation> OpcodeLocationToCodeLocation;

#ifdef _DEBUG
    PodArray<Opcode*> OpcodeDebug;
#endif
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_CORE_HPP
#define ZILCH_CORE_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TYPE_HPP
#define ZILCH_TYPE_HPP

// Includes





namespace Zilch
{
  // A structure that is responsible for resolving members and functions of a class
  class Resolver
  {
  public:
    // Get the instance resolver
    static Resolver Instance(BoundType* type);

    // Get the static resolver
    static Resolver Static(BoundType* type);

    // The virtual member functions that we'll call on the compiled type
    GetOverloadedFunctionsFn  GetOverloadedFunctions;
    GetFieldFn                GetField;
    GetPropertyFn             GetProperty;
    BoundType*                TypeInstance;
    bool                      IsStatic;
  };

  // In the case where we're attempting to find members
  namespace FindMemberOptions
  {
    enum Enum
    {
      // No options
      None = 0,

      // A member that is not part of an instance,
      // but rather part of the type itself
      Static = 1,

      // Specifies that we will search only this type,
      // and not the hierarchy (base types) for the function
      DoNotIncludeBaseClasses = 2,
    };
    typedef unsigned Flags;
  }

  namespace CastOperation
  {
    enum Enum
    {
      // The casting operation was not valid
      Invalid,

      // A cast that has nothing to do (the underlying values are equivalent in raw form)
      // Includes casting from a derived class to a base class (ex: Cat to Animal)
      // Also include casting from NullType to any reference/handle type (null to Animal)
      Raw,
      
      // Casting from a built in primitive (ex: Integer to Real)
      // This really implies that there is an entire instruction made to deal with this cast
      Primitive,
      
      // Casting a base class to a dervied class, which must be checked (ex: Animal to Cat)
      DynamicDown,

      // Casting to the 'any' type, a special type that can contain or be anything (ex: Integer to any)
      ToAny,

      // Casting from the 'any' type which must be chcecked (ex: any to Integer)
      FromAny,

      // A special cast from null to a delegate type (null is a handle type)
      NullToDelegate,
    };
  }

  // A type is the base representation of all types
  class ZeroShared Type : public DocumentedObject
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareBaseType(Type, TypeCopyMode::ReferenceType);

    // Constructor
    Type();

    // DocumentedObject interface
    Library* GetOwningLibrary() override;
    Type* GetTypeOrNull() override;

    // Hash the type
    virtual GuidType Hash() const = 0;

    // Gets a human readable name for the type
    // This name is only used for debugging and printing
    virtual String ToString() const = 0;

    // Gets a short non-unique name in lower camel case form (can be a keyword)
    virtual String GetShortLowerCamelCaseName() const = 0;

    // Checks whether a type has a complicated copy operator (handles, delegates, etc)
    // The opposite of this being that the data is POD (plain old data / value types)
    virtual bool IsCopyComplex() const = 0;

    // Get the size of the type (or if it's a reference type, the size of a handle)
    virtual size_t GetCopyableSize() const;

    // Get the size of the type if we were to allocate it in a memory block
    virtual size_t GetAllocatedSize() const = 0;

    // Constructs a default instance of this type
    // For as many types as possible, this will construct something akin to null
    // If the type does not support a null (such as value types) it will clear the memory to zeros
    // This is mainy used for templating, and the concept of 'default(T)'
    virtual void GenericDefaultConstruct(byte* toConstruct) const = 0;

    // Copies a value at one place to another
    // If the given type is a reference / delegate type, a handle copy will be performed
    // All value types will be directly memory copied
    virtual void GenericCopyConstruct(byte* to, const byte* from) const = 0;

    // Performs a handle release in the case that the type is a reference / delegate
    // Otherwise in the case of value types, this does nothing
    virtual void GenericDestruct(byte* value) const = 0;

    // Get the memory of the underlying object (only used for debugging)
    // For a reference/handle type, we will Dereference the handle (so this could be null)
    // Otherwise for value types, it will just directly return the passed in memory
    // For delegate types, this will also directly return the memory
    // For the AnyType, this will recursively call GenericGetMemory on the value stored inside the Any (if none, it will return itself)
    virtual byte* GenericGetMemory(const byte* value) const;

    // Get the most derived type of whatever we're looking at
    // In all case that the values that the value is null of (whatever that means) it will return this types itself
    // For bound value types this will just return the type directly (value types are always the correct type)
    // For all handle types (bound reference, indirect, AnyHandleType) this will return the type stored in the handle
    // For all delegate types (delegate type, AnyDelegateType) this will return the type of the function stored in the delegate
    // For the AnyType, this will recursively call GenericGetVirtualType on the value stored within the Any (if none, it will return itself)
    virtual Type* GenericGetVirtualType(const byte* value) const = 0;

    // Hashes an object of this type
    virtual Integer GenericHash(const byte* value) const = 0;

    // Converts the object or value into a human readable string
    virtual String GenericToString(const byte* value) const = 0;

    // Tests equality of two objects of the exact same type
    virtual Boolean GenericEquals(const byte* lhs, const byte* rhs) const = 0;

    // Check if a given type is a handle type
    static bool IsHandleType(Type* type);

    // Check if a given type is a value type
    static bool IsValueType(Type* type);

    // Check if a given type is a delegate type
    static bool IsDelegateType(Type* type);

    // Check if a given type is an enum type
    static bool IsEnumType(Type* type);

    // Check if a given type is an flags type
    static bool IsFlagsType(Type* type);

    // Check if a given type is an enum or flags type
    static bool IsEnumOrFlagsType(Type* type);

    // Check if a given type is a any type
    static bool IsAnyType(Type* type);

    // Generically get the base class type (if we have one) or return null
    static Type* GetBaseType(Type* type);

    // If the given type is a BoundType, it will cast it and return it directly
    // If the given type is an IndirectionType, then it will return the 'ReferencedType' on that
    static BoundType* GetBoundType(Type* handleType);

    // Returns the type referenced by a handle type, or nullptr if the type was not a handle
    // Note that this function works for both indirect types as well as class bound types
    static BoundType* GetHandleType(Type* handleType);

    // Check if two types are of the same type
    static bool IsSame(Type* a, Type* b);

    // Store the parent library from which the type originated
    // This information is generally used for linking purposes
    Library* SourceLibrary;

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructibleBuffer ComplexUserData;

    // Not copyable
    ZilchNoCopy(Type);
  };

  // A qualified type represents a true-type with qualifications
  class IndirectionType : public Type
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IndirectionType, Type);

    // Constructor
    IndirectionType();

    // Implement the type interface
    bool IsCopyComplex() const override;
    size_t GetAllocatedSize() const override;
    GuidType Hash() const override;
    String ToString() const override;
    String GetShortLowerCamelCaseName() const override;
    void GenericDefaultConstruct(byte* toConstruct) const override;
    void GenericCopyConstruct(byte* to, const byte* from) const override;
    void GenericDestruct(byte* value) const override;
    int GenericHash(const byte* value) const override;
    String GenericToString(const byte* value) const override;
    bool GenericEquals(const byte* lhs, const byte* rhs) const override;
    byte* GenericGetMemory(const byte* value) const override;
    Type* GenericGetVirtualType(const byte* value) const override;

    // Store the referenced type (the parent type that this qualified type represents)
    BoundType* ReferencedType;
  };

  // The 'any type' is a special type that can contain any primitive (delegates, handles, values, etc)
  // Note: There should only ever be one instantiation of this type (core.AnyType)
  class ZeroShared AnyType : public Type
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(AnyType, Type);

    // Constructor
    AnyType();

    // Implement the type interface
    bool IsCopyComplex() const override;
    size_t GetAllocatedSize() const override;
    GuidType Hash() const override;
    String ToString() const override;
    String GetShortLowerCamelCaseName() const override;
    void GenericDefaultConstruct(byte* toConstruct) const override;
    void GenericCopyConstruct(byte* to, const byte* from) const override;
    void GenericDestruct(byte* value) const override;
    int GenericHash(const byte* value) const override;
    String GenericToString(const byte* value) const override;
    bool GenericEquals(const byte* lhs, const byte* rhs) const override;
    byte* GenericGetMemory(const byte* value) const override;
    Type* GenericGetVirtualType(const byte* value) const override;
  };

  // A special constant that means we haven't yet figured out the size of an object
  static const size_t UndeterminedSize = (size_t)-1;

  // A function used for converting a value or object to a string
  typedef String (*ToStringFn)(const BoundType* type, const byte* data);

  // Retreives the event handler for an object (or null if this object cannot send/receive events)
  typedef EventHandler* (*GetEventHandlerFn)(const BoundType* type, const byte* data);

  namespace SpecialType
  {
    enum Enum
    {
      Standard,
      Enumeration,
      Flags
    };
  }

  namespace AddMemberResult
  {
    enum Enum
    {
      AlreadyExists,
      Added
    };
  }

  // A type that provides us with a simple way of grabbing members and functions from maps
  class ZeroShared BoundType : public Type
  {
  public:

    // Declare the class for RTTI
    ZilchDeclareDerivedType(BoundType, Type);

    // Constructor
    BoundType(const String& name, TypeCopyMode::Enum copyMode, size_t size, size_t nativeVirtualCount);

    // Destructor
    ~BoundType();

    // Implement the type interface
    bool IsCopyComplex() const override;
    size_t GetCopyableSize() const override;
    size_t GetAllocatedSize() const override;
    void GenericDefaultConstruct(byte* toConstruct) const override;
    void GenericCopyConstruct(byte* to, const byte* from) const override;
    void GenericDestruct(byte* value) const override;
    int GenericHash(const byte* value) const override;
    String GenericToString(const byte* value) const override;
    bool GenericEquals(const byte* lhs, const byte* rhs) const override;
    byte* GenericGetMemory(const byte* value) const override;
    Type* GenericGetVirtualType(const byte* value) const override;
    GuidType Hash() const override;
    String ToString() const override;
    String GetShortLowerCamelCaseName() const override;

    // Finds a function by name given the type signature
    Function* FindFunction(StringParam name, const Array<Type*>& parameters, Type* returnType, FindMemberOptions::Flags options) const;

    // Finds a function given a delegate type
    Function* FindFunction(StringParam name, DelegateType* type, FindMemberOptions::Flags options) const;

    // Finds a property or field by a name (can be static or instance)
    Property* FindPropertyOrField(StringParam name, FindMemberOptions::Flags options) const;

    // Get an array of overloaded instance functions under the same name. Returning null
    // or an empty array will signal that the function does not exist. Moreover, returning
    // a single function in the array will also work as if it were not overloaded
    const FunctionArray* GetOverloadedInstanceFunctions(StringParam name) const;

    // Get an array of overloaded static functions under the same name. Returning null
    // or an empty array will signal that the function does not exist. Moreover, returning
    // a single function in the array will also work as if it were not overloaded
    const FunctionArray* GetOverloadedStaticFunctions(StringParam name) const;

    // Get an array of overloaded constructors (either on your type, or inherited). Returning
    // null or an empty array will signal that no constructors exist. Moreover, returning
    // a single constructor in the array will also work as if it were not overloaded
    const FunctionArray* GetOverloadedInheritedConstructors() const;

    // Get an instance member by name
    Field* GetInstanceField(StringParam name) const;

    // Get a static member by name
    Field* GetStaticField(StringParam name) const;

    // Get an instance property by name
    Property* GetInstanceProperty(StringParam name) const;

    // Get a static property by name
    Property* GetStaticProperty(StringParam name) const;

    // Add a function (created through the library) to the bound type
    AddMemberResult::Enum AddRawFunction(Function* function);

    // Add a constructor (created through the library) to the bound type
    AddMemberResult::Enum AddRawConstructor(Function* function);

    // Add a property to the bound type
    AddMemberResult::Enum AddRawProperty(Property* property);

    // Add a field to the bound type
    AddMemberResult::Enum AddRawField(Field* field);

    // Get either the static or instance field map (maps strings to the fields)
    FieldMap& GetFieldMap(bool isStatic);

    // Get either the static or instance property map (maps strings to the fields)
    PropertyMap& GetPropertyMap(bool isStatic);

    // Get either the static or instance function map (maps strings to the fields)
    FunctionMultiMap& GetFunctionMap(bool isStatic);

    // Get an event handler from an instance of the object
    EventHandler* GetEventHandler(const byte* data);

    // Check if this type or any base type is a native type
    bool IsTypeOrBaseNative();
    
    // Attempt to get a default constructor (or return null if one cannot be found)
    static Function* GetDefaultConstructor(const FunctionArray* constructors);

    // By default, when our object is converted into
    // a string it simply prints out the type name
    static String DefaultTypeToString(const BoundType* type, const byte* data);

  public:

    // Tells us whether this is considered to be a value type or not
    // Value types have the property that they are memory copyable
    // and can therefore not store any references of any kind (only POD data)
    TypeCopyMode::Enum CopyMode;

    // Whether or not we can use new/local to create this type
    bool CreatableInScript;

    // Whether this type was bound natively
    bool Native;

    // Store the pre-constructor
    Function* PreConstructor;

    // Store the constructors
    FunctionArray Constructors;

    // The singular destructor (can be null if no destructor exists)
    Function* Destructor;

    // Responsible for the destruction of members
    PostDestructorFn PostDestructor;

    // Store all the instance functions defined within this class
    FunctionMultiMap InstanceFunctions;

    // Store all the static functions defined within this class
    FunctionMultiMap StaticFunctions;

    // Store all the instance class fields
    // Even though fields are properties, they do not exist in the property map
    FieldMap InstanceFields;

    // Store all the static class fields
    // Even though fields are properties, they do not exist in the property map
    FieldMap StaticFields;

    // Store all the instance class properties
    PropertyMap InstanceProperties;

    // Store all the static class properties
    PropertyMap StaticProperties;

    // Which events get sent by this type
    SendsEventArray SendsEvents;

    // All the properties in the order they are declared (includes both static and instance!)
    // This also includes all fields and properties (unlike the PropertyMap)
    PropertyArray AllProperties;

    // All the functions in the order they are declared (includes both static and instance!)
    // This does not include constructors, however it does include generated Get/Set functions (check for IsPropertyGetOrSet)
    FunctionArray AllFunctions;
    
    // Store the size of the object
    size_t Size;

    // Store the name of the type
    String Name;

    // In the case that this type is being generically allocated or a handle
    // is being pushed via binding/pointer, we need to know which handle manager
    // we are associated with
    HandleManagerId HandleManager;

    // The number of native virtual functions that the type has (0 if the type is non-native)
    // This is basically the exact number of entries in the C++ virtual table
    size_t RawNativeVirtualCount;

    // How many virtual functions we've actually bound
    // This is used to determine whether or not we need to build a v-table for this type upon creation
    size_t BoundNativeVirtualCount;

    // A user provided function that converts an instance of this type into a string
    ToStringFn ToStringFunction;
    
    // A user provided function that retreives an event handler from an instance of this type
    GetEventHandlerFn GetEventHandlerFunction;

    // A bound type could be an enum, flags, or just a regular old type
    // This is important because it affects what operators can be applied to the object
    SpecialType::Enum SpecialType;

    // Any interface types that we implement
    Array<BoundType*> InterfaceTypes;

    // The base type (or null if there is no base)
    BoundType* BaseType;

    // The handles that need to be cleaned up
    Array<size_t> Handles;

    // The delegates that need to be cleaned up
    Array<size_t> Delegates;
  };

  // Structure for delegate parameters
  class ZeroShared DelegateParameter
  {
  public:
    // Constructor
    DelegateParameter();

    // Implicit conversion from a type
    DelegateParameter(Type* type);

    // The name of the parameter
    String Name;

    // The type of the parameter
    Type* ParameterType;

    // If a name is not provided, we generate one based on the type and the position of the parameter
    bool IsNameGenerated;

    // The offset on the stack where this parameter exists
    // Note that the first parameter always comes after the
    // return value, and every parameter comes after that
    OperandIndex StackOffset;
  };

  // Type-defines
  typedef Array<DelegateParameter> ParameterArray;

  // The delegate type essentially stores the signature of a function (regardless of the class it belongs to)
  class ZeroShared DelegateType : public Type
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DelegateType, Type);

    // Constructor
    DelegateType();
    
    // Implement the type interface
    bool IsCopyComplex() const override;
    size_t GetAllocatedSize() const override;
    GuidType Hash() const override;
    String ToString() const override;
    String GetShortLowerCamelCaseName() const override;
    void GenericDefaultConstruct(byte* toConstruct) const override;
    void GenericCopyConstruct(byte* to, const byte* from) const override;
    void GenericDestruct(byte* value) const override;
    int GenericHash(const byte* value) const override;
    String GenericToString(const byte* value) const override;
    bool GenericEquals(const byte* lhs, const byte* rhs) const override;
    Type* GenericGetVirtualType(const byte* value) const override;

    // Builds the just the parameter part of the string (used in overload resolving)
    void BuildParameterString(StringBuilder& builder, bool includeGeneratedNames = true) const;

    // Builds the entire signature string, without the name
    void BuildSignatureString(StringBuilder& builder, bool includeGeneratedNames = true) const;

    // Gets the entire signature string, without the name
    String GetSignatureString() const;

    // The list of parameter types this function will take
    ParameterArray Parameters;

    // The single return type of the delegate (should never be null, but rather core.VoidType)
    Type* Return;

    // The return value's stack offset
    // This should always be zero (just added for clarity)
    OperandIndex ReturnStackOffset;

    // If we're calling a delegate that uses a 'this' handle, then this
    // parameter represents the stack offset to where the handle exists
    // In our calling convention, the 'this' handle always resides after
    // the return value and all parameters
    OperandIndex ThisHandleStackOffset;

    // The total stack size, excluding the optional this handle size at the end
    // Note that this should always be the same value as 'ThisHandleStackOffset'
    // (it is provided for clarification)
    size_t TotalStackSizeExcludingThisHandle;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_LIBRARY_HPP
#define ZILCH_LIBRARY_HPP

// Includes


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_DOCUMENTATION_HPP
#define ZILCH_DOCUMENTATION_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_STRING_BUILDER_HPP
#define ZILCH_STRING_BUILDER_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_EVENTS_HPP
#define ZILCH_EVENTS_HPP

// Includes



namespace Zilch
{
  // Declares an event to be sent by an EventHandler
  // The typical pattern in C++ is to declare these within the Events namespace
  #define ZilchDeclareEvent(EventName, EventType) ZeroShared extern const String EventName;

  // Defines the event so only cpp uint allocates the string 
  #define ZilchDefineEvent(EventName) ZeroShared const String EventName = #EventName;

  // All events that are sent must be derived from this type
  class ZeroShared EventData : public IZilchObject
  {
  public:
    ZilchDeclareBaseType(EventData, TypeCopyMode::ReferenceType);

    // Mark the destructor as virtual so we can properly clean up resources
    virtual ~EventData();

    // The name that we sent the event under
    String EventName;
  };

  // The virtual base class that represents a callback
  // This class is specialized for C++ static and member and Zilch delegates (can be made for other languages too)
  class ZeroShared EventDelegate
  {
  public:

    // The size of the event delegate must be less than or equal to this size
    static const size_t MaxEventDelegateSize = 128;

    // Default constructor
    EventDelegate();

    // Mark the destructor as virtual so we can properly clean up resources
    virtual ~EventDelegate();

    // Invokes the delegate (with whatever representation we use under the hood)
    // Returns how many event connections this in turn invoked (forwarding will return how many it invoked)
    // In general most handlers will return 1 if it succeeded, or 0 if it failed to invoke the delegate
    virtual int Invoke(EventData* event) = 0;

    // To support safe iteration through events (and modification of event handlers while sending)
    // All event delegates need to be copyable
    // This is achieved by knowing the size of the derived event delegate, and implementing an in place clone
    // Use the macro 'ZilchDefineEventDelegateHelpers' to automatically implement these virtual methods

    // Copy the event delegate in place
    virtual void CopyInto(byte* destination) = 0;

    // Get a unique id or pointer that lets us identify the owner of the delegate (who the delegate is bound to)
    virtual void* GetThisPointerOrUniqueId() = 0;

    // The type of event we accept
    // Note: We'll also accept more derived versions of this type
    BoundType* Type;

    // Every delegate is connected to the list of dispatched events per message type (MessageDelegateList)
    Link<EventDelegate> OutgoingLink;

    // Delegates are also connected to the message handler that will receive them (MessageHandler)
    Link<EventDelegate> IncomingLink;
  };

  // When we create new event delegates, we put this at the top to automatically implement 'GetSize' and 'CopyInto'
  // Our implementation of 'CopyInto' just invokes the copy constructor via placement new
  #define ZilchDefineEventDelegateHelpers(SelfType)                                     \
    void CopyInto(byte* destination) override                                           \
    {                                                                                   \
      ZilchStaticAssert(sizeof(SelfType) <= MaxEventDelegateSize,                       \
        "The size of the event delegate must not exceed MaxEventDelegateSize",          \
        EventDelegateExceedsMaxEventDelegateSize);                                      \
      SelfType* copy = new (destination) SelfType(*this);                               \
      copy->OutgoingLink.Next = nullptr;                                                \
      copy->IncomingLink.Next = nullptr;                                                \
    }

  // We use dual intrusively linked lists with the delegate to ensure that
  // events get destroyed when either the sender or receiver dies
  typedef InList<EventDelegate, &EventDelegate::OutgoingLink> OutgoingList;
  typedef InList<EventDelegate, &EventDelegate::IncomingLink> IncomingList;

  // Stores all outbound connections for a particular event name
  // As an optimization, this list can be pulled out and stored next to an EventHandler (but will be destroyed along with the handler)
  class ZeroShared EventDelegateList
  {
  public:

    // The destructor deletes all outgoing connections
    ~EventDelegateList();

    // Send an event to all outgoing delegates
    int Send(EventData* event);
    
    //******** Internal ********//

    // Store the name of the events associated with this list
    String EventName;

    // The intrusive list of all outgoing connections
    // A connection can be marked as invalid, in which it will be erased
    OutgoingList Outgoing;
  };

  // Stores all outgoing connections
  class ZeroShared EventHandler : public IZilchObject
  {
  public:
    ZilchDeclareBaseType(EventHandler, TypeCopyMode::ReferenceType);

    // Default constructor
    EventHandler();

    // When we get destructed we mark all outgoing and incoming events as destroyed
    ~EventHandler();

    // Get or create a delegate list for the particular event name
    // As an optimization, this list can be pulled out and stored next to an EventHandler (but will be destroyed along with the handler)
    EventDelegateList* GetOrCreateOutgoingDelegateList(StringParam eventName);

    //******** Internal ********//

    // Whenever we send an event, we look if anyone will respond by looking in this map
    // The delegate list stores an intrusive list of all event delegates that need to receive the event
    HashMap<String, EventDelegateList*> OutgoingPerEventName;

    // We keep track of all delegates that would send events to us
    // If we get destroyed, we'll mark all these delegates as destroyed
    IncomingList Incoming;

    // A global event handler (used for registering static functions and such)
    static EventHandler Global;
    ZilchNoCopy(EventHandler);
  };

  // Swap all the events from one handler to another (generally used when we want to disable all events, but save their states)
  ZeroShared void EventSwapAll(EventHandler* a, EventHandler* b);

  // Connects a sender and receiver event handler for a particular event, given an event connection
  ZeroShared void EventConnect(EventHandler* sender, StringParam eventName, EventDelegate* delegate, EventHandler* receiver);

  // Disconnect an event that we previously connected to
  // Disconnecting can also be done by storing the event delegate and deleting it
  // Returns the number of connections that were disconnected
  // Note: There can be more than one disconnected, but only if someone connected to the same event twice on the same object
  ZeroShared int EventDisconnect(EventHandler* sender, EventHandler* receiver, StringParam eventName, void* thisPointerOrUniqueId);

  // Invokes the event handler for anyone listening to this event name on our object
  // Returns how many receiver callbacks were successfully invoked
  ZeroShared int EventSend(EventHandler* sender, StringParam eventName, EventData* event);

  // When we want to connect up member functions, we use this template
  template <typename ClassType, typename EventType>
  class ZeroSharedTemplate MemberFunctionEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(MemberFunctionEventDelegate);

    // This is the signature of method that we accept
    typedef void (ClassType::*FunctionType)(EventType* event);

    // We store the member function pointer and the 'this' pointer for the class
    FunctionType FunctionPointer;
    ClassType* ThisPointer;

    // Construct a member function delegate from a class instance and member function pointer
    MemberFunctionEventDelegate(FunctionType function, ClassType* instance) :
      FunctionPointer(function),
      ThisPointer(instance)
    {
      this->Type = ZilchTypeId(EventType);
    }

    // Invoking the delegate just invokes the member function pointer (casts the event type too)
    int Invoke(EventData* event) override
    {
      // Technically the event type cast is unsafe, however we validate that it is safe using our reflection
      (this->ThisPointer->*this->FunctionPointer)((EventType*)event);
      return 1;
    }

    // We can just directly return the this pointer for the member function connection
    void* GetThisPointerOrUniqueId() override
    {
      return (void*)this->ThisPointer;
    }
  };

  // A special template helper that can infer template arguments to make member function connecting easier
  template <typename ClassType, typename EventType>
  void EventConnect(EventHandler* sender, StringParam eventName, void (ClassType::*function)(EventType*), ClassType* receiver)
  {
    // Create a member function delegate
    typedef MemberFunctionEventDelegate<ClassType, EventType> EventDelegateType;
    EventDelegateType* eventDelegate = new EventDelegateType(function, receiver);
    
    // Connect the event handler up to this newly created member delegate
    EventConnect(sender, eventName, eventDelegate, receiver);
  }

  // When we want to connect up static functions, we use this template
  template <typename EventType>
  class ZeroSharedTemplate StaticFunctionEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(StaticFunctionEventDelegate);

    // This is the signature of function that we accept
    typedef void (*FunctionType)(EventType* event);

    // We store the static function pointer to call
    FunctionType FunctionPointer;

    // Construct a member function delegate from a class instance and member function pointer
    StaticFunctionEventDelegate(FunctionType function) :
      FunctionPointer(function)
    {
      this->Type = ZilchTypeId(EventType);
    }

    // Invoking the delegate just invokes the static function pointer (casts the event type too)
    int Invoke(EventData* event) override
    {
      // Technically the event type cast is unsafe, however we validate that it is safe using our reflection
      this->FunctionPointer((EventType*)event);
      return 1;
    }
    
    // Since we have no real 'this' pointer, we're just going to return the function's address
    void* GetThisPointerOrUniqueId() override
    {
      return (void*)this->FunctionPointer;
    }
  };

  // A special template helper that can infer template arguments to make static function connecting easier
  template <typename EventType>
  void EventConnect(EventHandler* sender, StringParam eventName, void (*function)(EventType*))
  {
    // Create a member function delegate
    typedef StaticFunctionEventDelegate<EventType> EventDelegateType;
    EventDelegateType* eventDelegate = new EventDelegateType(function);
    
    // Connect the event handler up to this newly created static function delegate
    // We use the global event handler here (there is no receiver...)
    EventConnect(sender, eventName, eventDelegate, &EventHandler::Global);
  }

  // When we want to connect up static functions with userdata, we use this template
  template <typename EventType>
  class ZeroSharedTemplate StaticFunctionUserDataEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(StaticFunctionUserDataEventDelegate);

    // This is the signature of function that we accept
    typedef void (*FunctionType)(EventType* event, void* userData);

    // We store the static function pointer to call and the user-data
    FunctionType FunctionPointer;
    void* UserData;

    // Construct a member function delegate from a class instance and member function pointer
    StaticFunctionUserDataEventDelegate(FunctionType function, void* userData) :
      FunctionPointer(function),
      UserData(userData)
    {
      this->Type = ZilchTypeId(EventType);
    }

    // Invoking the delegate just invokes the static function pointer (casts the event type too)
    int Invoke(EventData* event) override
    {
      // Technically the event type cast is unsafe, however we validate that it is safe using our reflection
      this->FunctionPointer((EventType*)event, this->UserData);
      return 1;
    }
    
    // Return whatever the user gave us as user-data
    void* GetThisPointerOrUniqueId() override
    {
      return (void*)this->UserData;
    }
  };

  // A special template helper that can infer template arguments to make static function connecting easier (with user-data)
  template <typename EventType>
  void EventConnect(EventHandler* sender, StringParam eventName, void (*function)(EventType*, void*), void* userData)
  {
    // Create a member function delegate
    typedef StaticFunctionUserDataEventDelegate<EventType> EventDelegateType;
    EventDelegateType* eventDelegate = new EventDelegateType(function, userData);
    
    // Connect the event handler up to this newly created static function delegate
    // We use the global event handler here (there is no receiver...)
    EventConnect(sender, eventName, eventDelegate, &EventHandler::Global);
  }

  // A simple event delegate that just forwards events to another EventHandler
  class ZeroShared ForwardingEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(ForwardingEventDelegate);

    // The event handler we forward received events to
    // Note: This is safe to store as a pointer because we only allow forwarding to
    // whoever this event delegate is connected to (OutgoingLink)
    // If that object gets deleted, this delegate will automatically be deleted
    EventHandler* ForwardTo;

    // Construct a member function delegate from a class instance and member function pointer
    ForwardingEventDelegate(EventHandler* forwardTo);

    // EventDelegate interface
    int Invoke(EventData* event);
    void* GetThisPointerOrUniqueId();
  };

  // An event delegate that can call Zilch code
  class ZeroShared ZilchEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(ZilchEventDelegate);

    // Constructs the event from the Zilch delegate
    // NOTE: Must be validated by 'ValidateEventConnection prior to constructing!
    ZilchEventDelegate(const Delegate& delegate, ExecutableState* state);

    // The delegate *safely* stores the handle to the object as well as the function to call
    Delegate FunctionWithThis;

    // The state that we want to call this event in
    // The state should always be valid because if we destroy the state,
    // all objects get destroyed, and all events disconnected
    ExecutableState* State;

    // EventDelegate interface
    int Invoke(EventData* event);
    void* GetThisPointerOrUniqueId();
  };

  // Automatically forwards all events of a type of event name to another receiver
  ZeroShared void EventForward(EventHandler* sender, StringParam eventName, EventHandler* receiver);

  // A class that represents the 'Events' class within Zilch code (for binding purposes)
  class ZeroShared EventsClass
  {
  public:
    ZilchDeclareBaseType(EventsClass, TypeCopyMode::ReferenceType);

    // Sends an event out to anyone listening
    // Events are only accepted if their type is either the same or more derived then the callback's event type
    // Returns the number of listeners that received the event
    static int Send(const Handle& sender, StringParam eventName, EventData* event);

    // Listen for a given event sent by the 'sender'; invoke the callback when it is received
    // Event connections form a two way binding between the sender and the receiver
    // If either the sender or receiver is deleted, then the connection is broken
    // Here, the receiver is implicitly grabbed from the 'this' handle on the callback delegate
    // Returns an id that can be used to manually 'Disconnect' the event
    // When using a static function as a callback, the user must manually disconnect the event
    // Connect validates that a delegate is in proper form (and will throw an exception if it is not)
    // This validates that we did not get a null delegate, the this pointer was not null (static functions are ok!),
    // and that the delegate has no return and only one argument that inherits from the EventData type
    static void Connect(const Handle& sender, StringParam eventName, const Delegate& callback);
  };
}

// End header protection
#endif


namespace Zilch
{
  // Forward declarations
  typedef const Any& AnyParam;

  // String builder is a convenient way to concatenate strings
  class ZeroShared StringBuilderExtended : public StringBuilder
  {
  public:
    ZilchDeclareBaseType(StringBuilderExtended, TypeCopyMode::ReferenceType);

    // Write to the string builder
    void Write(AnyParam value);
    void Write(StringParam value);
    void Write(StringRange value);
    void Write(char value);
    void Write(cstr value);
    void Write(Boolean value);
    void Write(Boolean2Param value);
    void Write(Boolean3Param value);
    void Write(Boolean4Param value);
    void Write(Integer value);
    void Write(Integer2Param value);
    void Write(Integer3Param value);
    void Write(Integer4Param value);
    void Write(Real value);
    void Write(Real2Param value);
    void Write(Real3Param value);
    void Write(Real4Param value);
    void Write(DoubleInteger value);
    void Write(DoubleReal value);
    void Write(QuaternionParam value);
    void WriteLine();
    void WriteLine(AnyParam value);
    void WriteLine(StringParam value);
    void WriteLine(StringRange value);
    void WriteLine(cstr value);
    void WriteLine(char value);
    void WriteLine(Boolean value);
    void WriteLine(Boolean2Param value);
    void WriteLine(Boolean3Param value);
    void WriteLine(Boolean4Param value);
    void WriteLine(Integer value);
    void WriteLine(Integer2Param value);
    void WriteLine(Integer3Param value);
    void WriteLine(Integer4Param value);
    void WriteLine(Real value);
    void WriteLine(Real2Param value);
    void WriteLine(Real3Param value);
    void WriteLine(Real4Param value);
    void WriteLine(DoubleInteger value);
    void WriteLine(DoubleReal value);
    void WriteLine(QuaternionParam value);

    // Clears the current buffer and frees all blocks
    void Clear();

    // Convert the internally stored buffers into a string
    String ToString() const;
  };

  // Represents one utf-8 character in a string.
  class ZeroShared Rune
  {
    ZilchDeclareBaseType(Rune, TypeCopyMode::ValueType);

    Rune();
    Rune(int value);

    static String ToString(const BoundType* type, const byte* data);

  public:
    int mValue;
  };

  // An iterator to one rune (think char) in a string
  // This iterator also keeps a reference to the string to keep it alive
  class ZeroShared RuneIterator
  {
  public:
    ZilchDeclareBaseType(RuneIterator, TypeCopyMode::ReferenceType);
    
    static String ToString(const BoundType* type, const byte* data);

    // Range interface
    static void All(Call& call, ExceptionReport& report);
    static void Current(Call& call, ExceptionReport& report);
    static void IsNotEmpty(Call& call, ExceptionReport& report);

    // Iterator interface
    static void Increment(Call& call, ExceptionReport& report);
    static void Decrement(Call& call, ExceptionReport& report);
    static void Equals(Call& call, ExceptionReport& report);

    static void GetByteIndex(Call& call, ExceptionReport& report);
    static void GetOriginalString(Call& call, ExceptionReport& report);
    static void FindRuneIndexFromIterator(Call& call, ExceptionReport& report);

    // The original string this range was made from. Also keeps this string alive.
    String mOriginalStringReference;
    StringRange mRange;
  };

  // A string range bound to Zilch. This range will also keep the string that it's referencing alive
  class ZeroShared StringRangeExtended
  {
    ZilchDeclareBaseType(StringRangeExtended, TypeCopyMode::ReferenceType);

    static String ToString(const BoundType* type, const byte* data);

    // Range interface
    static void All(Call& call, ExceptionReport& report);
    void MoveNext();
    static void Current(Call& call, ExceptionReport& report);
    static void IsNotEmpty(Call& call, ExceptionReport& report);

    static void Begin(Call& call, ExceptionReport& report);
    int CompareTo(StringRangeExtended range);
    bool Contains(StringRangeExtended string);
    static void ConvertToString(Call& call, ExceptionReport& report);
    static void End(Call& call, ExceptionReport& report);
    bool EndsWith(StringRangeExtended subString);
    static void FindFirstOf(Call& call, ExceptionReport& report);
    static void FindLastOf(Call& call, ExceptionReport& report);
    static void FindRangeExclusive(Call& call, ExceptionReport& report);
    static void FindRangeInclusive(Call& call, ExceptionReport& report);
    String Replace(StringRangeExtended oldValue, StringRangeExtended newValue);
    static void RuneIteratorFromByteIndex(Call& call, ExceptionReport& report);
    static void RuneIteratorFromByteIndexInternal(Call& call, ExceptionReport& report, StringParam strRef, StringRange range, int byteIndex);
    static void RuneIteratorFromRuneIndex(Call& call, ExceptionReport& report);
    static void RuneIteratorFromRuneIndexInternal(Call& call, ExceptionReport& report, StringParam strRef, StringRange range, int runeIndex);
    static void Split(Call& call, ExceptionReport& report);
    bool StartsWith(StringRangeExtended subString);
    static void SubString(Call& call, ExceptionReport& report);
    static void SubStringBytes(Call& call, ExceptionReport& report);
    static void Trim(Call& call, ExceptionReport& report);
    static void TrimEnd(Call& call, ExceptionReport& report);
    static void TrimStart(Call& call, ExceptionReport& report);
    String ToLower();
    String ToUpper();
    static void SetResultStringRange(Call& call, ExceptionReport& report, const String& strRef, StringRange result);
    static void SetResultStringSplitRange(Call& call, ExceptionReport& report, StringParam strRef, const Zero::StringSplitRange& result);
    static void SetResultIterator(Call& call, ExceptionReport& report, StringParam strRef, StringRange result);
    static void GetOriginalString(Call& call, ExceptionReport& report);

    static bool ValidateRange(StringParam strRef, const StringRange& range);

    StringRange mRange;
    // The original string this range was made from. Also keeps this string alive
    String mOriginalStringReference;
  };

  // The results from a String.Split operation
  class ZeroShared StringSplitRangeExtended
  {
    ZilchDeclareBaseType(StringSplitRangeExtended, TypeCopyMode::ReferenceType);

    static void All(Call& call, ExceptionReport& report);
    static void MoveNext(Call& call, ExceptionReport& report);
    static void Current(Call& call, ExceptionReport& report);
    static void IsNotEmpty(Call& call, ExceptionReport& report);

    // The original string this range was made from. Also keeps this string alive
    String mOriginalStringReference;
    Zero::StringSplitRange mSplitRange;
  };
}

// End header protection
#endif


namespace Zilch
{
  // Represents a parameter in a function
  class DocumentationParameter
  {
  public:

    // The name of the parameter (or an empty string if it's nothing)
    String Name;

    // The type of the parameter
    String Type;
  };

  // Documentation that describes an individual function
  class DocumentationFunction
  {
  public:

    // Destructor
    ~DocumentationFunction();

    // The name of the function
    String Name;

    // The parameter names and types
    Array<DocumentationParameter*> Parameters;

    // The return type (or empty if it's void / returns nothing)
    String ReturnType;

    // The entire signature (no name, but includes parameters and return type)
    String Signature;

    // A basic description for the function (typically parsed from comments)
    String Description;
    
    // Any samples or remarks about the usage of a particular object or member
    StringArray Remarks;

    // The exceptions that this function can throw
    StringArray ExceptionsThrown;
  };

  // Documentation that describes an individual property
  class DocumentationProperty
  {
  public:

    // Constructor
    DocumentationProperty();

    // Destructor
    ~DocumentationProperty();

    // The name of the property
    String Name;

    // The type of the property
    String Type;

    // A basic description for the property (typically parsed from comments)
    String Description;
    
    // Any samples or remarks about the usage of a particular object or member
    StringArray Remarks;

    // Tells us if this property can be set
    bool IsSettable;

    // Tells us if this property can be retrieved
    bool IsGettable;

    // Tells us if this property is a data member
    // Generally data members should be displayed along with properties
    bool IsField;
  };

  // Documentation that describes an individual type
  class DocumentationType
  {
  public:

    // Destructor
    ~DocumentationType();

    // Constructor
    DocumentationType();

    // The name of the type
    String Name;

    // The name of the base type, or empty if there is none
    String BaseName;

    // Is this a value type or a reference type?
    bool IsValueType;

    // A basic description for the type (typically parsed from comments)
    String Description;
    
    // Any samples or remarks about the usage of a particular object or member
    StringArray Remarks;
    
    // The constructors that belong to this type
    Array<DocumentationFunction*> Constructors;
    
    // The instance methods that belong to this type (sorted by name, owned)
    Array<DocumentationFunction*> InstanceMethods;
    
    // The static methods that belong to this type (sorted by name, owned)
    Array<DocumentationFunction*> StaticMethods;
    
    // The instance methods that belong to this type (sorted by name, includes data members, owned)
    Array<DocumentationProperty*> InstanceProperties;
    
    // The static methods that belong to this type (sorted by name, includes data members, owned)
    Array<DocumentationProperty*> StaticProperties;
  };

  // Represents an entire library built by our documentation engine
  class DocumentationLibrary
  {
  public:

    // Destructor
    ~DocumentationLibrary();
    
    // The name of the library
    String Name;

    // All the types defined within the library
    HashMap<String, DocumentationType*> TypesByName;

    // The same array of types, sorted by name
    Array<DocumentationType*> TypesSorted;
  };

  // Represents an entire library built by our documentation engine
  class DocumentationModule
  {
  public:

    // Destructor
    ~DocumentationModule();

    // All the libraries we're dependent upon
    Array<DocumentationLibrary*> Libraries;
  };

  class RstTable
  {
  public:
    // Constructor
    RstTable();

    // Resize the table to have the number of columns and rows
    void Resize(size_t columns, size_t rows);

    // Set a cell by column and row
    void SetCell(StringParam value, size_t column, size_t row);

    // Get a cell by column and row
    String GetCell(size_t column, size_t row);

    // All the cells in the table (indexed as a 2d array)
    Array<String> Cells;

    // The number of columns and rows of this table
    // Cells must be Rows * Columns in size
    size_t Columns;
    size_t Rows;

    // How many of the first rows are header rows (does not add to the total number)
    // Must be less than or equal to Rows
    size_t HeaderRows;
  };

  namespace RstHeadingType
  {
    enum Enum
    {
      Part,
      Chapter,
      Section,
      SubSection,
      SubSubSection,
      Paragraph
    };
  }

  class RstBuilder : public StringBuilderExtended
  {
  public:
    // We don't want to hide the base class members, but rather add overloads
    using StringBuilderExtended::WriteLine;

    // Write out a table with columns and rows
    void WriteLine(RstTable& table);

    // Write out a heading (typically bold and larger)
    void WriteLineHeading(StringRange heading, RstHeadingType::Enum type);
  };
}

// End header protection
#endif


namespace Zilch
{
  // Type-defines
  typedef BoundType* (*InstantiateTemplateCallback)
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  );

  // An type parsed delegate is a structure that stores the callback and user-data
  class InstantiateTemplateDelegate
  {
  public:
    // Constructor
    InstantiateTemplateDelegate();

    // The associated callback / method
    InstantiateTemplateCallback Callback;

    // The 'this' pointer to the object
    const void* UserData;
  };

  // All the information we need to instantiate a new template
  class InstantiateTemplateInfo
  {
  public:
    // Get the fully qualified name of the template
    String GetFullName(const Array<Type*>& templateArguments);

    // The callback we use to instantiate the template (user provided)
    InstantiateTemplateDelegate Delegate;

    // The names of the template arguments
    StringArray TemplateArgumentNames;

    // The actual base name of the template
    String BaseName;
  };

  // A library stores all the types and 
  class ZeroShared Library
  {
  public:

    // Friends
    friend class LibraryBuilder;
    
    // Destructor
    ~Library();

    // For any native type wihin this library, we will generate stub code for that native type
    // We don't do this by default (to save memory) but we will generate and store the stub code on demand
    void GenerateDefinitionStubCode();

    // Gets an array of types with base classes coming before derived types
    // Useful for code generation with languages that require base classes to be defined prior to derived classes
    void GetTypesInDependencyOrder(Array<BoundType*>& typesOut);

    // The name of the library, used for debug purposes
    String Name;

    // The source code this library was built from (generally the result of a Project)
    // If this library is native / build via generation, this array will be empty
    // If a type is compiled from script, it should point back at the script it resulted from
    // Code locations also reference the index into this array
    Array<CodeEntry> Entries;

    // Store all the types compiled in this library
    BoundTypeMap BoundTypes;

    // Any types that we own that are non named types (delegate, qualifieds, etc)
    Array<Type*> OwnedTypes;

    // Store the array of bound functions
    FunctionArray OwnedFunctions;

    // Store any variable created by the functions
    Array<Variable*> OwnedVariables;

    // Store any properties created by the types (includes members)
    Array<Property*> OwnedProperties;

    // All the plugins that were loaded when this library was created
    Array<UniquePointer<Plugin> > OwnedPlugins;

    // This map controls how we extend types with functions without using inheritance
    // We map a type guid to the functions we extend it with
    FunctionExtensionMap StaticExtensionFunctions;
    FunctionExtensionMap InstanceExtensionFunctions;

    // This map controls how we extend types with properties without using inheritance
    // We map a type guid to the properties we extend it with
    PropertyExtensionMap StaticExtensionProperties;
    PropertyExtensionMap InstanceExtensionProperties;

    // All the string literals we contain (effectively the string pool)
    StringArray StringLiterals;

    // Callbacks that we try and call to handle template
    HashMap<String, InstantiateTemplateInfo> TemplateHandlers;

    // Whether or not we generated stub code (typically for 'go to definition' features)
    bool GeneratedDefinitionStubCode;

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructibleBuffer ComplexUserData;

    // Whether this library was built in tolerant mode or not
    bool TolerantMode;

  private:

    // Constructor
    Library();

    // Not copyable
    ZilchNoCopy(Library);

    // An intrusive reference count for memory handling
    ZilchRefLink(Library);
  };

  // When we refer to the Library class we always use a shared_ptr
  // These are typedefines that require the knowledge of Library
  typedef Ref<Library>                  LibraryRef;
  typedef HashMap<GuidType, LibraryRef> LibraryGuidMap;
  typedef LibraryGuidMap::range         LibraryGuidRange;
  typedef Array<LibraryRef>             LibraryArray;
  typedef LibraryArray::range           LibraryRange;

  // For some reason we encounter linker errors when exporting a dll
  // unless we use explicit instantiation for these types (related to the .def file)
  template class Ref<Library>;

  // Any options we use while building a function
  namespace FunctionOptions
  {
    enum Enum
    {
      // No options
      None = 0,

      // A member that is not part of an instance,
      // but rather part of the type itself
      Static = 1,

      // A function that is virtual can be overridden by
      // another function in a more derived class
      Virtual = 2
    };
    typedef unsigned Flags;
  }

  // Any options we use while building a member
  namespace MemberOptions
  {
    enum Enum
    {
      // No options
      None = 0,

      // A member that is not part of an instance,
      // but rather part of the type itself
      Static = 1,
    };
    typedef unsigned Flags;
  }

  // A hashing policy for the delegate type set
  class DelegateTypePolicy
  {
  public:
    // Hashing operator
    GuidType operator() (DelegateType* type);

    // Comparison operator
    bool equal(DelegateType* a, DelegateType* b);
  };

  // Make a hash set using the above policy
  typedef HashSet<DelegateType*, DelegateTypePolicy>  DelegateTypeSet;
  typedef DelegateTypeSet::range                      DelegateTypeRange;

  // Specifies how we want to check / verify token names in the library builder
  namespace TokenCheck
  {
    enum Enum
    {
      None = 0,
      IsUpper = 1,
      IsLower = 2,
      Asserts = 4,
      RemoveOuterBrackets = 8,
      NoMultipleInvalidCharacters = 16
    };

    typedef unsigned Flags;
  }

  // An error code for how we instantiate templates
  namespace TemplateResult
  {
    enum Enum
    {
      // We succeeded at instantiating the template
      Success,

      // A template instantiator by the same name could not be found
      FailedNameNotFound,

      // The template instantiator provided by the user failed to instantiate a template
      FailedInstantiatorDidNotReturnType,

      // We failed to instantiate the template because we provided the wrong number of arguments
      FailedInvalidArgumentCount
    };
  }

  // What we return from instantiating a template
  class InstantiatedTemplate
  {
  public:
    // Constructor
    InstantiatedTemplate();

    // The type of the template (or null if it failed)
    BoundType* Type;

    // The number of arguments expected for this template
    size_t ExpectedArguments;

    // The result (or an error code for why we couldn't instantiate the template)
    TemplateResult::Enum Result;
  };

  // Create an array of types
  #define ZilchTypes(...) Array<Type*>(ZeroInit, __VA_ARGS__)

  // Helper functions for generating parameter arrays (used in library building)
  ParameterArray OneParameter(Type* type);
  ParameterArray OneParameter(Type* type, StringParam name);
  ParameterArray TwoParameters(Type* type);
  ParameterArray TwoParameters(Type* type1, Type* type2);
  ParameterArray TwoParameters(Type* type, StringParam name1, StringParam name2);
  ParameterArray TwoParameters(Type* type1, StringParam name1, Type* type2, StringParam name2);
  ParameterArray ThreeParameters(Type* type);
  ParameterArray ThreeParameters(Type* type1, Type* type2, Type* type3);
  ParameterArray ThreeParameters(Type* type, StringParam name1, StringParam name2, StringParam name3);
  ParameterArray ThreeParameters(Type* type1, StringParam name1, Type* type2, StringParam name2, Type* type3, StringParam name3);
  ParameterArray FourParameters(Type* type);
  ParameterArray FourParameters(Type* type, StringParam name1, StringParam name2, StringParam name3, StringParam name4);
  ParameterArray FiveParameters(Type* type);
  ParameterArray FiveParameters(Type* type, StringParam name1, StringParam name2, StringParam name3, StringParam name4, StringParam name5);

  class ZeroShared LibraryBuilder
  {
  public:
    // Friends
    friend class Core;
    friend class CodeGenerator;
    friend class Syntaxer;
    friend class Module;

    // Constructor that takes the name of the library we want to build
    LibraryBuilder(StringParam name);

    // Get the name fo the library we are building
    String GetName();

    // Set the original source code entries that this library is being built from
    void SetEntries(const Array<CodeEntry>& entries);

    // Returns a pointer to the plugin if it is able to be loaded, or null if it failed to load
    // The plugin's lifetime will be associated with the library we are building (deleted when it dies)
    // All plugins loaded should have the '.zilchPlugin' extension (a shared object or dynamic linked library)
    // It may fail to load if the path specified isn't accessible, isn't a valid shared library,
    // or doesn't export the CreateZilchPlugin function
    // Loading a plugin will attempt to make a local/temporary copy so that dyanmic reloading can be done (on certain platforms)
    // This ideally prevents our program from locking the plugin file
    Plugin* LoadPlugin(Status& status, StringParam pluginFile);

    // Loads all the plugins from the given directory (must have the '.zilchPlugin' extension)
    void LoadPlugins(StringParam directory, Array<Plugin*>& pluginsOut);

    // Add a function to the library and bound type (pass nullptr for thisType if the function is static)
    Function* AddBoundFunction
    (
      BoundType* owner,
      StringParam name,
      BoundFn function,
      const ParameterArray& parameters,
      Type* returnType,
      FunctionOptions::Flags options,
      NativeVirtualInfo nativeVirtual = NativeVirtualInfo()
    );

    // Add a function to the library as an extension of another type (pass nullptr for thisType if the function is static)
    Function* AddExtensionFunction
    (
      BoundType* forType,
      StringParam name,
      BoundFn function,
      const ParameterArray& parameters,
      Type* returnType,
      FunctionOptions::Flags options
    );

    // Add an already created function to the library as an extension of another type
    void AddRawExtensionFunction(Function* function);
    
    // Add a pre-constructor to the library and bound type
    Function* AddBoundPreConstructor(BoundType* owner, BoundFn function);
    
    // Add a constructor to the library and bound type
    Function* AddBoundConstructor(BoundType* owner, BoundFn function, const ParameterArray& parameters);
    
    // Add a default constructor to the library and bound type
    Function* AddBoundDefaultConstructor(BoundType* owner, BoundFn function);
    
    // Add a destructor to the library and bound type
    Function* AddBoundDestructor(BoundType* owner, BoundFn function);

    // Add a member to the library and bound type
    Field* AddBoundField(BoundType* owner, StringParam name, Type* type, size_t offset, MemberOptions::Flags options);

    // Add a property to the library and bound type
    Property* AddBoundProperty(BoundType* owner, StringParam name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options);

    // Add a property to the library as an extension of another type
    Property* AddExtensionProperty(BoundType* forType, StringParam name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options);

    // Attempts to instantiate a template (or returns a failure error code)
    InstantiatedTemplate InstantiateTemplate(StringParam baseName, const Array<Type*>& arguments, const LibraryArray& fromLibraries);

    // Add a function to the library (pass nullptr for thisType if the function is static)
    Function* CreateRawFunction
    (
      BoundType* owner,
      String name,
      BoundFn function,
      const ParameterArray& parameters,
      Type* returnType,
      FunctionOptions::Flags options,
      NativeVirtualInfo nativeVirtual = NativeVirtualInfo()
    );
    
    // Add a pre-constructor to the library
    Function* CreateRawPreConstructor(BoundType* owner, BoundFn function);
    
    // Add a constructor to the library
    Function* CreateRawConstructor(BoundType* owner, BoundFn function, const ParameterArray& parameters);
    
    // Add a default constructor to the library
    Function* CreateRawDefaultConstructor(BoundType* owner, BoundFn function);

    // Add a destructor to the library
    Function* CreateRawDestructor(BoundType* owner, BoundFn function);

    // Add a property to the library
    Property* CreateRawProperty(BoundType* owner, String name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options);

    // Add a field to the library
    Field* CreateRawField(BoundType* owner, String name, Type* type, size_t offset, MemberOptions::Flags options);

    // Add a variable to the library
    Variable* CreateRawVariable(Function* function, String name);


    // Add a string constant to the library (typically only done by the compiler)
    const String& AddStringLiteral(cstr text);
    
    // Add a string constant to the library (typically only done by the compiler)
    const String& AddStringLiteral(StringParam text);
    
    // Add a string constant to the library (typically only done by the compiler)
    const String& AddStringLiteral(StringRange text);

    
    // Get the type that reprsents one more level of indirection to the given type
    Type* ToHandleType(BoundType* type);

    // Get the type that reprsents one more level of indirection to the given type
    IndirectionType* ReferenceOf(BoundType* type);

    // Dereference the given type and get the resulting type from that
    BoundType* Dereference(IndirectionType* type);

    // Given a created delegate type, add or merge it into the delegate set (and return the proper type that we should be using...)
    DelegateType* GetDelegateType(const ParameterArray& parameters, Type* returnType);


    // Adds a callback to the library that will be called any time a user attempts to instantiate a template type with this name
    void AddTemplateInstantiator(StringParam baseName, InstantiateTemplateCallback callback, const StringArray& templateArgumentNames, void* userData);

    // Adds a bound type to the library builder
    BoundType* AddBoundType(StringParam name, TypeCopyMode::Enum copyMode, size_t size, size_t nativeVirtualCount = 0);

    // Adds a bound type to the library
    void AddRawBoundType(BoundType* type);

    // Find a named type by name, or return null
    BoundType* FindBoundType(StringParam name);

    // Create a library from the builder
    LibraryRef CreateLibrary();

    // After computing the sizes of all types, we can go back through any created delegates
    // and udpate their information (such as required stack space, parameter positions, etc)
    void ComputeDelegateAndFunctionSizesOnce();

    // Checks to see if an upper-identifier is valid
    static bool CheckUpperIdentifier(StringParam identifier);

    // Checks to see if a lower-identifier is valid
    static bool CheckLowerIdentifier(StringParam identifier);

    // Checks to see if a identifier is valid
    static bool CheckIdentifier(StringParam identifier, TokenCheck::Flags flags);

    // Attempts to fix an identifier to make it valid (this may make it collide with others)
    // Removed leading invalid characters until we reach a letter
    // The following invalid characters will be replaced with 'invalidCharacter' (default underscore)
    // Use '\0' for the invalid character to have it removed from the identifier
    // Identifiers will be forced to have the first letter uppercased or lowercased depending on the flags
    // If 'None' is specified, the identifier returned will not be modified to be upper/lower
    // If the string is empty, this will return either "empty" or "Empty"
    static String FixIdentifier(StringParam identifier, TokenCheck::Flags flags, char invalidCharacter = '_');

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructibleBuffer ComplexUserData;

  public:

    // The library builder always creates a single library
    // This should generally not be touched until the builder is finished building
    LibraryRef BuiltLibrary;

  private:

    // A constant we can pass in as a get/set that signifies to not actually generate the get/set Function object
    static const BoundFn DoNotGenerate;

    // A constant that will generate a get/set Function object (can later be replaced)
    static const BoundFn NoOperation;

    // Generates the property getter/setter for fields
    // Must be called AFTER all sizes have been computed
    // Can be called multiple times (only checks fields with no get/set)
    void GenerateGetSetFields();

  private:

    // Store all the types compiled in this library
    BoundTypeMap BoundTypes;

    // A map that allows us to cut down on the number of qualified types we allocate
    TypeToIndirect IndirectTypes;

    // Store a set of all the delegate types (note that delegate types are shared, eg the same definition results in the same type)
    DelegateTypeSet DelegateTypes;

    // Whether we computed the size of all the delegates and the function stack offsets
    // This only needs to be done once, generally after all types, members, and functions have been collected (after all syntaxing)
    bool ComputedDelegateAndFunctionSizes;

    // Not copyable
    ZilchNoCopy(LibraryBuilder);
  };

  // A module contains many libraries
  class ZeroShared Module : public LibraryArray
  {
  public:

    // Constructor
    Module();

    // Finds a type in any of the libraries by name
    BoundType* FindType(StringParam name);

    // Link libraries together to create a single executable application
    ExecutableState* Link() const;

    // Builds a documentation object that contains all the libraries, types, functions, etc
    DocumentationModule* BuildDocumentation();
    
    // Create an html/javascript file that defines our documentation
    String BuildDocumentationHtml();
    
    // Output documentation for the library into rst format
    void BuildDocumentationRst(StringParam directory);

  private:

    // Build documentation for a given type
    void BuildTypeDocumentation(BoundType* type, DocumentationType* docType);

    // Build documentation for a set of functions
    void BuildFunctionDocumentation(Array<DocumentationFunction*>& addTo, const FunctionMultiMap& functions);
    void BuildFunctionDocumentation(Array<DocumentationFunction*>& addTo, const FunctionArray& functions);

    // Build documentation for properties and members
    void BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const FieldMap& fields);
    void BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const PropertyMap& properties);
    void BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const Property* property);

    // Builds a Json array of documented constructors
    void BuildJsonConstructors(JsonBuilder& json, const Array<DocumentationFunction*>& constructors, StringParam name);

    // Builds a Json array of documented functions
    void BuildJsonMethods(JsonBuilder& json, const Array<DocumentationFunction*>& functions, StringParam name);

    // Builds a Json array of documented properties
    void BuildJsonProperties(JsonBuilder& json, const Array<DocumentationProperty*>& properties, StringParam name);
  };

  namespace ForEachFunctorResult
  {
    enum Enum
    {
      Continue,
      Stop
    };
  }

  // The functor should return a ForEachFunctorResult::Enum and takes (Property*)
  template <typename Functor>
  void ForEachExtensionProperty(bool isStatic, const LibraryArray& libraries, BoundType* type, Functor functor)
  {
    // Loop through all the libraries
    for (size_t i = 0; i < libraries.size(); ++i)
    {
      // We need to look up the entire heirarchy (the property could be on any base classes)
      BoundType* baseIterator = type;
      while (baseIterator != nullptr)
      {
        // Grab the current library
        const LibraryRef& library = libraries[i];

        // Get the guid of the type (this should be legal here since we've collected all members)
        GuidType guid = baseIterator->Hash();

        // Get the array of properties (may be empty)
        PropertyMap* properties = nullptr;
        
        // If we're resolving a static member
        if (isStatic)
          properties = library->StaticExtensionProperties.findPointer(guid);
        else
          properties = library->InstanceExtensionProperties.findPointer(guid);
        
        // If we got a valid array of properties...
        if (properties != nullptr)
        {
          ZilchForEach(Property* property, properties->values())
          {
            if (functor(property) == ForEachFunctorResult::Stop)
              return;
          }
        }
          
        // Iterate to the next type
        baseIterator = baseIterator->BaseType;
      }
    }
  }

  // The functor should return a ForEachFunctorResult::Enum and takes (Function*)
  template <typename Functor>
  void ForEachExtensionFunction(bool isStatic, const LibraryArray& libraries, BoundType* type, Functor functor)
  {
    // Loop through all the libraries
    for (size_t i = 0; i < libraries.size(); ++i)
    {
      // We need to look up the entire heirarchy (the property could be on any base classes)
      BoundType* baseIterator = type;
      while (baseIterator != nullptr)
      {
        // Grab the current library
        const LibraryRef& library = libraries[i];

        // Get the guid of the type (this should be legal here since we've collected all members)
        GuidType guid = baseIterator->Hash();

        // Get the map of all functions
        FunctionMultiMap* functionMultiMap = nullptr;
        
        // If we're resolving a static function
        if (isStatic)
          functionMultiMap = library->StaticExtensionFunctions.findPointer(guid);
        else
          functionMultiMap = library->InstanceExtensionFunctions.findPointer(guid);
        
        // If we got a valid map from the type to the function overloads...
        if (functionMultiMap != nullptr)
        {
          // Walk through all overloads and functions...
          ZilchForEach(FunctionArray& overloads, functionMultiMap->values())
          {
            ZilchForEach(Function* function, overloads.all())
            {
              if (function->IsPropertyGetOrSet)
                continue;

              if (functor(function) == ForEachFunctorResult::Stop)
                return;
            }
          }
        }
          
        // Iterate to the next type
        baseIterator = baseIterator->BaseType;
      }
    }
  }

  // The functor should return a bool (true means stop, false means keep going) and takes (Property*)
  template <typename Functor>
  void ForEachProperty(bool isStatic, const LibraryArray& libraries, BoundType* type, Functor functor)
  {
    // Walk up the base class heirarchy
    BoundType* baseType = type;
    while (baseType != nullptr)
    {
      // Walk through all the properties on the bound type
      for (size_t i = 0; i < baseType->AllProperties.size(); ++i)
      {
        // Grab the current property and check if its static or not
        Property* property = baseType->AllProperties[i];
        if (property->IsStatic == isStatic)
        {
          if (functor(property) == ForEachFunctorResult::Stop)
            return;
        }
      }

      // Iterate to the base class (could be null)
      baseType = baseType->BaseType;
    }
    
    // Now walk through extension properties
    ForEachExtensionProperty(isStatic, libraries, type, functor);
  }

  // The functor should return a bool (true means stop, false means keep going) and takes (Function*)
  template <typename Functor>
  void ForEachFunction(bool isStatic, const LibraryArray& libraries, BoundType* type, Functor functor)
  {
    // Walk up the base class heirarchy
    BoundType* baseType = type;
    while (baseType != nullptr)
    {
      // Walk through all the functions on the bound type
      for (size_t i = 0; i < baseType->AllFunctions.size(); ++i)
      {
        // Grab the current function and check if its static or not
        Function* function = baseType->AllFunctions[i];
        if (function->IsPropertyGetOrSet == false && (function->This == nullptr) == isStatic)
        {
          if (functor(function) == ForEachFunctorResult::Stop)
            return;
        }
      }

      // Iterate to the base class (could be null)
      baseType = baseType->BaseType;
    }

    // Now walk through extension functions
    ForEachExtensionFunction(isStatic, libraries, type, functor);
  }
}

namespace Zero
{
  template class Array<Zilch::LibraryRef>;
  template class AllocationContainer<DefaultAllocator>;
}

// End header protection
#endif


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_STATIC_LIBRARY_HPP
#define ZILCH_STATIC_LIBRARY_HPP

// Includes



namespace Zilch
{
  // Type-defines
  typedef void (*StaticInitializeFn)(StaticLibrary& library);
  typedef void (*SetupTypeFn)(LibraryBuilder& library, BoundType* type);

  namespace BuildState
  {
    enum Enum
    {
      NotBuilt,
      Building,
      Built
    };
  }

  // This is the interface we expect to see when creating any static
  // library / using the binding system. The only other function that
  // is expected is a static 'GetLibrary()' function which returns a
  // reference to your own type
  class ZeroShared StaticLibrary
  {
  public:
    // Friends
    friend class StaticLibraries;

    // Check if this library was built, is in the process of being built, or hasn't started building yet
    BuildState::Enum GetBuildState();

    // Whether we can currently build types or not (used in ZilchTypeId and Binding)
    virtual bool CanBuildTypes();

    // Get the library that we represent
    LibraryRef GetLibrary();

    // Get a reference to the library builder
    LibraryBuilder* GetBuilder();

    // Create the type (the parent can be NULL if the type is a base)
    BoundType* MakeType
    (
      StringParam         name,
      size_t              size,
      TypeCopyMode::Enum  copyMode,
      BoundType*          parent,
      size_t              nativeVirtualCount
    );

    // Builds the library once and builds all dependencies
    void BuildLibrary();

  protected:

    // Constructor
    StaticLibrary(String name);

    // Declare a virtual destructor
    virtual ~StaticLibrary();

    // Setup any custom binding for the library
    virtual void SetupBinding(LibraryBuilder& builder);

  protected:

    // Any dependencies these libraries have upon other libraries
    // For example, many libraries depend upon the 'Core' library to be built before
    // themselves, so that primitive types such as 'Integer' and 'Real' exist
    Array<StaticLibrary*> Dependencies;

  private:

    // The name of the library
    String Name;

    // Tells us whether or not we built this library
    BuildState::Enum Build;

    // The library builder we use to create the static library
    LibraryBuilder* Builder;

    // The built library (only built after all the static classes get added to it)
    LibraryRef Library;
  };

  // Create a static library that we can use in C++ binding
  // Use this in a header (preferrably in a namespace)
  // After specifying the name, you can pass in a variable number of
  // ZilchDependency(Namespace::OtherLibrary) to mark dependencies
  // upon other static libraries
  // All libraries declared with this macro implicitly add a dependency on Core
  #define ZilchDeclareStaticLibrary(Name, ...)                    \
    class Name : public Zilch::StaticLibrary                      \
    {                                                             \
    public:                                                       \
      Name() :                                                    \
        Zilch::StaticLibrary(#Name)                               \
      {                                                           \
        ZilchDependency(Zilch::Core)                              \
        __VA_ARGS__                                               \
      }                                                           \
      static Name& GetInstance()                                  \
      {                                                           \
        static Name instance;                                     \
        return instance;                                          \
      }                                                           \
      static Zilch::LibraryRef GetLibrary()                       \
      {                                                           \
        return GetInstance().StaticLibrary::GetLibrary();         \
      }                                                           \
      static Zilch::LibraryBuilder* GetBuilder()                  \
      {                                                           \
        return GetInstance().StaticLibrary::GetBuilder();         \
      }                                                           \
      void SetupBinding(Zilch::LibraryBuilder& builder) override; \
    }
  
  // This allows us to define an initialize all the types that belong within our library
  // This should be put in a translational unit (cpp) that can see all of the types that need to be registered
  // We opted for this instead of automatic or pre-main initialization because there were issues on some compilers
  // that would optimize out pre-main code if it was never referenced anywhere (but would otherwise be available to script)
  #define ZilchDefineStaticLibrary(Name) void Name::SetupBinding(Zilch::LibraryBuilder& builder)

  // Used in declaring dependencies upon other static libraries
  #define ZilchDependency(Library) this->Dependencies.push_back(&Library::GetInstance());
}

// End header protection
#endif


namespace Zilch
{
  // What scalar types are used for vectors
  DeclareEnum3(VectorScalarTypes, Real, Integer, Boolean);

  // The core of Zilch contains all types that the compiler uses internally
  // The core also acts as a global database of all immutable and sharable types
  class ZeroShared Core : public StaticLibrary
  {
  public:
    // Friends
    friend class CodeGenerator;
    friend class Syntaxer;
    friend class CoreLibraries;
    friend class Type;

    // Grab the singleton instance of the type database
    static Core& GetInstance();

    // Store pointers to the basic data-types
    BoundType* ByteType;
    BoundType* BooleanType;
    BoundType* Boolean2Type;
    BoundType* Boolean3Type;
    BoundType* Boolean4Type;
    BoundType* IntegerType;
    BoundType* Integer2Type;
    BoundType* Integer3Type;
    BoundType* Integer4Type;
    BoundType* RealType;
    BoundType* Real2Type;
    BoundType* Real3Type;
    BoundType* Real4Type;
    BoundType* QuaternionType;
    BoundType* DoubleIntegerType;
    BoundType* DoubleRealType;
    BoundType* StringType;
    BoundType* StringRangeType;
    BoundType* ExceptionType;
    BoundType* MathType;

    // Void is a special type that can actually be declared, but is typically used for specifying no return type
    BoundType* VoidType;

    // The null type is the type that the constant 'null' has before implicit conversion
    BoundType* NullType;

    // This is used when types cannot be resolved (it should never show up in code generation)
    // Using this type helps to prevent crashes, which is useful for more tolerant cases like code-completion
    BoundType* ErrorType;

    // The overloaded methods type is akin to the ErrorType and is only used when we encounter method overloads
    // Typically this type is replaced by another type, however in the event that overloads are not resolved
    // this will be the final resulting type (an entirely useless type that should probably be an error to store)
    BoundType* OverloadedMethodsType;

    // A special array of vector types
    // Useful for when we're using an index
    static const size_t MaxComponents = 4;
    BoundType* RealTypes    [MaxComponents];
    BoundType* IntegerTypes [MaxComponents];
    BoundType* BooleanTypes [MaxComponents];
    // Note: AllRealTypes and AllIntegerTypes are currently expected to have a 1-1 mapping in the same
    // order (so a function that takes a real2 can return an int2)
    Array<BoundType*> AllRealTypes;
    Array<BoundType*> AllIntegerTypes;
    Array<BoundType*> AllBooleanTypes;

    BoundType* VectorScalarBoundTypes[VectorScalarTypes::Size];
    // To perform generic axis functions we need to know how to set a value for a given type to 1
    typedef void (*ScalarTypeOneFunction)(byte* outData);
    ScalarTypeOneFunction ScalarTypeOneFunctions[VectorScalarTypes::Size];
    // An array of types to vectors (so VectorScalarTypes::Integer to an array of IntegerTypes)
    BoundType** VectorTypes[VectorScalarTypes::Size];

    // Special array of what matrix types to make (real, int, etc...)
    static const size_t MinMatrixComponents = 2;
    static const size_t MaxMatrixComponents = 4;
    static const size_t MaxMatrixElementTypes = 3;
    BoundType* MatrixElementTypes[MaxMatrixElementTypes];
    // To perform certain generic matrix operations generically,
    // MultiplyAdd functions (a += b * c) are needed
    typedef void (*MatrixMultiplyAddFunction)(byte* outData, byte* inputA, byte* inputB);
    MatrixMultiplyAddFunction TypeMultiplyAddFunctions[MaxMatrixElementTypes];

    // A very special type that allows us to take a delegate of any type
    // This can currently not be declared in language, but can be used from C++
    DelegateType* AnyDelegateType;

    // A very special type that allows us to take a handle of any type
    // This can currently not be declared in language, but can be used from C++
    BoundType* AnyHandleType;

    // A type that can be set to anything (delegates, value types, reference types, etc)
    AnyType* AnythingType;

  protected:

    // Setup the binding for the core library
    void SetupBinding(LibraryBuilder& builder) override;

  private:

    // Instantiates a hash-map template when requested
    static BoundType* InstantiateHashMap
    (
      LibraryBuilder& builder,
      StringParam baseName,
      StringParam fullyQualifiedName,
      const Array<Type*>& templateTypes,
      const void* userData
    );

    // Instantiates a hash-map range template when requested
    static BoundType* InstantiateHashMapRange
    (
      LibraryBuilder& builder,
      StringParam baseName,
      StringParam fullyQualifiedName,
      const Array<Type*>& templateTypes,
      const void* userData
    );

    // Instantiates a pair template when requested
    static BoundType* InstantiateKeyValue
    (
      LibraryBuilder& builder,
      StringParam baseName,
      StringParam fullyQualifiedName,
      const Array<Type*>& templateTypes,
      const void* userData
    );

    // Instantiates a property delegate template when requested
    static BoundType* InstantiatePropertyDelegate
    (
      LibraryBuilder& builder,
      StringParam baseName,
      StringParam fullyQualifiedName,
      const Array<Type*>& templateTypes,
      const void* userData
    );

    // Privatized constructor (it's a singleton)
    Core();

    // Destructor
    ~Core();

    // Not copyable
    ZilchNoCopy(Core);
  };

  // A single entry in a stack trace
  class StackEntry
  {
  public:
    // Constructor
    StackEntry();

    // A file / line location of where we are in the stack
    CodeLocation Location;

    // The function we're currently on
    Function* ExecutingFunction;
  };

  // Contains all the locations that we're at in an execution of Zilch
  class StackTrace
  {
  public:
    // Get the most recent non-native call (for debugging and visualization)
    // or return null if the entire stack is native or empty
    // Typically when an exception occurs (or any place a stack trace happens) you will
    // want to use this to point the user at the location where the error occurred in their code
    StackEntry* GetMostRecentNonNativeStackEntry();

    // Get the relevant location that the exception occurred (where should show the user)
    // This will invoke the above 'GetMostRecentNonNativeStackEntry' function, and if it
    // returns null it will return an empty location
    CodeLocation GetMostRecentNonNativeLocation();

    // Get the standard formatting for stack traces (used by exception printing too)
    String GetFormattedMessage(MessageFormat::Enum format);
    
    // The code locations of the entire stack and what functions were called
    // We have to use a special allocator here that supports being memset to zero
    // (because exceptions are just memset to 0, no constructor called)
    Array<StackEntry, Zero::MemsetZeroDefaultAllocator> Stack;
  };

  // The base class of any exception that gets thrown
  class ZeroShared Exception
  {
  public:
    ZilchDeclareBaseType(Exception, TypeCopyMode::ReferenceType);

    // Default constructor
    Exception();

    // Construct an exception with a message
    Exception(StringParam message);

    // Get the standard formatting for error messages
    String GetFormattedMessage(MessageFormat::Enum format);

    // The error that occurred as a human readable string, including technical details
    String Message;

    // The code locations of the entire stack and what functions were called
    StackTrace Trace;
  };

  // A property delegate contains both the get and set delegates
  // Technically we store the handle twice, which could be compacted because
  // we know that the 'this' handle will always be the same among both
  class PropertyDelegateTemplate
  {
  public:
    // The property getter and setters
    Delegate Get;
    Delegate Set;
  };

  // Bind the StringBuilder class
  ZilchDeclareExternalBaseType(StringBuilder, TypeCopyMode::ReferenceType);

  // Functions for converting our primitives to strings
  String BooleanToString(Boolean value);
  String Boolean2ToString(Boolean2Param value);
  String Boolean3ToString(Boolean3Param value);
  String Boolean4ToString(Boolean4Param value);
  String ByteToString(Byte value);
  String IntegerToString(Integer value);
  String Integer2ToString(Integer2Param value);
  String Integer3ToString(Integer3Param value);
  String Integer4ToString(Integer4Param value);
  String RealToString(Real value);
  String Real2ToString(Real2Param value);
  String Real3ToString(Real3Param value);
  String Real4ToString(Real4Param value);
  String QuaternionToString(QuaternionParam value);
  String DoubleIntegerToString(DoubleInteger value);
  String DoubleRealToString(DoubleReal value);
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_HANDLE_MANAGER_HPP
#define ZILCH_HANDLE_MANAGER_HPP

// Includes


namespace Zilch
{
  // A function we use to create the handle managers by index
  typedef HandleManager* (*CreateHandleManagerFn)(ExecutableState* state);

  // Generates handle manager creator functions
  template <typename T>
  HandleManager* HandleManagerCreator(ExecutableState* state)
  {
    return new T(state);
  }

  // This holds any shared handle manager memory
  class HandleManagers
  {
  public:
    // Get the singleton instance
    static HandleManagers& GetInstance();

    // Constructor
    HandleManagers();

    // Destructor
    ~HandleManagers();

    // Add a shared handle manager
    void AddSharedManager(HandleManagerId index, HandleManager* manager);

    // Add a unique creator function
    void AddUniqueCreator(HandleManagerId index, CreateHandleManagerFn creator);

    // Get a shared handle manager
    HandleManager* GetSharedManager(HandleManagerId index);

    // Get a unique creator function
    CreateHandleManagerFn GetUniqueCreator(HandleManagerId index);

    // Get the next available id in the handle manager
    HandleManagerId GetNextId();

    // Lock it so we cannot add anymore handle managers
    void Lock();

  private:
    // All the shared handle managers, by index
    HashMap<size_t, HandleManager*> Shared;

    // For unqiue handle managers, this maps the index to a function that will create them
    HashMap<size_t, CreateHandleManagerFn> Unique;

    // Counter for assigning handle manager indices
    HandleManagerId UniqueCounter;

    // We consider this locked once we create ZilchSetup
    bool Locked;
  };

  template <typename T>
  class HandleManagerGuid
  {
  public:
    // The index into the executable state that this manager gets
    // This index is also used to uniquely identify the manager
    static const HandleManagerId Id;
  };

  // Auto-increment the handle manager index as we register more managers
  template <typename T>
  const HandleManagerId HandleManagerGuid<T>::Id = HandleManagers::GetInstance().GetNextId();

  // Get the id of a handle manager
  #define ZilchManagerId(Type) Zilch::HandleManagerGuid<Type>::Id

  // Creates and registers a shared handle manager
  // Any extra arguments will be given to the constructor of your type
  // Shared handle managers MUST be implemented in a thread safe fashion
  #define ZilchRegisterSharedHandleManager(Type)  \
    Zilch::HandleManagers::GetInstance().AddSharedManager(ZilchManagerId(Type), new Type(nullptr))

  // Registers a unqiue (per ExecutableState) handle manager
  // The types registered are expected to have a default constructor
  #define ZilchRegisterUniqueHandleManager(Type)  \
    Zilch::HandleManagers::GetInstance().AddUniqueCreator(ZilchManagerId(Type), Zilch::HandleManagerCreator<Type>)
  
  // The result we get back from releasing a reference to a handle object
  namespace ReleaseResult
  {
    enum Enum
    {
      // Zilch will invoke the destructors and call delete on the object
      DeleteObject,

      // The object is still being referenced and must be kept alive
      KeepAlive,

      // Tells Zilch not to worry about the lifetime of the object
      // This should be used when the object reference was already deleted
      Ignore
    };
  }

  // An interface that users must implement for their own handle types
  // Common handle types are slot map handles (index into a table with unique id)
  // Other types include refrence counted objects, or even garbage collected objects
  // Note that objects allocated within the language are managed by the language
  class ZeroShared HandleManager
  {
  public:

    // Constructor
    // The state will be null in the case that this is a shared handle manager
    HandleManager(ExecutableState* state);

    // Virtualize the destructor
    virtual ~HandleManager();

    // Get the name of the handle manager, only for debugging and exceptions
    virtual String GetName() = 0;

    // Allocate the type and initialize a handle to that allocated object
    // The custom flags can be used to pass in any information to the allocation scheme
    // For example, the HeapHandleManager uses the flags to specify whether the type should be reference counted or not
    // Note that the only portion of the handle the needs to be initialized is the Data field,
    // and that the handle will have been memory cleared to all 0 (the Type and Manager will be set externally)
    virtual void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) = 0;

    // Initializes a handle given a pointer to an object (generally used for Write / WriteRef in C++)
    // The 'object' is the same pointer that we would get back from Dereferencing the handle
    // Note that the only portion of the handle the needs to be initialized is the Data field,
    // and that the handle will have been memory cleared to all 0 (the Type and Manager will be set externally)
    virtual void ObjectToHandle(const byte* object, Handle& handleToInitialize) = 0;

    // Dereference the user-data stored on the handle and
    // turn it into an instance pointer to the user's object
    // Return a null pointer if the object handle is null
    virtual byte* HandleToObject(const Handle& handle) = 0;

    // Delete all references to stored objects (if we have any allocated)
    // This is called while the ExecutableState is being torn down, before we destruct all static memory
    // Shortly after this is called on all HandleManagers owned by that ExecutableState, the manager will be destructed
    // In general if Allocate is implemented to do anything, then this should be overridden
    // Leaks should be reported to the executable state via the MemoryLeak event
    virtual void DeleteAll(ExecutableState* state);

    // Retrieve the hash value of a given handle (generally just the pointer value or some unqiue value)
    // This is generally used to compare handles when added to hashable containers
    // All null handles should return 0
    virtual int Hash(const Handle& handle);
    
    // Add a reference to the object
    // The default behavior is to do nothing (assumes the object is a global and never dies)
    virtual void AddReference(const Handle& handle);

    // Releases the reference to the object and must return the current reference count
    // This function MUST NOT actually destroy the object
    // Instead, it should return either 'KeepAlive' to do nothing, or 'DeleteObject' to tell
    // Zilch to run the destructor chain (it will also call your 'Delete' function afterward)
    virtual ReleaseResult::Enum ReleaseReference(const Handle& handle);

    // Destroys the object and frees its memory
    // Deleting the object should always try and ensure that all references to it become null
    // This will only ever be called if CanDelete return true
    // Prior to deleteing we always check for null, so you do not need to test for null here
    virtual void Delete(const Handle& handle);

    // Returns true if the object is deletable, false otherwise
    // Note that returning false will cause a 'non-deleteable object' exception in the language
    // The default behavior is to return false (assumes the object can never be explicitly deleted)
    virtual bool CanDelete(const Handle& handle);

    // Set/Get that this type has been fully constructed (including any native base classes)
    // This happens only when types are either native or derive from a native type
    virtual void SetNativeTypeFullyConstructed(const Handle& handle, bool value);
    virtual bool GetNativeTypeFullyConstructed(const Handle& handle);

    // Compare two handles with each other; return true if they are equal, false otherwise
    // The default behavior is to compare the dereferenced pointers
    // Since this check is only done after the handles have already been deferenced,
    // we also pass in the dereferenced byte pointers we received
    virtual bool IsEqual
    (
      const Handle& handleLhs,
      const Handle& handleRhs,
      const byte* objectLhs,
      const byte* objectRhs
    );

  public:

    // The executable state (only used in the case that we're not shared)
    ExecutableState* const State;

    // Handle managers are non-copyable
    ZilchNoCopy(HandleManager);
  };
  
  // Flags passed into the heap Allocate function
  namespace HeapFlags
  {
    enum Enum
    {
      // Allocates a regular reference counted object (default)
      ReferenceCounted = 0,

      // Allocates a non-reference counted object, however supports safe handle behavior
      NonReferenceCounted
    };
  }
  
  // This MUST align exactly with the HeapFlags (it gets initialized to whatever the user passes in)
  namespace HeapObjectFlags
  {
    enum Enum
    {
      // A regular reference counted object (default)
      None = 0,

      // A non-reference counted object, however supports safe handle behavior
      NonReferenceCounted = 1,

      // Whether or not we completed the entire base class constructor chain
      // For example, if we throw an exception before fully initializing our base class, and our base class is native C++
      // and has a virutal table, then it would be VERY bad to invoke the C++ destructor if we're not fully constructed
      NativeFullyConstructed = 2
    };
  }
  
  // The object slot is basically just a pointer to the object with a free list
  class ObjectSlot
  {
  public:
    byte*                 Data;
    Uid                   UniqueId;
    unsigned              ReferenceCount;
    HeapObjectFlags::Enum Flags;
    ObjectSlot*           NextFreeSlot;
  };

  // The structure of our heap handle's inner data
  class HeapHandleData
  {
  public:
    Uid           UniqueId;
    ObjectSlot*   Slot;
  };
  ZilchStaticAssert(sizeof(HeapHandleData) <= HandleUserDataSize,
    "The HeapHandleData class must fit within Handle::Data (make handle Data bigger)",
    HeapHandleDataMustFitWithinHandleData);

  // The header exists at the beginning of the allocated object (the Data pointer on ObjectSlot)
  class ObjectHeader
  {
  public:
    ObjectSlot* Slot;
    BoundType*  Type;
  };

  // This manages heap objects allocated in the language (including references to heap members via offset)
  class ZeroShared HeapManager : public HandleManager
  {
  public:

    // HandleManager interface
    HeapManager(ExecutableState* state);
    String GetName() override;
    void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) override;
    byte* HandleToObject(const Handle& handle) override;
    void ObjectToHandle(const byte* object, Handle& handleToInitialize) override;
    void DeleteAll(ExecutableState* state) override;
    void Delete(const Handle& handle) override;
    bool CanDelete(const Handle& handle) override;
    void AddReference(const Handle& handle) override;
    ReleaseResult::Enum ReleaseReference(const Handle& handle) override;
    void SetNativeTypeFullyConstructed(const Handle& handle, bool value) override;
    bool GetNativeTypeFullyConstructed(const Handle& handle) override;

    // All the slots act as places to hold objects
    Array<ObjectSlot> Objects;

    // The next free object slot available to us
    ObjectSlot* NextFreeSlot;

    // Store statistics for how many objects we have allocated
    size_t ObjectCount;

    // A unique ID counter (so we can assign objects unique IDs...)
    Uid UidCount;
  };

  // The structure of our stack handle's inner data
  class StackHandleData
  {
  public:
    Uid           UniqueId;
    PerScopeData* Scope;
    byte*         StackLocation;
  };
  ZilchStaticAssert(sizeof(StackHandleData) <= HandleUserDataSize,
    "The StackHandleData class must fit within Handle::Data (make handle Data bigger)",
    StackHandleDataMustFitWithinHandleData);

  // This manages stack objects initialized in the language (including references to stack members via offset)
  class ZeroShared StackManager : public HandleManager
  {
  public:
    // HandleManager interface
    StackManager(ExecutableState* state);
    String GetName() override;
    void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) override;
    byte* HandleToObject(const Handle& handle) override;
    void ObjectToHandle(const byte* object, Handle& handleToInitialize) override;
  };

  // This manages insertion of pointers into the language, which are assumed to be global
  class ZeroShared PointerManager : public HandleManager
  {
  public:
    // HandleManager interface
    PointerManager(ExecutableState* state);
    String GetName() override;
    void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) override;
    byte* HandleToObject(const Handle& handle) override;
    void ObjectToHandle(const byte* object, Handle& handleToInitialize) override;
  };

  // This manages string nodes for the string class, which is always a reference type
  class ZeroShared StringManager : public HandleManager
  {
  public:
    // HandleManager interface
    StringManager(ExecutableState* state);
    String GetName() override;
    int Hash(const Handle& handle) override;
    void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) override;
    byte* HandleToObject(const Handle& handle) override;
    void ObjectToHandle(const byte* object, Handle& handleToInitialize) override;
    void AddReference(const Handle& handle) override;
    ReleaseResult::Enum ReleaseReference(const Handle& handle) override;
    bool IsEqual
    (
      const Handle& handleLhs,
      const Handle& handleRhs,
      const byte* objectLhs,
      const byte* objectRhs
    ) override;
  };
  ZilchStaticAssert(sizeof(String) <= HandleUserDataSize,
    "The String class must fit within Handle::Data (make handle Data bigger)",
    StringMustFitWithinHandleData);
}

// End header protection
#endif


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TIMER_HPP
#define ZILCH_TIMER_HPP

// Includes

namespace Zilch
{
  // The timer maintains a precision of at around 1ms and attempts to deal with wrap around
  class ZeroShared Timer
  {
  public:
    // Constructor
    Timer();

    // The ticks that make up a second
    static const long long TicksPerSecond;

    // Updates the timer and returns its time
    long long GetAndUpdateTicks();

    // Resets the ticks that have been counted
    void Reset();

  private:

    // We keep our own tick count which is actually in the same
    // measurement as clock_t, but deals with wrap around
    long long TotalTicks;

    // Store the last sample we did to the clock
    long long LastClock;
  };
}

// End header protection
#endif


namespace Zilch
{
  namespace Events
  {
    // Sent on ExecutableState when a fatal error occurs, such as
    // out of memory, stack overflow inside another overflow, etc
    // The program will be immediately aborted after this event is run
    ZilchDeclareEvent(FatalError, FatalErrorEvent);

    // Sent on ExecutableState when an exception occurs and isn't handled (can be user thrown, etc)
    ZilchDeclareEvent(UnhandledException, ExceptionEvent);

    // Sent on ExecutableState when an exception occurs and is caught by the user
    ZilchDeclareEvent(HandledException, ExceptionEvent);

    // Debugger and profiler events
    ZilchDeclareEvent(OpcodePreStep, OpcodeEvent);
    ZilchDeclareEvent(OpcodePostStep, OpcodeEvent);
    ZilchDeclareEvent(EnterFunction, OpcodeEvent);
    ZilchDeclareEvent(ExitFunction, OpcodeEvent);

    // Whenever an scripted object is leaked, it is reported when the executable state is torn down
    ZilchDeclareEvent(MemoryLeak, MemoryLeakEvent);
  }

  // Used when an object leaks when an executable state is torn down
  // Members may be null depending on the type of leak (always check for null)
  class MemoryLeakEvent : public EventData
  {
  public:
    MemoryLeakEvent();
    ExecutableState* State;
    Handle* LeakedObject;
    CodeLocation* AllocatedLocation;
  };

  // An event intended for debuggers and profilers (used when we enter/exit functions and step opcodes)
  class OpcodeEvent : public EventData
  {
  public:
    OpcodeEvent();
    ExecutableState* State;
    Function* CurrentFunction;
    size_t ProgramCounter;
    size_t StackOffset;
    CodeLocation* Location;
  };

  // An event sent out when an exception occurs
  class ExceptionEvent : public EventData
  {
  public:
    ExceptionEvent();
    ExecutableState* State;
    Exception* ThrownException;
  };
  
  // The types of fatal errors that can occur inside of Zilch (non recoverable errors)
  namespace FatalError
  {
    enum Enum
    {
      Invalid,
      OutOfMemory,
      StackReserveOverflow
    };
  }
  
  // The event sent out when a fatal error occurs
  class FatalErrorEvent : public EventData
  {
  public:
    FatalErrorEvent();
    FatalError::Enum ErrorCode; 
  };

  // Two constants we use to note the state of our debug program counter pointer
  const size_t ProgramCounterNotActive = (size_t)-1;
  const size_t ProgramCounterNative = (size_t)-2;

  // The data that exists per scope (per stack frame)
  // Every function has an implicit scope
  class PerScopeData
  {
  public:
    // Invoke the destructors of anything we need to cleanup
    // and clear out the arrays for recycling
    void PerformCleanup();

    // Handles on the stack that need to be cleaned up
    // This includes 'this' handles inside delegates, any handles that get copied to the stack,
    // and or any handles that are created (such as via local/new, or stack/member handles)
    Array<Any*> AnysToBeCleaned;
    Array<Handle*> HandlesToBeCleaned;
    Array<Delegate*> DelegatesToBeCleaned;

    // A special unique id we use to specify keep track of stack handles
    Uid UniqueId;
  };

  // Debug flags that we use for making and receiving calls
  namespace CallDebug
  {
    enum Enum
    {
      None                      = 0,
      SetParameter0             = 1 << 0,
      SetParameter1             = 1 << 1,
      SetParameter2             = 1 << 2,
      SetParameter3             = 1 << 3,
      SetParameter4             = 1 << 4,
      SetParameter5             = 1 << 5,
      SetParameter6             = 1 << 6,
      SetParameter7             = 1 << 7,
      SetParameter8             = 1 << 8,
      SetParameter9             = 1 << 9,
      SetParameter10            = 1 << 10,
      SetParameter11            = 1 << 11,
      SetParameter12            = 1 << 12,
      SetParameter13            = 1 << 13,
      SetParameter14            = 1 << 14,
      SetParameter15            = 1 << 15,
      SetParameter16            = 1 << 16,
      SetParameter17            = 1 << 17,
      SetParameter18            = 1 << 18,
      SetParameter19            = 1 << 19,
      SetParameter20            = 1 << 20,
      SetParameter21            = 1 << 21,
      SetReturn                 = 1 << 22,
      SetThis                   = 1 << 23,
      Invoked                   = 1 << 24,
      NoReturnChecking          = 1 << 25,
      NoReturnDestruction       = 1 << 26,
      NoParameterChecking       = 1 << 27,
      NoParameterDestruction    = 1 << 28,
      NoThisChecking            = 1 << 29,
      NoThisDestruction         = 1 << 30
    };
  }

  // The state of a stack frame
  namespace StackErrorState
  {
    enum Enum
    {
      Normal,
      Overflowed,
      MaxRecursionReached
    };
  }

  // The data that exists per stack frame
  class PerFrameData
  {
  public:
    // Constructor
    PerFrameData(ExecutableState* state);

    // Adds an 'any type' that needs cleanup
    void QueueAnyCleanup(Any* any);

    // Adds a handle that needs cleanup
    void QueueHandleCleanup(Handle* handle);

    // Adds a delegate that needs cleanup
    void QueueDelegateCleanup(Delegate* delegate);

    // If the stack overflowed or we reached the max recursion depth,
    // this will throw an exception and return true
    // Otherwise this will return false if no exception was thrown
    bool AttemptThrowStackExceptions(ExceptionReport& report);

    // Checks if a variable is initialized within the current frame
    // Note: This is only intended to be used by a debugger, and may be incorrect for value types
    bool IsVariableInitialized(Variable* variable);

    // For the current stack frame, this is where all the data lies
    byte* Frame;
    byte* NextFrame;

    // We need a pointer back to the state to do certain operations
    ExecutableState* State;

    // The active program counter for this call stack
    // By default, this is set to 'ProgramCounterNotActive' which indicates it should not be used
    // For C++ bound functions, this is 'ProgramCounterNative' which means it is active but more information is needed
    size_t ProgramCounter;

    // The current function that is being executed
    Function* CurrentFunction;

    // Any per scope data (this data is generally 'things to be destructed')
    // This is also used to destruct things when exceptions are thrown
    Array<PerScopeData*> Scopes;

    // Used for debugging (we can't invoke a function until all parameters are written)
    CallDebug::Enum Debug;

    // Where we report exceptions to
    // This is only set when actually entering the call, not when the frame is created
    ExceptionReport* Report;

    // When we're inside the VM, this is the location that we jump to if an exception occurs
    // This is only set when actually inside the VM's 'ExecuteNext' function
    jmp_buf ExceptionJump;

    // The number of timeouts we have associated with this stack frame
    // When this frame gets destroyed/unrolled, we need to pop these timeouts
    size_t Timeouts;

    // The frame itself could have been created past the recursion depth or in an overflowed state
    StackErrorState::Enum ErrorState;
  };

  namespace CheckPrimitive
  {
    enum Enum
    {
      Handle,
      Value,
      Delegate,
      Any
    };
  }

  namespace Direction
  {
    enum Enum
    {
      Get,
      Set
    };
  }

  // Describes where an operand is pointing to =
  // (a location on the stack, or an object, etc)
  class OperandLocation
  {
  public:
    // Constructor
    OperandLocation();

    // The type will either be set to Member, Constant, or Local
    OperandType::Enum Type;

    // If the operand is a Member, then this is a pointer to the base of
    // the object where the member exists. If the operand is a Constant,
    // this points at the base of the constant buffer for the current function.
    // If the operand is a Local, then this is a pointer to the stack.
    const char* Memory;

    // The size of the memory. In the case of the Member, this is the size
    // of the object. In the case of the Constant, this is the size of the
    // constant buffer. In the case of the Local, this is the size of the stack
    size_t MemorySize;

    // The offset into the memory where the Member, Constant, or Local exists
    size_t Offset;
  };

  // Tells us when a function or timeout scope started, and how
  // long it has until it exceeds its time and throws an exception
  class ZeroShared Timeout
  {
  public:
    // Constructor
    Timeout();

    // The length of the timeout in ticks (once the accumulation reaches this we throw an exception)
    // We also use this to print a meaningful exception message
    long long LengthTicks;

    // Stores the amount of ticks accumulated under this timeout (based on the Timer class)
    // Every timeout is exclusive, which means while a timeout is active it's parents DO NOT accumulate time
    long long AccumulatedTicks;

#if _DEBUG
    // Only used to verify that the correct frame that pushed us is the only one to pop us
    PerFrameData* Frame;
#endif
  };

  // With any function call, an exception can occur that we need to catch
  class ZeroShared ExceptionReport
  {
  public:
    // Friends
    friend class ExecutableState;

    // Constructor
    ExceptionReport();

    // Clear the exception report (will allow code to continue with execution)
    void Clear();

    // Tests if any exceptions were thrown
    bool HasThrownExceptions();

    // Gets all the exceptions concatenated in a list
    String GetConcatenatedMessages();
    
    // The exceptions that are being thrown (as we unravel the stack)
    Array<Handle> Exceptions;

    // In the event that an exception could not be allocated (or other fringe reasons)
    // we must set this flag (which forces 'HasThrownExceptions' to return true, even when Exceptions is empty)
    bool ForceThrownExceptions;

  private:
    // An array of exception pointers, only for debugging purposes
    Array<Exception*> ExceptionsForDebugOnly;
  };

  // A callback that prints to stderr whenever an exception occurs
  void DefaultExceptionCallback(ExceptionEvent* e);

  // Stores the generated functions, and anything else needed for a VM to execute
  class ZeroShared ExecutableState : public EventHandler
  {
  public:
    ZilchDeclareBaseType(ExecutableState, TypeCopyMode::ReferenceType);

    // Friends
    friend class VirtualMachine;
    friend class Module;
    friend class Handle;
    friend class CodeGenerator;
    friend class HeapManager;
    friend class StackManager;
    friend class Call;
    friend class PerFrameData;
    friend class Debugger;

    // Because users often need to access the state in their own bound functions, we provide a thread local
    // that is the last running state (set before each call to Zilch, and reset to the previous after the call)
    static ExecutableState* CallingState;
    static ExecutableState* GetCallingState();

    // Constructor
    ExecutableState();

    // Destructor
    ~ExecutableState();
    
    // Patch a library that already exists on the same state (by name)
    // The executable state must not be running inside any code (no stack frame) and currently
    // the library must have no other libraries that depend upon it (a leaf library)
    void PatchLibrary(LibraryRef newLibrary);

    // Set the timeout for this state in seconds (equivalent of a timeout statement in language)
    // Any code that runs for longer than this amount of time will throw an exception saying
    // that it timed out. This is mainly used to prevent user code from infinite looping/recursing
    // This can only be set while we're not inside a call-stack
    // A value of 0 seconds will clear the timeout
    void SetTimeout(size_t seconds);

    // Checks if we are currently inside a call stack
    bool IsInCallStack();

    // Allocates an object on the stack at the given stack
    // position and returns a stack handle to the object
    // Note that the handle will become null when we leave the scope
    // that the object was allocated in (return from a function, etc)
    Handle AllocateStackObject(byte* stackLocation, PerScopeData* scope, BoundType* type, ExceptionReport& report);

    // Allocates an object on the heap at the given stack
    // position and returns a heap handle to the object
    // Note that the memory will be managed by the language itself
    Handle AllocateHeapObject(BoundType* type, ExceptionReport& report, HeapFlags::Enum flags);

    // Allocates an object on the heap at the given stack
    // position and returns a heap handle to the object
    // Note that the memory will be managed by the language itself
    Handle AllocateDefaultConstructedHeapObject(BoundType* type, ExceptionReport& report, HeapFlags::Enum flags);

    // Get a pointer to the current stack for the current function
    // If the function has a return value, then it is the first value on the stack
    // After the return value comes the parameters, in tightly packed order
    // If the function is an instance method, then the last value is the 'this' handle,
    // whose type is actually 'Handle'; handles can be dereferenced to get a
    // direct pointer to the object
    // Only ever read up to the size of your return, parameters, and this handle
    byte* GetCurrentStackFrame();

    // Executes a statement or expression and returns the result
    // The dependent libraries are assumed to be the same libraries as the state compiled with (not including patches)
    // If the statement fails to compile, it will return a string that is the compilation error
    // If the statement results in an exception, this will return the a string with all the exceptions concatenated
    // This uses the 'patch library' logic to append a patch to the running state
    Any ExecuteStatement(StringParam code);

    // Throws a standard null reference exception
    void ThrowNullReferenceException(ExceptionReport& report);

    // Throws a standard null reference exception with a custom message
    void ThrowNullReferenceException(ExceptionReport& report, StringParam customMessage);

    // If a function is not implemented, this is a standard exception that lets the user know
    void ThrowNotImplementedException();

    // Throws a standard exception with the given message using the ExceptionReport from the latest stack frame
    void ThrowException(StringParam message);

    // Throws a standard exception with the given message
    void ThrowException(ExceptionReport& report, StringParam message);

    // Throws an exception allocated by the user
    void ThrowException(ExceptionReport& report, Handle& exception);

    // Ensures that a scope does not exceed a time limit (throws an exception if it does)
    // This should be periodically called in native C++ code for proper timeout protection
    // Returns true if we threw a timeout exception, false otherwise
    bool ThrowExceptionOnTimeout(ExceptionReport& report);

    // Gets the latest exception report via the thread local 'CallingState'
    static ExceptionReport& GetCallingReport();

    // Build a stack trace into the stack array
    void GetStackTrace(StackTrace& trace);

    // Gets a handle manager by type
    template <typename T>
    T* GetHandleManager() const
    {
      return (T*)this->GetHandleManager(ZilchManagerId(T));
    }

    // Gets a handle manager by id
    HandleManager* GetHandleManager(HandleManagerId id) const;

    // Update the virtual table of a native C++ object, or do nothing if it's not virtual or native
    void UpdateCppVirtualTable(byte* objectWithBaseVTable, BoundType* cppBaseType, BoundType* derivedType);

    // Get the raw stack array
    const byte* GetRawStack();

    // Get a static field from this state (must be a field in one of the dependent libraries)
    // If the field is not initialized, it will run the initializer code (user defined code)
    // to attempt to initialize the value, though it is first initialized to zero memory
    // An exception can be thrown from user code when attempting to initialize the field
    byte* GetStaticField(Field* field, ExceptionReport& report);

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructibleBuffer ComplexUserData;

  private:

    // Applies a patch, but skips some checks (used when we know patching a library is safe)
    void ForcePatchLibrary(LibraryRef newLibrary);

    // Gets a pointer to the next stack frame
    // If we're currently in a function, this represents the
    // position ahead of our current function. If we're not
    // in any functions, it should be the front of the stack
    // Always call this BEFORE you push any frame data
    byte* GetNextStackFrame();

    // Push a new stack frame and returns the location on the stack
    ZilchForceInline PerFrameData* PushFrame(Function* function);

    // A slightly more optmial version of pushing a stack frame (used internally in execution)
    ZilchForceInline PerFrameData* PushFrame(byte* frame, Function* function);

    // Pops a stack frame and return a pointer to where the return value should be
    ZilchForceInline PerFrameData* PopFrame();

    // Initialize a handle to point at a location on the stack
    void InitializeStackHandle(Handle& handle, byte* location, PerScopeData* scope, BoundType* type);

    // Initialize a handle with a direct pointer value
    // Generally unsafe, but used in cases such as statics which are guaranteed to exist and therefore safe
    void InitializePointerHandle(Handle& handle, byte* location, BoundType* type);

    // Invokes the pre-constructor (which initializes memory) on a handle
    void InvokePreConstructorOrRelease(Handle& handle, ExceptionReport& report);

    // Allocates or recycles a scope
    PerScopeData* AllocateScope();

    // A timeout is a low level construct that allows us to ensure code does not run beyond a certain time
    // Timeouts do not work while calling native code (except upon native code's return)
    // This will push a timeout based on a given number of seconds
    // Returns true if we threw a timeout exception, false otherwise
    bool PushTimeout(PerFrameData* frame, size_t seconds);

    // Exits a timeout scope and validates that the timeout was not reached
    // Returns true if we threw a timeout exception, false otherwise
    bool PopTimeout(PerFrameData* frame);

    // Send an opcode event (generally used for debuggers or profilers)
    ZilchForceInline void SendOpcodeEvent(StringParam eventId, PerFrameData* frame);

  public:

    // Enables debug events (opcode step, enter/exit function, etc)
    bool EnableDebugEvents;
    
    // Maps old functions to the new functions they were patched with (only if any library was patched in the state)
    HashMap<Function*, Function*> PatchedFunctions;
    
    // Maps old types to the new types they were patched with (only if any library was patched in the state)
    HashMap<BoundType*, BoundType*> PatchedBoundTypes;

    // Libraries that we need to keep alive because we were patched using thier types and functions
    //HashMap<LibraryRef, LibraryRef> PatchedLibraries;
    Array<LibraryRef> PatchedLibraries;

    // An id that is guarnateed to start at 0 and counts up every time we are patched
    // This can be used to re-enable features after a patch occurs on the state (such as event handlers)
    size_t PatchId;

    // Externally set breakpoints will overwrite the instruction, so we remap the opcode's index
    // to its original instruction here (if a breakpoint gets uneset, we use this to write back the original instruction)
    HashMap<size_t, Instruction::Enum> ExternalBreakpoints;

    // Static variables are currently just looked up by thier pointer
    // If the static field memory does not exist, it will be created and zerod out
    // In the future, we'll also run the initializer upon the memory the first time it is accessed
    // We may reserve a header byte to know whether the memory has been fully initialized,
    // because accessing a field that has been created but not fully initialized means there is a cycle
    HashMap<Field*, byte*> StaticFieldToMemory;

    // We need a way to map virtual function ids into our function
    HashMap<GuidType, Function*> ThunksToFunctions;

    // The size of the stack
    const size_t StackSize;

    // Reserved space after the stack, this is only used when we reach a stack overflow
    const size_t OverflowStackSize;

    // If this reference count is greater than 0, then we do not allow allocation
    // This is true when running any destructors (destructors must not allocate objects, or call any functions that allocate)
    size_t DoNotAllowAllocation;

    // The maximum number of recursive calls we allow in this state
    size_t MaxRecursionDepth;

    // Used for debugging (the name will show up in the debugger, and so on)
    String Name;

    // We want to hold references to the libraries that we were compiled with
    Module Dependencies;

    // Pointers to our global handle managers
    HeapManager* HeapObjects;
    StackManager* StackObjects;
    PointerManager* PointerObjects;

    // All the virtual tables (of varying sizes) for each native type that has virtual methods bound
    HashMap<BoundType*, byte*> NativeVirtualTables;

    // The handle managers we use to derefence and setup handles
    mutable HashMap<HandleManagerId, HandleManager*> UniqueManagers;

    // Map code entry ids to the code entry itself (the entry will be alive as long as the library is alive)
    // This maintains a list of all code entries used by this state
    HashMap<size_t, CodeEntry*> CodeHashToCodeEntry;

    // Data that we need each time we jump into a new stack frame
    Array<PerFrameData*> StackFrames;
    
    // Every time we allocate a stack frame, we don't actually delete it, but rather put it into this free list of stack frames
    // These are destroyed along with the executable state
    OwnedArray<PerFrameData*> RecycledFrames;

    // Recycled for memory efficiency (see RecycledFrames)
    OwnedArray<PerScopeData*> RecycledScopes;
    
    // Every time we allocate a scope (even for saved versions) we give it a unique
    // id so that way references formed to stack variables can be correctly used
    // It is very important that the scopes be recycled, because handles continue to point at old scopes
    // We use 0 as a special value that means a scope is not valid (in the recycle list) so the counter starts at 1
    Uid UniqueIdScopeCounter;

    // This stack of string builders that we use for efficient concatenation of strings
    Array<StringBuilder> StringBuilders;

    // In the case where we have no globally set timeout, and we have no timeout statements,
    // this array will be empty. Otherwise if a timeout exists it will be checked by the
    // virtual machine
    // Note: Timeouts are closely related to stack frames, as they can only be pushed
    // or popped by the same stack frame
    Array<Timeout> Timeouts;

    // The timer we use to measure timeouts
    // Ideally this timer would have a high fidelity to prevent timing inaccuracies
    Timer TimeoutTimer;

    // The amount of time we require when executing a timeout
    // A value of 0 means that we don't perform any timeouts
    // This value is only used when we enter the first function on the call stack
    size_t TimeoutSeconds;

    // The stack data used by the executable state
    // This is the base of the stack, NOT the current stack
    // Note that the stack is of a fixed size, and should never be reallocted
    byte* Stack;

    // Once we hit a stack overflow we no longer have stack space to invoke anything
    // such as destructors, or constructing the exception itself! To fix this issue,
    // we use an extra reserve of space at the end of the stack, however it is only
    // valid to access that stack space when this flag is set
    // If a destructor then stack overflows while another stack overflow occurred,
    // we hit a fatal error
    bool HitStackOverflow;

    // Not copyable
    ZilchNoCopy(ExecutableState);
  };
  
  // Grab the next value from the stack frame
  // This will push the stack frame pointer forward
  // You can get the current stack frame by calling 'GetCurrentStackFrame'
  // See 'GetCurrentStackFrame' for the calling conventions
  template <typename T>
  T InternalReadValue(byte* stackFrame)
  {
    // Return the read in value and advance the stack forward by the value's size
    typedef typename TypeBinding::StaticTypeId<T>::ReadType ReadType;
    ReadType readValue = TypeBinding::StaticTypeId<T>::Read(stackFrame);
    return TypeBinding::ReferenceCast<ReadType, T>::Cast(readValue);
  }

  // Pushes a value onto the stack frame
  // This will push the stack frame pointer forward
  // You can get the current stack frame by calling 'GetCurrentStackFrame'
  // See 'GetCurrentStackFrame' for the calling conventions
  template <typename T>
  void InternalWriteValue(const T& value, byte* stackFrame)
  {
    // Write the value directly to the stack frame
    typedef typename TypeBinding::StaticTypeId<T>::UnqualifiedType& ToType;
    typedef typename TypeBinding::StripConst<T>::Type& FromType;
    ZilchStaticType(T)::Write(TypeBinding::ReferenceCast<FromType, ToType>::Cast((FromType)value), stackFrame);
  }

  // Grab the next reference type from the stack frame
  // This will push the stack frame pointer forward
  // You can get the current stack frame by calling 'GetCurrentStackFrame'
  // See 'GetCurrentStackFrame' for the calling conventions
  template <typename T>
  T InternalReadRef(byte* stackFrame)
  {
    // Read the handle that will point at the string from the stack
    Handle& handle = *(Handle*)stackFrame;

    // Read the data from the handle by dereferencing it
    byte* data = handle.Dereference();

    // Read the value from the handle data
    return InternalReadValue<T>(data);
  }

  template <typename T>
  void InternalWriteRef(const T& value, byte* stackFrame, const ExecutableState* state)
  {
    // Get the type we're trying to write
    BoundType* type = ZilchTypeId(T);

    // Grab the handle manager via the state
    HandleManager* manager = state->GetHandleManager(type->HandleManager);

    // Create a handle that goes with the given manager index
    Handle* handle = new (stackFrame) Handle();
    handle->Manager = manager;

    // If this is a redirected type...
    if (ZilchStaticType(T)::DirectRead)
    {
      // Get a raw pointer to the value (removes all const, reference, and other qualifiers)
      ZilchStrip(T)* pointerToValue = ZilchToPointer(value);
      handle->Type = ZilchVirtualTypeId(pointerToValue);

      // Setup the newly created handle
      manager->ObjectToHandle((const byte*)pointerToValue, *handle);
    }
    else
    {
      // Write the value to a temporary buffer
      size_t size = sizeof(typename ZilchStaticType(T)::RepresentedType);
      byte* data = (byte*)alloca(size);

      // This was a redirect, so just take the type of the redirect and put it on the handle
      handle->Type = type;

      // Convert the value to the redirected type within our temporary buffer
      InternalWriteValue<T>(value, data);

      // Setup the newly created handle
      manager->ObjectToHandle(data, *handle);

      // Invoke the destructor on the temporary memory
      typedef typename ZilchStaticType(T)::RepresentedType RepresentedType;
      ((RepresentedType*)data)->~RepresentedType();
    }
  }


  class ZeroShared Call
  {
  public:
    friend class ExecutableState;
    friend class VirtualMachine;

    // Constructor for calling a function
    Call(Function* function, ExecutableState* state);

    // Constructor for calling a delegate (automatically sets the this handle)
    Call(const Delegate& delegate, ExecutableState* state);

    // Destructor (constructor is private so only the ExecutableState can create it)
    ~Call();

    // All getters and setters below perform checks on the size and type (if possible)
    // These are special constants that represent the 'this' handle and return value
    static const size_t Return  = (size_t)-1;
    static const size_t This    = (size_t)-2;

    // Set either a parameter or return for the call (value types only, this not allowed)
    void SetValue(size_t index, const byte* input, size_t size);

    // Set either a parameter, return, or this handle for the call
    void SetHandle(size_t index, const Handle& value);

    // Set either a parameter or return for the call (this not allowed)
    void SetDelegate(size_t index, const Delegate& value);
    
    // Set either a parameter or return for the call (value types only, this not allowed)
    template <typename T>
    void SetValue(size_t index, const T& value)
    {
      // Get the stack location and perform checks
      byte* stack = this->GetChecked(index, sizeof(typename ZilchStaticType(T)::RepresentedType), ZilchTypeId(T), CheckPrimitive::Value, Direction::Set);

      // Finally, copy the input into the stack position
      InternalWriteValue<T>(value, stack);
    }
    
    // Set either a parameter, return, or this handle for the call (reference types only)
    template <typename T>
    void SetHandle(size_t index, const T& value)
    {
      // Get the stack location and perform checks
      byte* stack = this->GetChecked(index, sizeof(Handle), ZilchTypeId(T), CheckPrimitive::Handle, Direction::Set);

      // Finally, copy the input into the stack position
      InternalWriteRef<T>(value, stack, this->Data->State);
    }

    // Set either a parameter, return, or this handle for the call
    // This method auto determines whether it's reference or value type
    template <typename T>
    void Set(size_t index, const T& value)
    {
      // If the type is a reference type... (this is always a handle)
      if (ZilchStaticType(T)::CopyMode == TypeCopyMode::ReferenceType || index == Call::This)
      {
        this->SetHandle<T>(index, value);
      }
      // Otherwise it must be a value type...
      else
      {
        this->SetValue<T>(index, value);
      }
    }

    // Get either a parameter or return from the call (value types only, this not allowed)
    void GetValue(size_t index, byte* output, size_t size);
    
    // Get either a parameter, return, or this handle from the call
    Handle& GetHandle(size_t index);
    
    // Get either a parameter or return from the call (this not allowed)
    Delegate& GetDelegate(size_t index);

    // Get either a parameter or return from the call (value types only, this not allowed)
    template <typename T>
    T GetValue(size_t index)
    {
      // Get the stack location and perform checks
      byte* stack = this->GetChecked(index, sizeof(typename ZilchStaticType(T)::RepresentedType), ZilchTypeId(T), CheckPrimitive::Value, Direction::Get);
      
      // Read the value from the stack and return it (or convert it)
      return InternalReadValue<T>(stack);
    }
    
    // Get either a parameter, return, or this handle from the call (reference types only)
    template <typename T>
    T GetHandle(size_t index)
    {
      // Get the stack location and perform checks
      byte* stack = this->GetChecked(index, sizeof(Handle), ZilchTypeId(T), CheckPrimitive::Handle, Direction::Get);
      
      // Read the value from the stack and return it (or convert it)
      return InternalReadRef<T>(stack);
    }

    // Get either a parameter, return, or this handle from the call
    // This method auto determines whether it's reference or value type
    template <typename T>
    T Get(size_t index)
    {
      // If the type is a reference type... (this is always a handle)
      if (ZilchStaticType(T)::CopyMode == TypeCopyMode::ReferenceType || index == Call::This)
      {
        return this->GetHandle<T>(index);
      }
      // Otherwise it must be a value type...
      else
      {
        return this->GetValue<T>(index);
      }
    }
    
    // Invoke the function / call
    // All parameters must be set before invoking (and the 'this' if it's an instance method)
    void Invoke(ExceptionReport& report);

    // Get a reference to the executable state
    ExecutableState* GetState();

    // Get a raw pointer to the stack
    byte* GetStackUnchecked();
    
    // Get a raw pointer to the stack where the 'this' handle is placed
    byte* GetThisUnchecked();

    // Get a raw pointer to the stack where the parameters are placed
    byte* GetParametersUnchecked();

    // Get a raw pointer to the stack where a particular parameter is placed
    byte* GetParameterUnchecked(size_t parameterIndex);

    // Get a raw pointer to the stack where the return is placed
    byte* GetReturnUnchecked();
    
    // Get the function involved in the call
    Function* GetFunction();

    // Makes it so we ignore debug checking for parameters
    // Only set this flag if you plan on raw manipulating the stack
    // If raw manipulation is done, make sure you also clean up the stack manually
    void DisableParameterChecks();

    // Makes it so we ignore debug checking for the 'this' handle
    // Only set this flag if you plan on raw manipulating the stack
    // If raw manipulation is done, make sure you also clean up the stack manually
    void DisableThisChecks();
    
    // Makes it so we ignore debug checking for the return value
    // Only set this flag if you plan on raw manipulating the stack
    // If raw manipulation is done, make sure you also clean up the stack manually
    void DisableReturnChecks();

    // Disables the automatic destruction of parameters at the end of the call
    // Only disable this feature if you plan on manually cleaning up the stack
    void DisableParameterDestruction();
    
    // Disables the automatic destruction of the 'this' handle at the end of the call
    // Only disable this feature if you plan on manually cleaning up the stack
    void DisableThisDestruction();
    
    // Disables the automatic destruction of the return value at the end of the call
    // Only disable this feature if you plan on manually cleaning up the stack
    void DisableReturnDestruction();

    // Tells the debugging features that the parameter, return, or this handle was set
    // Only use this if you set the return via direct stack memory
    void MarkAsSet(size_t index);

    // Tells the debugging features that the return value was set
    // Only use this if you set the return via direct stack memory
    void MarkReturnAsSet();

    // Tells the debugging features that the 'this' handle was set
    // Only use this if you set the return via direct stack memory
    void MarkThisAsSet();

    // Tells the debugging features that the 'this' handle was set
    // Only use this if you set the return via direct stack memory
    void MarkParameterAsSet(size_t parameterIndex);

    // Get a generic stack location and do error checking
    byte* GetChecked(size_t index, size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io);

  private:
    
    // Run a set of checks on the given type / size
    void PerformStandardChecks(size_t size, Type* userType, Type* actualType, CheckPrimitive::Enum primitive, Direction::Enum io);

    // Get a stack location to the 'this' handle and do error checking
    byte* GetThisChecked(size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io);

    // Get a stack location to the return and do error checking
    byte* GetReturnChecked(size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io);

    // Get a stack location to the given parameter and do error checking
    byte* GetParameterChecked(size_t parameterIndex, size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io);

    // Constructor for the virtual machine call
    Call(PerFrameData* data);

    // Make sure we can't copy this around
    ZilchNoCopy(Call);

  private:

    // Every call corresponds with per frame data
    PerFrameData* Data;
  };

  // Set the Any type (handled specially so we can bind 'Any')
  template <> ZeroShared void Call::Set<      Any*>(size_t index,       Any* const& value);
  template <> ZeroShared void Call::Set<      Any >(size_t index,        const Any& value);
  template <> ZeroShared void Call::Set<      Any&>(size_t index,              Any& value);
  template <> ZeroShared void Call::Set<const Any*>(size_t index, const Any* const& value);
  template <> ZeroShared void Call::Set<const Any&>(size_t index,        const Any& value);
    
  // Get the Any type (handle pointer, reference, and const types)
  template <> ZeroShared       Any* Call::Get<      Any*>(size_t index);
  template <> ZeroShared       Any  Call::Get<      Any >(size_t index);
  template <> ZeroShared       Any& Call::Get<      Any&>(size_t index);
  template <> ZeroShared const Any* Call::Get<const Any*>(size_t index);
  template <> ZeroShared const Any& Call::Get<const Any&>(size_t index);

  // Set the Handle type (handled specially so we can bind 'Handle')
  template <> ZeroShared void Call::Set<      Handle*>(size_t index,       Handle* const& value);
  template <> ZeroShared void Call::Set<      Handle >(size_t index,        const Handle& value);
  template <> ZeroShared void Call::Set<      Handle&>(size_t index,              Handle& value);
  template <> ZeroShared void Call::Set<const Handle*>(size_t index, const Handle* const& value);
  template <> ZeroShared void Call::Set<const Handle&>(size_t index,        const Handle& value);
    
  // Get the Handle type (handle pointer, reference, and const types)
  template <> ZeroShared       Handle* Call::Get<      Handle*>(size_t index);
  template <> ZeroShared       Handle  Call::Get<      Handle >(size_t index);
  template <> ZeroShared       Handle& Call::Get<      Handle&>(size_t index);
  template <> ZeroShared const Handle* Call::Get<const Handle*>(size_t index);
  template <> ZeroShared const Handle& Call::Get<const Handle&>(size_t index);

  // Set the Delegate type (handled specially so we can bind 'Delegate')
  template <> ZeroShared void Call::Set<      Delegate*>(size_t index,       Delegate* const& value);
  template <> ZeroShared void Call::Set<      Delegate >(size_t index,        const Delegate& value);
  template <> ZeroShared void Call::Set<      Delegate&>(size_t index,              Delegate& value);
  template <> ZeroShared void Call::Set<const Delegate*>(size_t index, const Delegate* const& value);
  template <> ZeroShared void Call::Set<const Delegate&>(size_t index,        const Delegate& value);
    
  // Get the Delegate type (handle pointer, reference, and const types)
  template <> ZeroShared       Delegate* Call::Get<      Delegate*>(size_t index);
  template <> ZeroShared       Delegate  Call::Get<      Delegate >(size_t index);
  template <> ZeroShared       Delegate& Call::Get<      Delegate&>(size_t index);
  template <> ZeroShared const Delegate* Call::Get<const Delegate*>(size_t index);
  template <> ZeroShared const Delegate& Call::Get<const Delegate&>(size_t index);

}

// End header protection
#endif


namespace Zilch
{
  // Stores any type of object (handles, delegates, or even value types)
  class ZeroShared Any
  {
  public:

    // Constructor that initializes the Any to null (a handle, set to NullType)
    Any();

    template <typename T>
    Any(const T& value, ExecutableState* state)
    {
      // Get how big the copyable size of the object is (size of a handle, or the entire value size)
      BoundType* type = ZilchTypeId(T);
      size_t copyableSize = type->GetCopyableSize();

      // Allocate room to store this type (may store locally and not actually allocate)
      byte* destination = this->AllocateData(copyableSize);

      // Store the type and copy construct the data into us
      this->StoredType = type;

      // If the type is a reference type... (this is always a handle)
      if (ZilchStaticType(T)::CopyMode == TypeCopyMode::ReferenceType)
      {
        InternalWriteRef<T>(value, destination, state);
      }
      // Otherwise it must be a value type...
      else
      {
        InternalWriteValue<T>(value, destination);
      }
    }

    // Constructor that initializes to the given data and type (the data is copied in using GenericCopyConstruct)
    Any(const byte* data, Type* type);

    // Construct a default instance of a particular type (equivalent of default(T))
    explicit Any(Type* type);

    // Copying will properly reference count handles, delegates this handle, and memcopy value types
    Any(const Any& other);

    // Destructor that decrements reference counts and properly handles stored data
    ~Any();
    
    // Copying will properly reference count handles, delegates this handle, and memcopy value types
    Any& operator=(const Any& rhs);

    // Checks if the internal handle/delegate/value is the same
    bool operator==(const Any& rhs) const;
    
    // Checks if the internal handle/delegate/value is the different
    bool operator!=(const Any& rhs) const;

    // Allocates data if the size goes past the sizeof(this->Data), or returns a pointer to this->Data
    byte* AllocateData(size_t size);

    // Get the raw type data that we point at (may be our internal Data, or may be allocated)
    const byte* GetData() const;

    // Hashes a handle (generally used by hashable containers)
    int Hash() const;

    // Converts the internal value to string (used for debugging)
    String ToString() const;

    // Destruct any data stored by the any
    // This also clears the entire any out to zero
    void Clear();

    // Much like the copy constructor or assignment of an any, except it avoids
    // creating an extra 'any' in cases where we just have the memory and the type
    void AssignFrom(const byte* data, Type* type);

    // Replaces our stored definition with a default constructed version of the given type (equivalent of default(T))
    // Typically makes handles null, delegates null, and value types cleared to 0
    void DefaultConstruct(Type* type);

    // Generically copies the value of this any to another location
    // This will NOT copy the 'Any' but rather the stored type
    // Make sure the size and type of destination matches!
    void CopyStoredValueTo(byte* to) const;

  public:

    // We want to store the largest type (the delegate, handle, etc)
    // The delegate stores the handle, so we know delegate is the biggest
    // If the size of the type is bigger then can fit here, then we allocate a pointer instead
    byte Data[sizeof(Delegate)];

    // The type that we're storing inside the data
    Type* StoredType;
  };

  // Type defines for ease of use
  typedef const Any& AnyParam;

  // Given a type we know natively, return a value pointed at by a data pointer
  // If the data is not given, this will default construct the type
  // This is specialized by the Any type to return an Any that encapsulates the value
  template <typename T>
  T CopyToAnyOrActualType(byte* data, Type* dataType)
  {
    // If no data was provided, then return the default value for T
    if (data == nullptr)
    {
      // Not all primitive constructors zero out the memory, so do that first
      byte memory[sizeof(T)] = {0};
      new (memory) T();
      return *(T*)memory;
    }

    // Otherwise just cast data into the T type
    return *(T*)data;
  }
  
  // Specialziation for the Any type, which will copy the value into an Any
  template <>
  Any CopyToAnyOrActualType<Any>(byte* data, Type* dataType);

  // Given a type we know natively, just directly copy it to a location
  // This is specialized by the Any type to only copy its inner value
  template <typename T>
  void CopyFromAnyOrActualType(const T& value, byte* to)
  {
    // Just directly construct the value
    new (to) T(value);
  }

  // Specialziation for the Any type, which will copy the value out of an Any
  template <>
  void CopyFromAnyOrActualType<Any>(const Any& any, byte* to);
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_HPP
#define ZILCH_HPP

// Includes


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_PROJECT_HPP
#define ZILCH_PROJECT_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TOKENIZER_HPP
#define ZILCH_TOKENIZER_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_GRAMMAR_CONSTANTS_HPP
#define ZILCH_GRAMMAR_CONSTANTS_HPP

namespace Zilch
{
  // All the symbol constants in the language
  namespace Grammar
  {
    enum Enum
    {
      Invalid = -1,
      End = 0,
      Error = 1,
      Whitespace = 2,
      UpperIdentifier = 3,
      LowerIdentifier = 4,
      IntegerLiteral = 5,
      DoubleIntegerLiteral = 6,
      RealLiteral = 7,
      DoubleRealLiteral = 8,
      CharacterLiteral = 9,
      StringLiteral = 10,
      BeginStringInterpolate = 11,
      EndStringInterpolate = 12,
      EndBeginStringInterpolate = 13,
      Abstract = 14,
      Alias = 15,
      Alignof = 16,
      Assert = 17,
      Auto = 18,
      Case = 19,
      Catch = 20,
      Checked = 21,
      Const = 22,
      Default = 23,
      Dynamic = 24,
      Explicit = 25,
      Export = 26,
      Extern = 27,
      Finally = 28,
      Fixed = 29,
      Friend = 30,
      Global = 31,
      Goto = 32,
      Immutable = 33,
      Implicit = 34,
      Import = 35,
      In = 36,
      Include = 37,
      Inline = 38,
      Interface = 39,
      Internal = 40,
      Is = 41,
      Local = 42,
      Lock = 43,
      Module = 44,
      Mutable = 45,
      Namespace = 46,
      Operator = 47,
      Out = 48,
      Override = 49,
      Package = 50,
      Params = 51,
      Partial = 52,
      Positional = 53,
      Private = 54,
      Protected = 55,
      Public = 56,
      Readonly = 57,
      Register = 58,
      Require = 59,
      Scope = 60,
      Sealed = 61,
      Signed = 62,
      Sizeof = 63,
      Stackalloc = 64,
      Static = 65,
      Switch = 66,
      Timeout = 67,
      Try = 68,
      Typedef = 69,
      Typename = 70,
      Unchecked = 71,
      Unsafe = 72,
      Unsigned = 73,
      Using = 74,
      Virtual = 75,
      Volatile = 76,
      Where = 77,
      Yield = 78,
      Any = 79,
      And = 80,
      As = 81,
      Base = 82,
      Break = 83,
      Class = 84,
      Constructor = 85,
      Continue = 86,
      Debug = 87,
      Delegate = 88,
      Delete = 89,
      Destructor = 90,
      Do = 91,
      Else = 92,
      Enumeration = 93,
      False = 94,
      Flags = 95,
      For = 96,
      ForEach = 97,
      Function = 98,
      Get = 99,
      If = 100,
      Loop = 101,
      New = 102,
      Not = 103,
      Null = 104,
      Or = 105,
      Ref = 106,
      Return = 107,
      Sends = 108,
      Set = 109,
      Struct = 110,
      Throw = 111,
      True = 112,
      Typeid = 113,
      Typeof = 114,
      Variable = 115,
      While = 116,
      Access = 117,
      DynamicAccess = 118,
      NonVirtualAccess = 119,
      TypeSpecifier = 120,
      NameSpecifier = 120,
      Inheritance = 120,
      InitializerList = 120,
      ArgumentSeparator = 121,
      RefersTo = 122,
      Assignment = 123,
      AssignmentSubtract = 124,
      AssignmentAdd = 125,
      AssignmentDivide = 126,
      AssignmentMultiply = 127,
      AssignmentModulo = 128,
      AssignmentExponent = 129,
      AssignmentLeftShift = 130,
      AssignmentRightShift = 131,
      AssignmentBitwiseXor = 132,
      AssignmentBitwiseOr = 133,
      AssignmentBitwiseAnd = 134,
      Equality = 135,
      Inequality = 136,
      LessThan = 137,
      LessThanOrEqualTo = 138,
      GreaterThan = 139,
      GreaterThanOrEqualTo = 140,
      Negative = 141,
      Subtract = 141,
      Positive = 142,
      Add = 142,
      Divide = 143,
      Multiply = 144,
      Modulo = 145,
      Exponent = 146,
      Decrement = 147,
      Increment = 148,
      BitshiftLeft = 149,
      BitshiftRight = 150,
      BitwiseXor = 151,
      BitwiseOr = 152,
      BitwiseAnd = 153,
      BitwiseNot = 154,
      PropertyDelegate = 155,
      LogicalOr = 156,
      LogicalAnd = 157,
      LogicalNot = 158,
      StatementSeparator = 159,
      BeginIndex = 160,
      BeginTemplate = 160,
      BeginAttribute = 160,
      OldBeginInitializer = 160,
      EndIndex = 161,
      EndTemplate = 161,
      EndAttribute = 161,
      OldEndInitializer = 161,
      BeginFunctionCall = 162,
      BeginFunctionParameters = 162,
      BeginGroup = 162,
      EndFunctionCall = 163,
      EndFunctionParameters = 163,
      EndGroup = 163,
      BeginScope = 164,
      BeginInitializer = 164,
      EndScope = 165,
      EndInitializer = 165,
      CommentLine = 166,
      CommentStart = 167,
      CommentEnd = 168,
      SymbolCount
    };

    // Gets the name of a given grammar constant
    const String& GetName(Grammar::Enum value);

    // Gets the keyword or symbol associated with a grammar constant, or returns the string 'Invalid'
    const String& GetKeywordOrSymbol(Grammar::Enum value);

    // Get a list of keywords used by Zilch (typically provided for syntax highlighting)
    // If you need a list of words separated by spaces, you can use Zilch::JoinStrings
    const Array<String>& GetUsedKeywords();

    // Special keywords that only exist in certain contexts, (eg this, value...)
    // If you need a list of words separated by spaces, you can use Zilch::JoinStrings
    const Array<String>& GetSpecialKeywords();

    // Get a list of keywords reserved by Zilch (these may not be used, but do nothing)
    const Array<String>& GetReservedKeywords();
  }
}

// End header protection
#endif


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TOKEN_HPP
#define ZILCH_TOKEN_HPP

// Includes



namespace Zilch
{
  // This struct is given back to the user when asking for tokens
  class UserToken
  {
  public:
    // Default constructor
    UserToken();
    
    // Construct a token for a keyword or symbol (NOT for variable length things such as identifiers)
    UserToken(Grammar::Enum tokenId, CodeLocation* location = nullptr);

    // Constructor for a special type of token
    UserToken(StringParam token, Grammar::Enum tokenId, CodeLocation* location = nullptr);

    // The location is optional (if null is given, this will do nothing)
    void SetLocationAndStartLength(CodeLocation* location);

    // Make it easier to get the c-string for the token
    cstr c_str() const;

    String Token;
    Grammar::Enum TokenId;
    CodeLocation Location;
    size_t Start;
    size_t Length;
  };

  // A classifcation of tokens (not the specific token, but rather a category)
  namespace TokenCategory
  {
    enum Enum
    {
      Keyword,
      Symbol,
      Unknown,
    };
  }
}

// Explicit specializations
namespace Zero
{
  // UserToken should be directly memory movable (so should CodeLocation)
  // String would technically just increment a reference and then decrement, so skip it!
  template <>
  struct MoveWithoutDestructionOperator<Zilch::UserToken>
  {
    static inline void MoveWithoutDestruction(Zilch::UserToken* dest, Zilch::UserToken* source)
    {
      memcpy(dest, source, sizeof(*source));
    }
  };
}

// End header protection
#endif

namespace Zilch
{
  // This class parses the input stream using a grammar
  class Tokenizer
  {
  public:

    // Constructor
    Tokenizer(CompilationErrors& errors);

    // Parse data from a null terminated memory pointer
    bool Parse(const CodeEntry& entry, Array<UserToken>& tokensOut, Array<UserToken>& commentsOut);

    // Finalizes a token stream
    void Finalize(Array<UserToken>& tokensOut);

    // Commonly used imposter tokens for generated code
    static const UserToken* GetBaseToken();
    static const UserToken* GetThisToken();
    static const UserToken* GetValueToken();
    static const UserToken* GetAccessToken();
    static const UserToken* GetAssignmentToken();

  private:

    // Initialize the internals
    void InitializeInternals();

    // Reads back a character out of the input stream
    inline char ReadCharacter();

    // Traverse through the rest of the input buffer and compare it to the given string
    bool DiffString(const char* string);

    // Attempts to read a keyword or a symbol (any non-varying token)
    inline bool ReadKeywordOrSymbol(UserToken* outToken, size_t& lastAcceptedPos, char& character, TokenCategory::Enum& tokenType);

    // Attempt to read an identifier
    bool ReadIdentifier(UserToken* outToken, bool startedFromKeyword, size_t& lastAcceptedPos, char& character);

    // Attempt to read a number (both real or integer)
    bool ReadNumber(UserToken* outToken, size_t& lastAcceptedPos, char& character);

    // Attempt to read a string
    bool ReadString(UserToken* outToken, size_t& lastAcceptedPos, char& character);

    // Attempts to read a token
    bool ReadToken(UserToken* outToken);

    // Update what line and character we're on
    void UpdateLineAndCharacterNumber(char character);

    // Skip to the end of the line via modifying the position
    String SkipToEndOfLine();

    // Parse the data
    bool ParseInternal(Array<UserToken>& tokensOut, Array<UserToken>& commentsOut);

  public:

    // When set, we will parse the special '`' characters in strings to mean string interpolation (default true)
    bool EnableStringInterpolation;

  private:

    // The token that means 'end of file'
    UserToken Eof;

    // Store a reference to the error handler
    CompilationErrors& Errors;

    // The script string that needs to be tokenized
    String Data;

    // If the last character we read was a carriage return
    // This is to support the CRLF style newlines (which only counts as one line, not two)
    bool WasCarriageReturn;

    // The position in the data stream
    size_t Position;

    // The most forward position we've reached
    size_t ForwardPosition;

    // The location that we're at in the tokenizer (only updated when we read full tokens)
    CodeLocation Location;

    // The location that we're at in the tokenizer that is updated with every character read
    size_t Character;
    size_t Line;

    // The depth of comment we're in (how many nested block comments inside of block comments)
    size_t CommentDepth;

    // Not copyable
    ZilchNoCopy(Tokenizer);
  };

  // Character utilities that we use for tokenizing
  class CharacterUtilities
  {
  public:
    // Detect if a character is a white-space character
    static bool IsWhiteSpace(char c);

    // Detect if a character is alpha
    static bool IsAlpha(char c);

    // Detect if a character is numeric
    static bool IsNumeric(char c);

    // Detect if a character is alpha-numeric
    static bool IsAlphaNumeric(char c);

    // Detect if a character is uppercase
    static bool IsUpper(char c);

    // Is this a valid escape character in a string literal
    static bool IsStringEscapee(char c);
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SYNTAX_TREE_HPP
#define ZILCH_SYNTAX_TREE_HPP

// Includes


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SYNTAX_TREE_HELPERS_HPP
#define ZILCH_SYNTAX_TREE_HELPERS_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_ERROR_HANDLER_HPP
#define ZILCH_ERROR_HANDLER_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_ERROR_DATABASE_HPP
#define ZILCH_ERROR_DATABASE_HPP

// Includes



namespace Zilch
{
  // All the possible errors in the language
  namespace ErrorCode
  {
    enum Enum
    {
      Invalid = -1,

      // Include the generated error enumeration values
AttributeArgumentMustBeLiteral = 0,
AttributeNotComplete = 1,
AttributesNotAttached = 2,
AttributeTypeNotFound = 3,
BaseClassInitializerMustComeFirst = 4,
BaseClassInitializerRequiresBaseClassInheritance = 5,
BaseInitializerRequired = 6,
BinaryOperatorRightOperandNotFound = 7,
BlockCommentNotComplete = 8,
BlockCommentNotFound = 9,
BreakCountMustBeGreaterThanZero = 10,
BreakLoopNotFound = 11,
CannotCreateType = 12,
CannotReplaceTemplateInstanceWithNonTemplateType = 13,
CannotReplaceTemplateInstanceWithTemplateArguments = 14,
CastTypeNotFound = 15,
ClassBodyNotComplete = 16,
ClassBodyNotFound = 17,
ClassNameNotFound = 18,
CompositionCycleDetected = 19,
ConditionMustBeABooleanType = 20,
ConstructorCallNotFound = 21,
ConstructorCannotAccessStaticMembers = 22,
ContinueLoopNotFound = 23,
CreatedTypeNotFound = 24,
CreationInitializeMemberExpectedInitialValue = 25,
CreationInitializerExpectedSubElement = 26,
CreationInitializerNotComplete = 27,
CustomError = 28,
DelegateReturnTypeNotFound = 29,
DeletingNonReferenceType = 30,
DeletingNonWritableValue = 31,
DoWhileConditionalExpressionNotComplete = 32,
DoWhileConditionalExpressionNotFound = 33,
DuplicateLocalVariableName = 34,
DuplicateMemberName = 35,
DuplicateTypeName = 36,
EnumBodyNotComplete = 37,
EnumBodyNotFound = 38,
EnumDuplicateValue = 39,
EnumNameNotFound = 40,
EnumValueRequiresIntegerLiteral = 41,
ExternalTypeNamesCollide = 42,
ForEachInKeywordNotFound = 43,
ForEachRangeExpressionNotFound = 44,
ForEachVariableDeclarationNotFound = 45,
ForLoopExpressionsNotComplete = 46,
ForLoopExpressionsNotFound = 47,
FunctionArgumentListNotComplete = 48,
FunctionArgumentListNotFound = 49,
FunctionBodyNotComplete = 50,
FunctionBodyNotFound = 51,
FunctionCallExpectedAfterInitializer = 52,
FunctionCallNamedArgumentNotFound = 53,
FunctionCallNotComplete = 54,
FunctionCallOnNonCallableType = 55,
FunctionNameNotFound = 56,
FunctionParameterNotFound = 57,
FunctionReturnTypeNotFound = 58,
GenericError = 59,
GetFoundAfterSet = 60,
GroupingOperatorNotComplete = 61,
IfConditionalExpressionNotComplete = 62,
IfConditionalExpressionNotFound = 63,
IndexerIndicesNotFound = 64,
IndexerNotComplete = 65,
InternalError = 66,
InvalidAttribute = 67,
InvalidBinaryOperation = 68,
InvalidEscapeInStringLiteral = 69,
InvalidNumberOfTemplateArguments = 70,
InvalidTypeCast = 71,
InvalidUnaryOperation = 72,
LocalCreateMustBeValueType = 73,
LocalVariableReferenceNotFound = 74,
MemberAccessNameNotFound = 75,
MemberNotFound = 76,
MemberVariableTypesCannotBeInferred = 77,
MultipleInheritanceNotSupported = 78,
NativeTypesRequireConstructors = 79,
NoArgumentConstructorsProvided = 80,
NotAllPathsReturn = 81,
OnlyOneDestructorAllowed = 82,
OverloadsCannotBeTheSame = 83,
ParameterTypeNotFound = 84,
ParameterTypeSpecifierNotFound = 85,
ParsingNotComplete = 86,
PropertyDeclarationNotComplete = 87,
PropertyDelegateOperatorRequiresProperty = 88,
PropertyDelegateRequiresGetOrSet = 89,
ReadingFromAWriteOnlyValue = 90,
ReferencesOnlyToNamedValueTypes = 91,
ReferenceToUndefinedType = 92,
ReturnTypeMismatch = 93,
ReturnValueNotFound = 94,
ReturnValueUnexpected = 95,
ScopeBodyNotComplete = 96,
ScopeBodyNotFound = 97,
SendsEventStatementNameNotFound = 98,
SendsEventStatementNotComplete = 99,
SendsEventStatementTypeNotFound = 100,
SendsEventStatementTypeSpecifierNotFound = 101,
StatementSeparatorNotFound = 102,
StatementsWillNotBeExecutedEarlyReturn = 103,
StaticCannotBeOverriding = 104,
StaticCannotBeVirtual = 105,
StaticTypeConstructorOrAccessNotFound = 106,
StringInterpolantExpectedExpression = 107,
StringInterpolantNotComplete = 108,
StringLiteralNotComplete = 109,
StructsCanOnlyContainValueTypes = 110,
TemplateArgumentNotFound = 111,
TemplateTypeArgumentsNotComplete = 112,
ThrowExceptionExpressionNotFound = 113,
ThrowTypeMustDeriveFromException = 114,
TimeoutBodyNotComplete = 115,
TimeoutBodyNotFound = 116,
TimeoutSecondsExpectedIntegerLiteral = 117,
TimeoutSecondsMustBeNonZeroPositive = 118,
TimeoutSecondsNotComplete = 119,
TimeoutSecondsNotFound = 120,
TypeIdExpressionNotComplete = 121,
TypeIdExpressionNotFound = 122,
UnableToResolveFunction = 123,
UnaryOperatorOperandNotFound = 124,
UnidentifiedSymbol = 125,
UnnecessaryVirtualAndOverride = 126,
VariableInitializationNotComplete = 127,
VariableInitialValueNotFound = 128,
VariableMustBeInitialized = 129,
VariableNameNotFound = 130,
VariableTypeMismatch = 131,
VariableTypeNotFound = 132,
WhileConditionalExpressionNotComplete = 133,
WhileConditionalExpressionNotFound = 134,
WritingToAReadOnlyValue = 135,


      Count
    };
  }

  // Store example error information and how it was fixed
  class ErrorExample
  {
  public:
    // The lines of code where the error can be seen
    String ErrorCode;

    // The same lines of code as above, but with the error fixed
    String FixedCode;

    // A brief explanation of the fix
    String ExplanationOfFix;
  };

  // Store information about a particular error
  class ErrorInfo
  {
  public:
    // The error itself (possibly a context sensative string)
    String Error;

    // The name of the error
    String Name;

    // A reason given for why the error occurs that generally explains to the user why it exists and common pitfalls (human friendly!)
    String Reason;

    // A series of examples as to where the error occurs and examples of fixes (as well as a brief explanation)
    Array<ErrorExample> Examples;
  };

  // A created database that stores all the errors
  class ErrorDatabase
  {
  public:

    // Get the singleton instance of the error database (which also initializes it)
    static ErrorDatabase& GetInstance();

    // Get the error info for a given error code
    const ErrorInfo& GetErrorInfo(ErrorCode::Enum errorCode) const;

  private:

    // Constructor (initializes the errors)
    ErrorDatabase();

    // Store an array of all the errors and their information
    Array<ErrorInfo> Errors;
  };

  // This structure is what gets reported to the user
  class ErrorEvent : public EventData
  {
  public:
    // Default constructor
    ErrorEvent();

    // Constructor
    ErrorEvent(const ErrorInfo& info, const CodeLocation& location, ErrorCode::Enum code, va_list args);

    // The specific error code for the error
    ErrorCode::Enum ErrorCode;

    // The location that the error occurred (file/place, line, etc)
    CodeLocation Location;

    // Other locations associated with the error
    // For example, duplicate class names would include the other place where the class was defined
    // Never rely upon this being set in certain errors, as sometimes the locations are unknown and do not get populated
    Array<CodeLocation> AssociatedOtherLocations;

    // A reason given for why the error occurs that generally explains to the user why it exists and common pitfalls (human friendly!)
    String Reason;

    // The exact error message, including context
    String ExactError;

    // A series of examples as to where the error occurs and examples of fixes (as well as a brief explanation)
    Array<ErrorExample> Examples;

    // Get the standard formatting for error messages
    String GetFormattedMessage(MessageFormat::Enum format) const;
  };
}

// End header protection
#endif




namespace Zilch
{
  namespace Events
  {
    // Sent on the CompilationErrors object every time an error occurs
    ZilchDeclareEvent(CompilationError, ErrorEvent);
  }

  // Type-defines
  typedef Array<const CodeLocation*> LocationArray;

  // The default error callback prints compiler errors to stderr (pass null for userData)
  void DefaultErrorCallback(ErrorEvent* e);

  // A special callback that assumes the user-data is a pointer to a String class
  void OutputErrorStringCallback(ErrorEvent* e, void* stringPointer);

  // This class provides a general output handler that we can use in all modules (for outputting messages, warnings, and errors)
  class ZeroShared CompilationErrors : public EventHandler
  {
  public:

    // Constructor
    CompilationErrors();

    // Print out an error message with extra context (one extra location, given a va_list)
    void RaiseArgs(const CodeLocation& location, StringParam extra, const CodeLocation& associatedLocation, ErrorCode::Enum errorCode, va_list args);

    // Print out an error message (given a va_list)
    void RaiseArgs(const CodeLocation& location, StringParam extra, const LocationArray& associatedLocations, ErrorCode::Enum errorCode, va_list args);

    // Print out an error message with extra context (multiple locations, given a va_list)
    void RaiseArgs(const CodeLocation& location, ErrorCode::Enum errorCode, va_list args);

    // Print out an error message with extra context (one extra location)
    void Raise(const CodeLocation& location, StringParam extra, const CodeLocation& associatedLocation, ErrorCode::Enum errorCode, ...);

    // Print out an error message with extra context (multiple locations)
    void Raise(const CodeLocation& location, StringParam extra, const LocationArray& associatedLocations, ErrorCode::Enum errorCode, ...);

    // Print out an error message
    void Raise(const CodeLocation& location, ErrorCode::Enum errorCode, ...);

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructibleBuffer ComplexUserData;

  public:

    // If set to true, all operations will cease and the stack will be unwound
    // This is used internally for error handling
    bool WasError;

    // If set to true, then any errors we get after the 'WasError' flag is
    // set will be ignored. In general this is only set in a few specific
    // cases and should not be set by the user as it can lead to missed errors
    bool IgnoreMultipleErrors;

    // If this is set, errors will be reported but ignored (which allows parsing and syntaxing to continue)
    bool TolerantMode;
  };
}

// End header protection
#endif



namespace Zilch
{
  // This list is used to hold nodes in the tree
  template <typename ValueType>
  class DoublePointerArray : public PodArray<ValueType**>
  {
  public:
    // Type-defines
    typedef PodArray<ValueType**> base;
    
    // Add a node, as long as the value is not null
    template <typename T>
    bool Add(T*& value) // where T : SyntaxNode*
    {
      // Check the value to see if it's null
      if (value != nullptr)
      {
        // It's not, so push it on and return success
        base::push_back((ValueType**)&value);
        return true;
      }

      // We failed to add the node since it was null
      return false;
    }

  private:
    // Don't allow direct pushing back
    void push_back(const ValueType**& item);
    ValueType**& push_back();
  };


  // This list is used to hold nodes in the tree
  template <typename ValueType>
  class PopulatingPointerArray : public PodBlockArray<ValueType*>
  {
  public:
    // Type-defines
    typedef PodBlockArray<ValueType*> base;
    
    // Add a node, as long as the value is not null
    ValueType* Add(ValueType* value)
    {
      // Check the value to see if it's null
      if (value != nullptr)
      {
        // It's not, so push it on and return success
        base::push_back(value);
      }

      // Return whatever was added, so it can be checked if it was valid
      return value;
    }

    // Populates an external list with pointers to each syntax node
    template <typename T>
    void Populate(DoublePointerArray<T>& childrenOut)
    {
      // Reserve space for performance
      childrenOut.reserve(childrenOut.size() + this->size());

      // Loop throuhg all the nodes
      for (size_t i = 0; i < this->size(); ++i)
      {
        childrenOut.Add((*this)[i]);
      }
    }

  private:
    // Don't allow direct pushing back
    void push_back(const ValueType*& item);
    ValueType*& push_back();
  };

  // This list is used to hold nodes of any type in the tree
  template <typename T>
  class NodeList : public PopulatingPointerArray<T>
  {
  };

  // Type-defines
  typedef DoublePointerArray<SyntaxNode> NodeChildren;
  typedef DoublePointerArray<SyntaxType> SyntaxTypes;
  typedef PopulatingPointerArray<SyntaxType> SyntaxTypeList;

  template <typename TreeOwnerType, typename ContextType>
  class BranchWalker;
  
  namespace WalkerFlags
  {
    enum Enum
    {
      None = 0,
      ChildrenNotHandled = 1,
      PreventOtherWalkers = 2,
      Error = 4
    };
    typedef size_t Type;
  }

  template <typename TreeOwnerType, typename ContextType>
  class WalkerContext
  {
  public:
    // Store a pointer back to the walker
    BranchWalker<TreeOwnerType, ContextType>* Walker;

    // These flags get reset with every walk
    WalkerFlags::Type Flags;
  };

  template <typename TreeOwnerType, typename ContextType>
  class BranchWalker
  {
  public:

    // Constructor
    BranchWalker(CompilationErrors* errors = nullptr) :
      WasError(false),
      Errors(errors)
    {
    }

    // The member function type that we'd like to be able to traverse our trees
    typedef void (TreeOwnerType::*MemberFn)(SyntaxNode*& node, ContextType* context);

    // Register a visitor, and the condition is implied to be 
    template <typename ChildType>
    void Register(void (TreeOwnerType::*visitor)(ChildType*& node, ContextType* context))
    {
      RegisterInternal((MemberFn) visitor, ZilchTypeId(ChildType), false);
    }

    // Register a visitor, for a more derived child type
    template <typename DerivedChildType, typename ChildType>
    void RegisterDerived(void (TreeOwnerType::*visitor)(ChildType*& node, ContextType* context))
    {
      RegisterInternal((MemberFn) visitor, ZilchTypeId(DerivedChildType), false);
    }

    // Register a visitor that will visit any node of this base type, even if it derives from it
    template <typename ChildType>
    void RegisterNonLeafBase(void (TreeOwnerType::*visitor)(ChildType*& node, ContextType* context))
    {
      RegisterInternal((MemberFn) visitor, ZilchTypeId(ChildType), true);
    }

    template <typename NodeType>
    void GenericWalkChildren(TreeOwnerType* owner, NodeType*& node, ContextType* context)
    {
      // Now we need to go through every child that wasn't visited
      NodeChildren children;
      node->PopulateChildren(children);

      // Loop through all of the children that matched that type (including derived types)
      for (size_t i = 0; i < children.size(); ++i)
      {
        // Get the current child
        SyntaxNode*& child = *children[i];

        // Walk down to the children
        Walk(owner, child, context);

        // If the error handler is available and an error ocurred...
        if (this->Errors != nullptr && this->Errors->WasError)
          return;
      }
    }

    // Using the registered visitors, visit all of the direct child nodes
    template <typename NodeType>
    void Walk(TreeOwnerType* owner, NodeList<NodeType>& nodes, ContextType* context)
    {
      // Loop through all the nodes in the list
      for (size_t i = 0; i < nodes.size(); ++i)
      {
        // Get the current node
        NodeType*& node = nodes[i];

        // Walk this specific node
        this->Walk(owner, node, context);
      }
    }

    // Checks to see if any errors have occurred
    bool HasErrorOccurred()
    {
      return this->WasError || (this->Errors != nullptr && this->Errors->WasError);
    }

    // Using the registered visitors, visit all of the direct child nodes
    template <typename NodeType>
    void Walk(TreeOwnerType* owner, NodeType*& node, ContextType* context)
    {
      // Early out if an error occurred
      if (this->HasErrorOccurred())
        return;

      // Set the walker on the context
      context->Walker = this;

      // Error checking
      ErrorIf(node == nullptr, "You should never attempt to traverse a null node");

      // Get the node type
      BoundType* nodeType = node->ZilchGetDerivedType();

      // Were the children walked over (or explicitly ignored)?
      bool childrenWereHandled = false;

      // Loop through all the visitors
      for (size_t i = 0; i < this->Visitors.size(); ++i)
      {
        // Get the current visitor
        VisitorInfo& visitor = this->Visitors[i];

        // As long as the node we're visiting is somehow derived from the node visitor type
        if (nodeType == visitor.NodeType || (visitor.IsNonLeafBase && TypeBinding::IsA(nodeType, visitor.NodeType)))
        {
          // Clear any flags before visiting this node
          context->Flags = WalkerFlags::None;

          // Invoke the visitor on that child
          (owner->*(visitor.Visitor))((SyntaxNode*&)node, context);

          // Store and reset the flags again
          WalkerFlags::Type flags = context->Flags;
          context->Flags = WalkerFlags::None;

          // If any kind of error occurred, early out
          if (flags & WalkerFlags::Error || this->HasErrorOccurred())
          {
            // Set an error flag so we won't do any more visiting
            this->WasError = true;
            return;
          }

          // If the children were walked by this visitor, then mark it so
          // This just means we will not generically walk the tree later
          if ((flags & WalkerFlags::ChildrenNotHandled) == 0)
            childrenWereHandled = true;

          // If we don't want anyone else to visit this node after us...
          // Note: We do not 'return' because we may still want to generically walk it's children
          if (flags & WalkerFlags::PreventOtherWalkers)
            break;

          // If the node was ever cleared...
          if (node == nullptr)
            return;

          // If the error handler is available and an error ocurred...
          if (this->Errors != nullptr && this->Errors->WasError)
            return;
        }
      }

      // Check if the children were not visited...
      if (childrenWereHandled == false)
      {
        // Generically walk all the children since nobody visited this poor old node
        this->GenericWalkChildren(owner, node, context);
      }
    }

  private:

    // Register a visitor
    void RegisterInternal(MemberFn visitor, BoundType* childTypeToVisit, bool isNonLeafBase)
    {
      VisitorInfo info;
      info.Visitor = visitor;
      info.NodeType = childTypeToVisit;
      info.IsNonLeafBase = isNonLeafBase;

      // Add the node to the children
      this->Visitors.push_back(info);
    }

  public:

    // If an error occurred, this will be set
    // This must be cleared before reusing a walker
    bool WasError;

    // Store a reference to the error handler (may be null)
    CompilationErrors* Errors;

  private:

    // Information about the visitors
    class VisitorInfo
    {
    public:
      // Constructor
      VisitorInfo() :
        Visitor(nullptr),
        NodeType(nullptr),
        IsNonLeafBase(false)
      {
      }

      MemberFn Visitor;
      BoundType* NodeType;
      bool IsNonLeafBase;
    };

    // The visitors that have been registered
    typedef Array<VisitorInfo> VisitorArray;

    // Store all the visitors
    VisitorArray Visitors;

    // Not copyable
    ZilchNoCopy(BranchWalker);
  };
}

#endif





/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SHARED_HPP
#define ZILCH_SHARED_HPP

// Includes




// We need to make a specialization because the hash maps do not work with enums
// On other compilers, the 'Enum' type is actually an int, which would produce a
// duplicate definition compiler error since a specialization of int already exists
#ifdef _MSC_VER
template<>
class ZeroShared Zero::HashPolicy<Zilch::Grammar::Enum> : public Zero::ComparePolicy<size_t>
{
public:
  inline size_t operator()(const Zilch::Grammar::Enum& value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};
#endif

namespace Zilch
{
  // What type of IO an expression allows
  namespace IoMode
  {
    enum Enum
    {
      // Some expressions we ignore their io-usage (but never the io of the expression itself)
      // Examples being expressions used as a standalone statement (nobody reads/writes)
      Ignore = 0,
      // A variable is readable (constants, temporaries, property get)
      ReadRValue = 1,
      // A variable is writable (variables, property set)
      WriteLValue = 2,
      // We're strictly doing a property 'set', which means 'WriteLValue' should be set
      // This is used to let handle and delegate properties know that they are initializing
      // a value rather than assigning a value (when assignment '=' is used)
      StrictPropertySet = 4,
      // If the access type was not set, we either haven't resolved it or it's a bug
      NotSet = (uint)-1
    };
  }

  // This struct is given back to the user when asking for tokens
  class ZeroShared BinaryOperator
  {
  public:
    // Constructor
    BinaryOperator();

    // The hash function which allows us to put it in a hash container
    size_t Hash() const;

    // The hash function which allows us to put it in a hash container
    bool operator==(const BinaryOperator& rhs) const;

    // Whether this operator was valid or not (a non-existant operator is invalid)
    bool IsValid;

    // In a binary operator, these include the left and right hand types
    Type* Lhs;
    Type* Rhs;

    // If the left or right hand argument needs to be casted for this operation to work
    // This only appears when the direct operator does not exist, but an implicit cast of one side, or the other, or both exists
    Type* CastLhsTo;
    Type* CastRhsTo;

    // The resulting type of the operation
    Type* Result;

    // The operator used in grammar to represent
    Grammar::Enum Operator;

    // The resulting instruction
    Instruction::Enum Instruction;

    // If the operation is communative but it's between two different types, this tells
    // us if the opcode requires the arguments to be flipped (to reduce opcodes)
    bool FlipArguments;

    // Whether or not this results in an l-value or r-value
    IoMode::Enum Io;
  };

  // This struct is given back to the user when asking for tokens
  class ZeroShared UnaryOperator
  {
  public:
    // Constructor
    UnaryOperator();

    // The hash function which allows us to put it in a hash container
    size_t Hash() const;

    // The hash function which allows us to put it in a hash container
    bool operator==(const UnaryOperator& rhs) const;

    // Whether this operator was valid or not (a non-existant operator is invalid)
    bool IsValid;

    // In a unary operator, this is the operand
    Type* Operand;

    // The resulting type of the operation
    Type* Result;

    // The operator used in grammar to represent
    Grammar::Enum Operator;

    // The resulting instruction
    Instruction::Enum Instruction;

    // Whether or not this results in an l-value or r-value
    IoMode::Enum Io;
  };

  // Tells us which way an operator evaluates it's arguments
  namespace OperatorAssociativity
  {
    enum Enum
    {
      RightToLeft,
      LeftToRight
    };
  }

  // Lets us query information about the validity of a cast, as well as what kind it will be
  class ZeroShared CastOperator
  {
  public:
    // Constructor
    CastOperator();

    // The hash function which allows us to put it in a hash container
    size_t Hash() const;

    // The hash function which allows us to put it in a hash container
    bool operator==(const CastOperator& rhs) const;

    // Whether this operator was valid or not (a non-existant operator is invalid)
    bool IsValid;

    // Only used for efficient query / lookup
    // These may be null in cases other than primitive casts
    Type* From;
    Type* To;

    // The operator used in grammar to represent
    CastOperation::Enum Operation;

    // The resulting instruction if a single one exists (eg ConvertRealToInteger)
    // Only valid when the cast operation is Primitive
    // Otherwise if no direct instruction exists, the instruction will be set to 'InvalidInstruction'
    Instruction::Enum PrimitiveInstruction;

    // If we allow this cast to be implicit (default false)
    // If true, then the syntaxer will automatically allow it in cases
    // such as return, passing parameters, resolving overloads, etc
    bool CanBeImplicit;

    // Some casts require actual instructions to run
    // Ex: Real to Integer must perform a floating point conversion, Integer to the special Any type, etc
    // Other casts can be directly raw convertable with no execution
    // Ex: An enum value to an Integer, or a derived class to a base class (Cat to Animal)
    // This will be set if the cast type requires any sort of code generation / execution
    bool RequiresCodeGeneration;
  };

  // Tells us which way an operator evaluates it's arguments
  namespace OperatorArity
  {
    enum Enum
    {
      Unary,
      Binary
    };
  }

  // Encompasses everything we need to know about operator precedence
  class ZeroShared UntypedOperator
  {
  public:
    // Constructor
    UntypedOperator();

    // Whether this operator was valid or not (a non-existant operator is invalid)
    bool IsValid;

    Grammar::Enum Operator;
    size_t Precedence;
    OperatorAssociativity::Enum Associativity;
    OperatorArity::Enum Arity;
  };

  // Contains information that is shared between the syntaxer and the code generator
  class ZeroShared Shared
  {
  public:

    // Construct the shared object
    Shared();

    // Get the instance of the singleton
    static Shared& GetInstance();

    // Lookup a binary operator between two types
    // Both entries for communative operators will exist, eg, scalar * vector and vector * scalar
    BinaryOperator GetBinaryOperator(Type* lhs, Type* rhs, Grammar::Enum oper, bool allowRecursiveLookup = true);

    // Lookup a unary operator
    UnaryOperator GetUnaryOperator(Type* type, Grammar::Enum oper);

    // Lookup any cast operators from this type to any other type
    Array<CastOperator> GetPrimitiveCastOperatorsFrom(Type* from);

    // Lookup a cast operator (can be explicit or implicit)
    CastOperator GetCastOperator(Type* from, Type* to);

    // Get a structure that represents the precedence and associativity of an operator, regardless of types
    UntypedOperator GetOperatorPrecedence(Grammar::Enum oper, OperatorArity::Enum arity);

    // Gets all the operators stored in an array thats indexed by precedence
    // Note: Precedence starts at 0 and ends at size() - 1
    const Array<Array<UntypedOperator> >& GetPrecedences();

  private:

    // Adds a binary operator
    void AddBinary(Type* lhs, Type* rhs, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io, bool flip);

    // Adds a binary communative operator (which adds the reversed operator too)
    void AddBinaryCommunative(Type* type1, Type* type2, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io);

    // Adds a binary non-communative operator (the reverse will not be added)
    void AddBinaryNonCommunative(Type* lhs, Type* rhs, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io);
    
    // Adds a binary operator where the operands are the same type
    // Note: If the operator is the same type, we don't care if it's communative or not because we always perform
    // the operation in the correct order, and we only need one opcode to represent it
    void AddBinary(Type* sameType, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io);

    // Adds a unary operator
    void AddUnary(Type* operand, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io);

    // Adds a primitive cast operator (must have an instruction
    void AddPrimitiveCast(Type* fromType, Type* toType, Instruction::Enum instruction, bool canBeImplicit);

    // Adds an operator to the precedence chart (maps it both ways)
    void AddPrecedence(size_t precedence, OperatorAssociativity::Enum associativity, OperatorArity::Enum arity, Grammar::Enum oper);

  private:

    // Special binary operators
    BinaryOperator HandleAssignment;
    BinaryOperator HandleEquality;
    BinaryOperator HandleInequality;
    BinaryOperator ValueAssignment;
    BinaryOperator ValueEquality;
    BinaryOperator ValueInequality;
    BinaryOperator DelegateAssignment;
    BinaryOperator DelegateEquality;
    BinaryOperator DelegateInequality;
    BinaryOperator AnyAssignment;
    BinaryOperator AnyEquality;
    BinaryOperator AnyInequality;

    // Our hash set of binary operators that get registered once (hence the singleton)
    HashSet<BinaryOperator> BinaryOperators;

    // Our hash set of unary operators that get registered once (hence the singleton)
    HashSet<UnaryOperator> UnaryOperators;
    
    // Special cast operators
    // RawImplicitCast includes same-cast, up-cast, null-cast, any-delegate-cast
    CastOperator RawImplicitCast;
    CastOperator DynamicDownCast;
    CastOperator ToAnyCast;
    CastOperator FromAnyCast;
    CastOperator EnumIntegerCast;
    CastOperator IntegerEnumCast;
    CastOperator NullToDelegate;

    // Our hash set of casting operators that get registered once (hence the singleton)
    HashSet<CastOperator> CastOperators;

    // Associate all the cast operators from this type to any other type
    ZilchTodo("This should actually use some kind of policy because we're not hashing types correctly (works because we only care about BoundType* right now, Real/Integer, etc )");
    HashMap<Type*, Array<CastOperator> > PrimitiveCastOperatorsFrom;

    // We use this as a key into a hash map
    class OperatorWithArity
    {
    public:
      // Define these so we can be used as a key
      bool operator==(const OperatorWithArity& rhs) const;
      size_t Hash() const;

      Grammar::Enum Operator;
      OperatorArity::Enum Arity;
    };

    // We map operators to their precedence and back (useful for code formatters and documentation)
    HashMap<OperatorWithArity, UntypedOperator> OperatorToPrecedence;
    Array<Array<UntypedOperator> > PrecedenceToOperators;
  };
}

// End header protection
#endif

namespace Zilch
{
  ZilchDeclareStaticLibrary(Syntax);

  namespace EvaluationMode
  {
    enum Enum
    {
      // Parses the entire project (including classes, functions, members, etc)
      Project,

      // Parses just a single input expression
      Expression,
    };
  }

  // This tree stores the parsed language in a format that's easy to traverse
  class SyntaxTree
  {
  public:

    // Friends
    friend class Parser;

    // Constructor
    SyntaxTree();

    // Destructor
    ~SyntaxTree();

    // Get all the nodes at the given cursor position
    void GetNodesAtCursor(size_t cursorPosition, StringParam cursorOrigin, Array<SyntaxNode*>& nodesOut);

    // Get the graphviz representation for debugging purposes
    String GetGraphVizRepresentation();

    // Show the graphviz representation for debugging purposes
    void ShowGraphVizRepresentation();

  private:
    
    // Recursively walks child nodes looking for any node whose range encompasses the cursor
    void GetNodesAtCursorRecursive(SyntaxNode* node, size_t cursorPosition, StringParam cursorOrigin, Array<SyntaxNode*>& nodesOut);

  public:

    // The root of the tree
    RootNode* Root;

    // A singlular expression to be evaluated (or null if we're compiling an entire tree)
    // Its not actually safe to store the expression here, so we store its parent and index
    // This is also technically not safe, but for now we know we don't do any operations that mess with scopes
    ScopeNode* SingleExpressionScope;
    size_t SingleExpressionIndex;

    // Not copyable
    ZilchNoCopy(SyntaxTree);
  };

  #define ZilchClonableNode(Type)                   \
    ~Type()                                         \
    {                                               \
      this->DestroyChildren();                      \
    }                                               \
    Type* Clone() const override                    \
    {                                               \
      Type* clone = new Type(*this);                \
                                                    \
      NodeChildren children;                        \
      clone->PopulateChildren(children);            \
      clone->PopulateNonTraversedChildren(children);\
      for (size_t i = 0; i < children.size(); ++i)  \
      {                                             \
        SyntaxNode*& child = *children[i];          \
        child = child->Clone();                     \
      }                                             \
                                                    \
      SyntaxNode::FixParentPointers(clone, nullptr);\
                                                    \
      return clone;                                 \
    }

  // A syntax node represents any syntactical entity in the syntax tree
  class SyntaxNode : public IZilchObject
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareBaseType(SyntaxNode, TypeCopyMode::ReferenceType);

    // Constructor
    SyntaxNode();

    // Destructor
    virtual ~SyntaxNode() {};

    // Copy constructor
    SyntaxNode(const SyntaxNode& toCopy);

    // Convert the node to a string representation
    virtual String ToString() const;

    // Clones a node
    virtual SyntaxNode* Clone() const = 0;

    // Populates an array with the children of this node
    virtual void PopulateChildren(NodeChildren& childrenOut);

    // Populates an array with the non-traversed children of this node
    virtual void PopulateNonTraversedChildren(NodeChildren& childrenOut);

    // Populates an array with SyntaxTypes (we walk all children and single out those that inherit from SyntaxType)
    virtual void PopulateSyntaxTypes(SyntaxTypes& typesOut);

    // Fix all the parent pointers so they point up to their parents
    static void FixParentPointers(SyntaxNode* node, SyntaxNode* parent);

    // Get the merged/trimmed comments for this node
    String GetMergedComments();

  protected:

    // Destroys all the children (used for cleanup)
    void DestroyChildren();

  private:

    // Directly add a child (regardless of lock mode)
    void DirectAdd(SyntaxNode* node);

    // Directly remove a child (regardless of lock mode)
    void DirectRemove(SyntaxNode* node);

  public:

    // Store the parent pointer
    SyntaxNode* Parent;

    // The location that the syntax node originated from
    CodeLocation Location;

    // Any comments collected for this syntax node (used for documentation / translation)
    StringArray Comments;
  };

  // A pre-type representation for the syntax tree
  class SyntaxType : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(SyntaxType, SyntaxNode);

    // Constructor
    SyntaxType();

    // Tells us if a particular declarations of a syntax type is a template instantiation
    virtual bool IsTemplateInstantiation() const;

    // Whatever type this syntax type resovled to
    Type* ResolvedType;
  };

  class AnySyntaxType : public SyntaxType
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(AnySyntaxType, SyntaxType);
    ZilchClonableNode(AnySyntaxType);

    // SyntaxType interface
    String ToString() const override;
  };

  class IndirectionSyntaxType : public SyntaxType
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IndirectionSyntaxType, SyntaxType);
    ZilchClonableNode(IndirectionSyntaxType);

    // Constructor
    IndirectionSyntaxType();

    // The syntax type that we refer to
    SyntaxType* ReferencedType;

    // SyntaxType interface
    String ToString() const override;
    virtual void PopulateChildren(NodeChildren& childrenOut);
  };

  class BoundSyntaxType : public SyntaxType
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(BoundSyntaxType, SyntaxType);
    ZilchClonableNode(BoundSyntaxType);

    // Store the name of the type
    String TypeName;

    // Template arguments (if we have any)
    SyntaxTypeList TemplateArguments;
    
    // SyntaxType interface
    bool IsTemplateInstantiation() const override;
    String ToString() const override;
    virtual void PopulateChildren(NodeChildren& childrenOut);
  };

  // A parameter that belongs inside of a delegate declaration
  class DelegateSyntaxParameter
  {
  public:
    // Constructor
    DelegateSyntaxParameter();

    // A parameter generally has a name
    const UserToken* Name;

    // A parameter also has a type
    SyntaxType* Type;
  };

  class DelegateSyntaxType : public SyntaxType
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DelegateSyntaxType, SyntaxType);
    ZilchClonableNode(DelegateSyntaxType);

    // Constructor
    DelegateSyntaxType();

    // Template arguments (if we have any)
    SyntaxTypeList TemplateArguments;

    // Store the variable types as well as thier names
    Array<DelegateSyntaxParameter> Parameters;

    // The return type of the delegate (or null for no return type)
    SyntaxType* Return;
    
    // SyntaxType interface
    bool IsTemplateInstantiation() const override;
    String ToString() const override;
    virtual void PopulateChildren(NodeChildren& childrenOut);
  };

  // Whether or not we're virtual or overriding
  namespace VirtualMode
  {
    enum Enum
    {
      NonVirtual,
      Virtual,
      Overriding
    };
  }

  // A root node is the root of a syntax tree
  class RootNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(RootNode, SyntaxNode);
    ZilchClonableNode(RootNode);

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Store all the root level classes
    NodeList<ClassNode> Classes;

    // Store all the root level enums
    NodeList<EnumNode> Enums;

    // Contains all classes, enums, etc in the order they are declared
    NodeList<SyntaxNode> NonTraversedNonOwnedNodesInOrder;
  };

  // An attribute that can be attached to classes, functions, member variables, etc
  class AttributeNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(AttributeNode, SyntaxNode);
    ZilchClonableNode(AttributeNode);

    // Default constructor
    AttributeNode();

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The attribute type name
    const UserToken* TypeName;

    // An optional node for when the user wants to pass parameters to an attribute
    FunctionCallNode* AttributeCall;
  };

  // A statement node represents any kind of statement
  class StatementNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(StatementNode, SyntaxNode);

    // Returns if the given node is used as a statement
    // For example: Expressions are statements, but are only considered
    // being used as a statement when they appear alone, eg 'i += 5;'
    static bool IsNodeUsedAsStatement(SyntaxNode* node);

    // Clones a node
    virtual StatementNode* Clone() const = 0;
  };

  // An evaluatable node represents anything that can be evaluated into a value (expressions, function calls, values, etc)
  class ExpressionNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ExpressionNode, StatementNode);

    // Constructor
    ExpressionNode();

    // Clones a node
    virtual ExpressionNode* Clone() const = 0;

    // Store the type along with the expression (this will be filled in later)
    Type* ResultType;

    // Stores how we access this particular expression (stack, member, etc)
    Operand Access;

    // How people are allowed to use this value
    IoMode::Enum Io;

    // How it is trying to be used by it's parent node
    // If this value conflicts with the node's IO mode, then it will result in an error
    // This value is also used to determine whether we call the get/set or both for properties
    IoMode::Enum IoUsage;

    // This determines whether or not this node is being used as a statement
    // See 'IsNodeUsedAsStatement' on StatementNode
    bool IsUsedAsStatement;
  };

  // A binary-operator node represents a binary operator and its operands
  class BinaryOperatorNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(BinaryOperatorNode, ExpressionNode);
    ZilchClonableNode(BinaryOperatorNode);

    // Constructor
    BinaryOperatorNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The left and right arguments that the binary operator is being applied to
    ExpressionNode* LeftOperand;
    ExpressionNode* RightOperand;

    // All the info we need about the operator (filled out by the syntaxer)
    BinaryOperator OperatorInfo;

    // The operator that tells us what kind of binary operation this is
    const UserToken* Operator;
  };

  // A unary-operator node represents a unary operator and its operand
  class UnaryOperatorNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(UnaryOperatorNode, ExpressionNode);
    ZilchClonableNode(UnaryOperatorNode);

    // Constructor
    UnaryOperatorNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The single argument of the unary operator
    ExpressionNode* Operand;

    // All the info we need about the operator
    UnaryOperator OperatorInfo;

    // The operator that tells us what kind of unary operation this is
    const UserToken* Operator;
  };

  // A unary-operator node represents a unary operator and its operand
  class PropertyDelegateOperatorNode : public UnaryOperatorNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(PropertyDelegateOperatorNode, UnaryOperatorNode);
    ZilchClonableNode(PropertyDelegateOperatorNode);

    // Constructor
    PropertyDelegateOperatorNode();

    // The property we're associated with
    Property* AccessedProperty;
  };

  // A type-cast node represents a type cast from an expression to a specified type
  class TypeCastNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TypeCastNode, ExpressionNode);
    ZilchClonableNode(TypeCastNode);

    // Constructor
    TypeCastNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The type of cast operation we do
    CastOperator OperatorInfo;

    // Store the expression that will be casted
    ExpressionNode* Operand;

    // Name of the type that we represent
    SyntaxType* Type;
  };


  // A post expression node represents right hand operators (call, indexer, access, etc)
  class PostExpressionNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(PostExpressionNode, ExpressionNode);

    // Constructor
    PostExpressionNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Post expressions are special expressions that come after an operand
    ExpressionNode* LeftOperand;
  };

  // An indexer call node represents a list of passed in arguments used in an indexer call
  class IndexerCallNode : public PostExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IndexerCallNode, PostExpressionNode);
    ZilchClonableNode(IndexerCallNode);
    
    // Constructor
    IndexerCallNode();

    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The list of arguments, provided in order, to the indexer
    NodeList<ExpressionNode> Arguments;

    // The indexer can end up invoking just the Get, or Get and then Set, or just Set
    // The parser generates all three possibilities, and the Syntaxer chooses the correct
    // one based on the usage (compound operators such as += will chosee the GetSet version, but = will just choose Set)
    // The above arguments actually get cloned into each of these possibilities
    // In the future, we may try and reduce this so not all of these have to be generated (its a lot of extra data)
    MultiExpressionNode* Get;
    MultiExpressionNode* GetSet;
    MultiExpressionNode* Set;
  };

  // A function call node represents a list of passed in arguments used in a function call
  class FunctionCallNode : public PostExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(FunctionCallNode, PostExpressionNode);
    ZilchClonableNode(FunctionCallNode);

    // Constructor
    FunctionCallNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // If the left operand is a local variable whose initializer is a creation call node, this will return that node
    StaticTypeNode* FindCreationCall();

    // An array of all the names given to the arguments
    // Empty if we're doing a standard call
    StringArray ArgumentNames;

    // Store the actual expressions passed in for each argument
    NodeList<ExpressionNode> Arguments;

    // Maps the arguments in their passed in order to the actual argument order of the function
    Array<size_t> ArgumentMap;

    // If the call is done in named style, then we have no argument names
    bool IsNamed;
  };

  namespace MemberAccessType
  {
    enum Enum
    {
      Invalid,
      Field,
      Property,
      Function,
      Dynamic
    };
  }

  // A member-access node represents accessing a member / field
  class MemberAccessNode : public PostExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(MemberAccessNode, PostExpressionNode);
    ZilchClonableNode(MemberAccessNode);

    // Constructor
    MemberAccessNode();
    
    // SyntaxNode interface
    String ToString() const override;

    // The name that we're accessing
    String Name;

    // If this is a static access
    bool IsStatic;

    // The operator used to access (eg '.')
    Grammar::Enum Operator;

    // The type of member we're accessing
    MemberAccessType::Enum MemberType;
    
    // If this node is a property access node, then this refers to which property
    Property* AccessedProperty;

    // If this node is a field access node, then this refers to which field
    Field* AccessedField;

    // This is needed since a function can actually be overloaded
    const FunctionArray* OverloadedFunctions;
    Function* AccessedFunction;
  };

  // Lets us get the runtime type object that describes a type
  class TypeIdNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TypeIdNode, ExpressionNode);
    ZilchClonableNode(TypeIdNode);

    // Constructor
    TypeIdNode();

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The syntax type that we need runtime type identification for
    // This may be null if the 'value' expression node is set
    SyntaxType* CompileTimeSyntaxType;

    // The expression we need to get the type of
    // This may be null if a sytax type is set!
    ExpressionNode* Value;

    // The type we resolved for the expression or static type given to
    // typeid at compile time. In the case of handles and delegates,
    // the type will be resolved further in opcode
    Type* CompileTimeType;
  };

  namespace CreationMode
  {
    enum Enum
    {
      Invalid,
      New,
      Local
    };
  }

  // Used when we access static members as well as invoking constructors (could be after new/local, or just by itself)
  class StaticTypeNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(StaticTypeNode, ExpressionNode);
    ZilchClonableNode(StaticTypeNode);

    // Constructor
    StaticTypeNode();

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;
    
    // The syntax type that we are accessing
    BoundSyntaxType* ReferencedSyntaxType;

    // The type we resolve to what we're accessing
    BoundType* ReferencedType;
    
    // The below members are ONLY used if this node is being used in a constructor call:
    // The token we used to create this (new, local, etc)
    CreationMode::Enum Mode;

    // The constructor we're running, or null for pre-constructor only
    const FunctionArray* OverloadedConstructors;
    Function* ConstructorFunction;

    // We always create a handle to the type; for example, new always returns a handle, and we
    // always need a handle for preconstructor and constructor calls, even on local objects
    OperandIndex ThisHandleLocal;
  };

  // When we want to initialize a type we can also initialize particular members
  class ExpressionInitializerMemberNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ExpressionInitializerMemberNode, SyntaxNode);
    ZilchClonableNode(ExpressionInitializerMemberNode);

    // Constructor
    ExpressionInitializerMemberNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The name of the member that we're initializing
    UserToken MemberName;

    // The value that we want to initialize the member to
    ExpressionNode* Value;
  };

  // When we want to initialize a type we can also add values to it (generally for containers)
  class ExpressionInitializerAddNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ExpressionInitializerAddNode, SyntaxNode);
    ZilchClonableNode(ExpressionInitializerAddNode);
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // These arguments get directly passed in to a call to add on the given container
    NodeList<ExpressionNode> Arguments;
  };
  
  // When we want to initialize a type (either a container, with .Add calls, or members of a class / properties)
  class ExpressionInitializerNode : public PostExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ExpressionInitializerNode, PostExpressionNode);
    ZilchClonableNode(ExpressionInitializerNode);

    // Constructor
    ExpressionInitializerNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // All the elements we want to add to the container (by literally invoking .Add)
    NodeList<ExpressionInitializerAddNode> AddValues;

    // All the members we want to initialize
    NodeList<ExpressionInitializerMemberNode> InitailizeMembers;

    // The above element expressions get translated directly into statements
    // This is primarily used for code generation (the above is just syntactic sugar)
    // For example, for the 'add values' to a container, it gets translated into object.Add(value, value...)
    // Member initializers get translated into object.MemberName = value;
    // Warning: many of these nodes point unsafely at another node above in the tree (eg at the creation call itself)
    NodeList<ExpressionNode> InitializerStatements;
  };
  
  // A multi-expression contains multiple expressions but only yields the results of one of them (done by index)
  class MultiExpressionNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(MultiExpressionNode, ExpressionNode);
    ZilchClonableNode(MultiExpressionNode);

    // Constructor
    MultiExpressionNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // All the expressions that the multi-expression will execute
    NodeList<ExpressionNode> Expressions;

    // An index into the array of expressions that controls what this expression results in
    // Basically we just forward our ResultType and Access to that node
    // It is an error to leave this index unset
    size_t YieldChildExpressionIndex;

    // Initialize the yield index to this (we will internal error in the Syntaxer if this is still set)
    static const size_t InvalidIndex = (size_t)-1;
  };

  // A variable node represents any variable declaration
  class VariableNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(VariableNode, ExpressionNode);

    // Constructor
    VariableNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Check if the node is inferred (denoted by ResultSyntaxType being null)
    bool IsInferred() const;

    // Store the variable name
    UserToken Name;

    // The initial value assigned to the variable
    ExpressionNode* InitialValue;

    // Is the variable static?
    bool IsStatic;

    // Name of the type that we represent
    SyntaxType* ResultSyntaxType;
  };

  // A local variable node represents a local variable declaration (such as one inside a function)
  class LocalVariableNode : public VariableNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(LocalVariableNode, VariableNode);
    ZilchClonableNode(LocalVariableNode);

    // Constructor
    LocalVariableNode();

    // Constructor to generate a unique local variable node
    // This case is generally for when we want to wrap a local stack value with a name we can lookup later
    // We're typically using the local variable as an expression that wraps the intial value
    LocalVariableNode(StringParam baseName, Project* parentProject, ExpressionNode* optionalInitialValue);

    // Store a pointer that gives information about the local variable
    Variable* CreatedVariable;

    // If this is set, it means this local variable will not generate temporary space, but instead
    // will directly forward access to its initial value expression (requires the initial value to exist!)
    bool ForwardLocalAccessIfPossible;

    // A pointer to the attributes this function has
    NodeList<AttributeNode> Attributes;

    // In cases where we generate a temporary (such as creation call nodes for initializer lists, indexers, etc)
    // we will create a local variable node as an expression that need not be walked by formatters and translators
    bool IsGenerated;
  };

  // A parameter node represents the parameter of a function
  class ParameterNode : public LocalVariableNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ParameterNode, LocalVariableNode);
    ZilchClonableNode(ParameterNode);

    // Constructor
    ParameterNode();

    // Which parameter this is in the function
    size_t ParameterIndex;
  };

  // A member variable node represents a member variable declaration (such as one inside a class)
  class MemberVariableNode : public VariableNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(MemberVariableNode, VariableNode);
    ZilchClonableNode(MemberVariableNode);
    
    // Constructor
    MemberVariableNode();

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Store the associated member on this node
    Field* CreatedField;
    Property* CreatedProperty;

    // Store the parent class type
    BoundType* ParentClassType;

    // Store the resulting type of the node
    Type* ResultType;

    // The get and set functions for this variable
    // Only valid for properties, we always know that either the get or set will exist (or both)
    FunctionNode* Get;
    FunctionNode* Set;

    // Whether or not this is a property
    // Note that this also tells us if the get/set are generated
    bool IsProperty;

    // A pointer to the attributes this function has
    NodeList<AttributeNode> Attributes;

    // If this is an extension method, this will be the new owner of the method
    BoundSyntaxType* ExtensionOwner;

    // Is the function a virtual function (or overriding)?
    VirtualMode::Enum Virtualized;
  };

  // A value node represents any constant or identifier value
  class ValueNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ValueNode, ExpressionNode);
    ZilchClonableNode(ValueNode);

    // Constructor
    ValueNode();
    
    // SyntaxNode interface
    String ToString() const override;

    // Store the token that represents the value
    UserToken Value;
  };

  // String interpolants are basically advanced efficient string concatenations with values
  class StringInterpolantNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(StringInterpolantNode, ExpressionNode);
    ZilchClonableNode(StringInterpolantNode);

    // Constructor
    StringInterpolantNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // All the elements of the interpolant, in order of concatenation
    // The elements will be converted into string types during the interpolation
    NodeList<ExpressionNode> Elements;
  };

  // A delete node represents explicit deletion of an object
  class DeleteNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DeleteNode, StatementNode);
    ZilchClonableNode(DeleteNode);

    // Constructor
    DeleteNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The object that we'd like to delete
    ExpressionNode* DeletedObject;
  };

  // An return node represents the return statement for a function
  class ReturnNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ReturnNode, StatementNode);
    ZilchClonableNode(ReturnNode);

    // Constructor
    ReturnNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Store the expression that is to be returned by this statement
    ExpressionNode* ReturnValue;

    // If this is a debug return, then we will ignore flow control errors
    bool IsDebugReturn;
  };

  // A scope node represends a type of scope
  class ScopeNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ScopeNode, StatementNode);
    ZilchClonableNode(ScopeNode);

    // Constructor
    ScopeNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The statements executed if the condition is met
    NodeList<StatementNode> Statements;

    // Tells us if this is a closed path
    // Note that if the processed statements mark this node
    // as being a full return, then the scope node itself
    // needs to report to its parent scope that it is a full return
    bool AllPathsReturn;
    bool IsDebugReturn;

    // Any variables that belong to this scope
    VariableMap ScopedVariables;
  };

  // Allows code to run for a period of time before it throws an exception and 'times out'
  class TimeoutNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TimeoutNode, ScopeNode);
    ZilchClonableNode(TimeoutNode);

    // Constructor
    TimeoutNode();

    // The number of seconds that the timeout will last for
    size_t Seconds;
  };

  // An if node represents the if-then else-if else construct
  class IfNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IfNode, ScopeNode);
    ZilchClonableNode(IfNode);

    // Constructor
    IfNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Marks whether this is the first part of the if statement (not an else if or else)
    bool IsFirstPart;

    // The conditional expression used in this if statement
    // Non null for all if elses, and only the last CAN be null, but may not be null!
    ExpressionNode* Condition;
  };

  // We hold all parts of the if as children
  class IfRootNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IfRootNode, StatementNode);
    ZilchClonableNode(IfRootNode);

    // Constructor
    IfRootNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // All parts of the if statement
    // The first node in this list is the if itself (not an else!)
    // All nodes after that are 'else if' nodes and have conditions, except
    // the last one can omit the condition and be just an 'else' node
    NodeList<IfNode> IfParts;
  };

  // Declares that a class sends a particular type of event
  class SendsEventNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(SendsEventNode, SyntaxNode);
    ZilchClonableNode(SendsEventNode);

    // Constructor
    SendsEventNode();

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The type of event we send
    SyntaxType* EventType;

    // The name of the event we send
    const UserToken* Name;

    // The static property that allows users access to the event (string type)
    Property* EventProperty;
  };

  // An break node represents the break statement in a loop
  class BreakNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(BreakNode, StatementNode);
    ZilchClonableNode(BreakNode);

    // Constructor
    BreakNode();

    // How many scopes we wish to break out of (default 1)
    size_t ScopeCount;

    // The instruction index for where the jump occurs
    size_t InstructionIndex;

    // The jump opcode that's associated with our continue (where we jump to)
    // We need to store this so that, after we build code for a function, we can
    // come back to this statement and setup the jump to the end of the loop
    RelativeJumpOpcode* JumpOpcode;
  };

  // An break node represents a debug breakpoint in the virtual machine
  class DebugBreakNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DebugBreakNode, StatementNode);
    ZilchClonableNode(DebugBreakNode);
  };

  // An continue node represents the continue statement in a loop
  class ContinueNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ContinueNode, StatementNode);
    ZilchClonableNode(ContinueNode);

    // Constructor
    ContinueNode();

    // The instruction index for where the jump occurs
    size_t InstructionIndex;

    // The jump opcode that's associated with our continue (where we jump to)
    // We need to store this so that, after we build code for a function, we can
    // come back to this statement and setup the jump to the end of the loop
    RelativeJumpOpcode* JumpOpcode;
  };

  // Represents throwing an exception in langugae
  class ThrowNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ThrowNode, StatementNode);
    ZilchClonableNode(ThrowNode);

    // Constructor
    ThrowNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The exception to be thrown
    ExpressionNode* Exception;
  };

  // A loop scope is a scope that we can break out of or continue from
  class LoopScopeNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(LoopScopeNode, ScopeNode);

    // Default constructor
    LoopScopeNode();

    // Copy constructor
    LoopScopeNode(const LoopScopeNode& toCopy);

    // Store a list of any break statements that are targeted at us
    Array<BreakNode*> Breaks;

    // Store a list of any continue statements that are targeted at us
    Array<ContinueNode*> Continues;
  };

  // A loop that contains a conditional expression
  class ConditionalLoopNode : public LoopScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ConditionalLoopNode, LoopScopeNode);

    // Constructor
    ConditionalLoopNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The conditional expression used in this if statement
    ExpressionNode* Condition;
  };

  // A while node represents the a while loop
  class WhileNode : public ConditionalLoopNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(WhileNode, ConditionalLoopNode);
    ZilchClonableNode(WhileNode);
  };

  // A do-while node represents the a do-while loop
  class DoWhileNode : public ConditionalLoopNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DoWhileNode, ConditionalLoopNode);
    ZilchClonableNode(DoWhileNode);
  };

  // A for node represents the a for loop
  class ForNode : public ConditionalLoopNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ForNode, ConditionalLoopNode);
    ZilchClonableNode(ForNode);

    // Constructor
    ForNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The creation of the variable (the first part)
    LocalVariableNode* ValueVariable;

    // Only used in the case of 'foreach' to store a temporary range variable
    LocalVariableNode* RangeVariable;

    // Alternative, instead of a variable we could have an initialization expression
    ExpressionNode* Initialization;

    // The iterator expression of the for loop (the last part)
    ExpressionNode* Iterator;
  };

  // A for node represents the a for loop
  class ForEachNode : public ForNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ForEachNode, ForNode);
    ZilchClonableNode(ForEachNode);

    // Constructor
    ForEachNode();
    
    // SyntaxNode interface
    void PopulateNonTraversedChildren(NodeChildren& childrenOut) override;
    
    // The original variable that was declared
    // This is not used by the Syntaxer or CodeGenerator (only there for translation and other purposes)
    LocalVariableNode* NonTraversedVariable;

    // The original range we used (eg, array.All)
    // This is not used by the Syntaxer or CodeGenerator (only there for translation and other purposes)
    ExpressionNode* NonTraversedRange;
  };

  // A loop node represents the a loop
  class LoopNode : public LoopScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(LoopNode, LoopScopeNode);
    ZilchClonableNode(LoopNode);
  };

  // A generic function only takes parameters, has no returns and is not marked as static
  class GenericFunctionNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(GenericFunctionNode, ScopeNode);

    // Constructor
    GenericFunctionNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The name of the function (including 'constructor', 'destructor', 'get', and 'set')
    UserToken Name;

    // A genetated type for this function (the type is the signature type)
    DelegateType* Type;

    // The function definition that this node represents (will be filled in later)
    Function* DefinedFunction;

    // The parameters defined for the function (names, types, defaults, etc)
    NodeList<ParameterNode> Parameters;

    // A pointer to the attributes this function has
    NodeList<AttributeNode> Attributes;

    // For auto-complete, one of the methods we use is to build a psuedo class and function
    // that we evaluate expressions within. This works for most expressions, except when the
    // expression relies upon the 'this' variable, in which the type would result in the pseudo class
    // Therefore, we actually replace the type with the old previously compiled version if it exists
    //BoundType* SubstituteTypeOfThisVariable;
  };

  // A function node represent the definition of a function
  class FunctionNode : public GenericFunctionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(FunctionNode, GenericFunctionNode);
    ZilchClonableNode(FunctionNode);

    // Constructor
    FunctionNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The return type of the function (or null if there is none)
    SyntaxType* ReturnType;

    // If this is an extension method, this will be the new owner of the method
    BoundSyntaxType* ExtensionOwner;

    // Is the function a static function?
    bool IsStatic;

    // Is the function a virtual function (or overriding)?
    VirtualMode::Enum Virtualized;
  };

  // Note that represents an initializer in the initailizer list
  class InitializerNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(InitializerNode, ExpressionNode);
    ZilchClonableNode(InitializerNode);

    // Constructor
    InitializerNode();
    
    // Whatever it is we're initializing (this or base)
    const UserToken* InitializerType;

    // The function that this initializer invoke
    Function* InitializerFunction;
  };

  // A constructor is a specialized function for creating and initializing an object
  class ConstructorNode : public GenericFunctionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ConstructorNode, GenericFunctionNode);
    ZilchClonableNode(ConstructorNode);

    // Constructor
    ConstructorNode();

    // These are not owned initializers (technically the first statements in the constructor own them)
    // Hence we do not override 'PopulateChildren' and output these
    // If the initializers exist as the first statements, these MUST be set to be a valid tree
    // The presense of the base initializer tells us if we initialized our base or not
    InitializerNode* BaseInitializer;
    InitializerNode* ThisInitializer;
  };

  // A destructor is a specialized function for destroying an object
  class DestructorNode : public GenericFunctionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DestructorNode, GenericFunctionNode);
    ZilchClonableNode(DestructorNode);
  };

  // A class node represents the definition of a class
  // The class is a scope node itself because of the pre-constructor and member variable initialization
  class ClassNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ClassNode, ScopeNode);
    ZilchClonableNode(ClassNode);

    // Constructor
    ClassNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The name of the class
    UserToken Name;

    // If the node represents a value type or not
    TypeCopyMode::Enum CopyMode;

    // The resolved type of the class
    BoundType* Type;

    // The names of the parent types
    SyntaxTypeList Inheritance;

    // Any template arguments
    Array<const UserToken*> TemplateArguments;

    // A list of member variables defined in the class
    NodeList<MemberVariableNode> Variables;

    // A list of functions defined in the class
    NodeList<FunctionNode> Functions;

    // A list of constructors defined in the class
    NodeList<ConstructorNode> Constructors;

    // A list of events that we send
    NodeList<SendsEventNode> SendsEvents;

    // A singular destructor
    DestructorNode* Destructor;

    // Contains all types of members that a class can have in the order they are declared (generally used for formatting)
    NodeList<SyntaxNode> NonTraversedNonOwnedNodesInOrder;

    // This function basically acts as a constructor that initializes all the members before we run the invoked constructor
    Function* PreConstructor;

    // A pointer to the attributes this class has
    NodeList<AttributeNode> Attributes;

    // Only valid when the class is a templated class
    // This is used for when the syntax tree for the class gets cloned
    // in order to make a template instantiation
    // (this is how we know it is a clone and not the original source!)
    const BoundSyntaxType* TemplateInstantiation;

    // Check if this class is a templated class
    bool IsTemplate() const;
  };

  // An enum value declared within an enum
  class EnumValueNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(EnumValueNode, SyntaxNode);
    ZilchClonableNode(EnumValueNode);

    // Constructor
    EnumValueNode();

    // SyntaxNode interface
    String ToString() const override;

    // The name of the value
    UserToken Name;
    
    // The integral value of this entry (or null if there is no user set value)
    const UserToken* Value;

    // The actual value assigned to this enum entry (Syntaxer)
    Integer IntegralValue;

    // The static property that we use at runtime to get the value
    Property* IntegralProperty;
  };

  // An enum node represents constant integral values that count up (or bitwise flags)
  class EnumNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(EnumNode, SyntaxNode);
    ZilchClonableNode(EnumNode);

    // Constructor
    EnumNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The name of the enum
    UserToken Name;

    // Whether or not this enum is considered to be flags
    // Flags allow operations such as bitwise or/and/xor
    bool IsFlags;

    // The resolved type of the enum
    BoundType* Type;

    // The names of the parent type, or null if we don't have one
    SyntaxType* Inheritance;

    // A list of enum values (integral constants)
    // These values may have a user set value or may be auto-picked
    NodeList<EnumValueNode> Values;

    // A pointer to the attributes this class has
    NodeList<AttributeNode> Attributes;
  };

  // A type-define node represnts 
  class TypeDefineNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TypeDefineNode, SyntaxNode);
    ZilchClonableNode(TypeDefineNode);

    // Constructor
    TypeDefineNode();

    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The name that we're giving the type-definition
    const UserToken* Name;

    // The type that we represent
    SyntaxType* Type;
  };

  // A local variable reference node replaces a generic identifier node
  class LocalVariableReferenceNode : public ValueNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(LocalVariableReferenceNode, ValueNode);
    ZilchClonableNode(LocalVariableReferenceNode);

    // Constructor
    LocalVariableReferenceNode();

    // SyntaxNode interface
    String ToString() const override;

    // Store a reference to the variable
    Variable* AccessedVariable;
  };
}

// End header protection
#endif


namespace Zilch
{
  namespace Events
  {
    // Sent before we even begin parsing (the library builder should be generally empty)
    // This is an ideal place to add new types to this builder that our parsed Zilch code may depend upon
    ZilchDeclareEvent(PreParser, ParseEvent);

    // Sent when the parsing engine parses a type
    // This event occurs before any members or functions are parsed, which makes it an ideal place
    // to dynamically add members (such as component properties like .RigidBody or .Transform to a composition)
    ZilchDeclareEvent(TypeParsed, ParseEvent);

    // Sent when the engine finishes syntax checking on the abstract syntax tree (but before code generation)
    // Note: Any types added in this phase will NOT be able to be used by the Zilch scripts
    // Note: None of the code from the library should be executed at this time
    ZilchDeclareEvent(PostSyntaxer, ParseEvent);
  }

  // An even that it sent out from parsing (such as when a type is parsed)
  class ZeroShared ParseEvent : public EventData
  {
  public:
    ParseEvent();
    LibraryBuilder* Builder;
    BoundType* Type;
    CodeLocation* Location;
  };

  // A completion is an entry in the auto complete list
  class CompletionEntry
  {
  public:
    // The comparison operator allows us to easily sort entries by name, type, longest description length, and finally description
    bool operator<(const CompletionEntry& rhs) const;

    // The name to show in the auto-complete list
    String Name;

    // A description provided by user comments or loaded documentation (for overloads, this is the first description)
    String Description;

    // The whole type name or delegate signature
    String Type;

    // The shorter version of the type name (limited to AutoCompleteInfo::ShortTypeNameMaxLength, usually around 20)
    String ShortType;
  };

  // A parameter in a function overload
  class CompletionParameter
  {
  public:
    // Constructor
    CompletionParameter();

    // The name of the parameter
    String Name;

    // The parameter's description (or empty if it doesn't have one, which is very common)
    String Description;

    // The type of the parameter stringified
    String Type;

    // The shorter version of the parameter's type name (limited to AutoCompleteInfo::ShortTypeNameMaxLength, usually around 20)
    String ShortType;

    // If a name is not provided, we generate one based on the type and the position of the parameter
    bool IsNameGenerated;
  };

  // When showing all the overloads for a function call, this is basically the signature and description
  // Note that we don't sort overloads because their order is actually important to Zilch
  class CompletionOverload
  {
  public:
    // All the parameters in the overload (with types and optional names/descriptions)
    Array<CompletionParameter> Parameters;

    // The description for this overload
    String Description;

    // The return type of the overload (or empty for Void)
    String ReturnType;

    // A shortened version of the return type (or empty for Void, limited to AutoCompleteInfo::ShortTypeNameMaxLength, usually around 20)
    String ReturnShortType;

    // The entire stringified signature of the overload in standard delegate format (with parameter names if applicable)
    String Signature;
  };

  // Returned when we perform an auto-complete query on the Project
  class AutoCompleteInfo
  {
  public:
    // The maximum length for generated short types
    static const size_t ShortTypeNameMaxLength = 20;

    // Constructor
    AutoCompleteInfo();

    // Generates a short type name from a full type name by taking the first word out of the type
    // If the name is still too long, then it truncates it with a trailing elipsis '...'
    static String GetShortTypeName(StringParam fullTypeName);

    // By default, we remove all duplicate completion entries (we sort by name/type and we keep ones with the longest description)
    bool RemoveDuplicateNameEntries;

    // Whether the completion query was successful at finding anything
    bool Success;
    
    // The nearest type we found to the left of the cursor (can be null if we were unable to find it)
    Type* NearestType;

    // If the value we're accessing is a literal value (such as "hello", 5, 3.3, true, false, etc)
    // If the NearestType is Integer and its a literal and the user is pressing '.', most IDEs will ignore this and not show auto-complete
    // The reason is that the user may be typing a Real value in after the '.' (eg 5.678)
    bool IsLiteral;

    // Whether or not we were accessing statics or instance members of the type
    bool IsStatic;

    // A convenient array of completion names and descriptions to show in any text editor (sorted by name)
    Array<CompletionEntry> CompletionEntries;

    // The name of the function when overloads are involved
    // If the overloads are generated from a delegate, the name will be "delegate"
    String FunctionName;

    // When performing a function call these are all the possible overloads that we should show (also works on single delegates)
    // This includes descriptions, parameter names, and the types
    Array<CompletionOverload> CompletionOverloads;

    // If any text editor is incapable of showing an overload resolution list (with classic up down arrows to change between overloads)
    // then the editor is recommended to show this the overload at this index
    // This will attempt to choose the first overload with a description, or it will choose the first overload (will be -1 if there are no overloads)
    int BestCompletionOverload;

    // In the case that we were accessing overloaded functions, these are our options
    FunctionArray FunctionOverloads;

    // We build an incomplete library to keep references to types alive
    LibraryRef IncompleteLibrary;

    // Turns the auto complete information to a Json format (typically used for reading by other external applications)
    String GetJson();
  };

  // Returned when we perform an definition query on the Project
  class DefinitionInfo
  {
  public:
    // Constructor
    DefinitionInfo();

    CodeLocation ElementLocation;
    CodeLocation NameLocation;

    Variable* DefinedVariable;
    Function* DefinedFunction;
    Property* DefinedProperty;
    Field* DefinedField;

    Type* ResolvedType;

    // We build an incomplete library to keep references to types alive
    LibraryRef IncompleteLibrary;
  };

  // The project contains all the files that are being compiled together
  class ZeroShared Project : public CompilationErrors
  {
  public:
    friend class Debugger;

    // Constructor
    Project();

    // Adds a code to the project
    // The origin is the display name (typically the file name)
    // Any time any error occurs with compilation, or anything that references
    // this particular block of code will be linked up to the code user-data
    void AddCodeFromString(StringParam code, StringParam origin = CodeString, void* codeUserData = nullptr);

    // Adds code from a file (see AddCode)
    // Returns true if it succeeded, false otherwise
    bool AddCodeFromFile(StringParam fileName, void* codeUserData = nullptr);

    // Clears out the project (removes all code strings/files, plugin directories, plugin files, etc)
    void Clear();

    // Reads a text file into a string, returns true on success, false on failure
    static bool ReadTextFile(StringParam fileName, String& textOut);

    // Tokenizes all files into a token stream
    bool Tokenize(Array<UserToken>& tokensOut, Array<UserToken>& commentsOut);

    // Attach all the parsed comments to the syntax tree nodes that are nearby
    void AttachCommentsToNodes(SyntaxTree& syntaxTree, Array<UserToken>& comments);

    // Compiles the project into an unchecked syntax tree (only parsed)
    bool CompileUncheckedSyntaxTree(SyntaxTree& syntaxTreeOut, Array<UserToken>& tokensOut, EvaluationMode::Enum evaluation);

    // Compiles the project into a checked syntax tree
    bool CompileCheckedSyntaxTree
    (
      SyntaxTree& syntaxTreeOut,
      LibraryBuilder& builder,
      Array<UserToken>& tokensOut,
      const Module& dependencies,
      EvaluationMode::Enum evaluation
    );

    // Compiles the project into a single library and also returns the syntax tree
    LibraryRef Compile(StringParam libraryName, Module& dependencies, EvaluationMode::Enum evaluation, SyntaxTree& treeOut);

    // Compiles the project into a single library
    LibraryRef Compile(StringParam libraryName, Module& dependencies, EvaluationMode::Enum evaluation);

    // Attempt to compile the code in tolerant mode, and return the type nearest to the left hand side of a given cursor
    // This function is generally used for auto-completion lists and will attempt to return the type left of the cursor
    // The minimum code you can provide to the project is a single class (the one that the cursor is inside of, typically the whole file being edited)
    // The old library can be a nullptr, however it is generally recommended to provide it if it has previously been compiled
    // since it will allow the auto-completer to resolve local types too
    void GetAutoCompleteInfo(Module& dependencies, size_t cursorPosition, StringParam cursorOrigin, AutoCompleteInfo& resultOut);

    // For every usage of an identifier there is a location where we defined that identifier (variable definiiton, member, type, etc)
    // This gets the defintion location (and the actual resulting definition object) of whatever is under the cursor
    void GetDefinitionInfo(Module& dependencies, size_t cursorPosition, StringParam cursorOrigin, DefinitionInfo& resultOut);

  public:

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructibleBuffer ComplexUserData;

    // If a variable needs to generate a unique name that will be guaranteed to never conflict with
    // any other local variables within the function, then we use this counter as a unique id
    size_t VariableUniqueIdCounter;

    // We will automatically attempt to load plugins from these directories
    Array<String> PluginDirectories;

    // We will also attempt to load these specific plugin files
    Array<String> PluginFiles;

  private:

    // Loads all the plugins into the given library builder
    void LoadPlugins(LibraryBuilder& builder, Module& dependencies);

    // Setup the location and the name for a found definition
    void InitializeDefinitionInfo(DefinitionInfo& resultOut, DocumentedObject* object);

    // Get auto complete information (but doesn't parse it into completions)
    void GetAutoCompleteInfoInternal(Module& dependencies, size_t cursorPosition, StringParam cursorOrigin, AutoCompleteInfo& resultOut);

    // Creates a completion for an overload using only the delegate type (generally used when performing a call)
    CompletionOverload& AddAutoCompleteOverload(AutoCompleteInfo& info, DelegateType* delegateType);

  private:

    // All the code that makes up this project
    Array<CodeEntry> Entries;

    // A special constant that means we don't have a cursor
    static const size_t NoCursor = (size_t)-1;

    // When attempting to generate code-completion, this is the cursor position for the user
    String CursorOrigin;
    size_t CursorPosition;

    // Not copyable
    ZilchNoCopy(Project);
  };
}

// End header protection
#endif







/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_CONSOLE_HPP
#define ZILCH_CONSOLE_HPP

// Includes




namespace Zilch
{
  namespace Events
  {
    // Sent when anyone prints to the console
    ZilchDeclareEvent(ConsoleWrite, ConsoleEvent);

    // Sent when anyone attempts to read from the console
    ZilchDeclareEvent(ConsoleRead, ConsoleEvent);
  }

  // When the user prints data using the console, or attempts to read
  // this will be the event type that we send out (for callbacks)
  class ConsoleEvent : public EventData
  {
  public:
    // The state invoking the console event
    ExecutableState* State;

    // The text of the console's WriteLine (to be printed)
    // If this is a read event, it is up to the user to set this text
    String Text;
  };

  // The default write text callback that prints to stdio
  void DefaultWriteText(ConsoleEvent* event);

  // The default read text callback that reads text from stdin
  void DefaultReadText(ConsoleEvent* event);

  // The type that we use to bind a console to the language
  class Console
  {
  public:
    ZilchDeclareBaseType(Console, TypeCopyMode::ReferenceType);

    // Write to the console (not bound to Zilch)
    static void Write(AnyParam value0);
    static void Write(AnyParam value0, AnyParam value1);
    static void Write(AnyParam value0, AnyParam value1, AnyParam value2);
    static void Write(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3);
    static void Write(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3, AnyParam value4);
    static void Write(StringParam value);
    static void Write(StringRange value);
    static void Write(cstr value);
    static void Write(char value);
    static void Write(Boolean value);
    static void Write(Boolean2Param value);
    static void Write(Boolean3Param value);
    static void Write(Boolean4Param value);
    static void Write(Integer value);
    static void Write(Integer2Param value);
    static void Write(Integer3Param value);
    static void Write(Integer4Param value);
    static void Write(Real value);
    static void Write(Real2Param value);
    static void Write(Real3Param value);
    static void Write(Real4Param value);
    static void Write(DoubleInteger value);
    static void Write(DoubleReal value);
    static void Write(QuaternionParam value);
    static void WriteLine();
    static void WriteLine(AnyParam value0);
    static void WriteLine(AnyParam value0, AnyParam value1);
    static void WriteLine(AnyParam value0, AnyParam value1, AnyParam value2);
    static void WriteLine(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3);
    static void WriteLine(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3, AnyParam value4);
    static void WriteLine(StringParam value);
    static void WriteLine(StringRange value);
    static void WriteLine(cstr value);
    static void WriteLine(char value);
    static void WriteLine(Boolean value);
    static void WriteLine(Boolean2Param value);
    static void WriteLine(Boolean3Param value);
    static void WriteLine(Boolean4Param value);
    static void WriteLine(Integer value);
    static void WriteLine(Integer2Param value);
    static void WriteLine(Integer3Param value);
    static void WriteLine(Integer4Param value);
    static void WriteLine(Real value);
    static void WriteLine(Real2Param value);
    static void WriteLine(Real3Param value);
    static void WriteLine(Real4Param value);
    static void WriteLine(DoubleInteger value);
    static void WriteLine(DoubleReal value);
    static void WriteLine(QuaternionParam value);

    // Write out an object (1 level deep - only properties)
    static void DumpValue(AnyParam value);

    // Write out an object to a certain number of levels deep (used for debugging)
    static void DumpValue(AnyParam value, Integer howDeep);

    // Read from the console
    static String ReadString();
    static Integer ReadInteger();
    static Boolean ReadBoolean();
    static Real ReadReal();

  public:

    // Write out data (sends the write event)
    static void WriteData(StringParam text);

    // Read text from the console (sends the read event)
    // If no users handle this then it will return an empty string
    static String ReadData();

    // Helper for writing out objects
    static void DumpValue(StringBuilderExtended& builder, Type* type, const byte* value, Integer howDeep, Integer currentDepth);

  public:

    // Responsible for the console sending and receiveing events (how we hook up callbacks!)
    static EventHandler Events;
  };
}

// End header protection
#endif



/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TEMPLATE_BINDING_HPP
#define ZILCH_TEMPALTE_BINDING_HPP

// Includes




/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_VIRTUAL_MACHINE_HPP
#define ZILCH_VIRTUAL_MACHINE_HPP

// Includes


namespace Zilch
{
  // This class is responsible for executing a stream of opcodes
  class VirtualMachine
  {
  public:
    // Fills out a table of function pointers with all the instruction functions we use
    static void InitializeJumpTable();

    // Execute a function, starting from a given stack frame
    static void ExecuteNext(Call& call, ExceptionReport& report);

    // Return the value of an enum property (the user data contains the value)
    static void EnumerationProperty(Call& call, ExceptionReport& report);

    // Return an events name string (the user data contains the value)
    static void EventsProperty(Call& call, ExceptionReport& report);

    // The native constructor invokes SetNativeTypeFullyConstructed on the Handle manager before calling the actual constructor code
    static void NativeConstructor(Call& call, ExceptionReport& report);

    // A special function that always returns a default value (zero, null, etc)
    // When we patch a library with a newer version, but the old version had functions that the newer one does not
    // they will be patched with this bound function (so that they do absolutely nothing)
    static void PatchDummy(Call& call, ExceptionReport& report);

    // Executes a destructor not actually from opcode, but
    // rather from a separate handle list on the ClassType
    static void PostDestructor(BoundType* boundType, byte* objectData);

    // Conversion from an enumeration into a string (prints out the value of the enum, or an integer if it fails)
    static String EnumerationToString(const BoundType* type, const byte* data);

    // Conversion from a flags into a string (prints out all enabled flags, or an integer if it fails)
    static String FlagsToString(const BoundType* type, const byte* data);

    // Generic integral power (expands to other integral sizes)
    template <typename T>
    static inline T IntegralPower(T base, T exponent)
    {
      T result = exponent >= 0;
      while (exponent && result)
      {
          if (exponent & 1)
          {
              result *= base;
          }

          exponent >>= 1;
          base *= base;
      }

      return result;
    }

    // A generic wrapper around 'raise to a power'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename T>
    static inline void GenericPow(T& out, const T& base, const T& exponent)
    {
      out = pow(base, exponent);
    }

    // A generic wrapper around 'modulus / remainder'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename T>
    static inline void GenericMod(T& out, const T& value, const T& mod)
    {
      out = value % mod;
    }

    // A generic wrapper around 'increment'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename T>
    static inline void GenericIncrement(T& value)
    {
      ++value;
    }

    // A generic wrapper around 'decrement'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename T>
    static inline void GenericDecrement(T& value)
    {
      --value;
    }

    // Checks if a value is zero or contains any zeros (in the case of vectors)
    template <typename T>
    static inline bool GenericIsZero(const T& value)
    {
      return value == 0;
    }

    // A generic wrapper around 'vector raise to a scalar power'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename VectorType, typename ScalarType>
    static inline void GenericScalarPow(VectorType& out, const VectorType& base, const ScalarType& exponent);

    // A generic wrapper around 'vector modulus / remainder by a scalar'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename VectorType, typename ScalarType>
    static inline void GenericScalarMod(VectorType& out, const VectorType& value, const ScalarType& mod)
    {
      out = value % mod;
    }

    // Define instruction functions for all of our opcodes
    #define ZilchEnumValue(Name) \
      static void Instruction##Name (ExecutableState* state, Call& call, ExceptionReport& report, size_t& programCounter, PerFrameData* ourFrame, const Opcode& opcode);
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Note: These macros mirror those inside of Shared and VirtualMachine (for generation of instructions)

// Copy
#define ZilchCopyInstructions(Type)               \
  ZilchEnumValue(Copy##Type)

// Equality and inequality
#define ZilchEqualityInstructions(Type)           \
  ZilchEnumValue(TestInequality##Type)            \
  ZilchEnumValue(TestEquality##Type)

// Less and greater comparison
#define ZilchComparisonInstructions(Type)         \
  ZilchEnumValue(TestLessThan##Type)              \
  ZilchEnumValue(TestLessThanOrEqualTo##Type)     \
  ZilchEnumValue(TestGreaterThan##Type)           \
  ZilchEnumValue(TestGreaterThanOrEqualTo##Type)

// Generic numeric operators, copy, equality
#define ZilchNumericInstructions(Type)            \
  ZilchCopyInstructions(Type)                     \
  ZilchEqualityInstructions(Type)                 \
  /* No instruction for unary plus */             \
  ZilchEnumValue(Negate##Type)                    \
  ZilchEnumValue(Increment##Type)                 \
  ZilchEnumValue(Decrement##Type)                 \
  ZilchEnumValue(Add##Type)                       \
  ZilchEnumValue(Subtract##Type)                  \
  ZilchEnumValue(Multiply##Type)                  \
  ZilchEnumValue(Divide##Type)                    \
  ZilchEnumValue(Modulo##Type)                    \
  ZilchEnumValue(Pow##Type)                       \
  ZilchEnumValue(AssignmentAdd##Type)             \
  ZilchEnumValue(AssignmentSubtract##Type)        \
  ZilchEnumValue(AssignmentMultiply##Type)        \
  ZilchEnumValue(AssignmentDivide##Type)          \
  ZilchEnumValue(AssignmentModulo##Type)          \
  ZilchEnumValue(AssignmentPow##Type)

// Generic numeric operators, copy, equality, comparison
#define ZilchScalarInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)

// Vector operations, generic numeric operators, copy, equality
#define ZilchVectorInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)               \
  ZilchEnumValue(ScalarMultiply##Type)            \
  ZilchEnumValue(ScalarDivide##Type)              \
  ZilchEnumValue(ScalarModulo##Type)              \
  ZilchEnumValue(ScalarPow##Type)                 \
  ZilchEnumValue(AssignmentScalarMultiply##Type)  \
  ZilchEnumValue(AssignmentScalarDivide##Type)    \
  ZilchEnumValue(AssignmentScalarModulo##Type)    \
  ZilchEnumValue(AssignmentScalarPow##Type)

// Special integral operators, generic numeric operators, copy, equality, and comparison
#define ZilchIntegralInstructions(Type)           \
  ZilchEnumValue(BitwiseNot##Type)                \
  ZilchEnumValue(BitshiftLeft##Type)              \
  ZilchEnumValue(BitshiftRight##Type)             \
  ZilchEnumValue(BitwiseOr##Type)                 \
  ZilchEnumValue(BitwiseXor##Type)                \
  ZilchEnumValue(BitwiseAnd##Type)                \
  ZilchEnumValue(AssignmentBitshiftLeft##Type)    \
  ZilchEnumValue(AssignmentBitshiftRight##Type)   \
  ZilchEnumValue(AssignmentBitwiseOr##Type)       \
  ZilchEnumValue(AssignmentBitwiseXor##Type)      \
  ZilchEnumValue(AssignmentBitwiseAnd##Type)


// Core instructions
ZilchEnumValue(InvalidInstruction)

ZilchEnumValue(InternalDebugBreakpoint)
ZilchEnumValue(ThrowException)
ZilchEnumValue(PropertyDelegate)

ZilchEnumValue(TypeId)

ZilchEnumValue(BeginTimeout)
ZilchEnumValue(EndTimeout)

ZilchEnumValue(BeginScope)
ZilchEnumValue(EndScope)

ZilchEnumValue(ToHandle)

ZilchEnumValue(BeginStringBuilder)
ZilchEnumValue(EndStringBuilder)
ZilchEnumValue(AddToStringBuilder)

ZilchEnumValue(CreateInstanceDelegate)
ZilchEnumValue(CreateStaticDelegate)

ZilchEnumValue(IfFalseRelativeGoTo)
ZilchEnumValue(IfTrueRelativeGoTo)
ZilchEnumValue(RelativeGoTo)

ZilchEnumValue(Return)
ZilchEnumValue(PrepForFunctionCall)
ZilchEnumValue(FunctionCall)

ZilchEnumValue(NewObject)
ZilchEnumValue(LocalObject)
ZilchEnumValue(DeleteObject)

// Primitive type instructions
ZilchIntegralInstructions(Byte)
ZilchScalarInstructions(Byte)
ZilchIntegralInstructions(Integer)
ZilchScalarInstructions(Integer)
ZilchVectorInstructions(Integer2)
ZilchVectorInstructions(Integer3)
ZilchVectorInstructions(Integer4)
ZilchIntegralInstructions(Integer2)
ZilchIntegralInstructions(Integer3)
ZilchIntegralInstructions(Integer4)
ZilchScalarInstructions(Real)
ZilchVectorInstructions(Real2)
ZilchVectorInstructions(Real3)
ZilchVectorInstructions(Real4)
ZilchScalarInstructions(DoubleReal)
ZilchIntegralInstructions(DoubleInteger)
ZilchScalarInstructions(DoubleInteger)

ZilchEqualityInstructions(Boolean)
ZilchEqualityInstructions(Handle)
ZilchEqualityInstructions(Delegate)
ZilchEqualityInstructions(Any)
ZilchEqualityInstructions(Value)

ZilchCopyInstructions(Boolean)
ZilchCopyInstructions(Any)
ZilchCopyInstructions(Handle)
ZilchCopyInstructions(Delegate)
ZilchCopyInstructions(Value)

ZilchEnumValue(LogicalNotBoolean)

ZilchEnumValue(ConvertByteToReal)
ZilchEnumValue(ConvertByteToBoolean)
ZilchEnumValue(ConvertByteToInteger)
ZilchEnumValue(ConvertByteToDoubleInteger)
ZilchEnumValue(ConvertByteToDoubleReal)
ZilchEnumValue(ConvertIntegerToReal)
ZilchEnumValue(ConvertIntegerToBoolean)
ZilchEnumValue(ConvertIntegerToByte)
ZilchEnumValue(ConvertIntegerToDoubleInteger)
ZilchEnumValue(ConvertIntegerToDoubleReal)
ZilchEnumValue(ConvertRealToInteger)
ZilchEnumValue(ConvertRealToBoolean)
ZilchEnumValue(ConvertRealToByte)
ZilchEnumValue(ConvertRealToDoubleInteger)
ZilchEnumValue(ConvertRealToDoubleReal)
ZilchEnumValue(ConvertBooleanToInteger)
ZilchEnumValue(ConvertBooleanToReal)
ZilchEnumValue(ConvertBooleanToByte)
ZilchEnumValue(ConvertBooleanToDoubleInteger)
ZilchEnumValue(ConvertBooleanToDoubleReal)
ZilchEnumValue(ConvertDoubleIntegerToReal)
ZilchEnumValue(ConvertDoubleIntegerToBoolean)
ZilchEnumValue(ConvertDoubleIntegerToByte)
ZilchEnumValue(ConvertDoubleIntegerToInteger)
ZilchEnumValue(ConvertDoubleIntegerToDoubleReal)
ZilchEnumValue(ConvertDoubleRealToReal)
ZilchEnumValue(ConvertDoubleRealToBoolean)
ZilchEnumValue(ConvertDoubleRealToByte)
ZilchEnumValue(ConvertDoubleRealToInteger)
ZilchEnumValue(ConvertDoubleRealToDoubleInteger)

ZilchEnumValue(ConvertInteger2ToReal2)
ZilchEnumValue(ConvertInteger2ToBoolean2)
ZilchEnumValue(ConvertReal2ToInteger2)
ZilchEnumValue(ConvertReal2ToBoolean2)
ZilchEnumValue(ConvertBoolean2ToInteger2)
ZilchEnumValue(ConvertBoolean2ToReal2)

ZilchEnumValue(ConvertInteger3ToReal3)
ZilchEnumValue(ConvertInteger3ToBoolean3)
ZilchEnumValue(ConvertReal3ToInteger3)
ZilchEnumValue(ConvertReal3ToBoolean3)
ZilchEnumValue(ConvertBoolean3ToInteger3)
ZilchEnumValue(ConvertBoolean3ToReal3)

ZilchEnumValue(ConvertInteger4ToReal4)
ZilchEnumValue(ConvertInteger4ToBoolean4)
ZilchEnumValue(ConvertReal4ToInteger4)
ZilchEnumValue(ConvertReal4ToBoolean4)
ZilchEnumValue(ConvertBoolean4ToInteger4)
ZilchEnumValue(ConvertBoolean4ToReal4)

ZilchEnumValue(ConvertStringToStringRangeExtended)

ZilchEnumValue(ConvertDowncast)
ZilchEnumValue(ConvertToAny)
ZilchEnumValue(ConvertFromAny)
ZilchEnumValue(AnyDynamicMemberGet)
ZilchEnumValue(AnyDynamicMemberSet)

    #undef ZilchEnumValue
  };

  // Note: These HAVE to be declared in namespace scope according to the C++ spec (cannot be put inside the class)
  // Specializations for Pow
  template <>
  inline void VirtualMachine::GenericPow<Byte>(Byte& out, const Byte& base, const Byte& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Integer>(Integer& out, const Integer& base, const Integer& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Integer2>(Integer2& out, const Integer2& base, const Integer2& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Integer3>(Integer3& out, const Integer3& base, const Integer3& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Integer4>(Integer4& out, const Integer4& base, const Integer4& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Real2>(Real2& out, const Real2& base, const Real2& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Real3>(Real3& out, const Real3& base, const Real3& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Real4>(Real4& out, const Real4& base, const Real4& exponent);
  template <>
  inline void VirtualMachine::GenericPow<DoubleInteger>(DoubleInteger& out, const DoubleInteger& base, const DoubleInteger& exponent);

  // Specializations for Mod
  template <>
  inline void VirtualMachine::GenericMod<Real>(Real& out, const Real& value, const Real& mod);
  template <>
  inline void VirtualMachine::GenericMod<Real2>(Real2& out, const Real2& value, const Real2& mod);
  template <>
  inline void VirtualMachine::GenericMod<Real3>(Real3& out, const Real3& value, const Real3& mod);
  template <>
  inline void VirtualMachine::GenericMod<Real4>(Real4& out, const Real4& value, const Real4& mod);
  template <>
  inline void VirtualMachine::GenericMod<DoubleReal>(DoubleReal& out, const DoubleReal& value, const DoubleReal& mod);

  // Specializations for Scalar Pow
  template <>
  inline void VirtualMachine::GenericScalarPow<Integer2, Integer>(Integer2& out, const Integer2& base, const Integer& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Integer3, Integer>(Integer3& out, const Integer3& base, const Integer& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Integer4, Integer>(Integer4& out, const Integer4& base, const Integer& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Real2, Real>(Real2& out, const Real2& base, const Real& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Real3, Real>(Real3& out, const Real3& base, const Real& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Real4, Real>(Real4& out, const Real4& base, const Real& exponent);

  // Specializations for Scalar Mod
  template <>
  inline void VirtualMachine::GenericScalarMod<Real2, Real>(Real2& out, const Real2& value, const Real& mod);
  template <>
  inline void VirtualMachine::GenericScalarMod<Real3, Real>(Real3& out, const Real3& value, const Real& mod);
  template <>
  inline void VirtualMachine::GenericScalarMod<Real4, Real>(Real4& out, const Real4& value, const Real& mod);

  // Specializations for Scalar Increment
  template <>
  inline void VirtualMachine::GenericIncrement<Real2>(Real2& out);
  template <>
  inline void VirtualMachine::GenericIncrement<Real3>(Real3& out);
  template <>
  inline void VirtualMachine::GenericIncrement<Real4>(Real4& out);

  // Specializations for Scalar Decrement
  template <>
  inline void VirtualMachine::GenericDecrement<Real2>(Real2& out);
  template <>
  inline void VirtualMachine::GenericDecrement<Real3>(Real3& out);
  template <>
  inline void VirtualMachine::GenericDecrement<Real4>(Real4& out);

  // Specializations for IsZero
  template <>
  inline bool VirtualMachine::GenericIsZero<Integer2>(const Integer2& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Integer3>(const Integer3& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Integer4>(const Integer4& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Real2>(const Real2& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Real3>(const Real3& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Real4>(const Real4& value);
}

// Crash report capture variables
// This is an attempt to force crash reports to store a variable / indirectly referenced memory (not thread safe either)
// Do NOT ever attempt to access this variable or do anything with it in code
extern byte* ZilchLastRunningOpcode;
extern Zilch::Function* ZilchLastRunningFunction;
extern size_t ZilchLastRunningOpcodeLength;

// End header protection
#endif


namespace Zilch
{
  namespace PropertyBinding
  {
    enum Enum
    {
      Get,
      Set,
      GetSet
    };
  }

  // All things relevant to binding methods
  class TemplateBinding
  {
  public:

    // Given a comma delimited string of names (eg, "destination, source, size") this will fill in the parameter array with
    // those names. The number of parameters must match the number of parsed names. All names should be lower-camel case
    // For generic use, if the names list is empty, this will immediately return with no errors
    static void ZeroShared ParseParameterArrays(ParameterArray& parameters, StringRange commaDelimitedNames);

    // Include all the binding code
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

//BeginBound
template <typename FunctionType, FunctionType function>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  function();
}
//EndBound
template <typename FunctionType, FunctionType function>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (*)() )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  function(arg0);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (*)(Arg0) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  function(arg0, arg1);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (*)(Arg0, Arg1) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  function(arg0, arg1, arg2);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (*)(Arg0, Arg1, Arg2) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  function(arg0, arg1, arg2, arg3);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (*)(Arg0, Arg1, Arg2, Arg3) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  ZilchBindingType(Arg4) arg4 = call.Get<ZilchBindingType(Arg4)>(4);
  function(arg0, arg1, arg2, arg3, arg4);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (*)(Arg0, Arg1, Arg2, Arg3, Arg4) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  Return result = function();
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (*)() )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  Return result = function(arg0);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (*)(Arg0) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  Return result = function(arg0, arg1);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (*)(Arg0, Arg1) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  Return result = function(arg0, arg1, arg2);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (*)(Arg0, Arg1, Arg2) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  Return result = function(arg0, arg1, arg2, arg3);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (*)(Arg0, Arg1, Arg2, Arg3) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  ZilchBindingType(Arg4) arg4 = call.Get<ZilchBindingType(Arg4)>(4);
  Return result = function(arg0, arg1, arg2, arg3, arg4);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (*)(Arg0, Arg1, Arg2, Arg3, Arg4) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)();
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)() )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0, arg1);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0, arg1, arg2);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0, arg1, arg2, arg3);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  ZilchBindingType(Arg4) arg4 = call.Get<ZilchBindingType(Arg4)>(4);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0, arg1, arg2, arg3, arg4);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)();
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)() )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0, arg1);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0, arg1, arg2);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0, arg1, arg2, arg3);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  ZilchBindingType(Arg4) arg4 = call.Get<ZilchBindingType(Arg4)>(4);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0, arg1, arg2, arg3, arg4);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)() const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)() const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromMethod(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

template <typename FunctionType, FunctionType function, typename Class>
void VirtualThunk()
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)())
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void>));
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
void VirtualThunk(Arg0 arg0)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
void VirtualThunk(Arg0 arg0, Arg1 arg1)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0, Arg1>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
void VirtualThunk(Arg0 arg0, Arg1 arg1, Arg2 arg2)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0, Arg1, Arg2>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
void VirtualThunk(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  call.Set<Arg3>(3, arg3);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0, Arg1, Arg2, Arg3>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
void VirtualThunk(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  call.Set<Arg3>(3, arg3);
  call.Set<Arg4>(4, arg4);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0, Arg1, Arg2, Arg3, Arg4>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return>
Return VirtualThunkReturn()
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)())
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return>));
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
Return VirtualThunkReturn(Arg0 arg0)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
Return VirtualThunkReturn(Arg0 arg0, Arg1 arg1)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0, Arg1>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
Return VirtualThunkReturn(Arg0 arg0, Arg1 arg1, Arg2 arg2)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
Return VirtualThunkReturn(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  call.Set<Arg3>(3, arg3);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
Return VirtualThunkReturn(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  call.Set<Arg3>(3, arg3);
  call.Set<Arg4>(4, arg4);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange name, StringRange spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3, Arg4>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

template <typename Class>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class();
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class();
}
template <typename Class>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0);
}
template <typename Class, typename Arg0>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0, typename Arg1>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1);
}
template <typename Class, typename Arg0, typename Arg1>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Arg3 arg3 = call.Get<Arg3>(3);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2, arg3);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Arg3 arg3 = call.Get<Arg3>(3);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2, arg3);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Arg3 arg3 = call.Get<Arg3>(3);
  Arg4 arg4 = call.Get<Arg4>(4);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2, arg3, arg4);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Arg3 arg3 = call.Get<Arg3>(3);
  Arg4 arg4 = call.Get<Arg4>(4);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2, arg3, arg4);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringRange spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}


    //*** BOUND DESTRUCTOR ***// Wraps a destructor call with the Zilch signature
    template <typename Class>
    static void BoundDestructor(Call& call, ExceptionReport& report)
    {
      //// Get our self object
      //Class* self = call.Get<Class*>(Call::This);

      // We need to investigate why the above call doesn't work
      // Unfortunately this comment is written whilst looking back, and I don't understand
      // why I had commented the above out. My guess would be that for struct types (value types)
      // the 'this type' is actually the ref instead of the type itself... something like that
      // Most likely the handle is storing the BoundType*, eg Quaternion, instead of the IndirectionType*
      // Why doesn't this appear elswhere, say the field get functions?
      Handle& selfHandle = call.GetHandle(Call::This);
      Class* self = (Class*)selfHandle.Dereference();

      // Explicitly call the destructor of the class
      self->~Class();
    }
    
    //*** BUILDER DESTRUCTOR ***// Generates a Zilch function to call a class destructor
    template <typename Class>
    static Function* FromDestructor(LibraryBuilder& builder, BoundType* classBoundType)
    {
      return builder.AddBoundDestructor(classBoundType, BoundDestructor<Class>);
    }
    
    //*** BOUND INSTANCE FIELD GET ***//
    template <typename FieldType, typename Class, FieldType Class::* field>
    static void BoundInstanceGet(Call& call, ExceptionReport& report)
    {
      // Get our self object
      Class* self = call.Get<Class*>(Call::This);

      // Get the value of the member
      FieldType& value = self->*field;

      // Get the member's value by returning it
      call.Set(Call::Return, value);
    }
    
    //*** BOUND INSTANCE FIELD SET ***//
    template <typename FieldType, typename Class, FieldType Class::* field>
    static void BoundInstanceSet(Call& call, ExceptionReport& report)
    {
      // Get our self object
      Class* self = call.Get<Class*>(Call::This);

      // Read in the value that we're trying to set
      ZilchBindingType(FieldType) value = call.Get<ZilchBindingType(FieldType)>(0);

      // Set the value of the member
      self->*field = value;
    }

    //*** BUILDER INSTANCE CONST FIELD ***//
    template <typename FieldPointer, FieldPointer field, typename Class, typename FieldType>
    static Property* FromField(LibraryBuilder& builder, BoundType* owner, StringParam name, const FieldType Class::* dummy, PropertyBinding::Enum mode)
    {
      ErrorIf(dummy != field, "The dummy should always match our template member");
      BoundFn get = BoundInstanceGet<const FieldType, Class, field>;
      ErrorIf(mode != PropertyBinding::Get, "The field is const and therefore a setter cannot be generated (use PropertyBinding::Get)");
      return builder.AddBoundProperty(owner, name, ZilchTypeId(FieldType), nullptr, get, MemberOptions::None);
    }

    //*** BUILDER INSTANCE FIELD ***//
    // Generates a Zilch property by creating get/set functions to wrap the member variable and binding them
    template <typename FieldPointer, FieldPointer field, typename Class, typename FieldType>
    static Property* FromField(LibraryBuilder& builder, BoundType* owner, StringParam name, FieldType Class::* dummy, PropertyBinding::Enum mode)
    {
      ErrorIf(dummy != field, "The dummy should always match our template member");
      BoundFn set = BoundInstanceSet<FieldType, Class, field>;
      BoundFn get = BoundInstanceGet<FieldType, Class, field>;
      
      if (mode == PropertyBinding::Get)
      {
        set = nullptr;
      }
      if (mode == PropertyBinding::Set)
      {
        get = nullptr;
      }

      return builder.AddBoundProperty(owner, name, ZilchTypeId(FieldType), set, get, MemberOptions::None);
    }

    //*** BOUND STATIC FIELD GET ***//
    template <typename FieldType, FieldType* field>
    static void BoundStaticGet(Call& call, ExceptionReport& report)
    {
      // Get the value of the member
      FieldType& value = *field;

      // Get the member's value by returning it
      call.Set(Call::Return, value);
    }
    
    //*** BOUND STATIC FIELD SET ***//
    template <typename FieldType, FieldType* field>
    static void BoundStaticSet(Call& call, ExceptionReport& report)
    {
      // Read in the value that we're trying to set
      ZilchBindingType(FieldType) value = call.Get<ZilchBindingType(FieldType)>(0);
      
      // Set the value of the member
      *field = value;
    }

    //*** BUILDER STATIC CONST FIELD ***//
    template <typename FieldPointer, FieldPointer field, typename FieldType>
    static Property* FromField(LibraryBuilder& builder, BoundType* owner, StringParam name, const FieldType* dummy, PropertyBinding::Enum mode)
    {
      ErrorIf(dummy != field, "The dummy should always match our template member");
      BoundFn get = BoundStaticGet<const FieldType, field>;
      ErrorIf(mode != PropertyBinding::Get, "The field is const and therefore a setter cannot be generated (use PropertyBinding::Get)");
      return builder.AddBoundProperty(owner, name, ZilchTypeId(FieldType), nullptr, get, MemberOptions::Static);
    }

    //*** BUILDER STATIC FIELD ***//
    // Generates a Zilch property by creating get/set functions to wrap the global variable and binding them
    template <typename FieldPointer, FieldPointer field, typename FieldType>
    static Property* FromField(LibraryBuilder& builder, BoundType* owner, StringParam name, FieldType* dummy, PropertyBinding::Enum mode)
    {
      ErrorIf(dummy != field, "The dummy should always match our template member");
      BoundFn set = BoundStaticSet<FieldType, field>;
      BoundFn get = BoundStaticGet<FieldType, field>;
      
      if (mode == PropertyBinding::Get)
        set = nullptr;
      if (mode == PropertyBinding::Set)
        get = nullptr;

      return builder.AddBoundProperty(owner, name, ZilchTypeId(FieldType), set, get, MemberOptions::Static);
    }

    //*** BUILDER INSTANCE PROPERTY GET/SET ***//
    template <typename GetterType, GetterType getter, typename SetterType, SetterType setter, typename Class, typename GetType, typename SetType>
    static Property* FromProperty(LibraryBuilder& builder, BoundType* owner, StringRange name, GetType (Class::*dummyGetter)(), void (Class::*dummySetter)(SetType))
    {
      ReturnIf
      (
        ZilchTypeId(GetType) != ZilchTypeId(SetType),
        nullptr,
        "Cannot bind a Get/Set property type that has a different fundamental type for the getter's return value and setters input value"
      );
  
      ErrorIf(dummyGetter != getter, "The dummy getter should always match our template member");
      ErrorIf(dummySetter != setter, "The dummy getter should always match our template member");
  
      BoundFn boundGet = BoundInstanceReturn<GetterType, getter, Class, GetType>;
      BoundFn boundSet = BoundInstance<SetterType, setter, Class, SetType>;
  
      return builder.AddBoundProperty(owner, name, ZilchTypeId(GetType), boundSet, boundGet, MemberOptions::None);
    }

    //*** BUILDER INSTANCE PROPERTY CONST GET/SET ***//
    template <typename GetterType, GetterType getter, typename SetterType, SetterType setter, typename Class, typename GetType, typename SetType>
    static Property* FromProperty(LibraryBuilder& builder, BoundType* owner, StringRange name, GetType (Class::*dummyGetter)() const, void (Class::*dummySetter)(SetType))
    {
      ReturnIf
      (
        ZilchTypeId(GetType) != ZilchTypeId(SetType),
        nullptr,
        "Cannot bind a Get/Set property type that has a different fundamental type for the getter's return value and setters input value"
      );
  
      ErrorIf(dummyGetter != getter, "The dummy getter should always match our template member");
      ErrorIf(dummySetter != setter, "The dummy getter should always match our template member");
  
      BoundFn boundGet = BoundInstanceReturn<GetterType, getter, Class, GetType>;
      BoundFn boundSet = BoundInstance<SetterType, setter, Class, SetType>;
  
      return builder.AddBoundProperty(owner, name, ZilchTypeId(GetType), boundSet, boundGet, MemberOptions::None);
    }

    //*** BUILDER INSTANCE PROPERTY GET ***//
    template <typename GetterType, GetterType getter, typename SetterType, SetterType setter, typename Class, typename GetType>
    static Property* FromProperty(LibraryBuilder& builder, BoundType* owner, StringRange name, GetType (Class::*dummyGetter)(), NullPointerType)
    {
      ErrorIf(dummyGetter != getter, "The dummy getter should always match our template member");
      BoundFn boundGet = BoundInstanceReturn<GetterType, getter, Class, GetType>;
      return builder.AddBoundProperty(owner, name, ZilchTypeId(GetType), nullptr, boundGet, MemberOptions::None);
    }

    //*** BUILDER INSTANCE PROPERTY CONST GET ***//
    template <typename GetterType, GetterType getter, typename SetterType, SetterType setter, typename Class, typename GetType>
    static Property* FromProperty(LibraryBuilder& builder, BoundType* owner, StringRange name, GetType (Class::*dummyGetter)() const, NullPointerType)
    {
      ErrorIf(dummyGetter != getter, "The dummy getter should always match our template member");
      BoundFn boundGet = BoundInstanceReturn<GetterType, getter, Class, GetType>;
      return builder.AddBoundProperty(owner, name, ZilchTypeId(GetType), nullptr, boundGet, MemberOptions::None);
    }

    //*** BUILDER INSTANCE PROPERTY SET ***//
    template <typename GetterType, GetterType getter, typename SetterType, SetterType setter, typename Class, typename SetType>
    static Property* FromProperty(LibraryBuilder& builder, BoundType* owner, StringRange name, NullPointerType, void (Class::*dummySetter)(SetType))
    {
      ErrorIf(dummySetter != setter, "The dummy setter should always match our template member");
      BoundFn boundSet = BoundInstance<SetterType, setter, Class, SetType>;
      return builder.AddBoundProperty(owner, name, ZilchTypeId(SetType), boundSet, nullptr, MemberOptions::None);
    }

    //*** BUILDER STATIC PROPERTY GET/SET ***//
    template <typename GetterType, GetterType getter, typename SetterType, SetterType setter, typename GetType, typename SetType>
    static Property* FromProperty(LibraryBuilder& builder, BoundType* owner, StringRange name, GetType (*dummyGetter)(), void (*dummySetter)(SetType))
    {
      ReturnIf
      (
        ZilchTypeId(GetType) != ZilchTypeId(SetType),
        nullptr,
        "Cannot bind a Get/Set property type that has a different fundamental type for the getter's return value and setters input value"
      );
  
      ErrorIf(dummyGetter != getter, "The dummy getter should always match our template member");
      ErrorIf(dummySetter != setter, "The dummy getter should always match our template member");
  
      BoundFn boundGet = BoundStaticReturn<GetterType, getter, GetType>;
      BoundFn boundSet = BoundStatic<SetterType, setter, SetType>;
  
      return builder.AddBoundProperty(owner, name, ZilchTypeId(GetType), boundSet, boundGet, MemberOptions::Static);
    }

    //*** BUILDER STATIC PROPERTY GET ***//
    template <typename GetterType, GetterType getter, typename SetterType, SetterType setter, typename GetType>
    static Property* FromProperty(LibraryBuilder& builder, BoundType* owner, StringRange name, GetType (*dummyGetter)(), NullPointerType)
    {
      ErrorIf(dummyGetter != getter, "The dummy getter should always match our template member");
      BoundFn boundGet = BoundStaticReturn<GetterType, getter, GetType>;
      return builder.AddBoundProperty(owner, name, ZilchTypeId(GetType), nullptr, boundGet, MemberOptions::Static);
    }

    //*** BUILDER STATIC PROPERTY SET ***//
    template <typename GetterType, GetterType getter, typename SetterType, SetterType setter, typename SetType>
    static Property* FromProperty(LibraryBuilder& builder, BoundType* owner, StringRange name, NullPointerType, void (*dummySetter)(SetType))
    {
      ErrorIf(dummySetter != setter, "The dummy setter should always match our template member");
      BoundFn boundSet = BoundStatic<SetterType, setter, SetType>;
      return builder.AddBoundProperty(owner, name, ZilchTypeId(SetType), boundSet, nullptr, MemberOptions::Static);
    }
  };

  // If we want more readable code when not specifying a getter or setter in ZilchBindProperty
  #define ZilchNoSetter nullptr
  #define ZilchNoGetter nullptr
  
  // When we want to specify that a method binding has no parameter names or documentation, we use this macro (more readable and clear)
  #define ZilchNoNames nullptr
  #define ZilchNoDocumentation nullptr

  // When using the ZilchBindMethod macro if we're binding a method that has no overloads then we use this constant for the parameter 'OverloadResolution'
  #define ZilchNoOverload

  // Workhorse macro for binding methods
  #define ZilchBindMethod(ZilchBuilder, ZilchType, MethodPointer, OverloadResolution, Name, SpaceDelimitedParameterNames) \
    Zilch::TemplateBinding::FromMethod<ZilchTypeOf(OverloadResolution MethodPointer), MethodPointer>(ZilchBuilder, ZilchType, Name, SpaceDelimitedParameterNames, OverloadResolution(MethodPointer))

  // Workhorse macro for binding virtual methods
  #define ZilchBindVirtualMethod(ZilchBuilder, ZilchType, MethodPointer, NameOrNull) \
    Zilch::TemplateBinding::FromVirtual<ZilchTypeOf(MethodPointer), MethodPointer>(ZilchBuilder, ZilchType, Name, SpaceDelimitedParameterNames, (MethodPointer))

  // Bind a constructor that takes any number of arguments
  // Due to the inability to get a 'member function pointer' to a constructor, the arguments must always be specified
  #define ZilchBindConstructor(ZilchBuilder, ZilchType, Class, SpaceDelimitedParameterNames, ...) \
    Zilch::TemplateBinding::FromConstructor<Class, ##__VA_ARGS__>(ZilchBuilder, ZilchType, SpaceDelimitedParameterNames)
  
  // Bind a constructor that takes any number of arguments (this binds a special constructor that lets Zilch know about the type's v-table)
  // Due to the inability to get a 'member function pointer' to a constructor, the arguments must always be specified
  #define ZilchBindConstructorVirtual(ZilchBuilder, ZilchType, Class, SpaceDelimitedParameterNames, ...) \
    Zilch::TemplateBinding::FromConstructorVirtual<Class, ##__VA_ARGS__>(ZilchBuilder, ZilchType, SpaceDelimitedParameterNames)

  // Bind the destructor of a class
  // The destructor should ALWAYS be bound if the constructor is bound
  #define ZilchBindDestructor(ZilchBuilder, ZilchType, Class) \
    Zilch::TemplateBinding::FromDestructor<Class>(ZilchBuilder, ZilchType)

  // Bind data members as properties
  #define ZilchBindField(ZilchBuilder, ZilchType, FieldPointer, Name, PropertyBinding) \
    Zilch::TemplateBinding::FromField<ZilchTypeOf(FieldPointer), FieldPointer>(ZilchBuilder, ZilchType, Name, FieldPointer, PropertyBinding)
  
  // Bind a property (getter and setter in C++) to Zilch
  // A property will appear like a member, but it will invoke the getter when being read, and the setter when being written to
  #define ZilchBindProperty(ZilchBuilder, ZilchType, GetterMethodPointer, SetterMethodPointer, Name) \
    Zilch::TemplateBinding::FromProperty<ZilchTypeOf(GetterMethodPointer), GetterMethodPointer, ZilchTypeOf(SetterMethodPointer), SetterMethodPointer>(ZilchBuilder, ZilchType, Name, GetterMethodPointer, SetterMethodPointer)

  // Bind a type as being an enum (verifies that the size matches)
  #define ZilchBindEnum(ZilchBuilder, ZilchType, SpecialTypeEnum)                                                       \
    (ZilchType)->SpecialType = SpecialTypeEnum;                                                                         \
    if ((SpecialTypeEnum) == SpecialType::Enumeration)                                                                  \
      (ZilchType)->ToStringFunction = VirtualMachine::EnumerationToString;                                              \
    else                                                                                                                \
      (ZilchType)->ToStringFunction = VirtualMachine::FlagsToString;                                                    \
    ErrorIf((ZilchType)->Size != sizeof(Integer), "The sizeof(Enum) bound to Zilch must match the sizeof(Integer)");

  // Bind a single value of 
  #define ZilchBindEnumValue(ZilchBuilder, ZilchType, EnumValue, Name) \
    ErrorIf(Type::IsEnumOrFlagsType(ZilchType) == false, "Use ZilchBindEnum before calling ZilchBindEnumValue"); \
    (ZilchBuilder).AddBoundProperty((ZilchType), (Name), ZilchType, nullptr, &VirtualMachine::EnumerationProperty, MemberOptions::Static)->Get->UserData = (void*)(size_t)(EnumValue);
}
// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_FORMATTER_HPP
#define ZILCH_FORMATTER_HPP

// Includes




namespace Zilch
{
  // Lets us define what lines tokens will go on, or if it relies upon a default setting
  // Used mostly for specifying styles of curley braces (eg. K&R style, Allman style, etc)
  namespace LineStyle
  {
    enum Enum
    {
      UseGlobalDefault,
      SameLine,
      NextLine,
      NextLineIndented
    };
  }
  
  // Lets us define whether we indent in certain places, or if it relies upon a default setting
  namespace IndentStyle
  {
    enum Enum
    {
      UseGlobalDefault,
      Indented,
      NotIndented
    };
  }
  
  // Lets us define if we want spaces before, after, or around both sides of a token,
  // or if it relies upon a default setting
  namespace SpaceStyle
  {
    enum Enum
    {
      UseGlobalDefault,
      None,
      Before,
      After,
      BeforeAndAfter
    };
  }

  // Allows us to specify almost every aspect of code formatting
  // The default values used here reflect the official coding standard of Zilch
  class CodeFormat
  {
  public:

    // Constructor
    CodeFormat();

    // If we use tabs for indents or spaces if false (default: false)
    bool IsTabs;

    // How many tabs or spaces we use when indenting (default: 2)
    size_t Identation;

    // Will remove whitespace from empty lines or fill whitespace if set to false (default: false)
    bool StripWhiteSpaceFromEmptyLines;

    // Whether we automatically indent after scopes, unless we override specific cases (default: Indented)
    IndentStyle::Enum IndentGlobalDefault;

    // Whether functions, properties, and fields get indented inside a class (default: UseGlobalDefault)
    IndentStyle::Enum IndentClassContents;

    // Whether values inside an enum are indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentEnumContents;

    // Whether statements inside a function's scope get indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentFunctionContents;

    // Whether statements inside a property's scope get indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentPropertyContents;

    // Whether statements inside a property's get/set scope get indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentGetSetContents;

    // Whether statements inside any other scope (such as an if statement) get indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentScopeContents;

    // Where the braces go for any scope, unless we override specific cases (default: NextLine)
    LineStyle::Enum LineStyleGlobalDefaultScope;

    // Where the braces go for a class scope (default: UseGlobalDefault)
    LineStyle::Enum LineStyleClassScope;

    // Where the braces go for a enum/flags scope (default: UseGlobalDefault)
    LineStyle::Enum LineStyleEnumScope;

    // Where the braces go for a function scope (default: UseGlobalDefault)
    LineStyle::Enum LineStyleFunctionScope;

    // Where the braces go for a property scope (default: UseGlobalDefault)
    LineStyle::Enum LineStylePropertyScope;

    // Where the braces go for a get/set scope inside a property scope (default: UseGlobalDefault)
    LineStyle::Enum LineStyleGetSetScope;

    // Where the braces go for any other type of scope (for example, if statements) (default: UseGlobalDefault)
    LineStyle::Enum LineStyleBlockScope;

    // Where the initializer list colon is placed (default: SameLine)
    LineStyle::Enum LineStyleInitializerList;

    // Whether we put spaces around colons, unless we override specific cases (default: BeforeAndAfter)
    SpaceStyle::Enum SpaceStyleGlobalDefaultColon;

    // Whether we put spaces around the colon in an inheritance list (after the class keyword) (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleInheritanceColon;

    // Whether we put spaces around the colon in an initializer list (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleInitializerListColon;

    // Whether we put spaces around the colon that specifices a type (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleTypeColon;

    // Whether we put spaces around the colon that specifices a type (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleNamedArgumentColon;

    // Whether we put spaces around commas, unless we override specific cases (default: After)
    SpaceStyle::Enum SpaceStyleGlobalDefaultComma;

    // Whether we put spaces around the commas in an inheritance list (after the class keyword) (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleInheritanceComma;

    // Whether we put spaces around the commas in an initializer list (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleInitializerListComma;

    // Whether we put spaces around the commas in a parameter list for a function definition (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleFunctionDefinitionParameterComma;

    // Whether we put spaces around the commas in a parameter list for a function invokation (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleFunctionCallParameterComma;

    // Whether we put spaces around the commas in a parameter list for a template definition (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleTemplateDefinitionParameterComma;

    // Whether we put spaces around the commas in a parameter list for a template instantiation (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleTemplateInstantiationParameterComma;

    // Whether we put spaces around parenthesis, unless we override specific cases (default: None)
    SpaceStyle::Enum SpaceStyleGlobalDefaultParenthesis;
    
    // Whether we put spaces around the beginning parenthesis in a function definition (default: None)
    SpaceStyle::Enum SpaceStyleFunctionDefinitionBeginParenthesis;
    
    // Whether we put spaces around the ending parenthesis in a function definition (default: None)
    SpaceStyle::Enum SpaceStyleFunctionDefinitionEndParenthesis;

    // In certain scenarios this is used to wrap comments (not necessarily used in
    // general formatting, but in other places where we use a code builder)
    size_t CommentWordWrapLength;

    // Whether we put a space after the comment // or /* (default: true)
    bool SpaceAfterComment;
  };

  // The type of scope we emit
  namespace ScopeType
  {
    enum Enum
    {
      Class,
      Enumeration,
      Function,
      Property,
      GetSet,
      Block
    };
  }

  // This class can be used to directly emit Zilch code as text
  // It's mostly a convenience (handles scoping, formatting, spaces, keywords, etc)
  class ZilchCodeBuilder : public StringBuilderExtended
  {
  public:
    // Constructor
    ZilchCodeBuilder();
    
    // Writes out a keyword
    void WriteKeywordOrSymbol(Grammar::Enum token);

    // Writes out a keyword with spacing rules
    void WriteKeywordOrSymbolSpaceStyle(Grammar::Enum token, SpaceStyle::Enum specific, SpaceStyle::Enum globalDefault);

    // Add a scope to the builder, which typically will indent the contents and emit a 'begin scope' token
    void BeginScope(ScopeType::Enum scope);

    // Ends a scope, which typically will unindent and emit an 'end scope' token
    void EndScope();
    
    // Writes out a token
    using StringBuilderExtended::Write;
    void Write(const UserToken& token);

    // Creates a new line, and indents it to the current indentation level
    // Note that if this line is empty, it will be indented all the way, which means
    // we need to do a post-pass over the string in case 'StripWhiteSpaceFromEmptyLines' is set
    void WriteLineIndented();

    // A templated version that forwards writes to the Write function and then writes an indented line (see above)
    template <typename T>
    void WriteLineIndented(const T& value)
    {
      this->Write(value);
      this->WriteLineIndented();
    }

    // We only overwrite this so we can count lines
    // Note: This function is NOT virtual, which means that calling any
    // WriteLine overloads on the base will fail to count lines properly
    using StringBuilderExtended::WriteLine;
    void WriteLine();

    // Creates a new line based on the line style
    void WriteLineStyle(LineStyle::Enum specific, LineStyle::Enum globalDefault);

    // Write a single indent at the latest position
    void WriteIndent();

    // Write a single space
    void WriteSpace();

    // Write out a single line comment
    void WriteSingleLineComment(StringParam text);

    // Trims any ending whitespace or lines
    void TrimEnd();

    // Outputs the final string
    // This also removes trailing whitespace, and modifies space for empty lines
    // depending on the setting 'StripWhiteSpaceFromEmptyLines'
    String ToString();

    // Get the current line that we're on
    size_t GetLine();

  private:

    // Get the preferred line rule
    static LineStyle::Enum GetLineStyle(LineStyle::Enum specific, LineStyle::Enum globalDefault);

    // Get the preferred indent rule
    static IndentStyle::Enum GetIndentStyle(IndentStyle::Enum specific, IndentStyle::Enum globalDefault);

    // Get the preferred space rule
    static SpaceStyle::Enum GetSpaceStyle(SpaceStyle::Enum specific, SpaceStyle::Enum globalDefault);

  public:

    // The format we emit the code in
    CodeFormat Format;

    // The current indentation level we're at. Indentation usually increases as we increase scope
    size_t Indentation;

  private:

    // Styling information for a scope
    class ScopeStyle
    {
    public:
      // Constructor
      ScopeStyle();

      bool BracesIndented;
      bool InnardsIndented;
    };

    // This is the level of scope we're at (an empty array means root / flat level)
    Array<ScopeStyle> Scopes;

    // The current line that we're on
    size_t Line;

    // The current character that we're on
    size_t Character;
    
    // Upon ending a scope, we currently use Trim, which isn't a great
    StringBuilder builder;
  };

  class ScopeLastNode
  {
  public:
    // Constructor
    ScopeLastNode();

    SyntaxNode* LastNode;
    SyntaxNode* AssociatedScope;
  };

  // The context we use to generate code
  class CodeFormatterContext : public WalkerContext<CodeFormatter, CodeFormatterContext>
  {
  public:
    // Constructor
    CodeFormatterContext();

    // The current functions we're generating code for
    FunctionArray FunctionStack;

    // The current classes we're generating code for
    Array<BoundType*> ClassTypeStack;

    // Where we emit formatted code to
    ZilchCodeBuilder Builder;

    // At the top of this stack contains the last statement we processed
    // for the current scope we're in. Every time we enter a scope, a 
    // statement is pushed on the stack (first null, then the last statement)
    Array<ScopeLastNode> FormatScopes;
  };

  // Responsible for converting a syntax tree back into code
  // This is incredibly useful for auto-formatting Zilch code, or translating into other languages
  class CodeFormatter
  {
  public:

    // Constructor
    CodeFormatter();

    // Formats a syntax tree back into code
    // The syntax tree can be 'unchecked', but must not be invalid (missing syntax types, etc)
    String FormatTree(SyntaxTree& syntaxTree, const CodeFormat& format);

  private:
    
    static bool IsDirectlyWithinScope(SyntaxNode* node);
    static size_t CountAttributes(SyntaxNode* node);

    void FormatCommentsAndLines(SyntaxNode*& node, CodeFormatterContext* context);

    // Handles delimiting of statements that require it
    void FormatStatement(StatementNode*& node, CodeFormatterContext* context);

    // Free (scoped) statements
    void FormatIf(IfNode*& node, CodeFormatterContext* context);
    void FormatLoop(LoopNode*& node, CodeFormatterContext* context);
    void FormatWhile(WhileNode*& node, CodeFormatterContext* context);
    void FormatDoWhile(DoWhileNode*& node, CodeFormatterContext* context);
    void FormatFor(ForNode*& node, CodeFormatterContext* context);
    void FormatForEach(ForEachNode*& node, CodeFormatterContext* context);

    // Delimited statements
    void FormatReturn(ReturnNode*& node, CodeFormatterContext* context);
    void FormatDelete(DeleteNode*& node, CodeFormatterContext* context);
    void FormatBreak(BreakNode*& node, CodeFormatterContext* context);
    void FormatDebugBreak(DebugBreakNode*& node, CodeFormatterContext* context);
    void FormatContinue(ContinueNode*& node, CodeFormatterContext* context);
    void FormatThrow(ThrowNode*& node, CodeFormatterContext* context);

    // Expressions (do not require emitting newline in front)
    void FormatBinaryOperator(BinaryOperatorNode*& node, CodeFormatterContext* context);
    void FormatUnaryOperator(UnaryOperatorNode*& node, CodeFormatterContext* context);
    void FormatTypeCast(TypeCastNode*& node, CodeFormatterContext* context);
    void FormatIndexerCall(IndexerCallNode*& node, CodeFormatterContext* context);
    void FormatFunctionCall(FunctionCallNode*& node, CodeFormatterContext* context);
    void FormatMemberAccess(MemberAccessNode*& node, CodeFormatterContext* context);
    void FormatLocalVariable(LocalVariableNode*& node, CodeFormatterContext* context);
    void FormatParameter(ParameterNode*& node, CodeFormatterContext* context);
    void FormatStaticTypeNode(StaticTypeNode*& node, CodeFormatterContext* context);
    void FormatValue(ValueNode*& node, CodeFormatterContext* context);
    void FormatStringInterpolant(StringInterpolantNode*& node, CodeFormatterContext* context);
    void FormatTypeId(TypeIdNode*& node, CodeFormatterContext* context);
    

    // Format a class back into Zilch format
    void FormatAttributes(NodeList<AttributeNode>& attributes, ZilchCodeBuilder& builder);
    void FormatEnum(EnumNode*& node, CodeFormatterContext* context);
    void FormatEnumValue(EnumValueNode*& node, CodeFormatterContext* context);
    void FormatClass(ClassNode*& node, CodeFormatterContext* context);
    void FormatSendsEvent(SendsEventNode*& node, CodeFormatterContext* context);
    void FormatMemberVariable(MemberVariableNode*& node, CodeFormatterContext* context);
    template <typename NodeType, typename FunctionType>
    void FormatGenericFunctionHelper(NodeType* node, CodeFormatterContext* context, FunctionType emitPostArgs);
    void FormatFunction(FunctionNode*& node, CodeFormatterContext* context);
    void FormatConstructor(ConstructorNode*& node, CodeFormatterContext* context);
    void FormatDestructor(DestructorNode*& node, CodeFormatterContext* context);
    
  private:

    // Store all the walkers
    BranchWalker<CodeFormatter, CodeFormatterContext> Walker;
  };
}

// End header protection
#endif


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_DEBUGGING_HPP
#define ZILCH_DEBUGGING_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_WEB_SOCKET_HPP
#define ZILCH_WEB_SOCKET_HPP

// Includes



namespace Zilch
{
  ZilchDeclareStaticLibrary(WebSockets);

  namespace Events
  {
    // Sent when the listener accepts a connection
    // This event MUST be handled, otherwise the accepted web-sockets will leak
    ZilchDeclareEvent(WebSocketAcceptedConnection, WebSocketEvent);

    // Sent any time the threaded web-socket receives data
    ZilchDeclareEvent(WebSocketReceivedData, WebSocketEvent);

    // Sent any time the threaded web-socket encounters an error
    // This should generally always be followed by a disconnect event
    ZilchDeclareEvent(WebSocketError, WebSocketEvent);

    // Sent any time the threaded web-socket is closed
    // If an error occurs, the web-socket is automatically closed and this event will be sent
    ZilchDeclareEvent(WebSocketDisconnected, WebSocketEvent);
  }

  // Describes the raw types of packets we can receive
  // The only packets that the user will recieve is Text and Binary
  // (all other packets are handled internally)
  namespace WebSocketPacketType
  {
    enum Enum
    {
      Invalid       = -1,
      Continuation  = 0x00,
      Text          = 0x01,
      Binary        = 0x02,
      // Reserved Non-Control Frames 0x03-0x07
      Close         = 0x08,
      Ping          = 0x09,
      Pong          = 0x0A
      // Reserved Control Frames 0x0B-0x0F
    };
  }

  // Forward declarations
  class ThreadedWebSocketConnection;

  // An event sent out whenever a web socket connection changes or receives data
  class WebSocketEvent : public EventData
  {
  public:
    ZilchDeclareDerivedType(WebSocketEvent, EventData);

    // Default constructor
    WebSocketEvent();

    // The connection involved in the event
    ThreadedWebSocketConnection* Connection;

    // If we received data, this will contain the data we received (otherwise will be empty if not applicable)
    WebSocketPacketType::Enum PacketType;

    // Any data that was received by the connection (or empty if not applicable)
    // The data can be binary or text, depending on PacketType
    String Data;

    // If any error occurred, this status will hold the error message and state
    Status ErrorStatus;
  };

  // A connection that we can communicate on (could be from cient to server, or server to client)
  // With the blocking version, the user must properly respond to the Close and Ping messages
  // The threaded version internally takes care of these messages
  class BlockingWebSocketConnection
  {
  public:

    // Constructor
    BlockingWebSocketConnection();
    
    // All the values we read from the HTTP headers
    HashMap<String, String> Headers;

    // Send a full packet to the remote end
    // This function will block until the entire packet is sent
    // It is safe to call this function from another thread (only one thread at a time though)
    void SendFullPacket(Status& status, const byte* data, size_t length, WebSocketPacketType::Enum packetType);

    // Receives an entire packet of data into an array
    // This function will block until the entire packet is received, or an error occurs
    // It is safe to call this function from another thread (only one thread at a time though)
    // Note: We use strings both as text and binary blobs of data
    // If we return an 'Invalid' packet, it means the connection was disconnected or an error occurred (check status)
    // The packet types we receive can be Text, Binary, Close, or Ping
    // Close must be responeded to by sending a Close message back, and Ping must be responded to by sending back a Pong
    WebSocketPacketType::Enum ReceiveFullPacket(Status& status, String& dataOut);
    
    // Checks if the connection is initialized
    bool IsValid();

    // The connection to the remote host (we can send and receive on this connection)
    Socket RemoteSocket;

    //******** Internal ********//
    
    // As we read data, we place it into this buffer
    Array<byte> ReadData;
  };

  // Listens for incoming web-socket connections
  // This class should only be initialized and closed once (it should not be reused)
  class BlockingWebSocketListener
  {
  public:

    // Constructor
    BlockingWebSocketListener();

    // Host a server on a given port and initialize the internal socket
    void Initialize(Status& status, int port);

    // Closes the socket
    void Close(Status& status);

    // Checks if the object is initialized
    bool IsValid();

    // Blocks until we receive an incoming connection
    // This method performs the full web-socket authentication and will not complete
    // until either the connection fails, or the socket is acceptped
    // Ideally the server should be run on another thread due to blocking
    void Accept(Status& status, BlockingWebSocketConnection& connectionOut);

    // The socket that we listen for incoming connections on
    Socket ListenerSocket;
  };

  // A threaded version of the blocking web-socket connection
  // This class can only be initialized from a ThreadedWebSocketListener
  // This class maintains a send and receive thread, and when updated we pull data
  // Either the user or the ThreadedWebSocketServer must periodically call Update from the owning thread
  // All send and update functions are safe to call from the owning thread (not multiple!)
  // Once this connection has been terminated, it may not be used again
  class ThreadedWebSocketConnection : public EventHandler
  {
  public:
    // sends WebSocketReceivedData : WebSocketEvent;
    // sends WebSocketError : WebSocketEvent;
    // sends WebSocketDisconnected : WebSocketEvent;

    // Default constructor
    ThreadedWebSocketConnection();

    // Destructor (terminates threads and closes the socket)
    ~ThreadedWebSocketConnection();

    // Send a single message
    // You should only ever send the Text or Binary packet types
    void SendPacket(StringParam message, WebSocketPacketType::Enum packetType);
    
    // Checks if the connection is initialized
    bool IsValid();

    // Shuts down a connection and closes the socket
    // Only the first call will actually terminate the socket (multiple calls allowed)
    void Close();

    // Pumps both recieved messages and events such as a disconnect
    // If a thread terminates early, or the socket becomes no longer writable, Close will be called and an event will be sent
    void Update();
    
    //******** Internal ********//

    // Thread entrypoints for receive, and send
    static OsInt ReceiveEntryPoint(void* context);
    static OsInt SendEntryPoint(void* context);

    // Sets the web-socket and spins up the send/receive threads
    // We can only be initialized by a listener (after our blocking WebSocket has been initialized)
    void Initialize();
    
    // The thread we receive data on (receive is a blocking call)
    Thread ReceiveThread;

    // We must lock the array of receive messages/errors it before reading or modifying it
    ThreadLock IncomingLock;

    // This array is locked by the web-socket receiving thread (and send thread when errors occur)
    // Any read in messages are enqued here and dispatched when the connection is updated
    // Note: We use strings both as text and binary blobs
    Array<WebSocketEvent> ThreadIncomingEvents;

    // This array of recieved messages is maintained by the owning thread, and is regularly swapped with the 'ThreadReceiveMessages'
    Array<WebSocketEvent> OwnerIncomingEvents;

    // The send outgoing messages on (send is a blocking call)
    Thread SendThread;

    // We must lock the array of send messages it before reading or modifying it
    ThreadLock SendLock;

    // This array is locked by the web-socket sending thread
    // Any messages we want sent should just get added here, and the
    // 'send' event should be signaled once a message is added (or multiple)
    // If the send event is signaled and there are no messages, it means we are being destroyed
    // Note: We use strings both as text and binary blobs
    Array<WebSocketEvent> SendMessages;

    // Every time we add a message to the queue of messages to be sent we
    // signal this event, this will wake up the send thread
    // The send thread will then swap array pointers with the 'SendMessages',
    // which will very quickly pull all the messages off and clear messages to be sent
    // If the send event is signaled and there are no messages, it means we are being destroyed
    OsEvent SendEvent;

    // The web socket we communicate on (where we send our messages, and receive from)
    // All operations are done on other threads (that we properly lock and make safe to pull into the owning thread)
    BlockingWebSocketConnection BlockingConnection;
  };

  
  // Listens for incoming web-socket connections on a thread
  // Can only be used once (once it is closed, it should be removed)
  // Must be preriodically updated by the owning thread, which will then dispatch events for accepted connections
  class ThreadedWebSocketListener : public EventHandler
  {
  public:
    // sends WebSocketAcceptedConnection : WebSocketEvent;
    // sends WebSocketError : WebSocketEvent;

    // Default constructor
    ThreadedWebSocketListener();

    // Destructor (terminates threads and closes the socket)
    ~ThreadedWebSocketListener();

    // Start listening and accepting connections on a given port
    // This also initializes the listener and should only be called once
    void Initialize(int port);

    // Shuts down a connection and closes the socket
    // Only the first call will actually terminate the socket (multiple calls allowed)
    void Close();

    // Checks if the object is initialized
    bool IsValid();
    
    // Updates the web socket connection, which pumps both recieved messages and events such as a disconnect
    void Update();
    
    //******** Internal ********//

    // The thread entrypoint we use for accepting socket connections
    static OsInt AcceptEntryPoint(void* context);

    // The current connection that we are processing
    // It is NOT safe to access this connection from the owning thread, unless using the 'AcceptingConnectionLock'
    // Note: The only action we should use the AcceptingConnectionLock for is terminating
    // the socket for the accepting connection upon our destruction
    ThreadedWebSocketConnection* AcceptingConnection;

    // Whenever the accepting thread creates a connection, it needs to lock to ensure that the owning thread
    // is not also accessing the accepting connection
    // If the accepting thread locks and finds the blocking listening socket to be terminated, we will immediately return
    ThreadLock AcceptingConnectionLock;

    // Anytime a connection is accepted or an error occurs, this must be locked (to write to ThreadIncomingEvents)
    ThreadLock IncomingLock;

    // We maintain a list of all connections that we accept and errors that occur
    Array<WebSocketEvent> ThreadIncomingEvents;

    // This array of recieved messages is maintained by the owning thread, and is regularly swapped with the 'ThreadReceiveMessages'
    Array<WebSocketEvent> OwnerIncomingEvents;

    // The thread we accept connections on
    Thread AcceptThread;

    // We tell the blocking listener to accept connections on the accepting thread
    BlockingWebSocketListener BlockingListener;
  };

  // The web-socket server maintains threaded web-socket connections and invokes
  // callbacks for when connections are received and fully handshook, or closed
  // The thread that owns the server is responsible for occasionally pumping events via Update
  class ThreadedWebSocketServer : public EventHandler
  {
  public:
    // Events will be forwarded from owned connections to the server
    // sends WebSocketAcceptedConnection : WebSocketEvent;
    // sends WebSocketError : WebSocketEvent;
    // sends WebSocketReceivedData : WebSocketEvent;
    // sends WebSocketDisconnected : WebSocketEvent;

    // Default constructor that sets the max connections
    ThreadedWebSocketServer(size_t maxConnections = 64);

    // Destructor (terminates all connections)
    ~ThreadedWebSocketServer();

    // Start listening and accepting connections on a given port
    void Host(int port);

    // Tells us if the server has been initialized (specifically, the listener)
    bool IsValid();

    // Updates the web socket connection, which pumps accepted
    // connections and all sends/recieves on stored connections
    void Update();
    
    // Send a message to all connections
    void SendPacketToAll(StringParam message, WebSocketPacketType::Enum packetType);

    // The maximum number of connections we'll accept
    size_t MaximumConnections;

    // The connections we maintain and accept
    Array<ThreadedWebSocketConnection*> Connections;

    
    //******** Internal ********//

    // Occurs when our listener accepts a connection (only when updating the listener)
    void OnAcceptedConnection(WebSocketEvent* event);

    // The listener we use to accept connections
    ThreadedWebSocketListener Listener;
  };
}

// End header protection
#endif




namespace Zilch
{
  namespace Events
  {
    // Sent repeatedly when the program is frozen by the debugger (a breakpoint is hit, or it is paused)
    // In general no logic that can affect the state of debugging should ever be run within this event handler
    // However, it can be used to draw screen overlays and other indicators to the user
    ZilchDeclareEvent(DebuggerPauseUpdate, DebuggerEvent);

    // Sent when we first pause execution (such as entering a breakpoint or clicking pause)
    ZilchDeclareEvent(DebuggerPause, DebuggerEvent);

    // Sent when we resume execution after being paused
    // Note that stepping a single line will resume and then pause again
    ZilchDeclareEvent(DebuggerResume, DebuggerEvent);
  }

  // When the debugger pauses or resumes, we send this event out
  class DebuggerEvent : public EventData
  {
  public:
    // The debugger we're currently paused inside of
    Debugger* RunningDebugger;

    // The state we're currently paused inside of (last running)
    ExecutableState* State;

    // The location of where we're at in script (generally where we're paused)
    CodeLocation* Location;
  };

  // Every platform should define an error handler
  bool DebugErrorHandler(ErrorSignaler::ErrorData& errorData);

  // Any data we receive from the debugger
  class DebuggerMessage
  {
  public:
    // The root of the json tree
    JsonValue* JsonRoot;

    // The message that we're currently processing
    String Type;
  };

  // The debugger message handler function
  typedef void (*MessageFn)(const DebuggerMessage& message, void* userData);

  namespace DebuggerAction
  {
    enum Enum
    {
      Resume,
      Pause,
      StepOver,
      StepIn,
      StepOut
    };
  }

  // The debugger hosts a web-socket connection and allows an external program to
  // place breakpoints, step over lines, see the call stack, inspect variables, etc
  // The debugger is NOT thread safe, so only ExecutableStates from the same thread
  // should be added to the debugger. Note however that you can create multiple
  // debuggers hosted on different ports for different threads
  // Note: The debugger must be periodically updated
  class Debugger : public EventHandler
  {
  public:
    // sends DebuggerPauseUpdate : DebuggerEvent;
    // sends DebuggerPause : DebuggerEvent;
    // sends DebuggerResume : DebuggerEvent;

    // Constructor
    Debugger();

    // Destructor
    ~Debugger();

    // Starts the debugger hosting on a given port
    void Host(int port);

    // Tells us if the debugger has been initialized (basically if we started hosting or not)
    bool IsValid();

    // The debugger must be periodically updated to ensure that it receives remote messages
    void Update();

    // Adds a project whose files we track
    // We use the hashes of the code from each file to show code entries in the debugger (as well as file name)
    void AddProject(Project* project);

    // Remove a project that we no longer want to track
    void RemoveProject(Project* project);

    // Adds a state to be debugged (this will inform any running debuggers of the new state)
    // Be sure to remove any states that get deleted (they will not be automatically removed!)
    // A state can only be added once (multiple times will be ignored)
    void AddState(ExecutableState* state);

    // Removes a state from the list of states to be debugged
    // It is safe to call this more than once (and can be called even when the state was not added)
    void RemoveState(ExecutableState* state);

    // When we receive a custom json message, this will attempt to handle it
    void AddMessageHandler(StringParam type, MessageFn callback, void* userData);

  private:

    // Send a single message
    void SendPacket(StringParam message);

    // Send a single json built message (helper function)
    void SendPacket(const JsonBuilder& message);

    // When we resume execution, we want to tell the remote client to clear the execution point
    void SetExecutionPoint(CodeLocation* codeLocation, ExecutableState* state);

    // When we resume execution, we want to tell the remote client to clear the execution point
    void ClearExecutionPoint();

    // Updates the view of executable states and their files
    void UpdateExplorerView();

    // The break loop will pause all execution on this thread, only processing debugger messages
    void PauseExecution(CodeLocation* codeLocation, ExecutableState* state);

    // Checks if a type has any debuggable properties (expandable)
    static bool HasDebuggableProperties(Type* type);

    // Called when the remote debugger connects to us
    void OnAcceptedConnection(WebSocketEvent* event);

    // Called by the same thread the debugger / states are on
    // This will process all incoming messages, such as breakpoint, step, continue, etc
    void OnReceivedData(WebSocketEvent* event);

    // Called when we encounter any errors with a connection or the listener (server)
    void OnError(WebSocketEvent* event);

    // Called when the remote debugger disconnects
    void OnDisconnected(WebSocketEvent* event);

    // Attempts to find a code entry by hash (first starting with the project, then with each executable state)
    CodeEntry* FindCodeEntry(size_t hash);

    // Messages from the client:
    // When we receive a remote message to add a breakpoint for a code file and line
    static void OnChangeBreakpoint(const DebuggerMessage& message, void* userData);

    // When we receive a remote message to remove a breakpoint for a code file and line
    static void OnRemoveBreakpoint(const DebuggerMessage& message, void* userData);

    // When the client sends us a common command like pause, resume, step over, etc
    static void OnPause(const DebuggerMessage& message, void* userData);
    static void OnResume(const DebuggerMessage& message, void* userData);
    static void OnStepOver(const DebuggerMessage& message, void* userData);
    static void OnStepIn(const DebuggerMessage& message, void* userData);
    static void OnStepOut(const DebuggerMessage& message, void* userData);
    
    // When the user attempted to view an item in the explorer, we're repsonsible for sending what to show
    static void OnViewExplorerItem(const DebuggerMessage& message, void* userData);
    
    // When the debugger attempts to query an expression (such as when hovering over a variable or watching an expression)
    static void OnQueryExpression(const DebuggerMessage& message, void* userData);

    // Callbacks from the state:
    // Every time the executable state steps into an opcode, this function is called
    void OnOpcodePreStep(OpcodeEvent* e);

    // Every time the executable state steps into a function, this function is called
    void OnEnterFunction(OpcodeEvent* e);

    // Every time the executable state steps out of a function, this function is called
    void OnExitFunction(OpcodeEvent* e);

    // Every time the executable state steps out of a function, this function is called
    void OnException(ExceptionEvent* e);

    // Whenever we print anything out using the console, we want to know about it
    void OnConsoleWrite(ConsoleEvent* event);

  private:

    // This data must be cleared properly upon the client disconnecting
    //******** BEGIN CLEARED DATA ********//
    
    // The last action that was queued up by the debugger for the current state
    DebuggerAction::Enum Action;

    // As we walk over lines of code (callbacks from any running ExecutableState)
    // we will check to see if the line exists in this breakpoints map
    // The map maps from code hash values to line numbers
    HashMap<size_t, HashSet<size_t> > Breakpoints;

    // Store the last location id and line
    CodeLocation LastLocation;

    // The last call stack position (how deep we were)
    size_t LastCallStackDepth;

    // The last state that we were accessing
    ExecutableState* LastState;

    // When we're doing stepping, we need to save the last location here (but not update it with each opcode step)
    CodeLocation StepLocation;

    // The call stack depth where we're stepping out of (state context relative operations)
    size_t StepOutOverCallStackDepth;

    // The state we were using when stepping out / over (state context relative operations)
    ExecutableState* StepOutOverState;

    //******** END CLEARED DATA ********//

    // The states we are currently debugging
    Array<ExecutableState*> States;

    // The projects whose code we are currently viewing
    Array<Project*> Projects;

    // We need to check if any projects change files, then update the remote end if that happens
    // Currently we just scan the projects each update for any changes (we detect changes by looking for hash code changes)
    unsigned long long AllProjectsHashCode;

    // When we recieve messages from the remote client, we look here to handle any messages
    class DebuggerMessageDelegate
    {
    public:
      MessageFn MessageCallback;
      void* UserData;
    };
    HashMap<String, DebuggerMessageDelegate> MessageHandlers;

    // Accepts connections and manages our remote connection
    ThreadedWebSocketServer Server;
  };

  // All information the debugger needs to know per state
  class DebuggerState
  {
  public:
  };
}

// End header protection
#endif


/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_PLUGIN_HPP
#define ZILCH_PLUGIN_HPP

// Includes





namespace Zilch
{
  namespace Events
  {
    // We send this even on a BuildPlugin prior to any code being built
    // During this phase we can populate the event with any dependent libraries (such as our own StaticLibrary)
    ZilchDeclareEvent(PreBuild, BuildEvent);
  }

  // The signature of the CreateZilchPlugin function that we look for in the shared library
  typedef Plugin* (*CreateZilchPluginFn)();

  class ZeroShared BuildEvent : public EventData
  {
  public:
    BuildEvent();

    // Finds a library from the dependencies by name
    LibraryRef FindLibrary(StringParam name);

    Project* BuildingProject;
    Module* Dependencies;
    LibraryBuilder* Builder;
  };

  // This class must be implemented to create a custom plugin (also implement the below function)
  // This class will be created upon building a library, and will be destroyed whenever the library itself dies
  class ZeroShared Plugin : public EventHandler
  {
  public:
    virtual ~Plugin();
  };

  // Mangles function names so they become unique and do not collide with overloads
  class NameMangler
  {
  public:
    // Mangle all functions from all types within a library
    void MangleLibrary(LibraryRef library);

    // Mangle a function name into one that is mostly unique to its binary signature
    String MangleFunction(Function* function);

    // Find a function by mangled name and asserts if it cannot find it (function name is intentionally a cstr)
    Function* FindFunction(StringParam mangledName, const char* functionName, StringParam typeName);

  private:
    HashMap<Function*, String> FunctionToMangledName;
    HashMap<String, Function*> MangledNameToFunction;
  };

  // A helper for easily retreiving the type (using in stub code generation, also asserts)
  BoundType* FindLibraryType(LibraryRef library, const char* name, BoundType*& outputType);

  class NativeName
  {
  public:
    NativeName();
    NativeName(StringParam className, StringParam parameterName, StringParam returnName);
    String Class;
    String Parameter;
    String Return;
  };

  // Generates C++ code that can be used within plugins which will allow users to
  // conveniently make calls to types bound to Zilch (or even Zilch scripts themselves)
  class NativeStubCode
  {
  public:
    NativeStubCode();

    // Given a library this will generate a C++ stub header and cpp file
    // The user must call HookUpX(BuildEvent) where X is the name of your library
    // The build event will come from the plugin PreBuild event
    void Generate(LibraryRef library);

  public:

    // A header appended to the hpp file (at the top)
    String HppHeader;

    // A header appended to the cpp file (at the top)
    String CppHeader;

    // These will be filled out when we call 'Generate'
    String Hpp;
    String Cpp;

  private:

    NameMangler Mangler;
    HashMap<Type*, NativeName> TypeToCppName;
    
    NativeName GetCppTypeName(Type* type, Library* generatingLibrary);
    String GenerateHpp(Library* library, Array<BoundType*>& orderedTypes);
    String GenerateCpp(Library* library, Array<BoundType*>& orderedTypes);
  };

  // Use this in a single translational unit (cpp) that can see the declaration of the above plugin
  #define ZilchDefinePluginInterface(PluginClass)                               \
    ZeroExport long GetZilchPluginVersion() { return 0; }                       \
    ZeroExport Zilch::Plugin* CreateZilchPlugin() { return new PluginClass(); }

  // This is a common macro for implementing a single static library and plugin in one
  #define ZilchDeclareStaticLibraryAndPlugin(LibraryName) \
    ZilchDeclareStaticLibrary(LibraryName);               \
    class LibraryName##Plugin : public Zilch::Plugin      \
    {                                                     \
    public:                                               \
      LibraryName##Plugin();                              \
      void OnPreBuild(Zilch::BuildEvent* event);          \
    };

  // This is a common macro for implementing a single static library and plugin in one
  #define ZilchDefineStaticLibraryAndPlugin(LibraryName)                                          \
    ZilchDefinePluginInterface(LibraryName##Plugin);                                              \
    LibraryName##Plugin::LibraryName##Plugin()                                                    \
    {                                                                                             \
      Zilch::EventConnect(this, Zilch::Events::PreBuild, &LibraryName##Plugin::OnPreBuild, this); \
    }                                                                                             \
    void LibraryName##Plugin::OnPreBuild(Zilch::BuildEvent* event)                                \
    {                                                                                             \
      event->Dependencies->push_back(LibraryName::GetInstance().GetLibrary());                    \
    }                                                                                             \
    ZilchDefineStaticLibrary(LibraryName)

  // A base class for all native stubs that cannot be constructed,
  // destructed, or copied in any way (basically never derferenced)
  class Base
  {
  };

  // A helper that returns the default constructed value of
  // any type (including POD C++ types, like int or int*)
  template <typename T>
  T Default()
  {
    return T();
  }

  // All stub generated C++ code uses external binding with this library
  // This library pretends to be the static library that the type belongs to, but it will be redirected
  // when we hook-up types through the dll/so-boundary
  class ZeroShared PluginStubLibrary : public StaticLibrary
  {
  public:
    // Grab the singleton instance of the plugin stub
    static PluginStubLibrary& GetInstance();

    // This is a special case where we always allow plugins to "build" so that we can do type hookups
    bool CanBuildTypes() override;

  private:
    PluginStubLibrary();
    ~PluginStubLibrary();
    ZilchNoCopy(PluginStubLibrary);
  };

}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Note: This code is based on Steve Reid's 100% Public Domain Sha1 implementation (thank you Steve!)

// Include protection
#pragma once
#ifndef ZILCH_SHA1_HPP
#define ZILCH_SHA1_HPP

namespace Zilch
{
  class Sha1Builder
  {
  public:
    static const size_t Sha1ByteSize = 20;

    Sha1Builder();

    // Updates the Sha1 with new data
    void Append(const byte* data, size_t length);

    // Updates the Sha1 with string data
    void Append(StringRange data);

    // Appends all the contents of a file to the hash (read chunk by chunk)
    // Returns true if it succeeded, or false if the file was not open or invalid
    bool Append(File& file);

    // Outputs the hash to an array of bytes (does not modify our builder)
    // The byte array must be at least 'Sha1ByteSize'
    void OutputHash(byte* hashOut);

    // Resizes the array and outputs the hash to it (does not modify our builder)
    void OutputHash(Array<byte>& hashOut);

    // Outputs the hash to a hex string (does not modify our builder)
    String OutputHashString();

    // Gets a Sha1 hash from string data
    static String GetHashString(StringRange data);

    // Gets a Sha1 hash from string data
    static String GetHashString(File& file);
    
    // Tests the implementation of Sha1
    static void RunUnitTests();
  private:

    u32 State[5];
    u32 Count[2];
    byte Buffer[64];
  };

}
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_ARRAY_HPP
#define ZILCH_ARRAY_HPP

// Includes






namespace Zilch
{
  // Instantiates an array template when requested
  BoundType* InstantiateArray
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  );
  
  // For every instantiated array, it may want to look up information about what it contains
  class ArrayUserData
  {
  public:
    ArrayUserData();

    Type* ContainedType;
    BoundType* RangeType;
    BoundType* SelfType;
  };

  // This is the base definition of our array class
  // It is not technically the leaf level class, but it is binary compatabile with the Zilch Array template
  // We add no members or virtuals in the derived class, and static assert that the sizes are the same
  template <typename T>
  class ArrayClass
  {
  public:
    // Constructor
    ArrayClass() :
      ModifyId(0)
    {
    }

    // Invalidates all active ranges via incrementing a modification id
    void Modified()
    {
      ++this->ModifyId;
    }

    // Our array is actually just an array of Any types
    // but for arrays of primitive/built in types, it will be optimized
    Array<T> NativeArray;

    // A special counter that we use to denote whenever the container has been modified
    Integer ModifyId;
  };

  // These are all the specializations that are optimized to store exactly that data type
  // All values that are unknown will be stored as the 'Any' type
  ZilchDeclareExternalBaseType(ArrayClass<Handle       >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Delegate     >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Boolean      >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Boolean2     >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Boolean3     >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Boolean4     >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Byte         >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Integer      >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Integer2     >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Integer3     >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Integer4     >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Real         >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Real2        >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Real3        >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Real4        >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Quaternion   >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<DoubleInteger>, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<DoubleReal   >, TypeCopyMode::ReferenceType);
  ZilchDeclareExternalBaseType(ArrayClass<Any          >, TypeCopyMode::ReferenceType);
}

// End header protection
#endif


namespace Zilch
{
  namespace StartupFlags
  {
    enum Enum
    {
      None = 0,
      CustomAssertHandlerOrNoAsserts = (1 << 0),
      NoDocumentationStrings = (1 << 1),
      DoNotShutdown = (1 << 2)
    };
    typedef unsigned Type;
  }
  
  // Initializes the shared global memory manager and builds all the static bound libraries
  class ZeroShared ZilchSetup
  {
  public:
    // Controls default setup parameters (such as whether we optimize out documentation string, etc)
    // Note: No Zilch classes should be created before this occurs
    ZilchSetup(StartupFlags::Type flags = StartupFlags::None);
    
    // Shuts down the shared global memory manager and releases any static libraries
    // Note: No Zilch classes should be created after this occurs
    ~ZilchSetup();

    // The setup is a singleton, which means two may not exist at the same time
    // However, you can create ZilchSetup and destroy it, then create another ZilchSetup
    // On destruction, this Instance will be cleared to null
    static ZilchSetup* Instance;

    // Whatever flags we were created with
    StartupFlags::Enum Flags;
  };

  // A simple macro that we specle everywhere to ensure that the user initializes Zilch
  #define ZilchErrorIfNotStarted(Name)                                                              \
    ErrorIf(ZilchSetup::Instance == nullptr,                                                        \
      "In order to use the Zilch " #Name " you must create the ZilchSetup type and hold on to it")

  // A convenient form of parsed main arguments (easily comparable and queryable)
  class MainArguments
  {
  public:
    // The first argument of the argv is generally a path to the executable
    String ExecutablePath;

    // All commands start with a '-' and generally a value follows (or empty if another command directly followed)
    HashMap<String, Array<String> > CommandToValues;

    // Any stray value that isn't preceeded by a command gets put here (a typical use is for file inputs and so on)
    Array<String> InputValues;

    // Whether a particular command was present
    bool HasCommand(StringParam command);

    // Gets the last value passed in for a particular command
    String GetCommandValue(StringParam command);

    // Gets the last value passed in for a particular command as a pointer (easy to test for null)
    String* GetCommandValuePointer(StringParam command);

    // Gets the array of all commands
    Array<String>& GetCommandValues(StringParam command);
  };

  // Parsers arguments that we typically get from main into the above structure
  void ZilchParseMainArguments(int argc, char* argv[], MainArguments& argumentsOut);

  // Processes command line arguments for running Zilch standalone (invokes Startup/Shutdown)
  int ZilchMain(int argc, char* argv[]);

  // Waits for a debugger to be attached (optionally can breakpoint upon attachment)
  // Note, if this is called and the breakpoint option is on, it will ALWAYS breakpoint when running from a debugger
  void ZilchWaitForDebugger(bool breakpointWhenAttached);
}

// End header protection
#endif
/*
cdecode.h - c header for a base64 decoding algorithm

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/

#ifndef BASE64_CDECODE_H
#define BASE64_CDECODE_H

#pragma once

typedef enum
{
	step_a, step_b, step_c, step_d
} base64_decodestep;

typedef struct
{
	base64_decodestep step;
	char plainchar;
} base64_decodestate;

void base64_init_decodestate(base64_decodestate* state_in);

int base64_decode_value(char value_in);

size_t base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in);

#endif /* BASE64_CDECODE_H */

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_CODE_GENERATOR_HPP
#define ZILCH_CODE_GENERATOR_HPP

// Includes




namespace Zilch
{
  // The context we use to generate code
  class GeneratorContext : public WalkerContext<CodeGenerator, GeneratorContext>
  {
  public:
    // Store the current function that we're building
    FunctionArray FunctionStack;

    // Store the current type that we're building
    Array<BoundType*> ClassTypeStack;
  };

  // This class uses the syntax tree (after type checking) to generate a byte-code known as the "three-address"
  class CodeGenerator
  {
  public:

    // Constructor
    CodeGenerator();

    // Generates a buffer of op-codes from the given syntax-tree
    LibraryRef Generate(SyntaxTree& syntaxTree, LibraryBuilder& builder);

  private:

    // Walks through the members of a type and determines the total size of those members
    // If a member is left uncomputed, then it will be walked and computed also
    void ComputeSize(BoundType* type, const CodeLocation& location);

    // Store the class in the code context
    void ClassContext(ClassNode*& node, GeneratorContext* context);

    // Generate the properties for enum values
    void GenerateEnumValueProperties(EnumValueNode*& node, GeneratorContext* context);

    // Generate the properties for event names
    void GenerateEventNameProperties(SendsEventNode*& node, GeneratorContext* context);

    // Store the class in the code context
    void ClassAndPreconstructorContext(ClassNode*& node, GeneratorContext* context);

    // Store the function in the code context
    void FunctionContext(GenericFunctionNode*& node, GeneratorContext* context);

    // Generate out of scope destructors
    void GenerateOutOfScope(ScopeNode*& node, GeneratorContext* context);

    // Generate the storage for parameters
    void GenerateParameter(ParameterNode*& node, GeneratorContext* context);

    // Generate the storage for variables
    void GenerateLocalVariable(LocalVariableNode*& node, GeneratorContext* context);

    // Generate debug breakpoints
    void GenerateDebugBreak(DebugBreakNode*& node, GeneratorContext* context);

    // Generate the initialization of member variables (static and fields) and also generate properties
    void GenerateMemberVariable(MemberVariableNode*& node, GeneratorContext* context);

    // Generate opcode for timeout statements
    void GenerateTimeout(TimeoutNode*& node, GeneratorContext* context);

    // Generate opcode for if statements
    void GenerateIfRoot(IfRootNode*& node, GeneratorContext* context);

    // Generate all the statements and the continue jumps inside
    void GenerateLoopStatementsAndContinues(GeneratorContext* context, LoopScopeNode* node);

    // Generate all the statements inside a node
    void GenerateStatements(GeneratorContext* context, ScopeNode* node);

    // Generate the backwards jump that most loops use to go back to the beginning
    void GenerateBackwardsLoopJump(GeneratorContext* context, size_t backwardsJumpInstructionIndex, const CodeLocation& debugLocation);

    // Generate the code for break statements in the loop
    void GenerateLoopBreaks(GeneratorContext* context, LoopScopeNode* node);

    // Generate opcode for while statements
    void GenerateWhile(WhileNode*& node, GeneratorContext* context);

    // Generate opcode for do while statements
    void GenerateDoWhile(DoWhileNode*& node, GeneratorContext* context);

    // Generate opcode for for statements
    void GenerateFor(ForNode*& node, GeneratorContext* context);

    // Generate opcode for loop statements
    void GenerateLoop(LoopNode*& node, GeneratorContext* context);

    // Generate opcode for scope statements
    void GenerateScope(ScopeNode*& node, GeneratorContext* context);

    // Generate opcode for break statements
    void GenerateBreak(BreakNode*& node, GeneratorContext* context);

    // Generate opcode for continue statements
    void GenerateContinue(ContinueNode*& node, GeneratorContext* context);

    // Generate opcode for binary operations
    void GenerateBinaryOperation(BinaryOperatorNode*& node, GeneratorContext* context);

    // Generate opcode for unary operations
    void GenerateUnaryOperation(UnaryOperatorNode*& node, GeneratorContext* context);

    // Generate opcode for the unary property delegate operator
    void GeneratePropertyDelegateOperation(PropertyDelegateOperatorNode*& node, GeneratorContext* context);

    // Generate opcode for member accesses (function, data, etc)
    void GenerateMemberAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for static data-member accesses
    void GenerateStaticFieldAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for data-member accesses
    void GenerateFieldAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for function-member accesses
    void GenerateFunctionDelegateMemberAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for property-member 'get'
    void GeneratePropertyGetMemberAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for property-member 'set'
    void GeneratePropertySetMemberAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for the initializers in the initializer list (base, this, etc)
    void GenerateInitializer(InitializerNode*& node, GeneratorContext* context);

    // Allocate a delegate opcode of type T
    template <typename T>
    T& DelegateOpcode
    (
      Function*           caller,
      Function*           toCall,
      OperandIndex        delegateDest,
      const CodeLocation& location,
      Instruction::Enum   instruction,
      DebugOrigin::Enum   debug
    );

    // Create an instance delegate for the given type or source (the this handle will be created)
    void CreateInstanceDelegateAndThisHandle
    (
      Function*           caller,
      Function*           toCall,
      Type*               thisType,
      const Operand&      thisSource,
      Operand&            delegateDestOut,
      bool                canBeVirtual,
      const CodeLocation& location,
      DebugOrigin::Enum   debug
    );

    // Create an instance delegate for the given type or source (we provide the this handle)
    void CreateInstanceDelegateWithThisHandle
    (
      Function*           caller,
      Function*           toCall,
      const Operand&      thisHandle,
      Operand&            delegateDestOut,
      bool                canBeVirtual,
      const CodeLocation& location,
      DebugOrigin::Enum   debug
    );

    // Create a static delegate for the given type or source
    void CreateStaticDelegate
    (
      Function*           caller,
      Function*           toCall,
      Operand&            delegateDest,
      const CodeLocation& location,
      DebugOrigin::Enum   debug
    );

    // Generate opcode for type-casts
    void GenerateTypeCast(TypeCastNode*& node, GeneratorContext* context);
    
    // Generate the retrieval of a type
    void GenerateTypeId(TypeIdNode*& node, GeneratorContext* context);

    // Generate opcode for referencing local and parameter variables
    void GenerateLocalVariableReference(LocalVariableReferenceNode*& node, GeneratorContext* context);

    // Generate opcode for return values
    void GenerateReturnValue(ReturnNode*& node, GeneratorContext* context);

    // Generate opcode for function calls
    void GenerateFunctionCall(FunctionCallNode*& node, GeneratorContext* context);

    // Generate the opcode for a function call (*before* opcode for argument copying)
    void GenerateCallOpcodePreArgs(Function* caller, DelegateType* delegateTypeToCall, const Operand& delegateLocal, const CodeLocation& location, DebugOrigin::Enum debugOrigin);

    // Generate the opcode for a function call (*after* opcode for argument copying)
    void GenerateCallOpcodePostArgs(Function* caller, DelegateType* delegateTypeToCall, Operand* returnAccessOut, const CodeLocation& location, DebugOrigin::Enum debugOrigin);

    // Collect all the values used in expressions
    void CollectValue(ValueNode*& node, GeneratorContext* context);

    // Collect all the string interpolant expressions
    void GenerateStringInterpolants(StringInterpolantNode*& node, GeneratorContext* context);

    // Generate opcode for deleting objects in memory
    void GenerateDelete(DeleteNode*& node, GeneratorContext* context);

    // Generate opcode for throwing an exception
    void GenerateThrow(ThrowNode*& node, GeneratorContext* context);

    // Finds all the new calls and generates opcode to create objects
    void GenerateStaticTypeOrCreationCall(StaticTypeNode*& node, GeneratorContext* context);

    // Invokes 'Add' and intializes members
    void GenerateExpressionInitializer(ExpressionInitializerNode*& node, GeneratorContext* context);
    
    // Perform all the expressions of the multi-expression, and then yield the access to one of them
    void GenerateMultiExpression(MultiExpressionNode*& node, GeneratorContext* context);

    // Allocate a local on a function (and setup an access to point at it)
    void CreateLocal(Function* function, size_t size, Operand& accessOut);

    // Create a r-value unary operator opcode
    void CreateRValueUnaryOpcode(Function* function, UnaryOperatorNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin);

    // Create a l-value unary operator opcode
    void CreateLValueUnaryOpcode(Function* function, UnaryOperatorNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin);

    // Create a conversion opcode
    void CreateConversionOpcode(Function* function, TypeCastNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin);

    // Determine the proper opcode for unary operations
    void GenerateUnaryOp(Function* function, UnaryOperatorNode& node, DebugOrigin::Enum debugOrigin);

    // Determine the proper opcode for conversion operations
    void GenerateConversion(Function* function, TypeCastNode& node, DebugOrigin::Enum debugOrigin);

    // Create a copy opcode
    void CreateCopyOpcode(Function* function, CopyMode::Enum mode, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for copy operations (we're initializing the return value)
    void GenerateCopyToReturn(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for copy operations (we're initializing memory)
    void GenerateCopyInitialize(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for copy parameter operations
    void GenerateCopyToParameter(Function* function, Type* type, const Operand& source, OperandIndex destRegister, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for copy return operations
    void GenerateCopyFromReturn(Function* function, Type* type, OperandIndex sourceRegister, OperandIndex destRegister, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for creating a handle
    void GenerateHandleInitialize(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

  private:

    // Store all the walkers
    BranchWalker<CodeGenerator, GeneratorContext> GeneratorWalker;
    BranchWalker<CodeGenerator, GeneratorContext> PropertySetWalker;

    // The library that we're currently building
    LibraryBuilder* Builder;
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SYNTAXER_HPP
#define ZILCH_SYNTAXER_HPP

// Includes



namespace Zilch
{
  // A context we use to collect all class types
  class ClassContext : public WalkerContext<Syntaxer, ClassContext>
  {
  public:
    // Store all the classes we're compiling
    Array<BoundType*> AllClasses;
  };

  // A context used for walking everything (classes, functions, expressions, etc)
  class TypingContext : public WalkerContext<Syntaxer, TypingContext>
  {
  public:
    // Store the current function that we're building
    FunctionArray FunctionStack;

    // Store the current type that we're building
    Array<BoundType*> ClassTypeStack;

    // In general it should not be required to clear this context, however, because of
    // tolerant mode it is possible to end a tree walk and still have data in the context stacks
    // If we are not in tolerant mode, this will assert if anything is leftover
    void Clear(bool tolerantMode);
  };

  // When we walk dependencies, this is the state of a type used in dependencies
  namespace DependencyState
  {
    enum Enum
    {
      Undetermined,
      BeingDetermined,
      Completed
    };
  }

  // This class implements a recursive descent parser that parses
  // through the token stream that we get from the tokenizer
  class Syntaxer
  {
  public:

    // Friends
    friend class CodeGenerator;
    friend class Overload;

    // Constructor
    Syntaxer(CompilationErrors& errors);

    // Destructor
    ~Syntaxer();

    // Perform type collecting, assigning, and checking on the tree or an individual expression
    void ApplyToTree
    (
      SyntaxTree& syntaxTree,
      LibraryBuilder& builder,
      Project& project,
      const Module& dependencies
    );

    // Retrieves/resolves a type if it exists
    Type* RetrieveType(SyntaxType* syntaxType, const CodeLocation& location, const Module& dependencies);

  private:

    // Walk through all dependenices, collect all their types and store them in a map
    void PopulateDependencies();

    void FindDependencyCycles(BoundType* type, HashMap<BoundType*, DependencyState::Enum>& dependencies, const CodeLocation& location);

    // Print out an error message corresponding to a given node
    void ErrorAt(SyntaxNode* node, ErrorCode::Enum errorCode, ...);

    // Print out an error message corresponding to a given node
    void ErrorAtArgs(SyntaxNode* node, ErrorCode::Enum errorCode, va_list argList);

    // Replace a populated array of syntax types
    void ReplaceTypes(SyntaxTypes& types, Array<const UserToken*>& names, const BoundSyntaxType* instanceType, const CodeLocation& location);

    // Recursively perform a templated replacement of certain parameters
    void PerformTemplateReplacement(SyntaxType* type, Array<const UserToken*>& names, const BoundSyntaxType* instanceType);
    void PerformTemplateReplacement(SyntaxNode* node, Array<const UserToken*>& names, const BoundSyntaxType* instanceType);

    // Retrieves a type by name (for cases where you expect the type to exist
    BoundType* RetrieveBoundType(BoundSyntaxType* type, const CodeLocation& location);

    // Retrieves a type if it exists (or potentially creates a type if it's a qualified version of a type that exists)
    Type* RetrieveType(SyntaxType* syntaxType, const CodeLocation& location);

    // Make sure we don't have another class/struct/enum of the same name
    // Sets WasError if another type exists of the same name
    void PreventDuplicateTypeNames(StringParam name, const CodeLocation& location);

    // Make sure we don't have another member of the same name (an exception is made for functions due to overloading)
    // Sets WasError if another type exists of the same name
    void PreventDuplicateMemberNames(BoundType* type, StringParam memberName, const CodeLocation& location, bool isStatic, bool isFunction);

    // Collect a class type
    void CollectClass(ClassNode*& node, ClassContext* context);

    // Collect an enum type
    void CollectEnum(EnumNode*& node, ClassContext* context);

    // Collect all template instantiations
    void CollectTemplateInstantiations(SyntaxNode*& node, ClassContext* context);

    // Given a list of syntax types, attempt to instantiate any referenced templates from them (recursive)
    void InstantiateTemplatesFromSyntaxTypes(SyntaxTypes& types, ClassContext* context, const CodeLocation& location);
    
    // Setup a class instance for a given class node (called by CollectClass, and CollectTemplateInstantiations)
    void SetupClassInstance(ClassNode* node, ClassContext* context);

    // Setup the location for a function, as well as the this variable
    void SetupFunctionLocation(Function* function, const CodeLocation& location, const CodeLocation& nameLocation);

    // Read all the attributes from an attribute node list into an array of attributes
    void ReadAttributes(SyntaxNode* parentNode, NodeList<AttributeNode>& nodes, Array<Attribute>& attributesOut);

    // Setup the inheritance chain (including interfaces and base class)
    void CollectClassInheritance(ClassNode*& node, TypingContext* context);

    // Collect all instances of send events declarations
    void CollectSendsEvents(SendsEventNode*& node, TypingContext* context);

    // Setup the inheritance chain for enums (only one parent, no interfaces)
    void CollectEnumInheritance(EnumNode*& node, TypingContext* context);

    // Collect/setup all the functions (the owner can be passed in for extension functions)
    // Otherwise the owner is obtained from the typing context stack
    void SetupGenericFunction(GenericFunctionNode* node, TypingContext* context, const UserToken& name, FunctionOptions::Enum options, Type* returnType, BoundType* owner = nullptr);

    // Collect all the constructors
    void CollectConstructor(ConstructorNode*& node, TypingContext* context);

    // Collect the destructor (if it exists)
    void CollectDestructor(DestructorNode*& node, TypingContext* context);

    // Collect all the functions
    void CollectFunction(FunctionNode*& node, TypingContext* context);

    // Collect the member variables
    void CollectMemberVariableAndProperty(MemberVariableNode*& node, TypingContext* context);

    // Collect the member properties
    void CollectPropertyGetSet(MemberVariableNode*& node, TypingContext* context);

    // Store the class in the code context
    void PushClass(ClassNode*& node, TypingContext* context);

    // Process all statements in a scope
    void ProcessScopeStatements(ScopeNode* node, TypingContext* context);

    // Helper functions
    template <typename FunctionNodeType>
    void PushFunctionHelper
    (
      FunctionNodeType* node,
      TypingContext* context,
      void (Syntaxer::*postArgs)(FunctionNodeType* node)
    );

    // Store the function in the code context
    void PushFunction(GenericFunctionNode*& node, TypingContext* context);

    // Store the constructor function in the code context
    void CheckInitializerList(ConstructorNode* node);
    void PushConstructor(ConstructorNode*& node, TypingContext* context);

    // Assign a type to any child value node
    void DecorateValue(ValueNode*& node, TypingContext* context);

    // Let the string interpolant know it's of a string type
    void DecorateStringInterpolant(StringInterpolantNode*& node, TypingContext* context);
    
    // Assign a type to the initializer
    void DecorateInitializer(InitializerNode*& node, TypingContext* context);

    // Handle checking that the creation call is valid for its type (also infers new/local if not provided)
    void DecorateStaticTypeOrCreationCall(StaticTypeNode*& node, TypingContext* context);

    // Handle initializing a created object or adding to a container (technically this can come after any expression)
    void DecorateExpressionInitializer(ExpressionInitializerNode*& node, TypingContext* context);
    
    // A multi-expression is a single expression that runs multiple expressions and then yields the results of one of them
    // This forwards the type of the yielded expresion (and walks them all)
    void DecorateMultiExpression(MultiExpressionNode*& node, TypingContext* context);

    // Make sure type-id results in a type
    void DecorateTypeId(TypeIdNode*& node, TypingContext* context);

    // Assign member variable types (if required), and check that the initialization type matches
    void CheckMemberVariable(MemberVariableNode*& node, TypingContext* context);

    // Assign local variable types (if required), and check that the initialization type matches
    void CheckLocalVariable(LocalVariableNode*& node, TypingContext* context);

    // Check the type of an delete statement's expression
    void CheckDelete(DeleteNode*& node, TypingContext* context);

    // Check that the type of a throw statement is an exception type (inherits from)
    void CheckThrow(ThrowNode*& node, TypingContext* context);

    // Check the condition and statements in a conditional loop
    void CheckConditionalLoop(ConditionalLoopNode* node, TypingContext* context);

    // Check the type of an while statement's condition
    void CheckWhile(WhileNode*& node, TypingContext* context);

    // Check the type of an do while statement's condition
    void CheckDoWhile(DoWhileNode*& node, TypingContext* context);

    // Check the type of an for statement's condition
    void CheckFor(ForNode*& node, TypingContext* context);

    // Checks the statements within a loop node
    void CheckLoop(LoopNode*& node, TypingContext* context);

    // Checks the statements within a scope node
    void CheckScope(ScopeNode*& node, TypingContext* context);

    // Checks the statements within a timeout node
    void CheckTimeout(TimeoutNode*& node, TypingContext* context);

    // Check the type of an if statement's condition
    void CheckIfRoot(IfRootNode*& node, TypingContext* context);

    // Check the type of an if statement's condition
    void CheckIf(IfNode*& node, TypingContext* context);

    // Find a loop scope node above our own node in the tree
    LoopScopeNode* FindLoopScope(size_t scopeCount, SyntaxNode* parent);

    // Check the type of an break statement's condition
    void CheckBreak(BreakNode*& node, TypingContext* context);

    // Check the type of an continue statement's condition
    void CheckContinue(ContinueNode*& node, TypingContext* context);

    // Resolve a local variable reference (get the variable its referencing)
    void ResolveLocalVariableReference(LocalVariableReferenceNode*& node, TypingContext* context);

    // Mark the parent scope node as being a complete path
    void MarkParentScopeAsAllPathsReturn(SyntaxNode* parent, bool isDebugReturn);

    // If the types are the same, no conversion is applied and the node is left alone
    // If the types are different and an implicit conversion exists, then it will reparent the expression to a TypeCastNode
    // Otherwise, it will return false since no conversion is available
    // Note: Always remember to pass the actual node pointer in instead of a stack local so we can modify it in place!
    static bool ImplicitConvertAfterWalkAndIo(ExpressionNode*& nodeToReparent, Type* toType);

    // Check the type of a return value
    void CheckReturn(ReturnNode*& node, TypingContext* context);

    // Assign a type to a type cast expression (and check the type)
    void DecorateCheckTypeCast(TypeCastNode*& node, TypingContext* context);

    // Assign a type to a function call (and check the type)
    void DecorateCheckFunctionCall(FunctionCallNode*& node, TypingContext* context);

    // Check that the binary operator is valid and that it's types are valid
    void DecorateCheckBinaryOperator(BinaryOperatorNode*& node, TypingContext* context);

    // Check that the unary operator is valid and that it's types are valid
    void DecorateCheckPropertyDelegateOperator(PropertyDelegateOperatorNode*& node, TypingContext* context);

    // Check that the unary operator is valid and that it's types are valid
    void DecorateCheckUnaryOperator(UnaryOperatorNode*& node, TypingContext* context);

    // Check all expressions and verify that their io modes are being used properly
    void CheckExpressionIoModes(ExpressionNode*& node, TypingContext* context);

    // Make sure all nodes know which library, class, and function they belong to
    void DecorateCodeLocations(SyntaxNode*& node, TypingContext* context);

    // Utility for replacing/clarifying a member access operator (works with both static and instance members)
    void ResolveMemberAccess(MemberAccessNode* node, const Resolver& resolver);

    // Resolve the node type of a member (after a member access operator...)
    void ResolveMember(MemberAccessNode*& node, TypingContext* context);

    // Because replacing the side-effect operator case for binary/unary operators is so similar, we functionalized it
    // The template type should be the operator node type
    template <typename NodeType>
    void BuildGetSetSideEffectIndexerNodes(NodeType*& node, IndexerCallNode* indexer, ExpressionNode* NodeType::* operandMemberThatWasIndexer, TypingContext* context);

    // When we hit a binary operator that has side effects and the left operand is an indexer
    // We need to transform the binary operator into being a child of the indexer, and promote the indexer to parent
    // If the binary operator is a straight assignment, then it only invokes Set, otherwise its a Get/Set
    void IndexerBinaryOperator(BinaryOperatorNode*& node, TypingContext* context);

    // When we hit a unary operator that has side effects and the left operand is an indexer
    // We need to transform the binary operator into being a child of the indexer, and promote the indexer to parent
    // If the binary operator is a straight assignment, then it only invokes Set, otherwise its a Get/Set
    void IndexerUnaryOperator(UnaryOperatorNode*& node, TypingContext* context);

    // If we visit an indexer by itself (not as a side effect left-binary/unary operator) then we simply
    // replace it with a call to .Get(index0, index1...)
    void IndexerIndexerCall(IndexerCallNode*& node, TypingContext* context);

  private:

    // Store a pointer to the current syntax tree
    SyntaxTree* Tree;

    // Store a pointer back to the project that we're created from
    Project* ParentProject;

    // Store a reference to the error handler
    CompilationErrors& Errors;

    // The library builder we use to generate the library
    LibraryBuilder* Builder;

    // All the other libraries we depend upon
    const Module* Dependencies;

    // All the dependency libraries, and our own (useful for generic searching)
    LibraryArray AllLibraries;

    // Store a map of all the named external types
    BoundTypeMap ExternalBoundTypes;

    // All named tempalte types
    HashMap<String, ClassNode*> InternalBoundTemplates;

    // A map that allows us to cut down on the number of qualified types we allocate
    TypeToIndirect IndirectTypes;

    // All the branch walkers
    BranchWalker<Syntaxer, ClassContext>  ClassWalker;
    BranchWalker<Syntaxer, ClassContext>  TemplateWalker;
    BranchWalker<Syntaxer, TypingContext> MemberWalker;
    BranchWalker<Syntaxer, TypingContext> IndexerWalker;
    BranchWalker<Syntaxer, TypingContext> FunctionWalker;
    BranchWalker<Syntaxer, TypingContext> LocationWalker;
    BranchWalker<Syntaxer, TypingContext> TypingWalker;
    BranchWalker<Syntaxer, TypingContext> ExpressionWalker;

    // Not copyable
    ZilchNoCopy(Syntaxer);
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Joshua Davis
* Copyright 2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_MATRIX_HPP
#define ZILCH_MATRIX_HPP



namespace Zilch
{

  // User data for a single matrix so that functions can be generic
  // to matrices of different sizes and types
  class MatrixUserData
  {
  public:
    MatrixUserData()
      : SizeX(4), SizeY(4), ElementTypeIndex(0)
    {

    }

    MatrixUserData(size_t sizeX, size_t sizeY, size_t elementTypeIndex)
      : SizeX(sizeX), SizeY(sizeY), ElementTypeIndex(elementTypeIndex)
    {

    }

    size_t SizeX;
    size_t SizeY;
    // What kind of matrix this is (Real, Integer, Boolean).
    // This is an index into Core::MatrixElementTypes.
    size_t ElementTypeIndex;
  };

  // Create all of the matrix types and their functions on the math class
  void CreateMatrixTypes(LibraryBuilder& builder);

}//namespace Zilch

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_HASH_CONTAINER_HPP
#define ZILCH_HASH_CONTAINER_HPP

// Includes



namespace Zilch
{
  typedef Pair<Any, Any> AnyKeyValue;

  class AnyHashMap : public HashMap<Any, Any>
  {
  public:
    // Constructor
    AnyHashMap();

    // Invalidates all active ranges via incrementing a modification id
    void Modified();

    // A special counter that we use to denote whenever the container has been modified
    Integer ModifyId;
  };

  class AnyHashMapRange
  {
  public:

    AnyHashMapRange();

    // The hash map range that we contain
    AnyHashMap::range Range;

    // The original range allows us to revert when Reset is called
    AnyHashMap::range OriginalRange;

    // A handle back to the source container that our data belongs to
    Handle HashMap;

    // The id that the container had when we were created from it
    Integer ModifyId;

    // Moves to the next element in the range
    void MoveNext();

    // Resets the range back to the original position
    void Reset();

    // Checks if there are no more elements left within the range
    bool IsEmpty();

    // Checks if there are still elements left within the range
    bool IsNotEmpty();
  };
  
  // The user-data we attach to the hash map class (every template instantiation)
  class HashMapUserData
  {
  public:
    HashMapUserData();

    Type* KeyType;
    Type* ValueType;
    BoundType* PairRangeType;
    BoundType* ValueRangeType;
    BoundType* KeyRangeType;
  };

  namespace HashMapRangeMode
  {
    enum Enum
    {
      Pair,
      Value,
      Key
    };
  }
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_FILE_PATH_HPP
#define ZILCH_FILE_PATH_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_STREAM_HPP
#define ZILCH_STREAM_HPP

// Includes






namespace Zilch
{
  class IStreamClass;
  class AsciiEncoding;
  class Utf8Encoding;

  // Lets us query what a stream is capable of doing before we try it
  // Otherwise we'll cause an exception to be thrown for doing something invalid
  namespace StreamCapabilities
  {
    enum Enum
    {
      None      = 0,
      Read      = 1,
      Write     = 2,
      Seek      = 4,
      GetCount  = 8,
      SetCount  = 16,

      // All enums bound to Zilch must be of Integer size, so force it on all platforms
      ForceIntegerSize = 0x7FFFFFFF
    };
  }
  ZilchDeclareExternalBaseType(StreamCapabilities::Enum, TypeCopyMode::ValueType);

  // When we seek in a stream, we can specifiy to seek from the start, end, etc
  // Note: This must match up to the Zero::FileOrigin
  namespace StreamOrigin
  {
    enum Enum
    {
      Current,
      Start,
      End,

      // All enums bound to Zilch must be of Integer size, so force it on all platforms
      ForceIntegerSize = 0x7FFFFFFF
    };
  }
  ZilchDeclareExternalBaseType(StreamOrigin::Enum, TypeCopyMode::ValueType);

  // An encoding is a generic interface for writing out strings to any format (wide character, Utf16, etc)
  class IEncoding
  {
  public:
    ZilchDeclareBaseType(IEncoding, TypeCopyMode::ReferenceType);

    // Ascii encoding will strip wide characters and turn them into spaces
    // All characters that fit within a single byte will be directly written to the stream
    static AsciiEncoding& GetAscii();

    // Writes every rune to the file encoded in Utf8 form
    // (the Zilch string is already in UTF8 form, so it would be written directly)
    static Utf8Encoding& GetUtf8();

    // Write whatever bytes are needed to represent a single rune
    // Returns the number of bytes written to the stream
    virtual Integer Write(Rune rune, IStreamClass& stream);

    // Read whatever bytes are needed to represent a single rune
    // If the stream Read or ReadByte returns that it read no data, this will return the null Rune
    virtual Rune Read(IStreamClass& stream);
  };
  
  // Ascii encoding will strip wide characters and turn them into spaces
  // All characters that fit within a single byte will be directly written to the stream
  class AsciiEncoding : public IEncoding
  {
  public:
    Integer Write(Rune rune, IStreamClass& stream) override;
    Rune Read(IStreamClass& stream) override;
  };
  
  // Ascii encoding will strip wide characters and turn them into spaces
  // All characters that fit within a single byte will be directly written to the stream
  class Utf8Encoding : public IEncoding
  {
  public:
    Integer Write(Rune rune, IStreamClass& stream) override;
    Rune Read(IStreamClass& stream) override;
  };

  // A generic interface for reading and writing data to a stream (file, network, etc)
  class IStreamClass
  {
  public:
    ZilchDeclareBaseType(IStreamClass, TypeCopyMode::ReferenceType);

    // Lets us query what a stream is capable of doing before we try it
    virtual StreamCapabilities::Enum GetCapabilities();

    // Get where we are in the stream relative to the beginning, in bytes
    // Note: The setter is non-virtual, and requires the Seek capability
    virtual DoubleInteger GetPosition();

    // Gets or sets how long our stream is in bytes
    // If the stream is capable of getting the count but it fails then it will return -1
    // Check the stream capabilities for both GetCount and SetCount before reading or writing to this value
    virtual DoubleInteger GetCount();
    virtual void SetCount(DoubleInteger count);

    // Moves the stream to a given position (relative to an origin)
    // Returns true if the seek fully succeeded, or false otherwise
    // Check the stream capabilities for Seek before calling this function
    virtual bool Seek(DoubleInteger position, StreamOrigin::Enum origin);

    // Writes an amount of data to the stream and returns the amount that was actually written
    // This will throw if the byteStart and byteCount exceeds the array size
    // Check the stream capabilities for Write before calling this function
    virtual Integer Write(ArrayClass<Byte>& data, Integer arrayByteStart, Integer arrayByteCount);

    // Writes a single byte of data to the stream (should be implemented for efficiency)
    // Returns 1 if the single byte was written, or 0
    // Check the stream capabilities for Write before calling this function
    virtual Integer WriteByte(Byte byte);

    // Reads data from the stream into an array
    // If the array is not large enough to store the data at the start/with the given count, it will be resized
    // Check the stream capabilities for Read before calling this function
    virtual Integer Read(ArrayClass<Byte>& data, Integer arrayByteStart, Integer arrayByteCount);

    // Reads a single byte of data or returns -1 if the byte could not be read
    // Check the stream capabilities for Write before calling this function
    virtual Integer ReadByte();

    // Some streams will buffer data before writing it out to whatever hardware device it targets
    // This is an optimization because memory is generally much faster, however, if you want to force the
    // stream to write out all its data, then call this function
    virtual void Flush();

    // Extensions below (non virtual functions that are just helpers)

    // If the flag 'resize' is true, then we will attempt to resize the array to fit the data
    // Otherwise we will throw exceptions for ranges that go outside the array
    // Invalid values will always cause exceptions to be thrown (such as a negative value)
    // Returns true if it succeeds (or resizes) or false if it throws an exception
    static bool ValidateArray(ArrayClass<Byte>& data, Integer byteStart, Integer byteCount, bool resizeArrayIfNeeded);
    
    // Directly set the position where we are in the stream (always from the beginning, in bytes)
    // Invokes Seek, and if it fails it will attempt to clamp the position either to 0 or to the end of the stream and Seek again
    // Check the stream capabilities for Seek before setting the position
    void SetPosition(DoubleInteger position);

    // Writes an entire array of bytes to the stream and returns the amount that was actually written
    // Check the stream capabilities for Write before calling this function
    Integer Write(ArrayClass<Byte>& data);

    // Writes a string range to the stream with a specified encoding (IEncoding.Ascii, etc)
    // Returns the number of bytes that were written to the stream
    // This function will not consume the string range
    // Check the stream capabilities for Write before calling this function
    Integer WriteText(StringParam text, IEncoding& destinationStreamEncoding);

    // Same as the above WriteText, but assumes Utf8 encoding
    Integer WriteText(StringParam text);
    
    // Reads data from the stream and returns it into an array
    // The length of the array will indicate how much was actually read
    // Check the stream capabilities for Read before calling this function
    // Note: The memory is allocated within Zilch's Heap Manager and must be freed after using ObjectToHandle
    // This function is not enabled until we fix binding being able to return Handle<ArrayClass<Byte> >
    //ArrayClass<Byte>* Read(Integer byteCount);

    // Reads bytes and converts them into runes via the specified encoding until we reach the '\n', '\0', or the end of the stream
    // Note: '\r' is not used as a line terminator because that format is out-dated
    // Read line always returns the line including the '\n' at the end
    // If a line does include a '\n' at the end, it means we reached the end of the stream (or an error occurred)
    // An empty string will be returned if ReadLine is called again after it already reached the end of the stream
    String ReadLine(IEncoding& sourceStreamEncoding);
    
    // Same as the above ReadLine, but assumes Utf8 encoding
    String ReadLine();
    
    // Reads bytes and converts them into runes via the specified encoding until we reach '\0' or the end of the stream
    String ReadAllText(IEncoding& sourceStreamEncoding);

    // Same as the above ReadAllText, but assumes Utf8 encoding
    String ReadAllText();
  };
}

// End header protection
#endif


namespace Zilch
{
  class FilePathClass
  {
  public:
    ZilchDocument(FilePathClass,
    "A helper class for building file paths and extracting information from file paths");
    ZilchDeclareBaseType(FilePathClass, TypeCopyMode::ReferenceType);

    ZilchDocument(CombineDirectories,
      "Combines directory paths and directories names together (empty entries are skipped). "
    "This will always include a directory separator at the end of the result.\n"
    "Example: ('Content', 'Powerups') results in 'Content\\Powerups\\'\n"
    "Example: ('Content\\', 'Powerups\\') results in 'Content\\Powerups\\'\n"
    "Example: ('Content\\', '', 'Powerups') results in 'Content\\Powerups\\'\n"
    "Example: ('C:\\Sandbox\\', 'Content') results in 'C:\\Sandbox\\Content\\'\n");
    static String CombineDirectories(StringParam dir0, StringParam dir1);
    static String CombineDirectories(StringParam dir0, StringParam dir1, StringParam dir2);
    static String CombineDirectories(StringParam dir0, StringParam dir1, StringParam dir2, StringParam dir3);
    static String CombineDirectories(StringParam dir0, StringParam dir1, StringParam dir2, StringParam dir3, StringParam dir4);

    ZilchDocument(CombineDirectoriesAndFile,
    "Combines directory paths, directories names, and a single file name together (empty entries are skipped). "
    "Because we are combining a file name at the end, this will not result in a trailing directory separator.\n"
    "Example: ('Content\\Powerups\\', 'Recharge.png') results in 'Content\\Powerups\\Recharge.png'\n"
    "Example: ('Content\\Powerups', '', 'Recharge.png') results in 'Content\\Powerups\\Recharge.png'\n"
    "Example: ('Content', 'Powerups', 'Recharge.png') results in 'Content\\Powerups\\Recharge.png'\n"
    "Example: ('C:\\Sandbox\\', 'Content\\Player.png') results in 'C:\\Sandbox\\Content\\Player.png'\n");
    static String CombineDirectoriesAndFile(StringParam dir0, StringParam fileName);
    static String CombineDirectoriesAndFile(StringParam dir0, StringParam dir1, StringParam fileName);
    static String CombineDirectoriesAndFile(StringParam dir0, StringParam dir1, StringParam dir2, StringParam fileName);
    static String CombineDirectoriesAndFile(StringParam dir0, StringParam dir1, StringParam dir2, StringParam dir3, StringParam fileName);
    
    ZilchDocument(DirectorySeparator,
    "Gets the character(s) used for separating directories and files. "
    "This value is often different depending on the operating system (generally either '/' or '\\')\n");
    static String GetDirectorySeparator();
    
    ZilchDocument(ChangeExtension,
    "Changes the extension of a path (with file name at the end) to a new extension. "
    "If the file has no extension, then this will automatically add the extension to the end. "
    "The extension is allowed to contain a leading dot '.' character (or not). "
    "The path is also allowed to contain a trailing dot '.' character (or not).\n"
    "Example: ('Content\\Player.png', 'jpg') results in 'Content\\Player.jpg'\n"
    "Example: ('Content\\Player', 'jpg') results in 'Content\\Player.jpg'\n"
    "Example: ('Content\\Player.', '.jpg') results in 'Content\\Player.jpg'\n");
    static String ChangeExtension(StringParam path, StringParam extension);
    
    ZilchDocument(GetExtensionWithDot,
    "Returns only the extension of a file (everything after the last dot, including the dot). "
    "If the file has no extension then this will return an empty string.\n"
    "Example: ('Content\\Player.png') results in '.png'\n"
    "Example: ('Content\\Player.') results in ''\n"
    "Example: ('Parent.Directory\\Log') results in ''\n");
    static String GetExtensionWithDot(StringParam path);
    
    ZilchDocument(GetExtensionWithoutDot,
    "Returns only the extension of a file (everything after the last dot, not including the dot). "
    "If the file has no extension then this will return an empty string.\n"
    "Example: ('Content\\Player.png') results in 'png'\n"
    "Example: ('Content\\Player.') results in ''\n"
    "Example: ('Parent.Directory\\Log') results in ''\n");
    static String GetExtensionWithoutDot(StringParam path);

    ZilchDocument(GetFileNameWithExtension,
    "Returns only the file portion of a path (everything past the last separator including the extension).\n"
    "Example: ('Content\\Player.png') results in 'Player.png'\n"
    "Example: ('Content\\Powerups\\') results in ''\n"
    "Example: ('Content\\Powerups') results in 'Powerups'\n");
    static String GetFileNameWithExtension(StringParam path);
    
    ZilchDocument(GetFileNameWithoutExtension,
    "Returns only the file portion of a path (everything past the last separator excluding the extension).\n"
    "Example: ('Content\\Player.png') results in 'Player'\n"
    "Example: ('Content\\Powerups\\') results in ''\n"
    "Example: ('Content\\Powerups') results in 'Powerups'\n");
    static String GetFileNameWithoutExtension(StringParam path);

    ZilchDocument(AddTrailingDirectorySeparator,
    "Pass in a directory path with or without the separator and this will add it at the end (if needed).\n"
    "Example: ('Content\\Powerups') results in 'Content\\Powerups\\'\n"
    "Example: ('Content\\Powerups\\') results in 'Content\\Powerups\\'\n");
    static String AddTrailingDirectorySeparator(StringParam path);

    ZilchDocument(RemoveTrailingDirectorySeparator,
    "Pass in a directory path with or without the separator and this will remove it from the end (if needed).\n"
    "Example: ('Content\\Powerups') results in 'Content\\Powerups'\n"
    "Example: ('Content\\Powerups\\') results in 'Content\\Powerups'\n");
    static String RemoveTrailingDirectorySeparator(StringParam path);

    ZilchDocument(GetDirectoryPath,
    "If a file path is passed in, this will return the parent directory. "
    "If a directory path is passed in (ending in a separator), this will return the directy back with no modifications. "
    "A directory path without a trailing separator is abiguous with a file that has no extension. "
    "This will always include a directory separator at the end of the result. "
    "In this case, we always assume it is a file and therefore get the parent directory's name.\n"
    "Example: ('Content\\Powerups\\Recharge.png') results in 'Content\\Powerups\\'\n"
    "Example: ('Content\\Powerups\\') results in 'Content\\Powerups\\'\n"
    "Example: ('Content\\Powerups') results in 'Content\\'\n"
    "Example: ('Content') results in ''\n");
    static String GetDirectoryPath(StringParam path);

    ZilchDocument(GetDirectoryName,
    "If a file path is passed in, this will return the name of the parent directory. "
    "If a directory path is passed in (ending in a separator), this will return the name of the directory. "
    "A directory path without a trailing separator is abiguous with a file that has no extension. "
    "In this case, we always assume it is a file and therefore get the parent directory's name.\n"
    "Example: ('Content\\Powerups\\Recharge.png') results in 'Powerups'\n"
    "Example: ('Content\\Powerups\\') results in 'Powerups'\n"
    "Example: ('Content\\Powerups') results in 'Content'\n"
    "Example: ('Content') results in ''\n");
    static String GetDirectoryName(StringParam path);

    ZilchDocument(GetCanonicalizedPathFromAbsolutePath,
    "Changes all directory separators to be the current operating system directory separator, removes duplicate separators, and removes '..' and '.' from the paths. "
    "Canonicalized is only guaranteed to work on absolute paths. "
    "This behavior is operating system dependant and may call the related OS functions.\n"
    "Example: ('C:/Sandbox//Engine/../Content/./Player.png') results in 'C:\\Sandbox\\Content\\Player.png'\n");
    static String GetCanonicalizedPathFromAbsolutePath(StringParam absolutePath);

    ZilchDocument(GetComparablePathFromAbsolutePath,
    "First this normalizes the path, then if the operating system is case insensative, it will make the path all lowercase so that it compares.\n"
    "Example: ('C:\\Sandbox\\Engine\\..\\Content\\.\\Player.png') results in 'c:\\sandbox\\content\\player.png'\n");
    static String GetComparablePathFromAbsolutePath(StringParam path);

    ZilchDocument(IsRelative,
    "Returns true if a path has no root (such as a volume/hard drive specifier, or unix like systems a beginning slash). "
    "Even a beginning slash that means 'relative to the current working directory volume' is still relative. "
    "Empty paths will return that they are relative.\n"
    "Example: ('C:\\Sandbox\\Engine\\..\\Content\\.\\Player.png') results in 'false'\n"
    "Example: ('Sandbox') results in 'true'\n"
    "Example: ('Content\\Powerups\\Recharge.png') results in 'true'\n"
    "Example: ('/usr/Content/Player.png') results in 'false'\n");
    static bool IsRelative(StringParam path);
    
    ZilchDocument(WorkingDirectory,
    "A directory that all relative paths start resolving from. "
    "In general the changing of the working directory is discouraged because it may affect assumptions of the host application. "
    "This will always include a directory separator at the end of the result.\n");
    static String GetWorkingDirectory();
    static void SetWorkingDirectory(StringParam path);
    
    ZilchDocument(TemporaryDirectory,
    "Temporary files should be placed here. "
    "This will always include a directory separator at the end of the result.\n");
    static String GetTemporaryDirectory();
    
    ZilchDocument(UserLocalDirectory,
    "Application saved information should be placed here (read/write/create permissions should be allowed). "
    "This will always include a directory separator at the end of the result.\n");
    static String GetUserLocalDirectory();
    
    ZilchDocument(UserDocumentsDirectory,
    "User saved data that the user can backup or modify should be placed here (read/write/create permissions should be allowed). "
    "This will always include a directory separator at the end of the result.\n");
    static String GetUserDocumentsDirectory();
    
    ZilchDocument(ExecutableDirectory,
    "The directory the executable lives with in (exe, elf...). "
    "This will always include a directory separator at the end of the result.\n");
    static String GetExecutableDirectory();
    
    ZilchDocument(ExecutableFile,
    "A path directly to the executable itself (exe, elf...).\n");
    static String GetExecutableFile();
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_FILE_STREAM_HPP
#define ZILCH_FILE_STREAM_HPP

// Includes


namespace Zilch
{
  // The options should specify whether we want to read or write from a file, as well as if we want to allow
  // others to read and write to the same file (via the share flags)
  namespace FileMode
  {
    enum Enum
    {
      // Reading will start at the beginning of the file
      // The file must exist or an exception will be thrown
      Read        = (1 << 0),

      // Writing will start at the beginning of the file
      // If the file does not exist it will be created
      Write       = (1 << 1),
      
      // Writing will start at the end of the file (implies the Write flag)
      // You cannot Seek to a position or Read from the stream in this mode
      // If the file does not exist it will be created
      Append      = (1 << 2),

      // Allows others to read from the file at the same time
      ShareRead   = (1 << 3),
      
      // Allows others to write to the file at the same time
      ShareWrite  = (1 << 4),
      
      // Allows others to delete the file even if we are using it
      ShareDelete = (1 << 5),

      // Optimizes for sequential reading (in order). Random access is implied if this flag is not set
      Sequential  = (1 << 6),

      // All enums bound to Zilch must be of Integer size, so force it on all platforms
      ForceIntegerSize = 0x7FFFFFFF
    };
  }
  ZilchDeclareExternalBaseType(FileMode::Enum, TypeCopyMode::ValueType);

  // A generic interface for reading and writing data to a stream (file, network, etc)
  class FileStream : public IStreamClass
  {
  public:
    ZilchDeclareDerivedType(FileStream, IStreamClass);

    // Constructor
    FileStream(StringParam filePath, FileMode::Enum mode);

    // IStreamClass interface
    StreamCapabilities::Enum GetCapabilities() override;
    DoubleInteger GetPosition() override;
    DoubleInteger GetCount() override;
    bool Seek(DoubleInteger position, StreamOrigin::Enum origin) override;
    Integer Write(ArrayClass<Byte>& data, Integer byteStart, Integer byteCount) override;
    Integer WriteByte(Byte byte) override;
    Integer Read(ArrayClass<Byte>& data, Integer byteStart, Integer byteCount) override;
    Integer ReadByte() override;
    void Flush() override;
    
  public:

    // The capabilities that we determined based on how we opened the file
    StreamCapabilities::Enum Capabilities;

    // The underlying operating system primitive that represents the file
    File InternalFile;
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Joshua Davis
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_RANDOM_HPP
#define ZILCH_RANDOM_HPP




///////////////////////////////////////////////////////////////////////////////
///
/// \file Random.hpp
/// Declaration of the Random number and vector generation functions.
/// 
/// Authors: Chris Peters, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
//The following comment is required to use the Mersenne Twister
/* 
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)  
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.                          

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote 
        products derived from this software without specific prior written 
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/
#pragma once





#include <stdlib.h>

namespace Math
{
//----------------------------------------------------------------------- Random
class Random
{
public:
  ///Seeds with a call to the "time" function
  Random(void);
  Random(int initialSeed);

  uint GetSeed();
  void SetSeed(uint seed);

  ///Generates a random number on the [0, 32,767] interval.
  uint Next(void);

  ///Generates a random number on the [0, 4,294,967,295] interval.
  u32 Uint32(void);

  ///Generates a random number on the [0, 18,446,744,073,709,551,616] interval.
  u64 Uint64(void);

  ///Generates a random number on the [0,1]-real-interval.
  float Float(void);

  ///Generates a random boolean value;
  bool Bool(void);

  ///Returns an integer value in the range of [min, max]
  int IntRangeInIn(int min, int max);

  ///Returns an integer value in the range of [min, max)
  int IntRangeInEx(int min, int max);

  ///Returns a integer value in the range of 
  ///[base - variance, base + variance]
  int IntVariance(int base, int variance);

  ///Returns a floating point value in the range of [min, max]
  float FloatRange(float min, float max);

  ///Returns a floating point value in the range of 
  ///[base - variance, base + variance]
  float FloatVariance(float base, float variance);

  Vector2 PointOnUnitCircle(void);

  ///Returns a point on a unit circle with the x-axis going through the center
  ///of the circle.
  Vector3 PointOnUnitCircleX(void);

  ///Returns a point on a unit circle with the y-axis going through the center
  ///of the circle.
  Vector3 PointOnUnitCircleY(void);

  ///Returns a point on a unit circle with the z-axis going through the center
  ///of the circle.
  Vector3 PointOnUnitCircleZ(void);
  

  Vector3 PointOnUnitCircle(uint axis);

  Vector3 PointOnUnitSphere(void);

  Vector3 PointInUnitSphere(void);

  ///Generate uniform random quaternion
  Quaternion RotationQuaternion(void);

  ///Randomly generates a Vec22 with its length between min and max
  Vector2 ScaledVector2(float minLength, float maxLength);

  ///Randomly generates a Vec3 with its length between min and max
  Vector3 ScaledVector3(float minLength, float maxLength);

  ///Generate uniform random matrix
  Matrix3 RotationMatrix(void);
  void RotationMatrix(Mat3Ptr matrix);

  // Randomly rolls a number in the range [1, sides]
  int DieRoll(uint sides);

  float BellCurve(float center, float range, float standardDeviation);

  static const uint cRandMax = 0x7FFF;

  // Global seed only when we don't seed the random
  // This is set every time anyone calls 'Next()', even if it's not used by the class
  static uint mGlobalSeed;

  uint mSeed;
};

//------------------------------------------------------------- Mersenne Twister
class MersenneTwister
{
public:
  ///Seeds with a call to the "time" function.
  MersenneTwister(void);

  ///Initializes the internal array with a seed.
  MersenneTwister(uint seed);

  ///Initialize by an array with array-length. "keys" is the array for 
  ///initializing keys. "keyLength" is its length.
  MersenneTwister(uint keys[], uint keyLength);

  ///Initializes the values with a seed.
  void Initialize(uint seed);

  ///Initialize by an array with array-length. "keys" is the array for 
  ///initializing keys. "keyLength" is its length.
  void Initialize(uint keys[], uint keyLength);

  ///Generates a random number on the [-2,147,483,648, 2,147,483,648] interval.
  int Int(void);

  ///Generates a random number on the [0, 4,294,967,295] interval.
  uint Uint(void);

  ///Generates a random number on the [0,1]-real-interval.
  float Float(void);

private:
  static const uint cN = 624;
  uint mValues[cN]; //The array for the state vector.
  uint mIndex;       //Index == cN+1 means the values aren't initialized.
};

}// namespace Math


namespace Zilch
{
  // Contains utility functions for random generation
  class Random
  {
  public:
    ZilchDeclareBaseType(Random, TypeCopyMode::ReferenceType);

    // Default constructor (grabs the random seed)
    Random();

    // Construct a random generator with a specific seed
    Random(uint seed);

    // The seed controls what random numbers are generated in a sequence (determanistically)
    // The same seed will always generate the same string of random numbers
    void SetSeed(uint seed);
    uint GetSeed();

    // Returns the max integer value that can be returned
    static int GetMaxInteger();

    // Returns a random boolean value
    bool Boolean();

    // Returns a random integer in the range of [0, MaxInt]
    int Integer();

    // Returns a random real in the range [0,1]
    float Real();

    // Generates a unit length Real2
    Math::Vector2 UnitReal2();

    // Randomly generates a Real2 with its length between min and max
    Math::Vector2 Real2(float minLength, float maxLength);

    // Generates a unit length Real3
    Math::Vector3 UnitReal3();

    // Randomly generates a Real3 with its length between min and max
    Math::Vector3 Real3(float minLength, float maxLength);

    // Random unit length quaternion. This is also a unit quaternion
    Zilch::Quaternion Quaternion();

    // Integer in the range [min, max)
    int RangeInclusiveMax(int min, int max);

    // Integer in the range [min, max]
    int RangeExclusiveMax(int min, int max);

    // Integer in the range [base - variance, base + variance]
    int Variance(int base, int variance);

    // A random Real in the range [min,max]
    float Range(float min, float max);

    // Returns a number in the range [base - variance, base + variance]
    float Variance(float base, float variance);

    // Randomly rolls a number in the range [1, sides]
    uint DieRoll(uint sides);

    // Takes a given probability that we get a true value
    bool Probability(float probOfTrue);

    // Returns true if the coin flips heads
    bool CoinFlip();

    // Random rotation quaternion. This is the same as calling Quaternion()
    Zilch::Quaternion Rotation();

    // Samples a bell curve with standard normal distribution in the range [0,1]
    // This is equivalent to a Gaussian distribution with standard deviation of 1
    float BellCurve();

    // Samples a bell curve with in the range [center - range, center + range]
    // This uses a standard deviation of 1.
    float BellCurve(float center, float range);

    // Samples a bell curve in the range [center - range, center + range] with the
    // given standard deviation. Around 68% will lie within the 1st standard deviation
    float BellCurve(float center, float range, float standardDeviation);

  private:

    // The internal random number generator we use
    Math::Random Generator;

    // We store the seed separately so that users can query what the original seed was
    uint OriginalSeed;
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_JSON_HPP
#define ZILCH_JSON_HPP

// Includes


namespace Zilch
{
  namespace JsonValueType
  {
    enum Enum
    {
      Invalid,
      String,
      Integer,
      Real,
      Object,
      Array,
      True,
      False,
      Null
    };
  }

  class JsonValue;

  // A member is basically just a key-value pair, where
  // the key is always a string and the value is generic
  class JsonMember
  {
  public:
    // Constructor
    JsonMember();

    // Destructor (cleans up value)
    ~JsonMember();

    // Effectively the name of the member
    String Key;

    // The value of our member
    JsonValue* Value;
  };

  namespace JsonErrorMode
  {
    enum Enum
    {
      DefaultValue,
      ReportError
    };
  }

  // A 'value' in Json can be a string, number, object, array, true/false, or null
  class JsonValue
  {
  public:

    // Constructor
    JsonValue();

    // Converts the value and it's children into Json
    String ToString();

    // Get a member (reports errors if this is not an object, or if the member doesn't exist)
    JsonValue* GetMember(StringParam name, JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Index a value of an array (reports errors if this is not an array, or if the index is out of bounds)
    JsonValue* IndexValue(size_t index, JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Helper functions for pulling native types out of a json value
    bool      AsBool    (bool         defaultValue = false,     JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    String    AsString  (StringParam  defaultValue = String(),  JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    double    AsDouble  (double       defaultValue = 0.0,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    float     AsFloat   (float        defaultValue = 0.0f,      JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    long long AsLongLong(long long    defaultValue = 0LL,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    int       AsInteger (int          defaultValue = 0,         JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Helper functions for pulling out members of a json object
    // Only valid when the 'Type' is set to 'Object'
    bool      MemberAsBool    (StringParam name, bool         defaultValue = false,     JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    String    MemberAsString  (StringParam name, StringParam  defaultValue = String(),  JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    double    MemberAsDouble  (StringParam name, double       defaultValue = 0.0,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    float     MemberAsFloat   (StringParam name, float        defaultValue = 0.0f,      JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    long long MemberAsLongLong(StringParam name, long long    defaultValue = 0LL,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    int       MemberAsInteger (StringParam name, int          defaultValue = 0,         JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Helper functions for indexing values of a json array
    // Only valid when the 'Type' is set to 'Array'
    bool      IndexAsBool     (size_t index, bool         defaultValue = false,     JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    String    IndexAsString   (size_t index, StringParam  defaultValue = String(),  JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    double    IndexAsDouble   (size_t index, double       defaultValue = 0.0,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    float     IndexAsFloat    (size_t index, float        defaultValue = 0.0f,      JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    long long IndexAsLongLong (size_t index, long long    defaultValue = 0LL,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    int       IndexAsInteger  (size_t index, int          defaultValue = 0,         JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Specifies what type of value this is
    JsonValueType::Enum Type;

    // Only valid when the 'Type' is set to 'String'
    String StringValue;

    // Only valid when the 'Type' is set to 'Real'
    double RealValue;

    // Only valid when the 'Type' is set to 'Integer'
    long long IntegralValue;

    // Only valid when the 'Type' is set to 'Object'
    OwnedArray<JsonMember*> OrderedMembers;

    // A map of names to the values
    // Only valid when the 'Type' is set to 'Object'
    HashMap<String, JsonValue*> Members;

    // Only valid when the 'Type' is set to 'Array'
    OwnedArray<JsonValue*> ArrayElements;
  };

  class JsonReader
  {
  public:

    // Reads a json text file into a tree format
    static JsonValue* ReadIntoTreeFromString(CompilationErrors& errors, StringParam json, StringParam origin, void* userData);
    
    // Reads json text into a tree format
    static JsonValue* ReadIntoTreeFromFile(CompilationErrors& errors, StringParam fileName, void* userData);
  };

  namespace JsonType
  {
    enum Enum
    {
      ArraySingleLine,
      ArrayMultiLine,
      Object
    };
  }

  class JsonBuilder
  {
  public:

    // Constructor
    JsonBuilder();

    // Get the resulting Json (only legal if it's completely closed)
    String ToString() const;

    // Writes the json tree out
    void WriteTree(JsonValue* value);

    // Start a key/member inside of an object (illegal to do at the root or inside an array)
    void Key(StringRange name);

    // Write a value to Json (only legal as a member or in an array)
    void Value(int value);
    void Value(unsigned int value);
    void Value(long value);
    void Value(unsigned long value);
    void Value(long long value);
    void Value(unsigned long long value);
    void Value(double value);
    void Value(StringRange value);
    void Value(cstr value);
    void Value(bool value);
    void Null();

    // The string provided is written exactly to the Json object as a value
    // Only legal as a member or in an array
    void RawValue(StringParam value);

    // Start either a Json object or array
    // When inside an object, it's only legal to call this after creating a 'Member'
    // When inside an array, it is always legal to call this
    void Begin(JsonType::Enum type);

    // End a Json object or array
    void End();

  private:

    // Checks if we can write a value (includes object or array)
    void VerifyCanWriteValue();

    // Returns an empty string or a string containing a
    // comma if it's needed to add a value/member for the current object or array
    void AttemptComma();

    void AttemptNewline();

  public:

    // In compact mode, we only output necessary spaces
    bool IsCompactMode;

  private:

    // Lets us know what's the last operation of the Json stack was
    Array<JsonType::Enum> Stack;

    // Lets us know if we started a member
    // This is only used when a Json object was the last thing on the stack
    bool IsMember;

    // Whether or not we wrote to the current object/array
    bool IsWrittenTo;

    // Allow us to efficiently build the json file
    StringBuilderExtended Builder;
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_STUB_CODE_HPP
#define ZILCH_STUB_CODE_HPP

// Includes


namespace Zilch
{
  // A helper for generating Zilch code (without implementation) for natively defined types
  // This code should be actually executable and can be used for 'Go To Definition' like features or for exporting
  // engine / application code to be used for auto-complete and more in an external editor
  // As we build stub code for native definitions, we need to keep track of all the code locations we've touched
  // so we can update the 'Code' portion of the location after we're finished generating stub code
  class StubCode
  {
  public:

    // Constructor
    StubCode();

    // A code builder that we store
    ZilchCodeBuilder Builder;
    
    // All the locations we've touched (including NameLocations)
    Array<CodeLocation*> NativeLocations;

    // If this is set we will set the Location and NameLocation portions of any member or type defined natively
    // This is used by library 'GenerateDefinitionStubCode' (be sure to set the 'GeneratedName' below)
    bool SetNativeLocations;

    // The name we the stub code (when we set the Origin on the CodeLocation for native
    String GeneratedOriginOrName;

    // Stringifies the builder and updates native locations if 'SetNativeLocations' is set
    String Finalize();
    
    // Generates a class/struct definition for this type based on all the members, properties, and functions
    // This will also output comments above the members (if a 'Description' is provided) as well as outputting
    // the proper attributes, get/sets, parameter names / types, etc
    // The stub version should compile (barring name conflicts) and should be usable as a placeholder for C++ bindings
    // It is also useful for when the user wants to view documentation / visualize a class that they don't have the code for (especially native)
    void Generate(BoundType* type);

    // Generates stub code for an array of functions
    void Generate(FunctionArray& functions);

    // Generates stub code for a function
    void Generate(Function* function);

    // Generates stub code for a sends statement
    void Generate(SendsEvent* sends);

    // Generates stub code for a property or field
    void Generate(Property* property);

    // Generates the header for a documented object including attributes, word-wrapped comments, etc
    void GenerateHeader(DocumentedObject* object);

    // Internally used to track native location starts
    void StartNativeLocation(CodeLocation& location);
    void EndNativeLocation(CodeLocation& location);
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_OVERLOAD_RESOLVER_HPP
#define ZILCH_OVERLOAD_RESOLVER_HPP

// Includes


namespace Zilch
{
  // We perform overload checking in three passes
  namespace OverloadPass
  {
    enum Enum
    {
      // Attempt to find a direct overload that works (exact signature match)
      NoImplicitConversion,
      
      // Now attempt to find an overload that works without any code generation
      // For example, if we have an overload that takes an Animal and we pass in a Cat
      // (only syntax conversion required, no actual code generation)
      RawImplicitConversion,

      // Lastly, if we really need to do a proper conversion (like Integer to Real)
      AnyImplicitConversion
    };
  }

  // A class that's responsible for resolving overloads
  class Overload
  {
  public:
    // Resolve an overload between a function call and the list of functions overloaded under the same name
    static bool ResolveAndImplicitConvert
    (
      const FunctionArray* functions,
      Function*& resolvedFunction,
      FunctionCallNode& functionCallNode
    );

    // Report an error based on the overload result
    static void ReportError
    (
      CompilationErrors& errors,
      const CodeLocation& location,
      const FunctionArray* functions,
      const FunctionCallNode& functionCallNode
    );

    // Report an error based on a single delegate type
    static void ReportSingleError
    (
      CompilationErrors& errors,
      const CodeLocation& location,
      const DelegateType* type,
      const FunctionCallNode& functionCallNode
    );

    // Get function call signature string
    static void GetFunctionCallSignatureString(StringBuilder& builder, const FunctionCallNode& functionCallNode);

    // Test a single function against a function call (performs all overload passes)
    // Note: This will modify the function call node if it needs to add implicit casts
    static bool TestCallAndImplicitConvert(DelegateType* delegateType, FunctionCallNode& functionCallNode);

    // Perform a single pass of the overload detection
    // Note: If we failed the first two passes and pass the 'AnyImplicitConversion' test, then we must generate
    // TypeCastNodes to perform implicit casts on the function call's arguments
    static bool TestDelegateTypeVsCall(DelegateType* delegateType, FunctionCallNode& functionCallNode, OverloadPass::Enum pass);

    // Generates any necessary casts for calling the function
    // This should only be called AFTER the 'AnyImplicitConversion' test has passed
    // Note: This function will modify the 'FunctionCallNode'
    static void GenerateImplicitCasts(DelegateType* delegateType, FunctionCallNode& functionCallNode);

    // Detect any ambiguities between one function signature and a list of other function signatures
    //static void DetectAmbiguities(FunctionArray& functions, Function* function);
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2015, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_PARSER_HPP
#define ZILCH_PARSER_HPP

// Includes




namespace Zilch
{
  // This class implements a recursive descent parser that parses
  // through the token stream that we get from the tokenizer
  class Parser
  {
  public:

    // Constructor
    Parser(Project& project);

    // Parses all scripts in a project into an syntax tree (with classes, functions, members, etc)
    void ParseIntoTree(const Array<UserToken>& tokens, SyntaxTree& syntaxTree, EvaluationMode::Enum evaluation);

    // Parses a single expression in the context of a function (evaluation of local variables, etc)
    void ParseExpressionInFunctionAndClass(const Array<UserToken>& expression, const Array<UserToken>& function, const Array<UserToken>& classTokensWithoutFunction, SyntaxTree& syntaxTree);

    // From a token stream, just attempt to parse a single type
    SyntaxType* ParseType(const Array<UserToken>& type);

    // Checks if a token either has zero elements, or if the only element is the End/Eof element
    static bool IsTokenStreamEmpty(const Array<UserToken>& tokens);

    // Tests if a list of attributes contains a particular attribute by name
    static AttributeNode* GetAttribute(NodeList<AttributeNode>& attributes, StringParam name);

  private:

    // Type-defines
    typedef ExpressionNode* (Parser::*ExpressionFn)();

    // Print out an error message corresponding to the current token
    void ErrorHere(ErrorCode::Enum errorCode, ...);

    // Print out an error message corresponding to the current token
    void ErrorHereArgs(ErrorCode::Enum errorCode, va_list argList);

    // Print out an error message corresponding to the current token (with extra context if needed)
    void ErrorHereArgs(ErrorCode::Enum errorCode, StringParam extra, va_list argList);

    // Set the starting line and character of a syntax node
    void SetNodeLocationStartHere(SyntaxNode* node);

    // Set the primary line and character of a syntax node
    void SetNodeLocationPrimaryHere(SyntaxNode* node);

    // Set the ending line and character of a syntax node
    void SetNodeLocationEndHere(SyntaxNode* node);

    // Set the starting line and character of a syntax node (at the last saved token)
    void SetNodeLocationStartToLastSave(SyntaxNode* node);

    // Set the starting line and character of a syntax node (at the last saved token)
    void SetNodeLocationPrimaryToLastSave(SyntaxNode* node);

    // Set the ending line and character of a syntax node (at the last saved token)
    void SetNodeLocationEndToLastSave(SyntaxNode* node);

    // Set the starting line and character of a syntax node to a given token's position
    static void SetNodeLocationStartToToken(SyntaxNode* node, const UserToken& token);

    // Set the starting line and character of a syntax node to a given token's position
    static void SetNodeLocationPrimaryToToken(SyntaxNode* node, const UserToken& token);

    // Set the ending line and character of a syntax node to a given token's position
    static void SetNodeLocationEndToToken(SyntaxNode* node, const UserToken& token);

    // Saves the tokens position onto the stack
    void SaveTokenPosition();

    // Recalls the token position by using the value on the top of the stack
    void RecallTokenPosition();

    // Accepts the current token position as the new token position, and removes the saved version from the stack
    void AcceptTokenPosition();

    // Attempts to accept any one of the given tokens, and outputs the one that matches (also moves the token index ahead by one)
    bool AcceptAnyArgs(size_t parameters, const UserToken** out_token, va_list vl);

    // Attempts to accept any one of the given tokens, and outputs the one that matches (also moves the token index ahead by one)
    bool AcceptAny(size_t parameters, const UserToken** out_token, ...);

    // Accepts the tokens in the order that they're given (moves the token index ahead by the number of tokens passed in, if they all match)
    bool Accept(size_t parameters, ...);

    // Accepts the tokens in the order that they're given and returns values out through parameters
    bool AcceptAndRetrieve(size_t parameters, ...);

    // Expects a given grammar constant, and otherwise produces an error (variadic for the error context)
    bool Expect(Grammar::Enum grammarConstant, ErrorCode::Enum errorCode, ...);

    // Expects a given grammar constant, and otherwise produces an error (variadic for the error context)
    bool ExpectAndRetrieve(Grammar::Enum grammarConstant, const UserToken*& outToken, ErrorCode::Enum errorCode, ...);

    // Expects a given grammar constant, and otherwise produces an error (variadic for the error context)
    bool ExpectAndRetrieveArgs(Grammar::Enum grammarConstant, const UserToken*& outToken, ErrorCode::Enum errorCode, va_list vl);

    // A helper function to read the contents of a delgate syntax type
    bool ReadDelegateTypeContents(DelegateSyntaxType* delegateSyntaxType);

    // Read a named type for the typing system
    BoundSyntaxType* ReadBoundTypeInfo();

    // Read a type for the typing system
    SyntaxType* ReadTypeInfo();

    // Typically only used in tolerant mode, this will skip tokens until we find the ending scope
    // It will also properly count scopes up and down as it looks for the end
    // Returns true if it find the end (and will advance the token), or false and the token will not move
    bool MoveToScopeEnd();

    // Find the nearest scope to a given code location
    // Generally this is only used for auto-complete
    static ScopeNode* FindNearestScope(SyntaxNode* root, const CodeLocation& location);

    // Parse an attribute defintion
    void ParseAllOptionalAttributes();

    // Parse a single attribute (not a group)
    bool ParseOneOptionalAttribute();

    // Apply the last attribute to a node
    void AttachLastAttributeToNode(NodeList<AttributeNode>& attributes);

    // Accept a type specifier (return type for a function)
    // Returns true if it parses successfully, false otherwise (note that no type specifier will return true!)
    bool AcceptOptionalTypeSpecifier(SyntaxType*& outSyntaxType, ErrorCode::Enum notFound, ...);

    // Accept a type specifier (return type for a function)
    // Returns true if it parses successfully, false otherwise (note that no type specifier will return true!)
    bool AcceptOptionalTypeSpecifierArgs(SyntaxType*& outSyntaxType, ErrorCode::Enum notFound, va_list args);

    // Expect an argument list
    bool ExpectArgumentList(GenericFunctionNode* node, StringParam functionName, bool mustBeEmpty);

    // Parse a scope body
    bool ExpectScopeBody(GenericFunctionNode* node, StringParam functionName);

    // Parse a variable defintion
    LocalVariableNode* LocalVariable(bool initialized = true);

    // Parse a variable defintion
    MemberVariableNode* MemberVariable();

    // Parse a class defintion
    ClassNode* Class();

    // Parse an enum defintion
    EnumNode* Enum();

    // Parse an enum value (an integral constant with a name)
    EnumValueNode* EnumValue();

    // Parse a specialized function (code reuse)
    template <typename FunctionNodeType>
    FunctionNodeType* SpecializedFunction
    (
      Grammar::Enum type,
      String functionName,
      bool (Parser::*postArgs)(FunctionNodeType* node)
    );

    // Parse a function definition
    FunctionNode* Function();

    // Generate the standard function node for a get set
    FunctionNode* GenerateGetSetFunctionNode(MemberVariableNode* variable, bool isGet);

    // Parse a get/set function definition
    FunctionNode* GetSetFunctionBody(MemberVariableNode* variable, bool isGet);

    // Parse a constructor definition
    ConstructorNode* Constructor();
    bool ConstructorInitializerList(ConstructorNode* node);

    // Parse a destructor definition
    DestructorNode* Destructor();

    // Parse a sends statement
    SendsEventNode* SendsEvent();

    // Parse a function parameter
    ParameterNode* Parameter();

    // A binary operator helper for parsing expressions (with right to left associativity)
    ExpressionNode* BinaryOperatorRightToLeftAssociative(ExpressionFn currentPrecedence, ExpressionFn nextPrecedence, int parameters, ...);

    // A binary operator helper for parsing expressions (with left to right associativity)
    ExpressionNode* BinaryOperatorLeftToRightAssociative(ExpressionFn nextPrecedence, int parameters, ...);

    // Parse an expression (including all precedent levels of operators, lower number = lower precedence)
    ExpressionNode* Expression();
    ExpressionNode* Expression00();
    ExpressionNode* Expression01();
    ExpressionNode* Expression02();
    ExpressionNode* Expression03();
    ExpressionNode* Expression04();
    ExpressionNode* Expression05();
    ExpressionNode* Expression06();
    ExpressionNode* Expression07();
    ExpressionNode* Expression08();
    ExpressionNode* Expression09();
    ExpressionNode* Expression10();
    ExpressionNode* Expression11();
    ExpressionNode* Expression12();
    ExpressionNode* Expression13();
    ExpressionNode* Expression14();

    // The post-expression takes care of right hand side operataors whose operands arent exactly a "single" expression
    ExpressionNode* PostExpression(ExpressionNode* leftOperand);

    // Parse an indexer call
    IndexerCallNode* IndexerCall(ExpressionNode* leftOperand);

    // Parse a function call
    FunctionCallNode* FunctionCall(ExpressionNode* leftOperand);

    // Parse a member access
    MemberAccessNode* MemberAccess(ExpressionNode* leftOperand);

    // Parse the expression initializer { } which can initialize members and add to containers
    ExpressionNode* ExpressionInitializer(ExpressionNode* leftOperand);

    // Parse a delete statement
    StatementNode* Delete();

    // Parse a return statement
    StatementNode* Return();

    // Parse a break statement
    StatementNode* Break();

    // Parse a debug breakpoint statement
    StatementNode* DebugBreak();

    // Parse a continue statement
    StatementNode* Continue();

    // Parse a throw statement
    StatementNode* Throw();

    // Parse a statement
    StatementNode* Statement(bool optionalDelimiter = false);

    // Parse a delimited statement
    StatementNode* DelimitedStatement();

    // Parse a free statement
    StatementNode* FreeStatement();

    // Parse a scope statement
    StatementNode* Scope();

    // Parse a timeout statement
    StatementNode* Timeout();

    // Parse an if statement
    IfRootNode* If();

    // Parse an if statement's body (nulls out the condition if it attaches it)
    void IfBody(ExpressionNode*& condition, IfRootNode* root);

    // Parse an if statement's condition
    ExpressionNode* IfCondition();

    // Parse an else statment (with a possible condition)
    void Else(IfRootNode* root);

    // Parse a scope (with statements) or a single statement
    bool ExpectScopedStatements(NodeList<StatementNode>& statements, Grammar::Enum parentKeyword);

    // Parse a for statement
    StatementNode* For();

    // Parse a foreach statement
    StatementNode* ForEach();

    // Parse an while statement
    StatementNode* While();

    // Parse an do-while statement
    StatementNode* DoWhile();

    // Parse a loop statement
    StatementNode* Loop();

    // Read a creation call (like "new" or "local") or just a static type name
    StaticTypeNode* StaticTypeOrCreationCall();

    // Read a type-id expression (which returns type information)
    ExpressionNode* TypeId();

    // Create a string literal value node (always sets the token directly to be a string literal)
    ValueNode* CreateStringLiteral(const UserToken* token);

    // Parse a string interpolant
    StringInterpolantNode* StringInterpolant();

    // Parse a value
    ExpressionNode* Value();

    // Read attributes for static, virtual, and overriding and apply them to a node
    // Expects that the node has the IsStatic and Virtualized members
    template <typename Node>
    void ApplyVirtualStaticExtensionAttributes(Node* node);

  private:

    // The last attribute we parsed, which will be attached to whatever node follows it
    NodeList<AttributeNode> LastAttributes;

    // Store a reference to the error handler
    CompilationErrors& Errors;

    // Store a pointer back to the project that we're created from
    Project* ParentProject;

    // The tokenizer we'll use that stores the input stream of tokens
    const Array<UserToken>* TokenStream;

    // This stack maintains any saved token positions (makes it easy to recall if necessary)
    PodArray<size_t> TokenPositions;

    // The index of the token we're currently parsing
    size_t TokenIndex;

    // Not copyable
    ZilchNoCopy(Parser);
  };
}

// End header protection
#endif
#pragma once
//Visual studio requires the precompiled header to be included the same for
//all files in the project EVEN when they are located in a different
//relative position. For G++ it needs to be a true path so this
//file redirects to the actual precompiled.
//For G++
//#include "../Precompiled.hpp"

#pragma once
//Visual studio requires the precompiled header to be included the same for
//all files in the project EVEN when they are located in a different
//relative position. For G++ it needs to be a true path so this
//file redirects to the actual precompiled.
//For G++
//#include "..\Precompiled.hpp"

///////////////////////////////////////////////////////////////////////////////
///
/// \file Block.hpp
/// Declaration of the block memory manger and allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

namespace Memory
{

///Block allocator implements a segmented memory model.
///The block allocator is an array of memory pools of fixed
///sizes. Allocations use a static look up table to find the free list
///their size will fit into.  For each free list size a intrusive singly 
///linked list of free blocks is stored just like in a memory pool.
///The Block allocator is efficient at allocating small objects and helps
///prevent memory fragmentation. The disadvantages is that
///the Block allocator can not allocate large objects 
///(with out falling back on heap allocation)
///and once memory is committed to a block size
///it can not be reclaimed easily.
class Block : public Graph
{
public:
  struct FreeBlock{FreeBlock* NextBlock;};
  Block(StringRange name, Graph* parent);
  ~Block();

  //Allocate an object and call its constructor.
  template<typename type>
  type* AllocateType();

  MemPtr Allocate(size_t numberOfBytes);
  void Deallocate(MemPtr ptr, size_t numberOfBytes);
  void Print(size_t tabs, size_t flags);
  void PushFreeBlock(size_t blockIndex, FreeBlock* block);
  FreeBlock* PopOnFreeList(size_t blockIndex);
  void AllocateBlockPage(size_t blockIndex);
  void CleanUp();
  //Configuration
  static const size_t cBlockCount = 14;
  static const size_t cMaxBlockSize = 640;
  static const size_t cPageSize = 4096;//4K Pages

private:

  //Used to store pages.
  Array<MemPtr> mPageBlocks;

  //Array of FreeLists for each block size.
  FreeBlock* mBlockArray[cBlockCount];

  //Table used to look up block index from allocation size.
  static byte BucketLookUp[cMaxBlockSize+1];
  //Is the allocation table initialized.
  static bool SizeTableInitialized;

  //Size of the block lists.
  static size_t BlockSizes[cBlockCount];

};

template<typename type>
type* Block::AllocateType()
{
  MemPtr memory = Allocate(sizeof(type));
  type* object = new(memory) type();
  return object;
}

}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Pool.hpp
/// Declaration of the memory pool allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{
namespace Memory
{

///A memory pool is an efficient allocator for objects of a fixed size.
///The memory pool allocates memory in pages then divides the page into a 
///intrusively singly linked list of free blocks. Every time an allocation
///is made the next free block is popped of the list. Every time an allocation
///is freed the memory is push back onto the front of the list. When their are 
///no more free blocks new pages are allocated.
class Pool : public Graph
{
public:
  struct FreeBlock{FreeBlock* NextBlock;};
  Pool(StringRange name, Graph* parent, size_t blockSize, size_t blocksPerPage);
  ~Pool();

  template<typename type>
  type* AllocateType();
  template<typename type>
  void DeallocateType(type* instance);
  MemPtr Allocate(size_t numberOfBytes);
  void Deallocate(MemPtr ptr, size_t numberOfBytes);
  void Print(size_t tabs, size_t flags);
  void CleanUp();
private:
  FreeBlock* mNextFreeBlock;
  size_t mBlockSize;
  size_t mBlocksPerPage;
  size_t mPageSize;
  Array<byte*> mPages;
  void PushOnFreeList(MemPtr chunk);
  MemPtr PopOnFreeList();
  void AllocatePage();
};

template<typename type>
type* Pool::AllocateType()
{
  MemPtr memory = Allocate(sizeof(type));
  type* object = new(memory) type();
  return object;
}

template<typename type>
void Pool::DeallocateType(type* instance)
{
  instance->~type();
  Deallocate(instance,sizeof(type));
}

}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Stack.hpp
/// Declaration of the Stack memory allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{
namespace Memory
{

static const bool StackDebug = true;

///The stack allocator works like the program stack. For every allocation the stack
///head is moved forward and for each deallocation it is moved back. 
///It is extremely efficient but allocations must be freed in stack order (LIFO). 
///This makes the stack allocator efficient for temporaries and scratch space 
///that exist only a part of a frame or for permanent allocations that are never
///freed.
class Stack : public Graph
{
public:
  //Entries are used to detect when allocation are not freed
  //in proper stack order.
  struct Entry
  {
    Entry()
    {

    }
    Entry(byte* ptr, size_t size)
      :Ptr(ptr),
      Size(size)
    {

    }

    byte* Ptr;
    size_t Size;
  };

  Stack(StringRange name, Graph* parent, size_t stackSize, size_t maxEntries);
  ~Stack();
  void Print(size_t tabs, size_t flags);
  MemPtr Allocate(size_t numberOfBytes);
  void Deallocate(MemPtr ptr, size_t numberOfBytes);
  void CleanUp();
private:
  size_t mStackIndex;
  byte* mStackHeader;
  size_t mStackSize;
  size_t mMaxEntries;
  size_t mMaxSizeReached;
  PodArray<Entry> mEntries;
};

}//namespace Memory

class StackAllocator : public Memory::StandardMemory
{
public:
  StackAllocator()
    :mStack(NULL)
  {
  }

  StackAllocator(Memory::Stack* manager)
    :mStack(manager)
  {
  }

  MemPtr Allocate(size_t numberOfBytes){return mStack->Allocate(numberOfBytes); };
  void Deallocate(MemPtr ptr, size_t numberOfBytes){mStack->Deallocate(ptr, numberOfBytes);}
  Memory::Stack* mStack;
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Regex.hpp
/// Declaration of the Regex.
///
/// Authors: Trevor Sundberg
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes




namespace Zero
{
  // Forward declaration
  struct RegexPrivateData;
  struct MatchesPrivateData;
  class StringBuilder;

  // The flavor of regular expressions
  DeclareEnum6(RegexFlavor, EcmaScript, PosixBasic, PosixExtended, Awk, Grep, Egrep);

  // Any flags we want to give to the regex (generally used for searching)
  DeclareBitField1(RegexFlags, MatchNotNull);

  // How we escape a string (normal means escape everything, extended
  // means escape everything except extended characters such as '\r'...)
  DeclareEnum2(EscapeMode, Normal, Extended);

  class Matches
  {
  public:
    friend class Regex;

    Matches();
    Matches(const Matches& source);
    ~Matches();
    
    // Clears the array of matches
    void clear();

    // How many matches we captured
    size_t size() const;

    // If there are no matches
    bool empty() const;

    // Grabs the match by index (0 is always the entire match, 1 and on are sub-strings / captures groups)
    StringRange operator[](size_t index) const;

    // Helpers to get the first and last element
    StringRange front() const;
    StringRange back() const;

    // All the text before this entire match
    StringRange Prefix() const;

    // All the text after this entire match
    StringRange Suffix() const;

    // Formats a match with a special $ format string
    String Format(StringRange format) const;

    // Formats a match with a special $ format string and outputs directly into a string builder
    void Format(StringRange format, StringBuilder& builder) const;

  private:
    // Store the private data
    MatchesPrivateData* mPrivate;
  };

  class Regex
  {
  public:
    friend class Matches;

    // Default Constructor
    Regex();

    // Constructor
    Regex(StringRange regex, RegexFlavor::Enum flavor = RegexFlavor::EcmaScript, bool caseSensitive = true, bool optimizeForMatching = true);
    
    // Copy constructor
    Regex(const Regex& source);

    // Destructor
    ~Regex();

    // Assignment operator
    Regex& operator=(const Regex& source);

    // Search a given string and return matches (clears matches that are passed in)
    void Search(StringRange text, Matches& matches, RegexFlags::Type flags = RegexFlags::None) const;

    // Replace all matches in a given string
    String Replace(StringRange source, StringRange replaceWith) const;

    // Escape a string so that it can be used directly in a regex, typically for finding exactly that string
    static String Escape(StringRange input, EscapeMode::Enum mode, RegexFlavor::Enum flavor = RegexFlavor::EcmaScript);

    // Validate the regular expression
    static bool Validate(StringRange regex, RegexFlavor::Enum flavor = RegexFlavor::EcmaScript, bool caseSensitive = true);

    // The original regular expression string that created this regex
    String mRegexString;

  private:

    // Store the private data
    RegexPrivateData* mPrivate;
  };
}
#pragma once
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <ctype.h>
///////////////////////////////////////////////////////////////////////////////
///
/// \file CharacterTraits.hpp
/// 
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

DeclareBitField7(CharacterBits, Graphical, Alpha, Number, WhiteSpace, Lower, Symbol, Control);

int IsSpace(int c);
int IsGraph(int c);
int IsGraphOrSpace(int c);
int IsAlpha(int c);
int IsDigit(int c);
int IsNumber(int c);
int IsAlphaNumeric(int c);
int IsLower(int c);
int IsUpper(int c);
int IsSymbol(int c);
int IsControl(int c);

int GetTraits(int c);

int ToLower(int c);
int ToUpper(int c);


}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file ToString.hpp
/// Conversion to and from strings.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Zero
{

template<typename type>
String ToString(const type& instance, bool shortFormat = false)
{
  return instance.ToString(shortFormat);
}

template<typename type>
String ToString(type*const instance, bool shortFormat = false)
{
  return instance->ToString(shortFormat);
}

inline String ToString(StringRef instance, bool shortFormat = false)
{
  return instance;
}

String ToString(const bool& value,   bool shortFormat = false);
String ToString(const int& value,    bool shortFormat = false);
String ToString(const uint& value,   bool shortFormat = false);
String ToString(const float& value,  bool shortFormat = false);
String ToString(const double& value, bool shortFormat = false);
String ToString(const u64& value,    bool shortFormat = false);

}
///////////////////////////////////////////////////////////////////////////////
///
/// \file PlatformSelector.hpp
/// 
/// Authors: Trevor sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Detect 32 or 64 bit
// If this is a windows platform...
#if defined(_WIN32) || defined(_WIN64)
  #if defined(_WIN64) || defined(_M_X64) || defined(_M_IA64)
    #define PLATFORM_64 1
  #else
    #define PLATFORM_32 1
  #endif
#else
  // If this is a gcc or clang platforms...
  #if defined(__x86_64__) || defined(__ppc64__)
    #define PLATFORM_64 1
  #else
    #define PLATFORM_32 1
  #endif
#endif

// Detect the Windows platform
#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64)
  #define PLATFORM_WINDOWS 1
  #define PLATFORM_HARDWARE 1
// Detect all Apple platforms
#elif defined(__APPLE__)
  // This header contains defines that tell us the current platform
  #include <TargetConditionals.h>
  #if TARGET_IPHONE_SIMULATOR
    #define PLATFORM_IPHONE 1
    #define PLATFORM_VIRTUAL 1
  #elif TARGET_OS_IPHONE
    #define PLATFORM_IPHONE 1
    #define PLATFORM_HARDWARE 1
  #elif TARGET_OS_MAC
    #define PLATFORM_MAC 1
    #define PLATFORM_POSIX 1
    #define PLATFORM_HARDWARE 1
  #else
    #error "Unsupported platform"
  #endif

#elif defined(EMSCRIPTEN)
  #define PLATFORM_EMSCRIPTEN 1
  #define PLATFORM_HARDWARE 1

// Linux, which is a posix platform
#elif defined(__linux) || defined(__linux__)
  #define PLATFORM_LINUX 1
  #define PLATFORM_POSIX 1
  #define PLATFORM_HARDWARE 1

// Unix, which is a posix platform
#elif defined(__unix) || defined(__unix__)
  #define PLATFORM_UNIX 1
  #define PLATFORM_POSIX 1
  #define PLATFORM_HARDWARE 1

// Catch all for other posix compatable platforms
#elif defined(__posix)
  #define PLATFORM_POSIX 1
  #define PLATFORM_HARDWARE 1
#endif

// Detect compilers
#if defined(_MSC_VER)
  #define COMPILER_MICROSOFT 1
#elif defined(__clang__)
  #define COMPILER_CLANG 1
#elif defined(__GNUC__)
  #define COMPILER_GCC 1
#elif defined(__llvm__)
  #define COMPILER_LLVM 1
#endif
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes



/// Globally unique identifier
typedef u64 Guid;

namespace Zero
{

/// Converts a guid to a hexadecimal string
String GuidToString(Guid guid);

} // namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.hpp
/// Precompiled header for the math library.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


#include <cstddef>

namespace Math
{

}// namespace Math




///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once




namespace Math
{

struct BlockVector3
{
  uint GetSize() const;
  void SetSize(uint size);

  Vector3 operator[](uint index) const;
  Vector3& operator[](uint index);

  real& GlobalIndex(uint index);
  
  //Binary Assignment Operators (reals)
  void operator*=(real rhs);

  //Binary Assignment Operators (vectors)
  void operator+=(const BlockVector3& rhs);
  void operator-=(const BlockVector3& rhs);

  real Dot(const BlockVector3& rhs) const;
  void Scale(const BlockVector3& rhs, BlockVector3& out) const; 

  Zero::Array<Vector3> mBlocks;
};

struct BlockMatrix3
{
  uint GetSize() const;
  void SetSize(uint size);

  Matrix3 operator()(uint row, uint col) const;
  Matrix3& operator()(uint row, uint col);

  real& GlobalIndex(uint row, uint col);

  BlockMatrix3 Transposed() const;
  BlockMatrix3 Transform(const BlockMatrix3& rhs) const;
  void Transform(const BlockVector3& rhs, BlockVector3& out) const; 

  typedef Zero::Array<Matrix3> Cells;
  typedef Zero::Array<Cells> Rows;
  Rows mBlocks;
};

struct BlockCgPolicy
{
  real& operator()(BlockMatrix3& A, uint row, uint col)
  {
    return A.GlobalIndex(row,col);
  }

  real& operator()(BlockVector3& v, uint i)
  {
    return v.GlobalIndex(i);
  }

  uint GetDimension(BlockVector3& v)
  {
    return v.GetSize() * 3;
  }

  BlockVector3 Add(const BlockVector3& lhs, const BlockVector3& rhs)
  {
    BlockVector3 result = lhs;
    result += rhs;
    return result;
  }

  BlockVector3 Subtract(const BlockVector3& lhs, const BlockVector3& rhs)
  {
    BlockVector3 result = lhs;
    result -= rhs;
    return result;
  }

  real Dot(const BlockVector3& lhs, const BlockVector3& rhs)
  {
    return lhs.Dot(rhs);
  }

  BlockVector3 Scale(const BlockVector3& lhs, real rhs)
  {
    BlockVector3 result = lhs;
    result *= rhs;
    return result;
  }

  BlockVector3 Transform(const BlockMatrix3& mat, const BlockVector3& vec)
  {
    BlockVector3 result;
    mat.Transform(vec,result);
    return result;
  }

  //v1 * scalar + v2
  //out is assumed to only ever be aliased as v2
  void MultiplyAdd(const BlockVector3& v1, real scalar, BlockVector3& v2, BlockVector3* out)
  {
    uint size = v1.GetSize();
    for(uint i = 0; i < size; ++i)
    {
      (*out)[i] = v2[i] + v1[i] * scalar;
    }
  }

  //-(v1 * scalar - v2) = v2 - v1 * scalar
  //out is assumed to only ever be aliased as v2
  void NegativeMultiplySubtract(const BlockVector3& v1, real scalar, BlockVector3& v2, BlockVector3* out)
  {
    uint size = v1.GetSize();
    for(uint i = 0; i < size; ++i)
    {
      (*out)[i] = v2[i] - v1[i] * scalar;
    }
  }

  //-(mat * v1 - v2) = v2 - mat * v1
  //out is assumed to only ever be aliased as v2
  void NegativeTransformSubtract(const BlockMatrix3& mat, const BlockVector3& v1, BlockVector3& v2, BlockVector3* out)
  {
    uint size = v1.GetSize();
    for(uint i = 0; i < size; ++i)
    {
      Vector3 sum = Vector3::cZero;

      for(uint j = 0; j < size; ++j)
      {
        Matrix3 m = mat(i,j);
        Vector3 v = v1[j];
        sum += Math::Transform(m,v);
      }
      (*out)[i] = v2[i] - sum;
    }
  }
};

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Curve.hpp
/// Declaration of the Curve class.
///
/// Authors: Joshua Davis
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once







namespace Math
{

typedef Zero::Array<Math::Vector3> Vec3Array;

DeclareEnum3(CurveType, Linear, BSpline, CatmulRom);

//------------------------------------------------------------------------ Curve
/// A generic curve object that can switched between different spline types.
struct SplineCurve
{
  SplineCurve();

  void AddControlPoint(Vec3Param controlPoint);
  void RemovePointAtIndex(uint index);
  void AddControlPoints(const Vec3Array& controlPoints);
  void SetControlPoints(const Vec3Array& controlPoints);

  void GetPoints(Vec3Array& results, uint resolution) const;
  /// Bake the curve out using adaptive sampling. The error is the allowed
  /// distance of a point on the curve from the baked approximation.
  void BakeAdaptive(Vec3Array& results, real error) const;

  Vec3Array& GetControlPoints();
  void Clear();

  /// Does the curve loop back in on itself at the end or does it just stop?
  bool GetClosed();
  void SetClosed(bool state);

  /// How the control points are used to generate the curve.
  uint GetCurveType();
  void SetCurveType(uint curveType);

  /// Estimates the distance between a point and the curve using point-to-line
  /// on each line segment generated using the given resolution
  bool DistanceSq(Vec3 point, uint resolution, real& distSq) const;
  
private:
  /// Get the correct set of control points for baking (continuous set or closed set).
  void GetSmoothPoints(Vec3Array& pts) const;
  void MakeContinuous(Vec3Array& points) const;
  void MakeClosed(Vec3Array& points) const;

  template <typename Policy>
  void GetPoints(const Vec3Array& points, Vec3Array& results, uint resolution) const;
  template <typename Policy>
  void GetPoints(const Vec3Array& points, Vec3Array& results, real error) const;

  template <typename Policy>
  Vec3 ComputePoint(real t, Vec3Param a, Vec3Param b, Vec3Param c, Vec3Param d) const;

  // Used to store a stack of a point on the curve (and how to compute that point)
  // so that sub-division can be performed at a later time.
  struct PointData
  {
    PointData() {};
    PointData(real t, Vec3Param point)
    {
      T = t;
      Point = point;
    }

    real T;
    Vec3 Point;
  };
  template <typename Policy>
  PointData ComputePointData(real t, Vec3Param a, Vec3Param b, Vec3Param c, Vec3Param d) const;

  //---------------------------------------------------------- B-Spline Policy
  struct BSplinePolicy
  {
    static const Mat4& GetBasis();
    static Vec4 GetParam(real t);
  }; 

  //------------------------------------------------------- Catmull-Rom Policy
  struct CatmullRomPolicy
  {
    static const Mat4& GetBasis();
    static Vec4 GetParam(real t);
  }; 

public:

  Vec3Array ControlPoints;
  uint mCurveType;
  bool mClosed;
};


/// A curve that has been baked out to a set of points and their respective arc-lengths.
/// This table can be used to find a point at a given distance along a curve.
class BakedCurve
{
public:
  struct BakedData
  {
    Vec3 Position;
    real ArcLength;
  };

  /// Bake out the given curve. The error term is the max number of
  /// units that a line segment is allowed to deviate from the curve.
  void Bake(const SplineCurve& curve, real error);
  /// The total number of points this curve was baked out to.
  uint Size() const;
  real GetTotalArcLength() const;
  /// Get one of the baked out points. Used primarily for debug drawing.
  BakedData GetPoint(uint index);
  void SetPoint(uint index, Vec3Param pos);

  /// Finds the point on the curve at the given arc-length distance.
  /// The tangent at this point can optionally be computed.
  Vec3 SampleTable(float distance, Vec3* tangent = NULL) const;

private:
  // Binary search to find the index just below the given arc-length.
  uint SampleLowerBound(real distance) const;

  Zero::Array<BakedData> mArcLengthTable;
};

//----------------------------------------------------------- Piecewise Function
struct PiecewiseFunction
{
  struct ControlPoint;

  /// Constructor.
  PiecewiseFunction();

  /// Clears the entire curve. This will invalidate the baked curve.
  void Clear();

  /// Adds the given control point to the curve. Sorts after insertion.
  /// This will invalidate the baked curve.
  void AddControlPoint(Vec2Param pos, Vec2Param tanIn, Vec2Param tanOut);

  /// Sets all the control points and sorts after.
  /// This will invalidate the baked curve.
  void SetControlPoints(Zero::Array<ControlPoint>& controlPoints);

  /// Samples the curve at the given point. This will bake the curve
  /// if not already baked.
  float Sample(real x);

  /// Bakes the curve to the given array of points.
  void Bake();

  /// Returns whether or not the curve is baked.
  bool IsBaked();

  /// Returns a range of the baked curve.
  Vec3Array::range GetBakedCurve();

  /// Returns whether or not there are any control points in the curve.
  bool empty();

  //-------------------------------------------------------------- Control Point
  struct ControlPoint
  {
    Vec2 Position;
    Vec2 TangentIn;
    Vec2 TangentOut;
  };

  /// The type of curve.
  CurveType::Type mCurveType;

  /// All control points in the curve.
  Zero::Array<ControlPoint> mControlPoints;

  /// The allowed distance of a point on the curve from the baked approximation.
  real mError;

private:
  /// We don't want to have to rebuild the curve every time it is sampled,
  /// so we will bake it out to this array for faster sample time.
  /// Whenever the piecewise function is modified, it will be invalid
  /// until baked again.
  Vec3Array mBakedCurve;
};

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file DecomposedMatrix4.hpp
/// Declaration of the DecomposedMatrix4 structure.
/// 
/// Authors: Joshua Davis
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once




namespace Math
{

/// Stores a decomposed matrix 4. This means that shear is lost.
/// This does however allow efficient inverse transforms and
/// extracting of each portion of a transformation.
struct DecomposedMatrix4
{
  DecomposedMatrix4();
  DecomposedMatrix4(Mat4Param transform);

  void Set(Mat4Param transform);

  Vector3 TransformNormal(Vec3Param normal);
  Vector3 InverseTransformNormal(Vec3Param normal);

  /// Transform the surface normal by doing the inverse transpose of the transform.
  Vector3 TransformSurfaceNormal(Vec3Param direction);
  Vector3 InverseTransformSurfaceNormal(Vec3Param direction);

  Vector3 TransformPoint(Vec3Param point);
  Vector3 InverseTransformPoint(Vec3Param point);

  Vector3 Scale;
  Matrix3 Rotation;
  Vector3 Translation;
};

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file ExtendableMath.hpp
/// 
/// Authors: Joshua Davis
/// Copyright 2014, DigiPen Institute of Technology
///
//////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Math
{

//-------------------------------------------------------------------ExtendableVector
struct ExtendableVector
{
  void resize(uint size);

  real& operator[](uint index);
  real operator[](uint index) const;

  uint GetSize() const;

  uint mSize;
  Zero::Array<real> mData;
};

//-------------------------------------------------------------------ExtendableMatrix
struct ExtendableMatrix
{
  void resize(uint sizeX, uint sizeY);

  real& operator()(uint y, uint x);
  real operator()(uint y, uint x) const;

  uint mSizeX;
  uint mSizeY;
  Zero::Array<real> mData;
};

//-------------------------------------------------------------------FixedVector
// A vector who's max size is compile-time but who's
// working size can be changed up to the fixed size.
// Currently used in position correction.
template <typename DataType, size_t FixedSize>
struct FixedVector
{
  void resize(size_t size)
  {
    if(size > FixedSize)
    {
      Error("Cannot set size greater than the fixed size.");
      size = FixedSize;
    }

    mSize = size;
  }

  DataType& operator[](uint index)
  {
    ErrorIf(index >= mSize, "Access array out of bounds");
    return mData[index];
  }
  DataType operator[](uint index) const
  {
    ErrorIf(index >= mSize, "Access array out of bounds");
    return mData[index];
  }

  size_t GetSize() const
  {
    return mSize;
  }

  size_t mSize;
  DataType mData[FixedSize];
};

//-------------------------------------------------------------------FixedMatrix
template <size_t SizeX, size_t SizeY>
struct FixedMatrix
{
  real& operator()(uint y, uint x)
  {
    ErrorIf(y > SizeY || x > SizeX, "Access matrix out of bounds");
    return mData[x + SizeX * y];
  }
  real operator()(uint y, uint x) const
  {
    ErrorIf(y > SizeY || x > SizeX, "Access matrix out of bounds");
    return mData[x + SizeX * y];
  }

  real mData[SizeX * SizeY];
};

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file Numerical.hpp
///  Contains functions that work on numerical data as functions.
///
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once






namespace Math
{

///Solves the quadratic polynomial
///                        a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter.
uint SolveQuadratic(real a0, real a1, real a2, real* roots);

///Solves the cubic polynomial 
///                 a3 * x^3 + a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter.
uint SolveCubic(real a0, real a1, real a2, real a3, real* roots);

///Solves the quartic polynomial 
///             a4 * x^4 + a3 * x^3 + a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter.
uint SolveQuartic(real a0, real a1, real a2, real a3, real a4, real* roots);

///Evaluates the quadratic polynomial at the given x-value.
///                          a2 * x^2 + a1 * x + a0
real EvaluateQuadratic(real x, real a0, real a1, real a2);

///Evaluates the cubic polynomial at the given x-value.
///                    a3 * x^3 + a2 * x^2 + a1 * x + a0
real EvaluateCubic(real x, real a0, real a1, real a2, real a3);

///Evaluates the quartic polynomial at the given x-value.
///               a4 * x^4 + a3 * x^3 + a2 * x^2 + a1 * x + a0
real EvaluateQuartic(real x, real a0, real a1, real a2, real a3, real a4);

///Evaluates the polynomial at the given x-value.
///             a[count] * x^(count) + ... + a[1] * x + a[0]
real EvaluatePolynomial(real x, real* coefficients, uint coefficientCount);

///

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
/// 
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Math
{

// Projects the input vector onto the given vector (must be normalized)
template <typename VectorType>
VectorType GenericProjectOnVector(const VectorType& input, const VectorType& normalizedVector)
{
  return normalizedVector * Math::Dot(input, normalizedVector);
}

// Projects the input vector onto a plane (the normal must be normalized)
template <typename VectorType>
VectorType GenericProjectOnPlane(const VectorType& input, const VectorType& planeNormal)
{
  return input - GenericProjectOnVector(input, planeNormal);
}

/// Calculates the reflection vector across a given plane.
template <typename VectorType>
VectorType GenericReflectAcrossPlane(const VectorType& input, const VectorType& planeNormal)
{
  return input - 2 * GenericProjectOnVector(input, planeNormal);
}

/// Calculates the reflection vector across a given vector.
template <typename VectorType>
VectorType GenericReflectAcrossVector(const VectorType& input, const VectorType& planeNormal)
{
  return 2 * GenericProjectOnVector(input, planeNormal) - input;
}

/// Calculates the refraction vector through a plane given a certain index of refraction.
template <typename VectorType>
VectorType GenericRefract(const VectorType& incidentVector, const VectorType& planeNormal, real refractionIndex)
{
  real iDotN = Math::Dot(incidentVector, planeNormal);
  real r = real(1.0) - refractionIndex * refractionIndex * (real(1.0) - iDotN * iDotN);
  if(r < 0)
    return VectorType::cZero;

  return refractionIndex * incidentVector - planeNormal * (refractionIndex * iDotN + Math::Sqrt(r));
}


}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.hpp
/// Precompiled header for platform library.
/// 
/// Authors: Andrew Colean
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes


///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Claeys
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once





namespace Zero
{

//-------------------------------------------------------------- File Save State
class FileModifiedState
{
public:
  FileModifiedState();

  static bool HasModifiedRecently(StringParam filePath);
  static bool HasModifiedSinceTime(StringParam filePath, TimeType time);

  static void BeginFileModified(StringParam filePath);
  static void EndFileModified(StringParam filePath);

private:
  static FileModifiedState* GetInstance();

  void Cleanup(TimeType currentTime);

  static float GetSecondsBetween(TimeType begin, TimeType end);

  // 1 as the TimeType means the file is currently open.
  typedef HashMap<String, TimeType> ModifiedMap;
  ModifiedMap mFileLastModified;
  ThreadLock mThreadLock;
  TimeType mLastCleanup;
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Andrew Colean
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes


namespace Zero
{

//---------------------------------------------------------------------------------//
//                                  IpAddress                                      //
//---------------------------------------------------------------------------------//

/// IPv4/6 network host identifier
/// Provided for convenience
/// Note: This class is not slice-able, it has extra data
class IpAddress : public SocketAddress
{
private:
  /// Base methods and data hidden to provide desired behavior
  using SocketAddress::SetIpv4;
  using SocketAddress::SetIpv6;
  using SocketAddress::Set;
  using SocketAddress::GetIpPort;
  using SocketAddress::SetIpPort;
  using SocketAddress::mPrivateData;

public:
  /// Constants
  static const IpAddress Invalid;

  /// Creates an empty IP address
  IpAddress();

  /// Creates an IP address identifying the specified IPv4/6 host and port
  /// Will block until host name resolution completes or times out
  IpAddress(Status& status, StringParam host, uint port, InternetProtocol::Enum internetProtocol);
  IpAddress(Status& status, StringParam host, uint port);
  IpAddress(StringParam host, uint port, InternetProtocol::Enum internetProtocol);
  IpAddress(StringParam host, uint port);

  /// Copy Constructors
  IpAddress(const IpAddress& rhs);
  IpAddress(const SocketAddress& rhs);

  /// Copy Assignment Operators
  IpAddress& operator =(const IpAddress& rhs);
  IpAddress& operator =(const SocketAddress& rhs);

  /// Returns true if this is a non-empty IPv4/6 address, else false
  bool IsValid() const;

  /// Returns the valid IP address protocol version, else InternetProtocol::Unspecified
  InternetProtocol::Enum GetInternetProtocol() const;

  /// Returns the valid IP address as a numeric "host:port" string, else String()
  const String& GetString() const;
  /// Returns the valid IP address as a hash value, else 0
  size_t GetHash() const;

  /// Sets the IP address host
  /// Specifying InternetProtocol::Unspecified will attempt to resolve IPv6 first, then IPv4
  /// Will block until host name resolution completes or times out
  void SetHost(Status& status, StringParam host, InternetProtocol::Enum internetProtocol);
  void SetHost(Status& status, StringParam host);
  void SetHost(StringParam host, InternetProtocol::Enum internetProtocol);
  void SetHost(StringParam host);
  /// Returns the valid IP address host as a numeric string, else String()
  String GetHost() const;

  /// Sets the valid IP address port
  void SetPort(Status& status, uint port);
  void SetPort(uint port);
  /// Returns the valid IP address port, else 0
  uint GetPort() const;
  /// Returns the valid IP address port as a numeric string, else String()
  String GetPortString() const;

  /// Clears the IP address
  void Clear();

  /// IP address as a numeric "host:port" string
  String mHostPortString;

  // Friends
  friend Bits Serialize(SerializeDirection::Enum direction, BitStream& bitStream, IpAddress& ipAddress);
};

/// Serializes an IP address
/// Returns the number of bits serialized if successful, else 0
Bits Serialize(SerializeDirection::Enum direction, BitStream& bitStream, IpAddress& ipAddress);

} // namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file PlatformSelector.hpp
/// 
/// Authors: Trevor sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Detect 32 or 64 bit
// If this is a windows platform...
#if defined(_WIN32) || defined(_WIN64)
  #if defined(_WIN64) || defined(_M_X64) || defined(_M_IA64)
    #define PLATFORM_64 1
  #else
    #define PLATFORM_32 1
  #endif
#else
  // If this is a gcc or clang platforms...
  #if defined(__x86_64__) || defined(__ppc64__)
    #define PLATFORM_64 1
  #else
    #define PLATFORM_32 1
  #endif
#endif

// Detect the Windows platform
#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64)
  #define PLATFORM_WINDOWS 1
  #define PLATFORM_HARDWARE 1
// Detect all Apple platforms
#elif defined(__APPLE__)
  // This header contains defines that tell us the current platform
  #include <TargetConditionals.h>
  #if TARGET_IPHONE_SIMULATOR
    #define PLATFORM_IPHONE 1
    #define PLATFORM_VIRTUAL 1
  #elif TARGET_OS_IPHONE
    #define PLATFORM_IPHONE 1
    #define PLATFORM_HARDWARE 1
  #elif TARGET_OS_MAC
    #define PLATFORM_MAC 1
    #define PLATFORM_POSIX 1
    #define PLATFORM_HARDWARE 1
  #else
    #error "Unsupported platform"
  #endif

#elif defined(EMSCRIPTEN)
  #define PLATFORM_EMSCRIPTEN 1
  #define PLATFORM_HARDWARE 1

// Linux, which is a posix platform
#elif defined(__linux) || defined(__linux__)
  #define PLATFORM_LINUX 1
  #define PLATFORM_POSIX 1
  #define PLATFORM_HARDWARE 1

// Unix, which is a posix platform
#elif defined(__unix) || defined(__unix__)
  #define PLATFORM_UNIX 1
  #define PLATFORM_POSIX 1
  #define PLATFORM_HARDWARE 1

// Catch all for other posix compatable platforms
#elif defined(__posix)
  #define PLATFORM_POSIX 1
  #define PLATFORM_HARDWARE 1
#endif

// Detect compilers
#if defined(_MSC_VER)
  #define COMPILER_MICROSOFT 1
#elif defined(__clang__)
  #define COMPILER_CLANG 1
#elif defined(__GNUC__)
  #define COMPILER_GCC 1
#elif defined(__llvm__)
  #define COMPILER_LLVM 1
#endif
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once





namespace Zero
{

struct SymbolInfo
{
  // The address of the symbol to look-up
  void* mAddress;

  // The name of the symbol (could be a function name or variable name).
  String mSymbolName;
  String mFileName;
  // The name of the module this symbol is in (stripped path).
  String mModuleName;
  String mModulePath;
  size_t mLineNumber;
};

// Given a process fill out the information for the symbol at the mAddress location on the SymbolInfo class.
void GetSymbolInfo(OsInt processHandle, SymbolInfo& symbolInfo);

// A simple stack walker that isn't fully flushed out but is much easier to follow than the StackWalker class.
class SimpleStackWalker
{
public:
  virtual ~SimpleStackWalker() {};

  void ShowCallstack(void* context, StringParam extraSymbolPaths = String(), int stacksToSkip = 1);
  virtual void AddSymbolInformation(SymbolInfo& symbolInfo);
  virtual String GetFinalOutput();

  StringBuilder mBuilder;
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Chris Peters, Joshua Claeys
/// Copyright 2010-2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once




namespace Zero
{
class Thread;
class Event;

class DirectoryWatcher
{
public:
  
  enum FileOperation
  {
    Added,
    Removed,
    Modified,
    Renamed
  };

  struct FileOperationInfo
  {
    FileOperation Operation;
    String OldFileName;
    String FileName;
  };

  typedef OsInt (*CallbackFunction)(void* callbackInstance, FileOperationInfo& info);

  DirectoryWatcher(cstr directoryToWatch, CallbackFunction callback, void* callbackInstance);
  ~DirectoryWatcher();
  void Shutdown();

  template<typename classType, OsInt (classType::*MemberFunction)(FileOperationInfo& info)>
  static OsInt CallBackCreator(void* objectInstance, FileOperationInfo& info)
  {
    classType* object = (classType*)objectInstance;
    OsInt returnValue = (object->*MemberFunction)(info);
    return returnValue;
  }

private:
  // Note: The directory watcher currently has no private data
  // because it stores everything on the stack of its thread
  char mDirectoryToWatch[File::MaxPath];
  CallbackFunction mCallback;
  void* mCallbackInstance;
  OsInt RunThreadEntryPoint();
  Thread mWorkThread;
  OsEvent mCancelEvent;
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file FpControl.hpp
/// Declaration of the ScopeFpuExceptionsEnabler, ScopeFpuExceptionsDisabler
/// and FpuControlSystem classes.
///
/// Authors: Joshua Davis
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

/// Temporarily changes the fpu exceptions mask so that fpu exceptions
/// will happen. After the current scope of this block, the old
/// exceptions mask will be replaced. Use sparingly as changing the
/// mask is not a cheap operation.
struct ScopeFpuExceptionsEnabler
{
  ScopeFpuExceptionsEnabler();
  ~ScopeFpuExceptionsEnabler();

  unsigned int mOldState;
};

/// Temporarily disables all fpu exception masks. Used primarily
/// before calling out into external programs such as directX
/// or CG.
struct ScopeFpuExceptionsDisabler
{
  ScopeFpuExceptionsDisabler();
  ~ScopeFpuExceptionsDisabler();

  unsigned int mOldState;
};

/// System to store the mask and active flag for floating point exceptions.
struct FpuControlSystem
{
  static uint DefaultMask;
  static bool Active;
};

}//namespace Zero

#define ZFpExceptions 1

#ifdef ZFpExceptions

#define FpuExceptionsEnabler() \
  ScopeFpuExceptionsEnabler __LocalScopedFpuExceptionsEnabler;

#define FpuExceptionsDisabler() \
  ScopeFpuExceptionsDisabler __LocalScopedFpuExceptionsDisabler;

#ifdef _DEBUG
  #define FpuExceptionsEnablerDebug() \
    ScopeFpuExceptionsEnabler __LocalScopedFpuExceptionsEnabler;
#else
    #define FpuExceptionsEnablerDebug() do {} while (0)
#endif

#else

#define FpuExceptionsEnabler() do {} while (0)

#define FpuExceptionsDisabler() do {} while (0)

#define FpuExceptionsEnablerDebug() do {} while (0)

#endif
///////////////////////////////////////////////////////////////////////////////
///
/// \file Process.hpp
/// Declaration of the Process class and support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Chris Peters
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Zero
{

// Simple callback interface for process stdio
class TextStream
{
public:
  virtual void Write(cstr text)=0;
  virtual ~TextStream(){};
};

class TextStreamDebugPrint : public TextStream
{
  virtual void Write(cstr text)
  {
    ZPrintFilter(Filter::DefaultFilter, text);
  }
};

class TextStreamBuffer : public TextStream
{
public:
  StringBuilder buffer;
  String ToString(){return buffer.ToString();}
  void Write(cstr text) override { buffer.Append(text);}
};

class TextStreamNull : public TextStream
{
  void Write(cstr text) override {};
};


}


namespace Zero
{

//---------------------------------------------------------------------- Process
/// Process class used for managing external processes and redirecting their stdio.
/// Used to launch and monitor various external programs, compilers and tools.
class Process
{
public:
  Process();
  ~Process();
  
  // Begin execution of another process. All output from this process 
  // will be passed to the provided console. This call will return immediately.
  uint ExecProcess(cstr debugName, cstr commandLine, 
                   TextStream* stream = NULL, bool showWindow = false);

  // Write to the process std in.
  void WriteToStdIn(cstr text, int size);

  // Close the process handle this does not force the process to exit.
  void Shutdown();

  // Wait for the process to close.
  void WaitForClose();

  // Get the exit code for the process.
  int GetExitCode();

  // Terminate the process (unsafe)
  void Terminate();

private:
  OsInt ReadThreadEntryPoint();
  Thread mReadThread;
  OsEvent mCancelEvent;
  TextStream* mTextStream;
  char mDebugName[cDebugNameMax];
  ZeroDeclarePrivateData(Process, 32);
};

struct ProcessInfo
{
  /// Unique identifyer for a process
  OsInt mProcessId;
  /// The name of the process by itself (e.g. ZeroEditor.exe)
  String mProcessName;
  /// The full path to the process
  String mProcessPath;
};

/// Fill out an array with all active processes.
void GetProcesses(Array<ProcessInfo>& results);
/// Given a process id (from the ProcessInfo struct) kill the process.
void KillProcess(OsInt processId, int exitCode = 1);

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Joshua Davis
/// Copyright 2015, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

// This is very much a stubbed api
bool GetRegistryValue(StringParam key, StringParam subKey, StringParam value, String& result);
bool GetRegistryValueFromCommonInstallPaths(StringParam programGuid, StringParam keyName, String& result);

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Resolution.hpp
/// Resolution support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once



namespace Zero
{

struct Resolution
{
  Resolution()
    :Width(0), Height(0)
  {}

  Resolution(int w, int h)
    :Width(w), Height(h)
  {}

  bool SameAspect(const Resolution& other)const
  {
    return other.Width * Height == other.Height * Width;
  }

  bool operator==(const Resolution& other) const
  {
    return other.Width == Width &&  other.Height * Height;
  }

  bool operator<(const Resolution& other) const
  {
    if (Width < other.Width)
      return true;
    else
    {
      if (Height < other.Height)
        return true;
      else
        return false;
    }
  }

  String ToString(bool shortFormat) const
  {
    return String::Format("%d x %d", Width, Height);
  }

  size_t Hash() const
  {
    return Hash64to32Shift( *(u64*)this );
  }

  int Width;
  int Height;
};

const Resolution AspectAny(0,0);
const Resolution Aspect4by3(4,3);
const Resolution Aspect5by4(5,4);
const Resolution Aspect16by9(16,9);
const Resolution Aspect16by10(16,10);
const Resolution Aspects[5] = {AspectAny, Aspect4by3, Aspect5by4, Aspect16by9, Aspect16by10};

inline uint GetAspectIndex(Resolution& toTest)
{
  for(uint i=1;i<5;++i)
  {
    if(Aspects[i].SameAspect(toTest))
      return i;
  }
  return 0;
}

// Return the index of the first resolution that is greater than or
// equal to minWidth and minHeight. Return the first resolution to pass or the last in the list
inline int FindMinResolution(Array<Resolution>& resolutions, int minWidth, int minHeight)
{
  for(uint i=0;i<resolutions.size();++i)
  {
    Resolution r = resolutions[i];
    if(r.Width >= minWidth && r.Height >= minHeight)
      return (int)i;
  }
  return (int)(resolutions.size()-1);
}

/// Get the current resolution of the desktop.
Resolution GetDesktopResolution();

/// Enumerate all Resolutions valid for the display adapter with the given bit depth
/// and aspect ratio
/// bitDepth zero for any bit depth
/// resolution any resolution with the same aspect ratio (0,0) will return all.
void Enumerate(Array<Resolution>& resolutions, uint bitDepth, Resolution aspect);

}

///////////////////////////////////////////////////////////////////////////////
///
/// \file Timer.hpp
/// Declaration of the Os High precision Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes


namespace Zero
{

/// Time in milliseconds
typedef u64 TimeMs;

/// Constants
static const TimeMs OneSecond = TimeMs(1000);
static const TimeMs Infinite  = TimeMs(-1);

/// Converts a rate (hertz) to an interval (milliseconds)
#define RATE_TO_INTERVAL(Rate) TimeMs((double(1) / double(Rate)) * OneSecond)

/// Returns the duration between start and end
inline TimeMs GetDuration(TimeMs start, TimeMs end)
{
  return end - start;
}

/// High precision timer class
class Timer
{
public:
  /// Tick type
  typedef unsigned long long TickType;

  /// Constructor
  Timer();

  /// Destructor
  ~Timer();

  /// Resets the time to zero
  void Reset();
  /// Updates the clock
  void Update();
  /// Gets the time in seconds since the last reset
  double Time() const;
  /// Gets the time in seconds between the last update and the update before it
  double TimeDelta() const;
  /// Updates the clock and gets the time in seconds since the last reset
  double UpdateAndGetTime();

  /// Gets the time in milliseconds since the last reset
  TimeMs TimeMilliseconds() const;
  /// Gets the time in milliseconds between the last update and the update before it
  TimeMs TimeDeltaMilliseconds() const;
  /// Updates the clock and gets the time in milliseconds since the last reset
  TimeMs UpdateAndGetTimeMilliseconds();

  /// Gets the time from the last update
  double TimeNoUpdate() const;
  /// Gets the tick time
  TickType GetTickTime() const;
  /// Gets the time in seconds from a tick count
  double TicksToSeconds(TickType ticks) const;

private:
  ZeroDeclarePrivateData(Timer, 50);
};

} // namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file CrashHandler.hpp
/// Declaration of the CrashHandler class.
///
/// Authors: Trevor Sundberg, Joshua Davis
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once


namespace Zero
{

class Engine;

// For debugging, this is so the crash handler can be called within visual studio.
// This can't know about the engine though, so it has to take a callback that calls run on the engine...
typedef void (*RunEngineFunction)(void* engine);
void RunEngine(RunEngineFunction runFn, void* engine);

// Wraps parameters being passed to the crash handler.
// Maybe change this to some interface type?
class CrashHandlerParameters
{
public:
  void AddParameter(StringRange name, StringRange value);

  String GetParameterString();

private:
  StringBuilder mParameters;
};

// Denotes a memory range that is used to insert extra memory into a crash dump.
struct MemoryRange
{
  byte* Begin;
  size_t Length;
};

// Startup information needed by the crash handler to find certain files.
struct CrashInfo
{
  CrashInfo()
  {
    mDumpName = "ZeroDump.dmp";
    mLogName = "ZeroLog.txt";
    mStackName = "ZeroStack.txt";
    mModuleName = "ZeroEditor";
    mStripModules = false;
  }

  // The names of the files to open/send.
  // In zero these have a date/time-stamp which is set in the CrashStartCallback.
  String mDumpName;
  String mLogName;
  String mStackName;

  // Do we strip modules? If so we include ntdll and whatever is in mModuleName.
  // Make sure to set mModuleName to the name of your program if you set mStripModules to true!
  bool mStripModules;
  String mModuleName;
};

struct CrashHandler
{
  // Enable the crash handler to start catching hardware exceptions. When a crash happens,
  // mRunCrashHandlerCallback will be called to control all of the crash handler logic.
  static void Enable();

  // If there are any extra locations to seach for symbols then they need to be added to a path internal to stackwalker.
  // For instance, the launcher needs to add the path to the dll that is actually being run (since crash handler only checks next to the .exe).
  static void AppendToExtraSymbolPath(StringParam path);

  typedef void (*RunCrashHandlerCallback)(void* crashData, bool doRescueCall, void* userData);
  // Called when a crash happens. This function controls all of the behavior of the crash handler,
  // including making the minidump and sending off the crash information.
  static void SetRunCrashHandlerCallback(RunCrashHandlerCallback callback, void* userData);

  typedef void (*CrashStartCallback)(CrashInfo&, void* userData);
  // The crash start callback is used primarily to get the dump/log/stack file name.
  // Any other initial setup for the crash handler can also be performed here.
  static void SetCrashStartCallback(CrashStartCallback callback, void* userData);

  typedef void (*PreMemoryDumpCallback)(void* userData);
  // Called before the memory dump is run. This allows for any setup before the CustomMemoryCallback is called.
  static void SetPreMemoryDumpCallback(PreMemoryDumpCallback callback, void* userData);

  typedef bool (*CustomMemoryCallback)(MemoryRange& memoryRange, void* userData);
  // Used to inject a range of memory manually into the crash dump.
  // This is a re-entrant call that will be continually called until false is returned.
  // Used currently to put Zilch op-code into the dump for debugging.
  // Can be used for any bit of memory used to make debugging easier (Strings?).
  static void SetCustomMemoryCallback(CustomMemoryCallback callback, void* userData);

  typedef void (*LoggingCallback)(CrashHandlerParameters& params, CrashInfo& info, void* userData);
  // Perform any logging before the crash report is sent.
  // This may need to flush any log files as well as add the log file's name to the parameters.
  static void SetLoggingCallback(LoggingCallback callback, void* userData);

  typedef void (*SendCrashReportCallback)(CrashHandlerParameters& params, void* userData);
  // Send the crash report out somehow. The params should contain all
  // of the files/parameters to properly invoke the crash reporter.
  static void SetSendCrashReportCallback(SendCrashReportCallback callback, void* userData);

  typedef void (*FinalRescueCall)(void* userData);
  // The rescue call happens after the crash report is sent so we can attempt to
  // rescue any user settings/data (such as modified levels or files).
  static void SetupRescueCallback(FinalRescueCall rescueCall, void* userData);

  // These functions invoke the various callbacks while wrapping each
  // call in the platform specific __try __except exceptions handlers for safety.
  static void InvokeCrashStartCallback(CrashInfo& info);
  static void InvokePreMemoryDumpCallback();
  static void WriteMiniDump(CrashHandlerParameters& params, void* crashData, CrashInfo& info);
  static void InvokeWriteCallstack(CrashHandlerParameters& params, void* crashData, CrashInfo& info);
  static void InvokeLoggingCallback(CrashHandlerParameters& params, CrashInfo& info);
  static void InvokeRescueCallback();
  static void InvokeSendCrashReport(CrashHandlerParameters& params);

  // Used to signal that a fatal error has happened and send out a crash report.
  // No minidump will be generated as there was no hardware exception,
  // but stack and log information will be sent. Also doesn't invoke the rescue callback.
  static void FatalError(int errorCode);
  
  // The default logic for the crash handler.
  static void DefaultRunCrashHandlerCallback(void* crashData, bool doRescueCall, void* userData);
  static void SetRestartCommandLine(StringRange commandLine);
  static void RestartOnCrash(bool state);

  static String mExtraSymbolPath;

  static RunCrashHandlerCallback mRunCrashHandlerCallback;
  static void* mRunCrashHandlerUserData;
  static CrashStartCallback mCrashStartCallback;
  static void* mCrashStartUserData;
  static PreMemoryDumpCallback mPreMemoryDumpCallback;
  static void* mPreMemoryDumpUserData;
  static CustomMemoryCallback mCustomMemoryCallback;
  static void* mCustomMemoryUserData;
  static LoggingCallback mLoggingCallback;
  static void* mLoggingUserData;
  static SendCrashReportCallback mSendCrashReportCallback;
  static void* mSendCrashReportUserData;
  static FinalRescueCall mRescueCallback;
  static void* mRescueUserData;

  // Do we auto restart the program instead of sending a crash report?
  static bool mAutoRestart;
  // The command line to use to restart ourself.
  static String mRestartCommandLine;
};

}//namespace Zero
